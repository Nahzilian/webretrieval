{"1": {"id": "1", "title": "Preliminary Report-International Algebraic Language", "authors": "Perlis, A. J. Samelson,K.", "words_pool": ["algebra", "intern", "languag", "preliminari", "report", "perli", "samelson"], "word_count": {"algebra": 1, "intern": 1, "languag": 1, "preliminari": 1, "report": 1, "perli": 1, "samelson": 1}}, "2": {"id": "2", "title": "Extraction of Roots by Repeated Subtractions for Digital Computers", "authors": "Sugai, I.", "words_pool": ["comput", "digit", "extract", "repeat", "root", "subtract", "sugai"], "word_count": {"comput": 1, "digit": 1, "extract": 1, "repeat": 1, "root": 1, "subtract": 1, "sugai": 1}}, "3": {"id": "3", "title": "Techniques Department on Matrix Program Schemes", "authors": "Friedman, M. D.", "words_pool": ["depart", "matrix", "program", "scheme", "techniqu", "friedman"], "word_count": {"depart": 1, "matrix": 1, "program": 1, "scheme": 1, "techniqu": 1, "friedman": 1}}, "4": {"id": "4", "title": "Glossary of Computer Engineering and Programming Terminology", "words_pool": ["comput", "engin", "glossari", "program", "terminolog"], "word_count": {"comput": 1, "engin": 1, "glossari": 1, "program": 1, "terminolog": 1}}, "5": {"id": "5", "title": "Two Square-Root Approximations", "authors": "Wadey, W. G.", "words_pool": ["approxim", "root", "squar", "wadey"], "word_count": {"approxim": 1, "root": 1, "squar": 1, "wadey": 1}}, "6": {"id": "6", "title": "The Use of Computers in Inspection Procedures", "authors": "Muller, M. E.", "words_pool": ["comput", "inspect", "procedur", "muller"], "word_count": {"comput": 1, "inspect": 1, "procedur": 1, "muller": 1}}, "7": {"id": "7", "title": "Glossary of Computer Engineering and Programming Terminology", "words_pool": ["comput", "engin", "glossari", "program", "terminolog"], "word_count": {"comput": 1, "engin": 1, "glossari": 1, "program": 1, "terminolog": 1}}, "8": {"id": "8", "title": "On The Equivalence and Transformation of Program Schemes", "authors": "Friedman, M. D.", "words_pool": ["equival", "program", "scheme", "transform", "friedman"], "word_count": {"equival": 1, "program": 1, "scheme": 1, "transform": 1, "friedman": 1}}, "9": {"id": "9", "title": "Proposal for an UNCOL", "authors": "Conway, M. E.", "words_pool": ["propos", "uncol", "conway"], "word_count": {"propos": 1, "uncol": 1, "conway": 1}}, "10": {"id": "10", "title": "Glossary of Computer Engineering and Programming Terminology", "words_pool": ["comput", "engin", "glossari", "program", "terminolog"], "word_count": {"comput": 1, "engin": 1, "glossari": 1, "program": 1, "terminolog": 1}}, "11": {"id": "11", "title": "The Problem of Programming Communication with Changing Machines A Proposed Solution-Part 2", "authors": "Strong, J. Wegstein, J. Tritter, A. Olsztyn, J. Mock, O. Steel, T.", "words_pool": ["chang", "commun", "machin", "part", "problem", "program", "propos", "solut", "strong", "wegstein", "tritter", "olsztyn", "mock", "steel"], "word_count": {"chang": 1, "commun": 1, "machin": 1, "part": 1, "problem": 1, "program": 1, "propos": 1, "solut": 1, "strong": 1, "wegstein": 1, "tritter": 1, "olsztyn": 1, "mock": 1, "steel": 1}}, "12": {"id": "12", "title": "Error Estimation in Runge-Kutta Procedures", "authors": "Call, D. H. Reeves, R. F.", "words_pool": ["error", "estim", "kutta", "procedur", "rung", "call", "reev"], "word_count": {"error": 1, "estim": 1, "kutta": 1, "procedur": 1, "rung": 1, "call": 1, "reev": 1}}, "13": {"id": "13", "title": "Glossary of Computer Engineering and Programming Terminology", "words_pool": ["comput", "engin", "glossari", "program", "terminolog"], "word_count": {"comput": 1, "engin": 1, "glossari": 1, "program": 1, "terminolog": 1}}, "14": {"id": "14", "title": "The Problem of Programming Communication with Changing Machines A Proposed Solution (Part 1)", "authors": "Strong, J. Wegstein, J. Tritter, A. Olsztyn, J. Mock, O. Steel, T.", "words_pool": ["chang", "commun", "machin", "part", "problem", "program", "propos", "solut", "strong", "wegstein", "tritter", "olsztyn", "mock", "steel"], "word_count": {"chang": 1, "commun": 1, "machin": 1, "part": 1, "problem": 1, "program": 1, "propos": 1, "solut": 1, "strong": 1, "wegstein": 1, "tritter": 1, "olsztyn": 1, "mock": 1, "steel": 1}}, "15": {"id": "15", "title": "Recursive Curve Fitting Technique", "authors": "Giblin, J.", "words_pool": ["curv", "fit", "recurs", "techniqu", "giblin"], "word_count": {"curv": 1, "fit": 1, "recurs": 1, "techniqu": 1, "giblin": 1}}, "16": {"id": "16", "title": "Secant Modification of Newton's Method", "authors": "Jeeves, T. A.", "words_pool": ["method", "modif", "newton", "secant", "jeev"], "word_count": {"method": 1, "modif": 1, "newton": 1, "secant": 1, "jeev": 1}}, "17": {"id": "17", "title": "On Programming of Arithmetic Operations", "authors": "Ershov, A. P.", "words_pool": ["arithmet", "oper", "program", "ershov"], "word_count": {"arithmet": 1, "oper": 1, "program": 1, "ershov": 1}}, "18": {"id": "18", "title": "Simple Automatic Coding Systems", "authors": "Adams, E. S. Schlesinger, S. I.", "words_pool": ["automat", "code", "simpl", "system", "adam", "schlesing"], "word_count": {"automat": 1, "code": 1, "simpl": 1, "system": 1, "adam": 1, "schlesing": 1}}, "19": {"id": "19", "title": "Glossary of Computer Engineering and Programming Terminology", "words_pool": ["comput", "engin", "glossari", "program", "terminolog"], "word_count": {"comput": 1, "engin": 1, "glossari": 1, "program": 1, "terminolog": 1}}, "20": {"id": "20", "title": "Accelerating Convergence of Iterative Processes", "abstract": "A technique is discussed which, when applied to an iterative procedure for the solution of an equation, accelerates the rate of convergence if the iteration converges and induces convergence if the iteration diverges.  An illustrative example is given.", "authors": "Wegstein, J. H.", "words_pool": ["acceler", "acceler", "appli", "converg", "converg", "discuss", "diverg", "equat", "illustr", "induc", "iter", "iter", "procedur", "process", "rate", "solut", "techniqu", "wegstein"], "word_count": {"acceler": 1, "appli": 1, "converg": 3, "discuss": 1, "diverg": 1, "equat": 1, "illustr": 1, "induc": 1, "iter": 3, "procedur": 1, "process": 1, "rate": 1, "solut": 1, "techniqu": 1, "wegstein": 1}}, "21": {"id": "21", "title": "Algebraic Formulation of Flow Diagrams", "authors": "Voorhees, E. A.", "words_pool": ["algebra", "diagram", "flow", "formul", "voorhe"], "word_count": {"algebra": 1, "diagram": 1, "flow": 1, "formul": 1, "voorhe": 1}}, "22": {"id": "22", "title": "Unusual Applications Department--Automatic Implementation of Computer Logic", "authors": "Morris, E. F. Wohr, T. E.", "words_pool": ["applic", "automat", "comput", "depart", "implement", "logic", "unusu", "morri", "wohr"], "word_count": {"applic": 1, "automat": 1, "comput": 1, "depart": 1, "implement": 1, "logic": 1, "unusu": 1, "morri": 1, "wohr": 1}}, "23": {"id": "23", "title": "Binary and Truth-Function Operations on a Decimal Computer with an Extract Command", "authors": "Kautz, W. H.", "words_pool": ["binari", "command", "comput", "decim", "extract", "function", "oper", "truth", "kautz"], "word_count": {"binari": 1, "command": 1, "comput": 1, "decim": 1, "extract": 1, "function": 1, "oper": 1, "truth": 1, "kautz": 1}}, "24": {"id": "24", "title": "An Improved Decimal Redundancy Check", "authors": "Sisson, R. L.", "words_pool": ["check", "decim", "improv", "redund", "sisson"], "word_count": {"check": 1, "decim": 1, "improv": 1, "redund": 1, "sisson": 1}}, "25": {"id": "25", "title": "General Purpose Programming Systems", "authors": "Holt, A. W.", "words_pool": ["gener", "program", "purpos", "system", "holt"], "word_count": {"gener": 1, "program": 1, "purpos": 1, "system": 1, "holt": 1}}, "26": {"id": "26", "title": "A Subroutine Method for Calculating Logarithms", "authors": "Bemer, R. W.", "words_pool": ["calcul", "logarithm", "method", "subroutin", "bemer"], "word_count": {"calcul": 1, "logarithm": 1, "method": 1, "subroutin": 1, "bemer": 1}}, "27": {"id": "27", "title": "Note On Empirical Bounds For Generating Bessel Functions", "authors": "Randels, J. B. Reeves, R. F.", "words_pool": ["bessel", "bound", "empir", "function", "gener", "note", "randel", "reev"], "word_count": {"bessel": 1, "bound": 1, "empir": 1, "function": 1, "gener": 1, "note": 1, "randel": 1, "reev": 1}}, "28": {"id": "28", "title": "Request for Methods or Programs", "authors": "Corley, H. P. T.", "words_pool": ["method", "program", "request", "corley"], "word_count": {"method": 1, "program": 1, "request": 1, "corley": 1}}, "29": {"id": "29", "title": "Need for an Algorithm", "authors": "Selden, W.", "words_pool": ["algorithm", "need", "selden"], "word_count": {"algorithm": 1, "need": 1, "selden": 1}}, "30": {"id": "30", "title": "Algorithm for Analyzing Logical Statements to Produce a Truth Function Table", "authors": "Wolpe, H.", "words_pool": ["algorithm", "analyz", "function", "logic", "produc", "statement", "tabl", "truth", "wolp"], "word_count": {"algorithm": 1, "analyz": 1, "function": 1, "logic": 1, "produc": 1, "statement": 1, "tabl": 1, "truth": 1, "wolp": 1}}, "31": {"id": "31", "title": "IBM 704 Code-Nundrums", "authors": "Grumette, M.", "words_pool": ["code", "ibm", "nundrum", "grumett"], "word_count": {"code": 1, "ibm": 1, "nundrum": 1, "grumett": 1}}, "32": {"id": "32", "title": "Variable-Width Tables with Binary-Search Facility", "authors": "Halpern, M.", "words_pool": ["binari", "facil", "search", "tabl", "variabl", "width", "halpern"], "word_count": {"binari": 1, "facil": 1, "search": 1, "tabl": 1, "variabl": 1, "width": 1, "halpern": 1}}, "33": {"id": "33", "title": "A Programmed Binary Counter For The IBM Type 650 Calculator", "authors": "Kenny, B. C. Hunter, J. A.", "words_pool": ["binari", "calcul", "counter", "ibm", "program", "type", "kenni", "hunter"], "word_count": {"binari": 1, "calcul": 1, "counter": 1, "ibm": 1, "program": 1, "type": 1, "kenni": 1, "hunter": 1}}, "34": {"id": "34", "title": "Tables for Automatic Computation", "authors": "Wilf, H. S.", "words_pool": ["automat", "comput", "tabl", "wilf"], "word_count": {"automat": 1, "comput": 1, "tabl": 1, "wilf": 1}}, "35": {"id": "35", "title": "A Machine Method for Square-Root Computation", "authors": "Bemer, R. W.", "words_pool": ["comput", "machin", "method", "root", "squar", "bemer"], "word_count": {"comput": 1, "machin": 1, "method": 1, "root": 1, "squar": 1, "bemer": 1}}, "36": {"id": "36", "title": "A Queue Network Simulator for the IBM 650 and Burroughs 220", "authors": "Conway, R. W. Johnson, B. M. Maxwell, W. L.", "words_pool": ["burrough", "ibm", "network", "queue", "simul", "conway", "johnson", "maxwel"], "word_count": {"burrough": 1, "ibm": 1, "network": 1, "queue": 1, "simul": 1, "conway": 1, "johnson": 1, "maxwel": 1}}, "37": {"id": "37", "title": "Impact of Computer Developments", "authors": "Humphrey, S. M.", "words_pool": ["comput", "develop", "impact", "humphrey"], "word_count": {"comput": 1, "develop": 1, "impact": 1, "humphrey": 1}}, "38": {"id": "38", "title": "A Proposed Interpretation in ALGOL", "authors": "Irons, E. T. Acton, F. S.", "words_pool": ["algol", "interpret", "propos", "iron", "acton"], "word_count": {"algol": 1, "interpret": 1, "propos": 1, "iron": 1, "acton": 1}}, "39": {"id": "39", "title": "The Secant Method for Simultaneous Nonlinear Equations", "abstract": "A procedure for the simultaneous solution of a system of not-necessarily-linear equations,  a generalization of the secant method for a single function of one variable, is given.", "authors": "Wolfe, P.", "words_pool": ["equat", "function", "gener", "linear", "method", "necessarili", "nonlinear", "procedur", "secant", "simultan", "singl", "solut", "system", "variabl", "wolf"], "word_count": {"equat": 1, "function": 1, "gener": 1, "linear": 1, "method": 1, "necessarili": 1, "nonlinear": 1, "procedur": 1, "secant": 1, "simultan": 1, "singl": 1, "solut": 1, "system": 1, "variabl": 1, "wolf": 1}}, "40": {"id": "40", "title": "Fingers or Fists? (The Choice of Decimal or Binary Representation)", "abstract": "The binary number system offers many advantages over a decimal representation for a high-performance,  general-purpose computer.  The greater simplicity of a binary arithmetic unit and the greater compactness  of binary numbers both contribute directly to arithmetic speed.  Less obvious and perhaps more important  is the way binary addressing and instruction formats can increase the overall performance.  Binary addresses  are also essential to certain powerful operations which are not practical with decimal instruction formats.   On the other hand, decimal numbers are essential for communicating between man and the computer.  In  applications requiring the processing of a large volume of inherently decimal input and output data,  the time for decimal-binary conversion needed by a purely binary computer may be significant.  A slower  decimal adder may take less time than a fast binary adder doing an addition and two conversions.  A careful  review of the significance of decimal and binary addressing and both binary and decimal data arithmetic,  supplemented by efficient conversion instructions.", "authors": "Buchholz, W.", "words_pool": ["adder", "addit", "address", "address", "advantag", "applic", "arithmet", "binari", "care", "choic", "commun", "compact", "comput", "contribut", "convers", "convers", "data", "decim", "directli", "effici", "essenti", "fast", "finger", "fist", "format", "gener", "greater", "hand", "high", "import", "increas", "inher", "input", "instruct", "instruct", "larg", "man", "need", "number", "number", "obviou", "offer", "oper", "output", "perform", "power", "practic", "process", "pure", "purpos", "represent", "requir", "review", "signific", "signific", "simplic", "slower", "speed", "supplement", "system", "take", "time", "unit", "volum", "buchholz"], "word_count": {"adder": 2, "addit": 1, "address": 3, "advantag": 1, "applic": 1, "arithmet": 3, "binari": 10, "care": 1, "choic": 1, "commun": 1, "compact": 1, "comput": 3, "contribut": 1, "convers": 3, "data": 2, "decim": 8, "directli": 1, "effici": 1, "essenti": 2, "fast": 1, "finger": 1, "fist": 1, "format": 2, "gener": 1, "greater": 2, "hand": 1, "high": 1, "import": 1, "increas": 1, "inher": 1, "input": 1, "instruct": 3, "larg": 1, "man": 1, "need": 1, "number": 3, "obviou": 1, "offer": 1, "oper": 1, "output": 1, "perform": 2, "power": 1, "practic": 1, "process": 1, "pure": 1, "purpos": 1, "represent": 1, "requir": 1, "review": 1, "signific": 2, "simplic": 1, "slower": 1, "speed": 1, "supplement": 1, "system": 1, "take": 1, "time": 2, "unit": 1, "volum": 1, "buchholz": 1}}, "41": {"id": "41", "title": "Some Notes on Computer Research in Eastern Europe", "authors": "Nadler, M.", "words_pool": ["comput", "eastern", "europ", "note", "research", "nadler"], "word_count": {"comput": 1, "eastern": 1, "europ": 1, "note": 1, "research": 1, "nadler": 1}}, "42": {"id": "42", "title": "A New Method of Computation of Square Roots Without Using Division", "authors": "Sarafyan, D.", "words_pool": ["comput", "divis", "method", "root", "squar", "sarafyan"], "word_count": {"comput": 1, "divis": 1, "method": 1, "root": 1, "squar": 1, "sarafyan": 1}}, "43": {"id": "43", "title": "A Technique for Handling Macro Instructions", "authors": "Greenwald, I. D.", "words_pool": ["handl", "instruct", "macro", "techniqu", "greenwald"], "word_count": {"handl": 1, "instruct": 1, "macro": 1, "techniqu": 1, "greenwald": 1}}, "44": {"id": "44", "title": "RUNCIBLE-Algebraic Translation on a Limited Computer", "authors": "Knuth, D. E.", "words_pool": ["algebra", "comput", "limit", "runcibl", "translat", "knuth"], "word_count": {"algebra": 1, "comput": 1, "limit": 1, "runcibl": 1, "translat": 1, "knuth": 1}}, "45": {"id": "45", "title": "Flow Outlining-A Substitute for Flow Charting", "authors": "Gant, W. T.", "words_pool": ["chart", "flow", "outlin", "substitut", "gant"], "word_count": {"chart": 1, "flow": 2, "outlin": 1, "substitut": 1, "gant": 1}}, "46": {"id": "46", "title": "Multiprogramming STRETCH: Feasibility Considerations", "abstract": "The tendency towards increased parallelism in computers is noted.  Exploitation of this parallelism  presents a number of new problems in machine design and in programming systems.  Minimum requirements  for successful concurrent execution of several independent problem programs are discussed.  These requirements  are met in the STRETCH system by a carefully balanced combination of built-in and programmed logic.   Techniques are described which place the burden of the programmed logic on system programs (supervisory  program and compiler) rather than on problem programs.", "authors": "Codd, E. F. Lowry, E. S. McDonough, E. Scalzi, C. A.", "words_pool": ["balanc", "built", "burden", "care", "combin", "compil", "comput", "concurr", "consider", "design", "discuss", "execut", "exploit", "feasibl", "increas", "independ", "logic", "machin", "met", "minimum", "multiprogram", "note", "number", "parallel", "place", "present", "problem", "problem", "program", "program", "program", "program", "requir", "stretch", "success", "supervisori", "system", "system", "techniqu", "tendenc", "codd", "lowri", "mcdonough", "scalzi"], "word_count": {"balanc": 1, "built": 1, "burden": 1, "care": 1, "combin": 1, "compil": 1, "comput": 1, "concurr": 1, "consider": 1, "design": 1, "discuss": 1, "execut": 1, "exploit": 1, "feasibl": 1, "increas": 1, "independ": 1, "logic": 2, "machin": 1, "met": 1, "minimum": 1, "multiprogram": 1, "note": 1, "number": 1, "parallel": 2, "place": 1, "present": 1, "problem": 3, "program": 7, "requir": 2, "stretch": 1, "success": 1, "supervisori": 1, "system": 3, "techniqu": 1, "tendenc": 1, "codd": 1, "lowri": 1, "mcdonough": 1, "scalzi": 1}}, "47": {"id": "47", "title": "Russian Visit to U.S. Computers", "authors": "Zaitzeff, E. M. Astrahan, M. M.", "words_pool": ["comput", "russian", "visit", "zaitzeff", "astrahan"], "word_count": {"comput": 1, "russian": 1, "visit": 1, "zaitzeff": 1, "astrahan": 1}}, "48": {"id": "48", "title": "Shift-Register Code for Indexing Applications", "abstract": "In this communication the use of a shift-register code with n = 10 is described for calling  64 wireless telemetering stations in a fixed cyclical order.  A high degree of redundancy is used, permitting  a single-error correcting code (\"minimum-distance-three\" code) with 64 10-bit code words to be employed  as the station identification code.  Embedding this in the shift-register code with period 1023 permits  the code to be employed without punctuation, each of the telemetering station receivers simply putting  received ones and zeros into a shift register.  Each time the given code combination arises identifying  the particular station (barring for tuitous error combinations of very low probability) it has been called.   The communication describes the properties and application of the code in some detail and the finding  of the particular example to be employed on URAL, the Soviet-built drum computer donated to the Indian  Statistical Institute by the United Nations Technical Aid Administration (UNTAA).", "authors": "Nadler, M. Sengupta, A.", "words_pool": ["administr", "aid", "applic", "applic", "aris", "bar", "bit", "built", "call", "call", "code", "combin", "combin", "commun", "comput", "correct", "cyclic", "degre", "describ", "detail", "distanc", "donat", "drum", "embed", "employ", "error", "find", "fix", "high", "identif", "identifi", "index", "indian", "institut", "low", "minimum", "nation", "order", "period", "permit", "permit", "probabl", "properti", "punctuat", "put", "receiv", "receiv", "redund", "regist", "shift", "simpli", "singl", "soviet", "station", "station", "statist", "technic", "telemet", "time", "tuitou", "unit", "untaa", "ural", "wireless", "word", "zero", "nadler", "sengupta"], "word_count": {"administr": 1, "aid": 1, "applic": 1, "aris": 1, "bar": 1, "bit": 1, "built": 1, "call": 2, "code": 9, "combin": 2, "commun": 2, "comput": 1, "correct": 1, "cyclic": 1, "degre": 1, "describ": 1, "detail": 1, "distanc": 1, "donat": 1, "drum": 1, "embed": 1, "employ": 3, "error": 2, "find": 1, "fix": 1, "high": 1, "identif": 1, "identifi": 1, "index": 1, "indian": 1, "institut": 1, "low": 1, "minimum": 1, "nation": 1, "order": 1, "period": 1, "permit": 2, "probabl": 1, "properti": 1, "punctuat": 1, "put": 1, "receiv": 2, "redund": 1, "regist": 3, "shift": 3, "simpli": 1, "singl": 1, "soviet": 1, "station": 4, "statist": 1, "technic": 1, "telemet": 2, "time": 1, "tuitou": 1, "unit": 1, "untaa": 1, "ural": 1, "wireless": 1, "word": 1, "zero": 1, "nadler": 1, "sengupta": 1}}, "49": {"id": "49", "title": "Scientific and Business Applications (Oracle Curve Plotter)", "authors": "Fike, C. T.", "words_pool": ["applic", "busi", "curv", "oracl", "plotter", "scientif", "fike"], "word_count": {"applic": 1, "busi": 1, "curv": 1, "oracl": 1, "plotter": 1, "scientif": 1, "fike": 1}}, "50": {"id": "50", "title": "Statistical Programs for the IBM 650-Part II", "authors": "Hamblen, J. W.", "words_pool": ["ibm", "ii", "part", "program", "statist", "hamblen"], "word_count": {"ibm": 1, "ii": 1, "part": 1, "program": 1, "statist": 1, "hamblen": 1}}, "51": {"id": "51", "title": "On the Construction of Micro-Flowcharts", "authors": "Gorn, S. Ingerman, P. Z. Crozier, J. B.", "words_pool": ["construct", "flowchart", "micro", "gorn", "ingerman", "crozier"], "word_count": {"construct": 1, "flowchart": 1, "micro": 1, "gorn": 1, "ingerman": 1, "crozier": 1}}, "52": {"id": "52", "title": "An Efficient Method for Generating Uniformly Distributed Points on the Surface on an n-Dimensional  Sphere (Corrigendum)", "authors": "Cook, J. M.", "words_pool": ["corrigendum", "dimension", "distribut", "effici", "gener", "method", "point", "sphere", "surfac", "uniformli", "cook"], "word_count": {"corrigendum": 1, "dimension": 1, "distribut": 1, "effici": 1, "gener": 1, "method": 1, "point": 1, "sphere": 1, "surfac": 1, "uniformli": 1, "cook": 1}}, "53": {"id": "53", "title": "Recommendations of the SHARE ALGOL Committee", "words_pool": ["algol", "committe", "recommend", "share"], "word_count": {"algol": 1, "committe": 1, "recommend": 1, "share": 1}}, "54": {"id": "54", "title": "SALE, a Simple Algebraic Language for Engineers", "authors": "Brittenham, W. R. Clark, K. Kuss, G. Thompson, H. Smith, A. O.", "words_pool": ["algebra", "engin", "languag", "sale", "simpl", "brittenham", "clark", "kuss", "thompson", "smith"], "word_count": {"algebra": 1, "engin": 1, "languag": 1, "sale": 1, "simpl": 1, "brittenham": 1, "clark": 1, "kuss": 1, "thompson": 1, "smith": 1}}, "55": {"id": "55", "title": "An Algebraic Translator", "authors": "Kaner, H.", "words_pool": ["algebra", "translat", "kaner"], "word_count": {"algebra": 1, "translat": 1, "kaner": 1}}, "56": {"id": "56", "title": "Proposed Standard Flow Chart Symbols", "words_pool": ["chart", "flow", "propos", "standard", "symbol"], "word_count": {"chart": 1, "flow": 1, "propos": 1, "standard": 1, "symbol": 1}}, "57": {"id": "57", "title": "J.E", "words_pool": [], "word_count": {}}, ".D": {"id": ".D", "authors": ". and Its Computer Center", "words_pool": ["comput", "center"], "word_count": {"comput": 1, "center": 1}}, "58": {"id": "58", "title": "LEM-1, Small Size General Purpose Digital Computer Using Magnetic (Ferrite) Elements", "abstract": "The paper examines some of the questions of development and construction of a general purpose  digital computer using contactless magnetic (ferrite) and capacitive \"DEZU\" (long duration capacitive  memory) elements, developed at the Laboratory of Electrical Modeling VINITYI AN SSSR, under the supervision  of Professor L", "words_pool": ["capacit", "comput", "construct", "contactless", "develop", "develop", "dezu", "digit", "durat", "electr", "element", "examin", "ferrit", "gener", "laboratori", "lem", "long", "magnet", "memori", "model", "paper", "professor", "purpos", "question", "size", "small", "sssr", "supervis", "vinityi"], "word_count": {"capacit": 2, "comput": 1, "construct": 1, "contactless": 1, "develop": 2, "dezu": 1, "digit": 1, "durat": 1, "electr": 1, "element": 1, "examin": 1, "ferrit": 1, "gener": 1, "laboratori": 1, "lem": 1, "long": 1, "magnet": 1, "memori": 1, "model": 1, "paper": 1, "professor": 1, "purpos": 1, "question": 1, "size": 1, "small": 1, "sssr": 1, "supervis": 1, "vinityi": 1}}, ". Gutenmacher.": {"id": ". Gutenmacher.", "authors": "Machmudov, U. A.", "words_pool": ["machmudov"], "word_count": {"machmudov": 1}}, "59": {"id": "59", "title": "Survey of Progress and Trend of Development and Use of Automatic Data Processing in Business and Management control Systems of the Federal Government, as of December 1957-III", "words_pool": ["automat", "busi", "control", "data", "decemb", "develop", "feder", "govern", "iii", "manag", "process", "progress", "survey", "system", "trend"], "word_count": {"automat": 1, "busi": 1, "control": 1, "data": 1, "decemb": 1, "develop": 1, "feder": 1, "govern": 1, "iii": 1, "manag": 1, "process": 1, "progress": 1, "survey": 1, "system": 1, "trend": 1}}, "60": {"id": "60", "title": "The Alpha Vector Transformation of a System of Linear Constraints", "authors": "Wersan, S. J.", "words_pool": ["alpha", "constraint", "linear", "system", "transform", "vector", "wersan"], "word_count": {"alpha": 1, "constraint": 1, "linear": 1, "system": 1, "transform": 1, "vector": 1, "wersan": 1}}, "61": {"id": "61", "title": "IBM 709 Tape Matrix Compiler", "authors": "Hornick, S. D.", "words_pool": ["compil", "ibm", "matrix", "tape", "hornick"], "word_count": {"compil": 1, "ibm": 1, "matrix": 1, "tape": 1, "hornick": 1}}, "62": {"id": "62", "title": "Multi-Dimensional Least-Squares Polynomial Curve Fitting", "authors": "Lesh, F. H.", "words_pool": ["curv", "dimension", "fit", "multi", "polynomi", "squar", "lesh"], "word_count": {"curv": 1, "dimension": 1, "fit": 1, "multi": 1, "polynomi": 1, "squar": 1, "lesh": 1}}, "63": {"id": "63", "title": "Octal Diagrams of Binary Conception and Their Applicability to Computer Design Logic", "abstract": "This paper dates back the genesis of binary conception circa 5000 years ago, and octal diagrams  about 4800 years ago, as derived by the Chinese ancients.  It analyzes the applicability of binary trinities  of the octal diagrams to modern electronic-digital-computer design logic.", "authors": "Li, S. T.", "words_pool": ["ago", "analyz", "ancient", "applic", "back", "binari", "chines", "circa", "comput", "concept", "date", "deriv", "design", "diagram", "digit", "electron", "genesi", "logic", "modern", "octal", "paper", "triniti", "year", "li"], "word_count": {"ago": 2, "analyz": 1, "ancient": 1, "applic": 1, "back": 1, "binari": 2, "chines": 1, "circa": 1, "comput": 1, "concept": 1, "date": 1, "deriv": 1, "design": 1, "diagram": 2, "digit": 1, "electron": 1, "genesi": 1, "logic": 1, "modern": 1, "octal": 2, "paper": 1, "triniti": 1, "year": 2, "li": 1}}, "64": {"id": "64", "title": "Remarks on ALGOL and Symbol Manipulation", "authors": "Green, J.", "words_pool": ["algol", "manipul", "remark", "symbol", "green"], "word_count": {"algol": 1, "manipul": 1, "remark": 1, "symbol": 1, "green": 1}}, "65": {"id": "65", "title": "ALGOL Sub-Committee Report - Extensions", "authors": "Dijkstra, E. W. Heise, W. Perlis, J. A. Samelson, K.", "words_pool": ["algol", "committe", "extens", "report", "dijkstra", "heis", "perli", "samelson"], "word_count": {"algol": 1, "committe": 1, "extens": 1, "report": 1, "dijkstra": 1, "heis": 1, "perli": 1, "samelson": 1}}, "66": {"id": "66", "title": "A Proposal for a Generalized Card Code for 256 Characters", "authors": "Bemer, R. W.", "words_pool": ["card", "charact", "code", "gener", "propos", "bemer"], "word_count": {"card": 1, "charact": 1, "code": 1, "gener": 1, "propos": 1, "bemer": 1}}, "67": {"id": "67", "title": "Central-European Computers", "authors": "Blachman, N. M.", "words_pool": ["central", "comput", "european", "blachman"], "word_count": {"central": 1, "comput": 1, "european": 1, "blachman": 1}}, "68": {"id": "68", "title": "The Role of the University in Computers, Data Processing and Related Fields", "abstract": "A study was made of university programs in the United States in the fields of computers, data  processing, operations research, and other closely related fields.  University policies, organization,  administration, faculties, students, researches, curricula, equipment, and financing were investigated.   An integrated university program is recommended reflecting the conviction that many present activities  related to computers will develop into disciplines and as such are the legitimate province of the university  scholar.  Details on a recommended Graduate School of \"Computer Sciences\" are given.", "authors": "Fein, L.", "words_pool": ["activ", "administr", "close", "comput", "comput", "convict", "curricula", "data", "detail", "develop", "disciplin", "equip", "faculti", "field", "financ", "graduat", "integr", "investig", "legitim", "made", "oper", "organ", "polici", "present", "process", "program", "program", "provinc", "recommend", "reflect", "relat", "research", "research", "role", "scholar", "school", "scienc", "state", "student", "studi", "unit", "univers", "fein"], "word_count": {"activ": 1, "administr": 1, "close": 1, "comput": 3, "convict": 1, "curricula": 1, "data": 1, "detail": 1, "develop": 1, "disciplin": 1, "equip": 1, "faculti": 1, "field": 2, "financ": 1, "graduat": 1, "integr": 1, "investig": 1, "legitim": 1, "made": 1, "oper": 1, "organ": 1, "polici": 1, "present": 1, "process": 1, "program": 2, "provinc": 1, "recommend": 2, "reflect": 1, "relat": 2, "research": 2, "role": 1, "scholar": 1, "school": 1, "scienc": 1, "state": 1, "student": 1, "studi": 1, "unit": 1, "univers": 4, "fein": 1}}, "69": {"id": "69", "title": "Statistical Programs for the IBM 650-Part I", "abstract": "A collection is given of brief descriptions of statistical programs now in use in university  computing centers which have IBM 650's.", "authors": "Hamblen, J. W.", "words_pool": ["center", "collect", "comput", "descript", "ibm", "part", "program", "statist", "univers", "hamblen"], "word_count": {"center": 1, "collect": 1, "comput": 1, "descript": 1, "ibm": 1, "part": 1, "program": 1, "statist": 1, "univers": 1, "hamblen": 1}}, "70": {"id": "70", "title": "Construction of a Set of Test Matrices", "abstract": "This paper develops the equations and properties of a set of test matrices which are useful  in the determination of the accuracy of routines for finding the inverse, determinant and/or eigenvalues  of a matrix.", "authors": "Aegerter, M. J.", "words_pool": ["accuraci", "construct", "determin", "determin", "develop", "eigenvalu", "equat", "find", "invers", "matric", "matrix", "paper", "properti", "routin", "set", "test", "aegert"], "word_count": {"accuraci": 1, "construct": 1, "determin": 2, "develop": 1, "eigenvalu": 1, "equat": 1, "find": 1, "invers": 1, "matric": 1, "matrix": 1, "paper": 1, "properti": 1, "routin": 1, "set": 1, "test": 1, "aegert": 1}}, "71": {"id": "71", "title": "Proposal for a Feasible Programming System", "abstract": "This paper proposes designing a programming facility (itself involving a digital computer and  a program) which will assist the preparation of large-scale real-time programs.  This facility is to  be capable of preparing programs for any of a variety of machines having characteristics similar to those  of the facility's computer.  One of the basic assumptions is that there will be enough random-access  storage available to avoid the necessity for segmenting a constructed program in any fashion other than  a trivial one.  While this assumption is somewhat unrealistic, it is intended to provide an opportunity  to concentrate on the other aspects of program construction.  The programming system should stress the  discovery in source program statements of as many errors as possible, before attempting to construct  an object program.  Among the computer characteristics which are advocated are a program interrupt scheme,  a large set of characters, and indirect addressing.", "authors": "Bagley, P. R.", "words_pool": ["access", "address", "advoc", "aspect", "assist", "assumpt", "assumpt", "attempt", "avoid", "basic", "capabl", "characterist", "charact", "comput", "concentr", "construct", "construct", "construct", "design", "digit", "discoveri", "error", "facil", "fashion", "feasibl", "indirect", "intend", "interrupt", "involv", "larg", "machin", "necess", "object", "opportun", "paper", "prepar", "prepar", "program", "program", "program", "propos", "propos", "provid", "random", "real", "scale", "scheme", "segment", "set", "similar", "sourc", "statement", "storag", "stress", "system", "time", "trivial", "unrealist", "varieti", "bagley"], "word_count": {"access": 1, "address": 1, "advoc": 1, "aspect": 1, "assist": 1, "assumpt": 2, "attempt": 1, "avoid": 1, "basic": 1, "capabl": 1, "characterist": 2, "charact": 1, "comput": 3, "concentr": 1, "construct": 3, "design": 1, "digit": 1, "discoveri": 1, "error": 1, "facil": 3, "fashion": 1, "feasibl": 1, "indirect": 1, "intend": 1, "interrupt": 1, "involv": 1, "larg": 2, "machin": 1, "necess": 1, "object": 1, "opportun": 1, "paper": 1, "prepar": 2, "program": 10, "propos": 1, "provid": 1, "random": 1, "real": 1, "scale": 1, "scheme": 1, "segment": 1, "set": 1, "similar": 1, "sourc": 1, "statement": 1, "storag": 1, "stress": 1, "system": 1, "time": 1, "trivial": 1, "unrealist": 1, "varieti": 1, "bagley": 1}}, "72": {"id": "72", "title": "An Educational Program in Computing", "authors": "Hollingsworth, J.", "words_pool": ["comput", "educ", "program", "hollingsworth"], "word_count": {"comput": 1, "educ": 1, "program": 1, "hollingsworth": 1}}, "73": {"id": "73", "title": "A Real Time Data Assimilator", "authors": "Gschwind, H. W.", "words_pool": ["assimil", "data", "real", "time", "gschwind"], "word_count": {"assimil": 1, "data": 1, "real": 1, "time": 1, "gschwind": 1}}, "74": {"id": "74", "title": "A High-Speed Sorting Procedure", "authors": "Shell, D. L.", "words_pool": ["high", "procedur", "sort", "speed", "shell"], "word_count": {"high": 1, "procedur": 1, "sort": 1, "speed": 1, "shell": 1}}, "75": {"id": "75", "title": "Parameter Estimation for Simple Nonlinear Models", "authors": "Chow, W. M.", "words_pool": ["estim", "model", "nonlinear", "paramet", "simpl", "chow"], "word_count": {"estim": 1, "model": 1, "nonlinear": 1, "paramet": 1, "simpl": 1, "chow": 1}}, "76": {"id": "76", "title": "Binary Conversion, With Fixed Decimal Precision, Of a Decimal Fraction", "authors": "Taranto, D.", "words_pool": ["binari", "convers", "decim", "fix", "fraction", "precis", "taranto"], "word_count": {"binari": 1, "convers": 1, "decim": 2, "fix": 1, "fraction": 1, "precis": 1, "taranto": 1}}, "77": {"id": "77", "title": "On GAT and the Construction of Translators", "authors": "Arden, B. Graham, R.", "words_pool": ["construct", "gat", "translat", "arden", "graham"], "word_count": {"construct": 1, "gat": 1, "translat": 1, "arden": 1, "graham": 1}}, "78": {"id": "78", "title": "Remarks on the Practical Solution of Characteristic Value Problems", "abstract": "This paper is concerned with the practical solution of characteristic value problem for an  ordinary differential equation.  It is at once apparent that sequential computers, be they digital or  analog, solve initial value problems, rather than boundary value problems, and some mathematical process  must be found to compensate for the machine's inadequacy.  (Compensating for machine imperfection is,  of course, the normal activity of the numerical analyst.)  A number of other papers have applied particular  devices to particular problems.  The purpose of this note is to establish a mathematical framework or  model for these practical procedures and thus assist in the use and extension of the ideas in other particular  problems.", "authors": "Wouk, A.", "words_pool": ["activ", "analog", "analyst", "appar", "appli", "assist", "boundari", "characterist", "compens", "compens", "comput", "concern", "cours", "devic", "differenti", "digit", "equat", "establish", "extens", "found", "framework", "idea", "imperfect", "inadequaci", "initi", "machin", "mathemat", "model", "normal", "note", "number", "numer", "ordinari", "paper", "paper", "practic", "problem", "problem", "procedur", "process", "purpos", "remark", "sequenti", "solut", "solv", "wouk"], "word_count": {"activ": 1, "analog": 1, "analyst": 1, "appar": 1, "appli": 1, "assist": 1, "boundari": 1, "characterist": 1, "compens": 2, "comput": 1, "concern": 1, "cours": 1, "devic": 1, "differenti": 1, "digit": 1, "equat": 1, "establish": 1, "extens": 1, "found": 1, "framework": 1, "idea": 1, "imperfect": 1, "inadequaci": 1, "initi": 1, "machin": 2, "mathemat": 2, "model": 1, "normal": 1, "note": 1, "number": 1, "numer": 1, "ordinari": 1, "paper": 2, "practic": 2, "problem": 5, "procedur": 1, "process": 1, "purpos": 1, "remark": 1, "sequenti": 1, "solut": 1, "solv": 1, "wouk": 1}}, "79": {"id": "79", "title": "Programming for a Machine With an Extended Address Calculational Mechanism", "authors": "Schecher, H.", "words_pool": ["address", "calcul", "extend", "machin", "mechan", "program", "schecher"], "word_count": {"address": 1, "calcul": 1, "extend": 1, "machin": 1, "mechan": 1, "program": 1, "schecher": 1}}, "80": {"id": "80", "title": "A Technique for Computing Critical Rotational Speeds of Flexible Shafts on an Automatic Computer", "authors": "Schwartz, B. L.", "words_pool": ["automat", "comput", "comput", "critic", "flexibl", "rotat", "shaft", "speed", "techniqu", "schwartz"], "word_count": {"automat": 1, "comput": 2, "critic": 1, "flexibl": 1, "rotat": 1, "shaft": 1, "speed": 1, "techniqu": 1, "schwartz": 1}}, "81": {"id": "81", "title": "NORC High-Speed Printer", "authors": "Gleissner, G. H.", "words_pool": ["high", "norc", "printer", "speed", "gleissner"], "word_count": {"high": 1, "norc": 1, "printer": 1, "speed": 1, "gleissner": 1}}, "82": {"id": "82", "title": "Handling Identifiers as Internal Symbols in Language Processors", "abstract": "Substitution of computer-oriented symbols for programmer-oriented symbols in language processors  is examined and a feasible method for doing so is presented.", "authors": "Williams, F. A.", "words_pool": ["comput", "examin", "feasibl", "handl", "identifi", "intern", "languag", "method", "orient", "present", "processor", "programm", "substitut", "symbol", "william"], "word_count": {"comput": 1, "examin": 1, "feasibl": 1, "handl": 1, "identifi": 1, "intern": 1, "languag": 1, "method": 1, "orient": 2, "present": 1, "processor": 1, "programm": 1, "substitut": 1, "symbol": 2, "william": 1}}, "83": {"id": "83", "title": "A Visit to Computation Centers in the Soviet Union", "authors": "Carr III, J. W.", "words_pool": ["center", "comput", "soviet", "union", "visit", "carr", "iii"], "word_count": {"center": 1, "comput": 1, "soviet": 1, "union": 1, "visit": 1, "carr": 1, "iii": 1}}, "84": {"id": "84", "title": "Survey of Progress and Trend of Development and Use of Automatic Data Processing in Business and Management Control Systems of the Federal Government, as of December 1957-II (Part 2 see CA590406)", "words_pool": ["automat", "busi", "ca590406", "control", "data", "decemb", "develop", "feder", "govern", "ii", "manag", "part", "process", "progress", "survey", "system", "trend"], "word_count": {"automat": 1, "busi": 1, "ca590406": 1, "control": 1, "data": 1, "decemb": 1, "develop": 1, "feder": 1, "govern": 1, "ii": 1, "manag": 1, "part": 1, "process": 1, "progress": 1, "survey": 1, "system": 1, "trend": 1}}, "85": {"id": "85", "title": "Error Analysis in Floating Point Arithmetic", "authors": "Carr III, J. W.", "words_pool": ["analysi", "arithmet", "error", "float", "point", "carr", "iii"], "word_count": {"analysi": 1, "arithmet": 1, "error": 1, "float": 1, "point": 1, "carr": 1, "iii": 1}}, "86": {"id": "86", "title": "Survey of Progress and Trend of Development and Use of Automatic Data Processing in Business  and Management Control Systems of the Federal Government, as of December 1957", "authors": "Controller General of the United States to the Congress of the United States", "words_pool": ["automat", "busi", "control", "data", "decemb", "develop", "feder", "govern", "manag", "process", "progress", "survey", "system", "trend", "control", "gener", "unit", "state", "congress", "unit", "state"], "word_count": {"automat": 1, "busi": 1, "control": 1, "data": 1, "decemb": 1, "develop": 1, "feder": 1, "govern": 1, "manag": 1, "process": 1, "progress": 1, "survey": 1, "system": 1, "trend": 1, "gener": 1, "unit": 1, "state": 1, "congress": 1}}, "87": {"id": "87", "title": "A Note on a Method for Generating Points Uniformly on N-Dimensional Spheres", "authors": "Muller, M. E.", "words_pool": ["dimension", "gener", "method", "note", "point", "sphere", "uniformli", "muller"], "word_count": {"dimension": 1, "gener": 1, "method": 1, "note": 1, "point": 1, "sphere": 1, "uniformli": 1, "muller": 1}}, "88": {"id": "88", "title": "An Efficient Method for Generating Uniformly Distributed Points on the Surface of an n-Dimensional Sphere", "authors": "Hicks, J. S. Wheeling, R. F.", "words_pool": ["dimension", "distribut", "effici", "gener", "method", "point", "sphere", "surfac", "uniformli", "hick", "wheel"], "word_count": {"dimension": 1, "distribut": 1, "effici": 1, "gener": 1, "method": 1, "point": 1, "sphere": 1, "surfac": 1, "uniformli": 1, "hick": 1, "wheel": 1}}, "89": {"id": "89", "title": "A Routine to Find the Solution of Simultaneous Linear Equations with Polynomial Coefficients", "authors": "Larson, E. H. Marshall, D. P.", "words_pool": ["coeffici", "equat", "find", "linear", "polynomi", "routin", "simultan", "solut", "larson", "marshal"], "word_count": {"coeffici": 1, "equat": 1, "find": 1, "linear": 1, "polynomi": 1, "routin": 1, "simultan": 1, "solut": 1, "larson": 1, "marshal": 1}}, "90": {"id": "90", "title": "Binary Arithmetic for Discretely Variable Word Length in a Serial Computer", "authors": "Ercoli, P. Vacca, R.", "words_pool": ["arithmet", "binari", "comput", "discret", "length", "serial", "variabl", "word", "ercoli", "vacca"], "word_count": {"arithmet": 1, "binari": 1, "comput": 1, "discret": 1, "length": 1, "serial": 1, "variabl": 1, "word": 1, "ercoli": 1, "vacca": 1}}, "91": {"id": "91", "title": "A Mathematical Procedure for Machine Division", "authors": "Gilman, R. E.", "words_pool": ["divis", "machin", "mathemat", "procedur", "gilman"], "word_count": {"divis": 1, "machin": 1, "mathemat": 1, "procedur": 1, "gilman": 1}}, "92": {"id": "92", "title": "A Checklist of Intelligence for Programming Systems", "abstract": "A remarkable variation exists in the degree of sophistication of various programming systems.   A particular manifestation is the jungle of assorted devices for reproducing limited human decision  procedures.  An attempt is made here to begin a systematic classification of the various devices for  educating the computer to take over the decision-making functions of one or many human operators, both  those that have been demonstrated feasible to date and those that are highly desirable for the future.", "authors": "Bemer, R. W.", "words_pool": ["assort", "attempt", "begin", "checklist", "classif", "comput", "date", "decis", "degre", "demonstr", "desir", "devic", "educ", "exist", "feasibl", "function", "futur", "highli", "human", "intellig", "jungl", "limit", "made", "make", "manifest", "oper", "procedur", "program", "remark", "reproduc", "sophist", "systemat", "system", "take", "variat", "bemer"], "word_count": {"assort": 1, "attempt": 1, "begin": 1, "checklist": 1, "classif": 1, "comput": 1, "date": 1, "decis": 2, "degre": 1, "demonstr": 1, "desir": 1, "devic": 2, "educ": 1, "exist": 1, "feasibl": 1, "function": 1, "futur": 1, "highli": 1, "human": 2, "intellig": 1, "jungl": 1, "limit": 1, "made": 1, "make": 1, "manifest": 1, "oper": 1, "procedur": 1, "program": 1, "remark": 1, "reproduc": 1, "sophist": 1, "systemat": 1, "system": 1, "take": 1, "variat": 1, "bemer": 1}}, "93": {"id": "93", "title": "From Formulas to Computer Oriented Language", "abstract": "A technique is shown for enabling a computer to translate simple algebraic formulas into a  three address computer code.", "authors": "Wegstein, J. H.", "words_pool": ["address", "algebra", "code", "comput", "enabl", "formula", "languag", "orient", "shown", "simpl", "techniqu", "translat", "wegstein"], "word_count": {"address": 1, "algebra": 1, "code": 1, "comput": 2, "enabl": 1, "formula": 1, "languag": 1, "orient": 1, "shown": 1, "simpl": 1, "techniqu": 1, "translat": 1, "wegstein": 1}}, "94": {"id": "94", "title": "An Iterative Method for Fitting the Logistic Curve", "abstract": "An iterative method is given for finding a logistic curve of best least squares fit to a set  of two-dimensional points.", "authors": "Howell, J.R.", "words_pool": ["curv", "dimension", "find", "fit", "fit", "iter", "logist", "method", "point", "set", "squar", "howel"], "word_count": {"curv": 1, "dimension": 1, "find": 1, "fit": 1, "iter": 1, "logist": 1, "method": 1, "point": 1, "set": 1, "squar": 1, "howel": 1}}, "95": {"id": "95", "title": "Elimination of Special Functions from Differential Equations", "abstract": "A set of ordinary differential equations which contains mathematical functions requiring the  use of subroutines for numerical solution by electronic computer, tabular data for numerical solution  by hand calculation or function generators when analog methods are applied can sometimes be expanded  to an equivalent set of equations which do not contain the functions.  This is practical if these functions  satisfy sufficiently simple differential equations.  Thus among those functions which can be eliminated  by this procedure are the trigonometric, inverse trigonometric, exponential, and many other transcendental  functions.", "authors": "Powers, J. E.", "words_pool": ["analog", "appli", "calcul", "comput", "data", "differenti", "electron", "elimin", "elimin", "equat", "equival", "expand", "exponenti", "function", "function", "gener", "hand", "invers", "mathemat", "method", "numer", "ordinari", "practic", "procedur", "requir", "satisfi", "set", "simpl", "solut", "special", "subroutin", "suffici", "tabular", "transcendent", "trigonometr", "power"], "word_count": {"analog": 1, "appli": 1, "calcul": 1, "comput": 1, "data": 1, "differenti": 2, "electron": 1, "elimin": 1, "equat": 3, "equival": 1, "expand": 1, "exponenti": 1, "function": 6, "gener": 1, "hand": 1, "invers": 1, "mathemat": 1, "method": 1, "numer": 2, "ordinari": 1, "practic": 1, "procedur": 1, "requir": 1, "satisfi": 1, "set": 2, "simpl": 1, "solut": 2, "special": 1, "subroutin": 1, "suffici": 1, "tabular": 1, "transcendent": 1, "trigonometr": 2, "power": 1}}, "96": {"id": "96", "title": "On Computing Radiation Integrals", "abstract": "The relative merit and cost of four ways of evaluating typical radiation integrals containing  spherical Bessel functions are investigated.  These methods are desk machine evaluation of a finite series,  integration of the appropriate differential equation by a Reeves Electronic Analog Computer and by a  Litton 40 IBM 704 computer.  Results are generally applicable to equations separated from a Helmholtz  or wave equation.", "authors": "Hansen, R. C. Bailin, L. L. Rutishauser, R. W.", "words_pool": ["analog", "applic", "bessel", "comput", "comput", "cost", "desk", "differenti", "electron", "equat", "equat", "evalu", "evalu", "finit", "function", "gener", "helmholtz", "ibm", "integr", "integr", "investig", "litton", "machin", "merit", "method", "radiat", "reev", "rel", "result", "separ", "seri", "spheric", "typic", "wave", "way", "hansen", "bailin", "rutishaus"], "word_count": {"analog": 1, "applic": 1, "bessel": 1, "comput": 2, "cost": 1, "desk": 1, "differenti": 1, "electron": 1, "equat": 3, "evalu": 2, "finit": 1, "function": 1, "gener": 1, "helmholtz": 1, "ibm": 1, "integr": 2, "investig": 1, "litton": 1, "machin": 1, "merit": 1, "method": 1, "radiat": 1, "reev": 1, "rel": 1, "result": 1, "separ": 1, "seri": 1, "spheric": 1, "typic": 1, "wave": 1, "way": 1, "hansen": 1, "bailin": 1, "rutishaus": 1}}, "97": {"id": "97", "title": "Signal Corps Research and Development on Automatic Programming of Digital Computers", "authors": "Luebbert, Capt. W. F. Collom Jr., Capt. P. W.", "words_pool": ["automat", "comput", "corp", "develop", "digit", "program", "research", "signal", "luebbert", "capt", "collom", "jr", "capt"], "word_count": {"automat": 1, "comput": 1, "corp": 1, "develop": 1, "digit": 1, "program": 1, "research": 1, "signal": 1, "luebbert": 1, "capt": 1, "collom": 1, "jr": 1}}, "98": {"id": "98", "title": "The Arithmetic Translator-Compiler of the IBM FORTRAN Automatic Coding System", "authors": "Sheridan, P. B.", "words_pool": ["arithmet", "automat", "code", "compil", "fortran", "ibm", "system", "translat", "sheridan"], "word_count": {"arithmet": 1, "automat": 1, "code": 1, "compil": 1, "fortran": 1, "ibm": 1, "system": 1, "translat": 1, "sheridan": 1}}, "99": {"id": "99", "title": "Possible Modifications to the International Algebraic Language", "authors": "Green, J.", "words_pool": ["algebra", "intern", "languag", "modif", "green"], "word_count": {"algebra": 1, "intern": 1, "languag": 1, "modif": 1, "green": 1}}, "100": {"id": "100", "title": "Recursive Subscripting Compilers and List-Types Memories", "authors": "Carr III, J. W.", "words_pool": ["compil", "list", "memori", "recurs", "subscript", "type", "carr", "iii"], "word_count": {"compil": 1, "list": 1, "memori": 1, "recurs": 1, "subscript": 1, "type": 1, "carr": 1, "iii": 1}}, "101": {"id": "101", "title": "Nuclear Reactor Codes", "authors": "Nather, V. Sangren, W.", "words_pool": ["code", "nuclear", "reactor", "nather", "sangren"], "word_count": {"code": 1, "nuclear": 1, "reactor": 1, "nather": 1, "sangren": 1}}, "102": {"id": "102", "title": "A Comparison of 650 Programming Methods", "authors": "Curtz, T. B. Riordan, J. F. Spohn,M.", "words_pool": ["comparison", "method", "program", "curtz", "riordan", "spohn"], "word_count": {"comparison": 1, "method": 1, "program": 1, "curtz": 1, "riordan": 1, "spohn": 1}}, "103": {"id": "103", "title": "COPE (Console Operator Proficiency Examination)*", "abstract": "Each year electronic computers become more sophisticated, and the programs they must process  become more complex.  Because of this,dependence of those in computing on the skill and experience of  operators is increasing.  At the same time, selection and training of qualified operators grows more  difficult.  To meet the need for a quick, accurate, uniform operator test and training aid, the authors  have developed COPE (Console Operator Proficiency Examination), outlined below.  While this examination  is programmed specifically for the IBM 705 Model II with two Tape Record Coordinators, similar programs  could be developed for other computers.", "authors": "Farbman, D. Ketover, R.", "words_pool": ["accur", "aid", "author", "complex", "comput", "comput", "consol", "coordin", "cope", "depend", "develop", "difficult", "electron", "examin", "experi", "grow", "ibm", "ii", "increas", "meet", "model", "need", "oper", "oper", "outlin", "process", "profici", "program", "program", "qualifi", "quick", "record", "select", "similar", "skill", "sophist", "specif", "tape", "test", "time", "train", "uniform", "year", "farbman", "ketov"], "word_count": {"accur": 1, "aid": 1, "author": 1, "complex": 1, "comput": 3, "consol": 1, "coordin": 1, "cope": 1, "depend": 1, "develop": 2, "difficult": 1, "electron": 1, "examin": 2, "experi": 1, "grow": 1, "ibm": 1, "ii": 1, "increas": 1, "meet": 1, "model": 1, "need": 1, "oper": 4, "outlin": 1, "process": 1, "profici": 1, "program": 3, "qualifi": 1, "quick": 1, "record": 1, "select": 1, "similar": 1, "skill": 1, "sophist": 1, "specif": 1, "tape": 1, "test": 1, "time": 1, "train": 2, "uniform": 1, "year": 1, "farbman": 1, "ketov": 1}}, "104": {"id": "104", "title": "Digital Simulation of Discrete Flow Systems*", "abstract": "The discrete flow systems discussed are characterized by the movement of randomly arriving  items along interacting channels.  Programing a digital computer to simulate such systems utilizes some  techniques not common in other approaches to physical problems.  The principal portion of the paper is  a discussion of two simulation studies that illustrate some of the programming problems involved. One  is of an extensive package-handling plant, with the objective being optimization of parameters such as  storage capacities and processing rates.  In the other, air traffic flow and control procedures are simulated  to compare the effects of alternative control decisions.", "authors": "Moore, C. J. Lewis, T. S.", "words_pool": ["air", "altern", "approach", "arriv", "capac", "channel", "character", "common", "compar", "comput", "control", "decis", "digit", "discret", "discuss", "discuss", "effect", "extens", "flow", "handl", "illustr", "interact", "involv", "item", "movement", "object", "optim", "packag", "paper", "paramet", "physic", "plant", "portion", "princip", "problem", "procedur", "process", "program", "program", "randomli", "rate", "simul", "simul", "simul", "storag", "studi", "system", "techniqu", "traffic", "util", "moor", "lewi"], "word_count": {"air": 1, "altern": 1, "approach": 1, "arriv": 1, "capac": 1, "channel": 1, "character": 1, "common": 1, "compar": 1, "comput": 1, "control": 2, "decis": 1, "digit": 1, "discret": 1, "discuss": 2, "effect": 1, "extens": 1, "flow": 2, "handl": 1, "illustr": 1, "interact": 1, "involv": 1, "item": 1, "movement": 1, "object": 1, "optim": 1, "packag": 1, "paper": 1, "paramet": 1, "physic": 1, "plant": 1, "portion": 1, "princip": 1, "problem": 2, "procedur": 1, "process": 1, "program": 2, "randomli": 1, "rate": 1, "simul": 3, "storag": 1, "studi": 1, "system": 2, "techniqu": 1, "traffic": 1, "util": 1, "moor": 1, "lewi": 1}}, "105": {"id": "105", "title": "Two Methods for Word Inversion on the IBM 709", "authors": "Price, R. A. Jardins, P. D.", "words_pool": ["ibm", "invers", "method", "word", "price", "jardin"], "word_count": {"ibm": 1, "invers": 1, "method": 1, "word": 1, "price": 1, "jardin": 1}}, "106": {"id": "106", "title": "A Method for Overlapping and Erasure of Lists", "abstract": "An important property of the Newell-Shaw-Simon scheme for computer storage of lists is that  data having multiple occurrences need not be stored at more than one place in the computer.  That is,  lists may be \"overlapped.\"  Unfortunately, overlapping poses a problem for subsequent erasure.  Given  a list that is no longer needed, it is desired to erase just those parts that do not overlap other lists.   In LISP, McCarthy employs an elegant but inefficient solution to the problem.  The present paper describes  a general method which enables efficient erasure.  The method employs interspersed reference counts to  describe the extent of the overlapping.", "authors": "Collins, G. E.", "words_pool": ["comput", "count", "data", "describ", "describ", "desir", "effici", "eleg", "employ", "enabl", "eras", "erasur", "extent", "gener", "import", "ineffici", "interspers", "lisp", "list", "list", "longer", "mccarthi", "method", "multipl", "need", "need", "newel", "occurr", "overlap", "overlap", "overlap", "paper", "part", "place", "pose", "present", "problem", "properti", "refer", "scheme", "shaw", "simon", "solut", "storag", "store", "subsequ", "unfortun", "collin"], "word_count": {"comput": 2, "count": 1, "data": 1, "describ": 2, "desir": 1, "effici": 1, "eleg": 1, "employ": 2, "enabl": 1, "eras": 1, "erasur": 2, "extent": 1, "gener": 1, "import": 1, "ineffici": 1, "interspers": 1, "lisp": 1, "list": 4, "longer": 1, "mccarthi": 1, "method": 2, "multipl": 1, "need": 2, "newel": 1, "occurr": 1, "overlap": 4, "paper": 1, "part": 1, "place": 1, "pose": 1, "present": 1, "problem": 2, "properti": 1, "refer": 1, "scheme": 1, "shaw": 1, "simon": 1, "solut": 1, "storag": 1, "store": 1, "subsequ": 1, "unfortun": 1, "collin": 1}}, "107": {"id": "107", "title": "Multiple Precision Arithmetic", "authors": "Pope, D. A. Stein, M. L.", "words_pool": ["arithmet", "multipl", "precis", "pope", "stein"], "word_count": {"arithmet": 1, "multipl": 1, "precis": 1, "pope": 1, "stein": 1}}, "108": {"id": "108", "title": "Programmed Error Correction in Project Mercury", "authors": "Dimsdale, B. Weinberg, G. M.", "words_pool": ["correct", "error", "mercuri", "program", "project", "dimsdal", "weinberg"], "word_count": {"correct": 1, "error": 1, "mercuri": 1, "program": 1, "project": 1, "dimsdal": 1, "weinberg": 1}}, "109": {"id": "109", "title": "A Note on Approximating e^x", "authors": "Lubkin, S.", "words_pool": ["approxim", "note", "lubkin"], "word_count": {"approxim": 1, "note": 1, "lubkin": 1}}, "110": {"id": "110", "title": "Fibonaccian Searching", "authors": "Ferguson, D. E.", "words_pool": ["fibonaccian", "search", "ferguson"], "word_count": {"fibonaccian": 1, "search": 1, "ferguson": 1}}, "111": {"id": "111", "title": "On Programming the Numerical Solution of Polynomial Equations", "abstract": "Numerical techniques are presented for computing the roots of polynomial equations.  By applying  the recommended scaling and inversion rules, the basic Bairstow and Newton-Raphson iterative techniques  can be applied with great reliability.  Both a high degree of accuracy and rapid convergence are realized.   Numerical examples are shown to illustrate the pitfalls and to show how these are circumvented by application  of the recommended procedures.", "authors": "Ellenberger, K. W.", "words_pool": ["accuraci", "applic", "appli", "appli", "bairstow", "basic", "circumv", "comput", "converg", "degre", "equat", "exampl", "great", "high", "illustr", "invers", "iter", "newton", "numer", "pitfal", "polynomi", "present", "procedur", "program", "raphson", "rapid", "realiz", "recommend", "reliabl", "root", "rule", "scale", "show", "shown", "solut", "techniqu", "ellenberg"], "word_count": {"accuraci": 1, "applic": 1, "appli": 2, "bairstow": 1, "basic": 1, "circumv": 1, "comput": 1, "converg": 1, "degre": 1, "equat": 1, "exampl": 1, "great": 1, "high": 1, "illustr": 1, "invers": 1, "iter": 1, "newton": 1, "numer": 2, "pitfal": 1, "polynomi": 1, "present": 1, "procedur": 1, "program": 1, "raphson": 1, "rapid": 1, "realiz": 1, "recommend": 2, "reliabl": 1, "root": 1, "rule": 1, "scale": 1, "show": 1, "shown": 1, "solut": 1, "techniqu": 2, "ellenberg": 1}}, "112": {"id": "112", "title": "Numerical Solution of the Polynomial Equation (Algorithm 30)", "authors": "Ellenberger, K. W.", "words_pool": ["algorithm", "equat", "numer", "polynomi", "solut", "ellenberg"], "word_count": {"algorithm": 1, "equat": 1, "numer": 1, "polynomi": 1, "solut": 1, "ellenberg": 1}}, "113": {"id": "113", "title": "Survey of Coded Character Representation", "authors": "Bemer, R. W.", "words_pool": ["charact", "code", "represent", "survey", "bemer"], "word_count": {"charact": 1, "code": 1, "represent": 1, "survey": 1, "bemer": 1}}, "114": {"id": "114", "title": "Survey of Punched Card Codes", "authors": "Smith, H. J. Williams, F. A.", "words_pool": ["card", "code", "punch", "survey", "smith", "william"], "word_count": {"card": 1, "code": 1, "punch": 1, "survey": 1, "smith": 1, "william": 1}}, "115": {"id": "115", "title": "Optimizers: Their Structure", "authors": "Wheeling, R. F.", "words_pool": ["optim", "structur", "wheel"], "word_count": {"optim": 1, "structur": 1, "wheel": 1}}, "116": {"id": "116", "title": "The Sumador Chino", "abstract": "On a recent motor trip through Mexico, the writer came across on adding device which was referred  to as a sumador chino (Chinese adder).  A survey of the more available literature on the history of mathematics  and on instruments of calculation has uncovered no reference to such a device.  The purpose of this communication  is to enlist the help of other members in bringing to light whatever may be known concerning the evolution  and present status of the sumador chino.", "authors": "Rogers, J. L.", "words_pool": ["adder", "ad", "bring", "calcul", "came", "chines", "chino", "commun", "concern", "devic", "enlist", "evolut", "help", "histori", "instrument", "known", "light", "literatur", "mathemat", "member", "mexico", "motor", "present", "purpos", "recent", "refer", "refer", "statu", "sumador", "survey", "trip", "uncov", "writer", "roger"], "word_count": {"adder": 1, "ad": 1, "bring": 1, "calcul": 1, "came": 1, "chines": 1, "chino": 2, "commun": 1, "concern": 1, "devic": 2, "enlist": 1, "evolut": 1, "help": 1, "histori": 1, "instrument": 1, "known": 1, "light": 1, "literatur": 1, "mathemat": 1, "member": 1, "mexico": 1, "motor": 1, "present": 1, "purpos": 1, "recent": 1, "refer": 2, "statu": 1, "sumador": 2, "survey": 1, "trip": 1, "uncov": 1, "writer": 1, "roger": 1}}, "117": {"id": "117", "title": "An Estimation of the Relative Efficiency of Two Internal Sorting Methods", "authors": "Nagler, H.", "words_pool": ["effici", "estim", "intern", "method", "rel", "sort", "nagler"], "word_count": {"effici": 1, "estim": 1, "intern": 1, "method": 1, "rel": 1, "sort": 1, "nagler": 1}}, "118": {"id": "118", "title": "Character Scanning on the IBM 7070", "authors": "Speckhard, A. E.", "words_pool": ["charact", "ibm", "scan", "speckhard"], "word_count": {"charact": 1, "ibm": 1, "scan": 1, "speckhard": 1}}, "119": {"id": "119", "title": "Note on Eigenvalue Computation", "authors": "Andrus, J. F.", "words_pool": ["comput", "eigenvalu", "note", "andru"], "word_count": {"comput": 1, "eigenvalu": 1, "note": 1, "andru": 1}}, "120": {"id": "120", "title": "A Simple Technique for Coding Differential Equations", "authors": "Sefton, P. Vaillancourt, R.", "words_pool": ["code", "differenti", "equat", "simpl", "techniqu", "sefton", "vaillancourt"], "word_count": {"code": 1, "differenti": 1, "equat": 1, "simpl": 1, "techniqu": 1, "sefton": 1, "vaillancourt": 1}}, "121": {"id": "121", "title": "Over-all Computation Control and Labelling", "authors": "Holt, A.", "words_pool": ["comput", "control", "label", "holt"], "word_count": {"comput": 1, "control": 1, "label": 1, "holt": 1}}, "122": {"id": "122", "title": "Least Squares Fitting of a Great Circle Through Points on a Sphere", "authors": "DeWitte, L.", "words_pool": ["circl", "fit", "great", "point", "sphere", "squar", "dewitt"], "word_count": {"circl": 1, "fit": 1, "great": 1, "point": 1, "sphere": 1, "squar": 1, "dewitt": 1}}, "123": {"id": "123", "title": "Compilation for Two Computers with NELIAC", "abstract": "NELIAC, a compiler based on ALGOL, was developed at the U.S. Navy Electronics Laboratory, San  Diego,California, as a\"boot-strap\" compiler for the Remington Rand Univac COUNTESS computer. This compiler  was used to generate a version of itself which, running as a COUNTESS program, generated machine code  for the Control Data Corporation CDC-1604.  All three versions of NELIAC accepted essentially identical  input language.", "authors": "Masterson Jr., K. S.", "words_pool": ["accept", "algol", "base", "boot", "california", "cdc", "code", "compil", "compil", "comput", "comput", "control", "corpor", "countess", "data", "develop", "diego", "electron", "essenti", "gener", "gener", "ident", "input", "laboratori", "languag", "machin", "navi", "neliac", "program", "rand", "remington", "run", "san", "strap", "univac", "version", "version", "masterson", "jr"], "word_count": {"accept": 1, "algol": 1, "base": 1, "boot": 1, "california": 1, "cdc": 1, "code": 1, "compil": 3, "comput": 1, "control": 1, "corpor": 1, "countess": 2, "data": 1, "develop": 1, "diego": 1, "electron": 1, "essenti": 1, "gener": 2, "ident": 1, "input": 1, "laboratori": 1, "languag": 1, "machin": 1, "navi": 1, "neliac": 2, "program": 1, "rand": 1, "remington": 1, "run": 1, "san": 1, "strap": 1, "univac": 1, "version": 2, "masterson": 1, "jr": 1}}, "124": {"id": "124", "title": "An Algorithm for the Assignment Problem", "abstract": "The assignment problem is formulated and briefly discussed.  An efficient algorithm for its  solution is presented in ALGOL code.  An empirical relation between solution time and the size of the  problem is given, based on extensive experiments carried out on a digital computer.", "authors": "Silver, R.", "words_pool": ["algol", "algorithm", "assign", "base", "briefli", "carri", "code", "comput", "digit", "discuss", "effici", "empir", "experi", "extens", "formul", "present", "problem", "relat", "size", "solut", "time", "silver"], "word_count": {"algol": 1, "algorithm": 1, "assign": 1, "base": 1, "briefli": 1, "carri": 1, "code": 1, "comput": 1, "digit": 1, "discuss": 1, "effici": 1, "empir": 1, "experi": 1, "extens": 1, "formul": 1, "present": 1, "problem": 2, "relat": 1, "size": 1, "solut": 2, "time": 1, "silver": 1}}, "125": {"id": "125", "title": "Polynomial Transformer (Algorithm 29)", "authors": "Mackinney, J. G.", "words_pool": ["algorithm", "polynomi", "transform", "mackinney"], "word_count": {"algorithm": 1, "polynomi": 1, "transform": 1, "mackinney": 1}}, "126": {"id": "126", "title": "Least Squares Fit By Orthogonal polynomials (Algorithm 28)", "authors": "Mackinney, J. G.", "words_pool": ["algorithm", "fit", "orthogon", "polynomi", "squar", "mackinney"], "word_count": {"algorithm": 1, "fit": 1, "orthogon": 1, "polynomi": 1, "squar": 1, "mackinney": 1}}, "127": {"id": "127", "title": "ASSIGNMENT (Algorithm 27)", "authors": "Silver, R.", "words_pool": ["algorithm", "assign", "silver"], "word_count": {"algorithm": 1, "assign": 1, "silver": 1}}, "128": {"id": "128", "title": "ROOTFINDER III (Algorithm 26)", "authors": "Herroit, J. G.", "words_pool": ["algorithm", "iii", "rootfind", "herroit"], "word_count": {"algorithm": 1, "iii": 1, "rootfind": 1, "herroit": 1}}, "129": {"id": "129", "title": "ROOTFINDER II (Algorithm 15)", "authors": "Forsythe, G. E. Herriot, J. G.", "words_pool": ["algorithm", "ii", "rootfind", "forsyth", "herriot"], "word_count": {"algorithm": 1, "ii": 1, "rootfind": 1, "forsyth": 1, "herriot": 1}}, "130": {"id": "130", "title": "Real Zeros of an Arbitrary Function (Algorithm 25)", "authors": "Leavenworth, B.", "words_pool": ["algorithm", "arbitrari", "function", "real", "zero", "leavenworth"], "word_count": {"algorithm": 1, "arbitrari": 1, "function": 1, "real": 1, "zero": 1, "leavenworth": 1}}, "131": {"id": "131", "title": "Solution of Tri-Diagonal Linear Equations (Algorithm 24)", "authors": "Leavenworth, B.", "words_pool": ["algorithm", "diagon", "equat", "linear", "solut", "tri", "leavenworth"], "word_count": {"algorithm": 1, "diagon": 1, "equat": 1, "linear": 1, "solut": 1, "tri": 1, "leavenworth": 1}}, "132": {"id": "132", "title": "Math Sort (Algorithm 23)", "authors": "Feurzeig, W.", "words_pool": ["algorithm", "math", "sort", "feurzeig"], "word_count": {"algorithm": 1, "math": 1, "sort": 1, "feurzeig": 1}}, "133": {"id": "133", "title": "Riccati-Bessel Functions of First And Second Kind (Algorithm 22)", "authors": "Oser, H.", "words_pool": ["algorithm", "bessel", "function", "kind", "riccati", "oser"], "word_count": {"algorithm": 1, "bessel": 1, "function": 1, "kind": 1, "riccati": 1, "oser": 1}}, "134": {"id": "134", "title": "Bessel Function for a Set of Integer Orders(Algorithm 21)", "authors": "Borsch-Supan, W.", "words_pool": ["algorithm", "bessel", "function", "integ", "order", "set", "borsch", "supan"], "word_count": {"algorithm": 1, "bessel": 1, "function": 1, "integ": 1, "order": 1, "set": 1, "borsch": 1, "supan": 1}}, "135": {"id": "135", "title": "Digital Computers in Universities-IV", "authors": "Reeves, R. F.", "words_pool": ["comput", "digit", "iv", "univers", "reev"], "word_count": {"comput": 1, "digit": 1, "iv": 1, "univers": 1, "reev": 1}}, "136": {"id": "136", "title": "A Note on the Calculation of Interest", "authors": "Ingerman, P. Z.", "words_pool": ["calcul", "interest", "note", "ingerman"], "word_count": {"calcul": 1, "interest": 1, "note": 1, "ingerman": 1}}, "137": {"id": "137", "title": "Evaluating Numbers Expressed as Strings of English Words", "authors": "Swift, C. J.", "words_pool": ["english", "evalu", "express", "number", "string", "word", "swift"], "word_count": {"english": 1, "evalu": 1, "express": 1, "number": 1, "string": 1, "word": 1, "swift": 1}}, "138": {"id": "138", "title": "Some Thoughts on Reconciling Various Character Set Proposals (Corrigenda)", "authors": "Voorhees, E. A.", "words_pool": ["charact", "corrigenda", "propos", "reconcil", "set", "thought", "voorhe"], "word_count": {"charact": 1, "corrigenda": 1, "propos": 1, "reconcil": 1, "set": 1, "thought": 1, "voorhe": 1}}, "139": {"id": "139", "title": "Binomial Coefficients (Algorithm 19)", "authors": "Kenyon, R. R.", "words_pool": ["algorithm", "binomi", "coeffici", "kenyon"], "word_count": {"algorithm": 1, "binomi": 1, "coeffici": 1, "kenyon": 1}}, "140": {"id": "140", "title": "Crout with Pivoting (Algorithm 16)", "authors": "Forsythe, G. E.", "words_pool": ["algorithm", "crout", "pivot", "forsyth"], "word_count": {"algorithm": 1, "crout": 1, "pivot": 1, "forsyth": 1}}, "141": {"id": "141", "title": "Some Thoughts on Parallel Processing", "authors": "Yarbrough, L. D.", "words_pool": ["parallel", "process", "thought", "yarbrough"], "word_count": {"parallel": 1, "process": 1, "thought": 1, "yarbrough": 1}}, "142": {"id": "142", "title": "Comments on a Technique for Counting Ones", "authors": "Sherman, P. M.", "words_pool": ["comment", "count", "techniqu", "sherman"], "word_count": {"comment": 1, "count": 1, "techniqu": 1, "sherman": 1}}, "143": {"id": "143", "title": "A List of Computer Systems Programs for the IBM 650, DATATRON 205, and UNIVAC SS-80", "authors": "Romberg, A.", "words_pool": ["comput", "datatron", "ibm", "list", "program", "ss", "system", "univac", "romberg"], "word_count": {"comput": 1, "datatron": 1, "ibm": 1, "list": 1, "program": 1, "ss": 1, "system": 1, "univac": 1, "romberg": 1}}, "144": {"id": "144", "title": "Do It by the Numbers-Digital Shorthand", "abstract": "Present communications systems transmit single characters in groups of coded pulses between  simple terminal equipments.  Since English words form only a sparse set of all possible alphabetic combinations,  present methods are inefficient when computer systems are substituted for these terminals.  Using numeric  representations of entire words or common phrases (rather than character-by-character representations)  requires approximately one-third of present transmission time.  This saving is reflected in overall costs.   Other benefits accrue in code and language translation schemes. Provision is made for transmission of  purely numeric and/or binary streams, and for single character-transmission of non-dictionary words such  as the names of people or places.", "authors": "Bemer, R. W.", "words_pool": ["accru", "alphabet", "approxim", "benefit", "binari", "charact", "charact", "code", "code", "combin", "common", "commun", "comput", "cost", "dictionari", "digit", "english", "entir", "equip", "form", "group", "ineffici", "languag", "made", "method", "name", "non", "number", "numer", "peopl", "phrase", "place", "present", "provis", "puls", "pure", "reflect", "represent", "requir", "save", "scheme", "set", "shorthand", "simpl", "singl", "spars", "stream", "substitut", "system", "termin", "termin", "time", "translat", "transmiss", "transmit", "word", "bemer"], "word_count": {"accru": 1, "alphabet": 1, "approxim": 1, "benefit": 1, "binari": 1, "charact": 4, "code": 2, "combin": 1, "common": 1, "commun": 1, "comput": 1, "cost": 1, "dictionari": 1, "digit": 1, "english": 1, "entir": 1, "equip": 1, "form": 1, "group": 1, "ineffici": 1, "languag": 1, "made": 1, "method": 1, "name": 1, "non": 1, "number": 1, "numer": 2, "peopl": 1, "phrase": 1, "place": 1, "present": 3, "provis": 1, "puls": 1, "pure": 1, "reflect": 1, "represent": 2, "requir": 1, "save": 1, "scheme": 1, "set": 1, "shorthand": 1, "simpl": 1, "singl": 2, "spars": 1, "stream": 1, "substitut": 1, "system": 2, "termin": 2, "time": 1, "translat": 1, "transmiss": 3, "transmit": 1, "word": 3, "bemer": 1}}, "145": {"id": "145", "title": "Automatic Graders for Programming Classes", "authors": "Hollingsworth, J.", "words_pool": ["automat", "class", "grader", "program", "hollingsworth"], "word_count": {"automat": 1, "class": 1, "grader": 1, "program": 1, "hollingsworth": 1}}, "146": {"id": "146", "title": "The Use of Computers in Engineering Classroom Instruction", "abstract": "On April 29-30, the Computer Committee of the College of Engineering, University of Michigan,  which acts as a steering committee for The Ford Foundation Project on the Use of Computers in Engineering  Education, held a special conference to discuss certain timely topics pertinent to the Ford Project.   This report contains a condensed transcription of the key ideas offered by the conference attendees  on selected topics.", "authors": "Katz, D. L.", "words_pool": ["act", "april", "attende", "classroom", "colleg", "committe", "comput", "comput", "condens", "confer", "discuss", "educ", "engin", "ford", "foundat", "held", "idea", "instruct", "key", "michigan", "offer", "pertin", "project", "report", "select", "special", "steer", "time", "topic", "transcript", "univers", "katz"], "word_count": {"act": 1, "april": 1, "attende": 1, "classroom": 1, "colleg": 1, "committe": 2, "comput": 2, "condens": 1, "confer": 2, "discuss": 1, "educ": 1, "engin": 2, "ford": 2, "foundat": 1, "held": 1, "idea": 1, "instruct": 1, "key": 1, "michigan": 1, "offer": 1, "pertin": 1, "project": 2, "report": 1, "select": 1, "special": 1, "steer": 1, "time": 1, "topic": 2, "transcript": 1, "univers": 1, "katz": 1}}, "147": {"id": "147", "title": "Report on a Conference of University Computing Center Directors", "words_pool": ["center", "comput", "confer", "director", "report", "univers"], "word_count": {"center": 1, "comput": 1, "confer": 1, "director": 1, "report": 1, "univers": 1}}, "148": {"id": "148", "title": "Digital Computers in Universities-III", "authors": "Reeves, R. F.", "words_pool": ["comput", "digit", "iii", "univers", "reev"], "word_count": {"comput": 1, "digit": 1, "iii": 1, "univers": 1, "reev": 1}}, "149": {"id": "149", "title": "A Decision Rule for Improved Efficiency in Solving Linear Programming Problems with the Simplex  Algorithm", "authors": "Dickson, J. C. Frederick, F. P.", "words_pool": ["algorithm", "decis", "effici", "improv", "linear", "problem", "program", "rule", "simplex", "solv", "dickson", "frederick"], "word_count": {"algorithm": 1, "decis": 1, "effici": 1, "improv": 1, "linear": 1, "problem": 1, "program": 1, "rule": 1, "simplex": 1, "solv": 1, "dickson": 1, "frederick": 1}}, "150": {"id": "150", "title": "Rational Interpolation by Continued Fractions (Algorithm 18)", "authors": "Floyd, R. W.", "words_pool": ["algorithm", "continu", "fraction", "interpol", "ration", "floyd"], "word_count": {"algorithm": 1, "continu": 1, "fraction": 1, "interpol": 1, "ration": 1, "floyd": 1}}, "151": {"id": "151", "title": "TRDIAG (Algorithm 17)", "authors": "Sprague III, C. D.", "words_pool": ["algorithm", "trdiag", "spragu", "iii"], "word_count": {"algorithm": 1, "trdiag": 1, "spragu": 1, "iii": 1}}, "152": {"id": "152", "title": "CROUT With Pivoting (Algorithm 16)", "authors": "Forsythe, G. E.", "words_pool": ["algorithm", "crout", "pivot", "forsyth"], "word_count": {"algorithm": 1, "crout": 1, "pivot": 1, "forsyth": 1}}, "153": {"id": "153", "title": "Comments from a FORTRAN User", "authors": "Blatt, J. M.", "words_pool": ["comment", "fortran", "user", "blatt"], "word_count": {"comment": 1, "fortran": 1, "user": 1, "blatt": 1}}, "154": {"id": "154", "title": "Rapidly Convergent Expressions for Evaluating e^x", "authors": "Berin, A.", "words_pool": ["converg", "evalu", "express", "rapidli", "berin"], "word_count": {"converg": 1, "evalu": 1, "express": 1, "rapidli": 1, "berin": 1}}, "155": {"id": "155", "title": "Trie Memory", "authors": "Fredkin, E.", "words_pool": ["memori", "trie", "fredkin"], "word_count": {"memori": 1, "trie": 1, "fredkin": 1}}, "156": {"id": "156", "title": "An Introductory Problem in Symbol Manipulation for the Student", "authors": "Rosin, R. F.", "words_pool": ["introductori", "manipul", "problem", "student", "symbol", "rosin"], "word_count": {"introductori": 1, "manipul": 1, "problem": 1, "student": 1, "symbol": 1, "rosin": 1}}, "157": {"id": "157", "title": "Digital Computers in Universities -II", "authors": "Reeves, R. F.", "words_pool": ["comput", "digit", "ii", "univers", "reev"], "word_count": {"comput": 1, "digit": 1, "ii": 1, "univers": 1, "reev": 1}}, "158": {"id": "158", "title": "ROOTFINDER II (Algorithm 15)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "ii", "rootfind", "thacher", "jr"], "word_count": {"algorithm": 1, "ii": 1, "rootfind": 1, "thacher": 1, "jr": 1}}, "159": {"id": "159", "title": "ROOTFINDER (Algorithm 2)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "rootfind", "thacher", "jr"], "word_count": {"algorithm": 1, "rootfind": 1, "thacher": 1, "jr": 1}}, "160": {"id": "160", "title": "ROOTFINDER II (Algorithm 15)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "ii", "rootfind", "thacher", "jr"], "word_count": {"algorithm": 1, "ii": 1, "rootfind": 1, "thacher": 1, "jr": 1}}, "161": {"id": "161", "title": "Abbreviating Words Systematically (Corrigendum)", "authors": "Barrett, J. A. Grems, M.", "words_pool": ["abbrevi", "corrigendum", "systemat", "word", "barrett", "grem"], "word_count": {"abbrevi": 1, "corrigendum": 1, "systemat": 1, "word": 1, "barrett": 1, "grem": 1}}, "162": {"id": "162", "title": "A Variant Technique for Counting Ones", "authors": "Frieden, H.", "words_pool": ["count", "techniqu", "variant", "frieden"], "word_count": {"count": 1, "techniqu": 1, "variant": 1, "frieden": 1}}, "163": {"id": "163", "title": "Counting Ones on the IBM 7090", "authors": "Kutler, S. S.", "words_pool": ["count", "ibm", "kutler"], "word_count": {"count": 1, "ibm": 1, "kutler": 1}}, "164": {"id": "164", "title": "A Short Study of Notation Efficiency", "authors": "Smith Jr., H. J.", "words_pool": ["effici", "notat", "short", "studi", "smith", "jr"], "word_count": {"effici": 1, "notat": 1, "short": 1, "studi": 1, "smith": 1, "jr": 1}}, "165": {"id": "165", "title": "NELIAC-A Dialect of ALGOL", "authors": "Huskey, H. D. Halstead, M. H.", "words_pool": ["algol", "dialect", "neliac", "huskey", "halstead"], "word_count": {"algol": 1, "dialect": 1, "neliac": 1, "huskey": 1, "halstead": 1}}, "166": {"id": "166", "title": "Programming Compatibility in a Family of Closely Related Digital Computers", "authors": "Luebbert, W. F.", "words_pool": ["close", "compat", "comput", "digit", "famili", "program", "relat", "luebbert"], "word_count": {"close": 1, "compat": 1, "comput": 1, "digit": 1, "famili": 1, "program": 1, "relat": 1, "luebbert": 1}}, "167": {"id": "167", "title": "Combining ALGOL Statement Analysis with Validity Checking", "authors": "McIsaac, P.", "words_pool": ["algol", "analysi", "check", "combin", "statement", "valid", "mcisaac"], "word_count": {"algol": 1, "analysi": 1, "check": 1, "combin": 1, "statement": 1, "valid": 1, "mcisaac": 1}}, "168": {"id": "168", "title": "Multiprogram Scheduling Parts 3 and 4 Scheduling Algorithm and External Constraints", "authors": "Codd, E. F.", "words_pool": ["algorithm", "constraint", "extern", "multiprogram", "part", "schedul", "codd"], "word_count": {"algorithm": 1, "constraint": 1, "extern": 1, "multiprogram": 1, "part": 1, "schedul": 2, "codd": 1}}, "169": {"id": "169", "title": "The Multilingual Terminology Project", "authors": "Holmstrom, J. E.", "words_pool": ["multilingu", "project", "terminolog", "holmstrom"], "word_count": {"multilingu": 1, "project": 1, "terminolog": 1, "holmstrom": 1}}, "170": {"id": "170", "title": "Some Thoughts on Reconciling Various Character Set Proposals", "authors": "Voorhees, E. A.", "words_pool": ["charact", "propos", "reconcil", "set", "thought", "voorhe"], "word_count": {"charact": 1, "propos": 1, "reconcil": 1, "set": 1, "thought": 1, "voorhe": 1}}, "171": {"id": "171", "title": "Digital Computers in Universities (Part I)", "authors": "Reeves, R. F.", "words_pool": ["comput", "digit", "part", "univers", "reev"], "word_count": {"comput": 1, "digit": 1, "part": 1, "univers": 1, "reev": 1}}, "172": {"id": "172", "title": "Complex Exponential Integral (Algorithm 13)", "authors": "Beam, A.", "words_pool": ["algorithm", "complex", "exponenti", "integr", "beam"], "word_count": {"algorithm": 1, "complex": 1, "exponenti": 1, "integr": 1, "beam": 1}}, "173": {"id": "173", "title": "ATLAS a new concept in large computer design", "words_pool": ["atla", "comput", "concept", "design", "larg"], "word_count": {"atla": 1, "comput": 1, "concept": 1, "design": 1, "larg": 1}}, "174": {"id": "174", "title": "Interval Estimation of the Time in One State to Total Time Ratio in a DoubleExponential Process", "authors": "Neal, W. R.", "words_pool": ["doubleexponenti", "estim", "interv", "process", "ratio", "state", "time", "total", "neal"], "word_count": {"doubleexponenti": 1, "estim": 1, "interv": 1, "process": 1, "ratio": 1, "state": 1, "time": 2, "total": 1, "neal": 1}}, "175": {"id": "175", "title": "The Solution of Simultaneous Ordinary Differential Equations Using a General Purpose Digital  Computer", "authors": "Anderson, W. H.", "words_pool": ["comput", "differenti", "digit", "equat", "gener", "ordinari", "purpos", "simultan", "solut", "anderson"], "word_count": {"comput": 1, "differenti": 1, "digit": 1, "equat": 1, "gener": 1, "ordinari": 1, "purpos": 1, "simultan": 1, "solut": 1, "anderson": 1}}, "176": {"id": "176", "title": "Symbol Manipulation by Threaded Lists (Corrigendum)", "authors": "Perlis, A. J. Thornton, C.", "words_pool": ["corrigendum", "list", "manipul", "symbol", "thread", "perli", "thornton"], "word_count": {"corrigendum": 1, "list": 1, "manipul": 1, "symbol": 1, "thread": 1, "perli": 1, "thornton": 1}}, "177": {"id": "177", "title": "Solution of Polynomial Equation by Bairstow Hitchcock Method, A. A. Grau Communications ACM,  February, 1960 (Algorithm)", "authors": "Thacher Jr., H. C.", "words_pool": ["acm", "algorithm", "bairstow", "commun", "equat", "februari", "grau", "hitchcock", "method", "polynomi", "solut", "thacher", "jr"], "word_count": {"acm": 1, "algorithm": 1, "bairstow": 1, "commun": 1, "equat": 1, "februari": 1, "grau": 1, "hitchcock": 1, "method": 1, "polynomi": 1, "solut": 1, "thacher": 1, "jr": 1}}, "178": {"id": "178", "title": "ROOTFINDER (Algorithm)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "rootfind", "thacher", "jr"], "word_count": {"algorithm": 1, "rootfind": 1, "thacher": 1, "jr": 1}}, "179": {"id": "179", "title": "Evaluation of the Legendre Polynomial Pn(X) by Recursion (Algorithm)", "authors": "Galler, G. M.", "words_pool": ["algorithm", "evalu", "legendr", "pn", "polynomi", "recurs", "galler"], "word_count": {"algorithm": 1, "evalu": 1, "legendr": 1, "pn": 1, "polynomi": 1, "recurs": 1, "galler": 1}}, "180": {"id": "180", "title": "Evaluation of the Laguerre Polynomial Ln(X) by Recursion (Algorithm)", "authors": "Galler, G. M.", "words_pool": ["algorithm", "evalu", "laguerr", "ln", "polynomi", "recurs", "galler"], "word_count": {"algorithm": 1, "evalu": 1, "laguerr": 1, "ln": 1, "polynomi": 1, "recurs": 1, "galler": 1}}, "181": {"id": "181", "title": "Evaluation of the Hermite Polynomial Hn(X) by Recursion (Algorithm)", "authors": "Galler, G. M.", "words_pool": ["algorithm", "evalu", "hermit", "hn", "polynomi", "recurs", "galler"], "word_count": {"algorithm": 1, "evalu": 1, "hermit": 1, "hn": 1, "polynomi": 1, "recurs": 1, "galler": 1}}, "182": {"id": "182", "title": "Evaluation of the Chebyshev Polynomial Tn(X) by Recursion (Algorithm)", "authors": "Galler, G. M.", "words_pool": ["algorithm", "chebyshev", "evalu", "polynomi", "recurs", "tn", "galler"], "word_count": {"algorithm": 1, "chebyshev": 1, "evalu": 1, "polynomi": 1, "recurs": 1, "tn": 1, "galler": 1}}, "183": {"id": "183", "title": "Conversion Between Floating Point Representations", "authors": "Perry, C.", "words_pool": ["convers", "float", "point", "represent", "perri"], "word_count": {"convers": 1, "float": 1, "point": 1, "represent": 1, "perri": 1}}, "184": {"id": "184", "title": "A Short Method for Measuring Error in a Least-Squares Power Series", "authors": "Robinson, S. M. Struble, G. W.", "words_pool": ["error", "measur", "method", "power", "seri", "short", "squar", "robinson", "strubl"], "word_count": {"error": 1, "measur": 1, "method": 1, "power": 1, "seri": 1, "short": 1, "squar": 1, "robinson": 1, "strubl": 1}}, "185": {"id": "185", "title": "Multiprogram Scheduling Parts 1 and 2.  Introduction and Theory*", "abstract": "In order to exploit fully a fast computer which possesses simultaneous processing abilities,  it should to a large extent schedule its own workload.  The scheduling routine must be capable of extremely  rapid execution if it is not to prove self-defeating.  The construction of a schedule entails determining  which programs are to be run concurrently and which sequentially with respect to each other.  A concise  scheduling algorithm is described which tends to minimize the time for executing the entire pending workload  (or any subset of it), subject to external constraints such as precedence, urgency, etc.  The algorithm  is applicable to a wide class of machines.", "authors": "Codd, E. F.", "words_pool": ["abil", "algorithm", "applic", "capabl", "class", "comput", "concis", "concurr", "constraint", "construct", "defeat", "determin", "entail", "entir", "execut", "execut", "exploit", "extent", "extern", "extrem", "fast", "fulli", "introduct", "larg", "machin", "minim", "multiprogram", "order", "part", "pend", "possess", "preced", "process", "program", "prove", "rapid", "respect", "routin", "run", "schedul", "schedul", "sequenti", "simultan", "subject", "subset", "tend", "theori", "time", "urgenc", "wide", "workload", "codd"], "word_count": {"abil": 1, "algorithm": 2, "applic": 1, "capabl": 1, "class": 1, "comput": 1, "concis": 1, "concurr": 1, "constraint": 1, "construct": 1, "defeat": 1, "determin": 1, "entail": 1, "entir": 1, "execut": 2, "exploit": 1, "extent": 1, "extern": 1, "extrem": 1, "fast": 1, "fulli": 1, "introduct": 1, "larg": 1, "machin": 1, "minim": 1, "multiprogram": 1, "order": 1, "part": 1, "pend": 1, "possess": 1, "preced": 1, "process": 1, "program": 1, "prove": 1, "rapid": 1, "respect": 1, "routin": 1, "run": 1, "schedul": 4, "sequenti": 1, "simultan": 1, "subject": 1, "subset": 1, "tend": 1, "theori": 1, "time": 1, "urgenc": 1, "wide": 1, "workload": 2, "codd": 1}}, "186": {"id": "186", "title": "An Algorithm Defining ALGOL Assignment Statements (Addendum)", "authors": "Floyd, R. W.", "words_pool": ["addendum", "algol", "algorithm", "assign", "defin", "statement", "floyd"], "word_count": {"addendum": 1, "algol": 1, "algorithm": 1, "assign": 1, "defin": 1, "statement": 1, "floyd": 1}}, "187": {"id": "187", "title": "Compiling Connectives", "authors": "Swift, C. J.", "words_pool": ["compil", "connect", "swift"], "word_count": {"compil": 1, "connect": 1, "swift": 1}}, "188": {"id": "188", "title": "The Department of Computer Mathematics at Moscow State University", "authors": "Berezin, I. S.", "words_pool": ["comput", "depart", "mathemat", "moscow", "state", "univers", "berezin"], "word_count": {"comput": 1, "depart": 1, "mathemat": 1, "moscow": 1, "state": 1, "univers": 1, "berezin": 1}}, "189": {"id": "189", "title": "The Future of Automatic Digital Computers", "authors": "Booth, A. D.", "words_pool": ["automat", "comput", "digit", "futur", "booth"], "word_count": {"automat": 1, "comput": 1, "digit": 1, "futur": 1, "booth": 1}}, "190": {"id": "190", "title": "Bendix G-20 System", "words_pool": ["bendix", "system"], "word_count": {"bendix": 1, "system": 1}}, "191": {"id": "191", "title": "Abbreviating Words Systematically", "authors": "Barrett, J. A. Grems, M.", "words_pool": ["abbrevi", "systemat", "word", "barrett", "grem"], "word_count": {"abbrevi": 1, "systemat": 1, "word": 1, "barrett": 1, "grem": 1}}, "192": {"id": "192", "title": "A Technique for Counting Ones in a Binary Computer", "authors": "Wegner, P.", "words_pool": ["binari", "comput", "count", "techniqu", "wegner"], "word_count": {"binari": 1, "comput": 1, "count": 1, "techniqu": 1, "wegner": 1}}, "193": {"id": "193", "title": "A Start at Automatic Storage Assignment", "authors": "Patrick, R. L.", "words_pool": ["assign", "automat", "start", "storag", "patrick"], "word_count": {"assign": 1, "automat": 1, "start": 1, "storag": 1, "patrick": 1}}, "194": {"id": "194", "title": "Divisionless Computation of Square Roots Through Continued Squaring", "authors": "Sarafyan, D.", "words_pool": ["comput", "continu", "divisionless", "root", "squar", "squar", "sarafyan"], "word_count": {"comput": 1, "continu": 1, "divisionless": 1, "root": 1, "squar": 2, "sarafyan": 1}}, "195": {"id": "195", "title": "What is a Code?", "authors": "Patterson, G. W.", "words_pool": ["code", "patterson"], "word_count": {"code": 1, "patterson": 1}}, "196": {"id": "196", "title": "Report on the Algorithmic Language ALGOL 60", "authors": "Naur, P. Backus, J.", "words_pool": ["algol", "algorithm", "languag", "report", "naur", "backu"], "word_count": {"algol": 1, "algorithm": 1, "languag": 1, "report": 1, "naur": 1, "backu": 1}}, "197": {"id": "197", "title": "An Imaginary Number System", "authors": "Knuth, D. E.", "words_pool": ["imaginari", "number", "system", "knuth"], "word_count": {"imaginari": 1, "number": 1, "system": 1, "knuth": 1}}, "198": {"id": "198", "title": "A High-Speed Multiplication Process for Digital Computers", "authors": "Gurzi, F.", "words_pool": ["comput", "digit", "high", "multipl", "process", "speed", "gurzi"], "word_count": {"comput": 1, "digit": 1, "high": 1, "multipl": 1, "process": 1, "speed": 1, "gurzi": 1}}, "199": {"id": "199", "title": "Euclidian Algorithm (Algorithm 7)", "authors": "Claussen, R.", "words_pool": ["algorithm", "euclidian", "claussen"], "word_count": {"algorithm": 2, "euclidian": 1, "claussen": 1}}, "200": {"id": "200", "title": "Bessel Function I, Asymptotic Expansion (Algorithm 6)", "authors": "Clarke, D. S.", "words_pool": ["algorithm", "asymptot", "bessel", "expans", "function", "clark"], "word_count": {"algorithm": 1, "asymptot": 1, "bessel": 1, "expans": 1, "function": 1, "clark": 1}}, "201": {"id": "201", "title": "Bessel Funtion I, Series Expansion (Algorithm 5)", "authors": "Clarke, D. S.", "words_pool": ["algorithm", "bessel", "expans", "funtion", "seri", "clark"], "word_count": {"algorithm": 1, "bessel": 1, "expans": 1, "funtion": 1, "seri": 1, "clark": 1}}, "202": {"id": "202", "title": "A Control System For Logical Block Diagnosis With Data Loading", "abstract": "This paper describes a section of an integrated diagnostic monitor system which facilitates  the checking of sections of instructions or subroutines anywhere in the object program.  A new method  of specifying all diagnostic operations in a format similar to a computer program makes the system convenient  to use and relatively simple to understand.  The paper also describes a number of other novel diagnostic  features which can be included in the system.", "authors": "Senko, M. E.", "words_pool": ["block", "check", "comput", "control", "conveni", "data", "describ", "diagnosi", "diagnost", "facilit", "featur", "format", "includ", "instruct", "integr", "load", "logic", "make", "method", "monitor", "number", "object", "oper", "paper", "program", "section", "section", "similar", "simpl", "subroutin", "system", "understand", "senko"], "word_count": {"block": 1, "check": 1, "comput": 1, "control": 1, "conveni": 1, "data": 1, "describ": 2, "diagnosi": 1, "diagnost": 3, "facilit": 1, "featur": 1, "format": 1, "includ": 1, "instruct": 1, "integr": 1, "load": 1, "logic": 1, "make": 1, "method": 1, "monitor": 1, "number": 1, "object": 1, "oper": 1, "paper": 2, "program": 2, "section": 2, "similar": 1, "simpl": 1, "subroutin": 1, "system": 3, "understand": 1, "senko": 1}}, "203": {"id": "203", "title": "Decoding Combinations of the First n Integers Taken k at a Time", "authors": "Brown, R. M.", "words_pool": ["combin", "decod", "integ", "time", "brown"], "word_count": {"combin": 1, "decod": 1, "integ": 1, "time": 1, "brown": 1}}, "204": {"id": "204", "title": "Proving Theorems by Pattern Recognition I", "authors": "Wang, H.", "words_pool": ["pattern", "prove", "recognit", "theorem", "wang"], "word_count": {"pattern": 1, "prove": 1, "recognit": 1, "theorem": 1, "wang": 1}}, "205": {"id": "205", "title": "Macro Instruction Extensions of Compiler Languages", "abstract": "Macroinstruction compilers constructed from a small set of functions can be made extremely  powerful.  In particular, conditional assembly, nested definitions, and parenthetical notation serve  to make a compiler capable of accepting very general extensions to its ground language.", "authors": "McIlroy, M. D.", "words_pool": ["accept", "assembl", "capabl", "compil", "compil", "condit", "construct", "definit", "extens", "extrem", "function", "gener", "ground", "instruct", "languag", "languag", "macro", "macroinstruct", "made", "make", "nest", "notat", "parenthet", "power", "serv", "set", "small", "mcilroy"], "word_count": {"accept": 1, "assembl": 1, "capabl": 1, "compil": 2, "condit": 1, "construct": 1, "definit": 1, "extens": 1, "extrem": 1, "function": 1, "gener": 1, "ground": 1, "instruct": 1, "languag": 1, "macro": 1, "macroinstruct": 1, "made": 1, "make": 1, "nest": 1, "notat": 1, "parenthet": 1, "power": 1, "serv": 1, "set": 1, "small": 1, "mcilroy": 1}}, "206": {"id": "206", "title": "Symbol Manipulation in XTRAN", "authors": "Green, J.", "words_pool": ["manipul", "symbol", "xtran", "green"], "word_count": {"manipul": 1, "symbol": 1, "xtran": 1, "green": 1}}, "207": {"id": "207", "title": "Syntactic and Semantic Augments to ALGOL", "authors": "Smith, J. W.", "words_pool": ["algol", "augment", "semant", "syntact", "smith"], "word_count": {"algol": 1, "augment": 1, "semant": 1, "syntact": 1, "smith": 1}}, "208": {"id": "208", "title": "An Introduction to Information Processing Language V", "authors": "Newell, A. Tonge, F. M.", "words_pool": ["inform", "introduct", "languag", "process", "newel", "tong"], "word_count": {"inform": 1, "introduct": 1, "languag": 1, "process": 1, "newel": 1, "tong": 1}}, "209": {"id": "209", "title": "Symbol Manipulation by Threaded Lists", "authors": "Perlis, A. J. Thornton, C.", "words_pool": ["list", "manipul", "symbol", "thread", "perli", "thornton"], "word_count": {"list": 1, "manipul": 1, "symbol": 1, "thread": 1, "perli": 1, "thornton": 1}}, "210": {"id": "210", "title": "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I", "authors": "McCarthy, J.", "words_pool": ["comput", "express", "function", "machin", "part", "recurs", "symbol", "mccarthi"], "word_count": {"comput": 1, "express": 1, "function": 1, "machin": 1, "part": 1, "recurs": 1, "symbol": 1, "mccarthi": 1}}, "211": {"id": "211", "title": "Share Standard Flow Chart Symbols", "authors": "Grems, M.", "words_pool": ["chart", "flow", "share", "standard", "symbol", "grem"], "word_count": {"chart": 1, "flow": 1, "share": 1, "standard": 1, "symbol": 1, "grem": 1}}, "212": {"id": "212", "title": "Bisection Routine (Algorithm 4)", "authors": "Gorn,S.", "words_pool": ["algorithm", "bisect", "routin", "gorn"], "word_count": {"algorithm": 1, "bisect": 1, "routin": 1, "gorn": 1}}, "213": {"id": "213", "title": "Numerical Inversion of Laplace Transforms", "authors": "Schmittroth, L. A.", "words_pool": ["invers", "laplac", "numer", "transform", "schmittroth"], "word_count": {"invers": 1, "laplac": 1, "numer": 1, "transform": 1, "schmittroth": 1}}, "214": {"id": "214", "title": "An Algorithm Defining ALGOL Assignment Statements", "authors": "Floyd, R. W.", "words_pool": ["algol", "algorithm", "assign", "defin", "statement", "floyd"], "word_count": {"algol": 1, "algorithm": 1, "assign": 1, "defin": 1, "statement": 1, "floyd": 1}}, "215": {"id": "215", "title": "The Execute Operations-A Fourth Mode of Instruction Sequencing", "authors": "Brooks, F. P.", "words_pool": ["execut", "fourth", "instruct", "mode", "oper", "sequenc", "brook"], "word_count": {"execut": 1, "fourth": 1, "instruct": 1, "mode": 1, "oper": 1, "sequenc": 1, "brook": 1}}, "216": {"id": "216", "title": "A Note on the Use of the Abacus in Number Conversion", "authors": "Kanner, H.", "words_pool": ["abacu", "convers", "note", "number", "kanner"], "word_count": {"abacu": 1, "convers": 1, "note": 1, "number": 1, "kanner": 1}}, "217": {"id": "217", "title": "Soviet Computer Technology-1959", "words_pool": ["comput", "soviet", "technolog"], "word_count": {"comput": 1, "soviet": 1, "technolog": 1}}, "218": {"id": "218", "title": "Computer Preparation of a Poetry Concordance", "authors": "Painter, J. A.", "words_pool": ["comput", "concord", "poetri", "prepar", "painter"], "word_count": {"comput": 1, "concord": 1, "poetri": 1, "prepar": 1, "painter": 1}}, "219": {"id": "219", "title": "Marriage-with Problems", "authors": "Shuchter, J. P.", "words_pool": ["marriag", "problem", "shuchter"], "word_count": {"marriag": 1, "problem": 1, "shuchter": 1}}, "220": {"id": "220", "title": "A New Method of Computation of Square Roots Without Using Division", "authors": "Traub, J. F.", "words_pool": ["comput", "divis", "method", "root", "squar", "traub"], "word_count": {"comput": 1, "divis": 1, "method": 1, "root": 1, "squar": 1, "traub": 1}}, "221": {"id": "221", "title": "The Basic Side of Tape Labeling", "authors": "Logan, W. A.", "words_pool": ["basic", "label", "side", "tape", "logan"], "word_count": {"basic": 1, "label": 1, "side": 1, "tape": 1, "logan": 1}}, "222": {"id": "222", "title": "Coding Isomorphisms", "abstract": "The coding of external symbols into symbols internal to a compute can sometimes be carried  out in such a way that relevant informational properties are preserved, but in a form much more easily  dealt with.  A case in point is presented.", "authors": "Lynch, W. C.", "words_pool": ["carri", "case", "code", "comput", "dealt", "easili", "extern", "form", "inform", "intern", "isomorph", "point", "present", "preserv", "properti", "relev", "symbol", "lynch"], "word_count": {"carri": 1, "case": 1, "code": 1, "comput": 1, "dealt": 1, "easili": 1, "extern": 1, "form": 1, "inform": 1, "intern": 1, "isomorph": 1, "point": 1, "present": 1, "preserv": 1, "properti": 1, "relev": 1, "symbol": 2, "lynch": 1}}, "223": {"id": "223", "title": "Selfcipher: Programming", "authors": "Pelta, H. N.", "words_pool": ["program", "selfciph", "pelta"], "word_count": {"program": 1, "selfciph": 1, "pelta": 1}}, "224": {"id": "224", "title": "Sequential Formula Translation", "abstract": "The syntax of an algorithmic language such as ALGOL is conveniently described as a sequence  of states indicated by an element called cellar.  Transitions are controlled by admissible state-symbol  pairs which may be represented by a transition matrix. This description of syntax furnishes at the same  time an extremely simple rule for translating into machine programs statements in the algorithmic language.   Sequential treatment, however, is not feasible in the case of certain optimizing processes such as recursive  address calculation.", "authors": "Samelson, K. Bauer, F. L.", "words_pool": ["address", "admiss", "algol", "algorithm", "calcul", "call", "case", "cellar", "control", "conveni", "descript", "element", "extrem", "feasibl", "formula", "furnish", "languag", "machin", "matrix", "optim", "pair", "process", "program", "recurs", "repres", "rule", "sequenc", "sequenti", "simpl", "state", "statement", "state", "symbol", "syntax", "time", "transit", "transit", "translat", "translat", "treatment", "samelson", "bauer"], "word_count": {"address": 1, "admiss": 1, "algol": 1, "algorithm": 2, "calcul": 1, "call": 1, "case": 1, "cellar": 1, "control": 1, "conveni": 1, "descript": 1, "element": 1, "extrem": 1, "feasibl": 1, "formula": 1, "furnish": 1, "languag": 2, "machin": 1, "matrix": 1, "optim": 1, "pair": 1, "process": 1, "program": 1, "recurs": 1, "repres": 1, "rule": 1, "sequenc": 1, "sequenti": 1, "simpl": 1, "state": 2, "statement": 1, "symbol": 1, "syntax": 2, "time": 1, "transit": 2, "translat": 1, "treatment": 1, "samelson": 1, "bauer": 1}}, "225": {"id": "225", "title": "A Techniquefor Handling Macro Instructions (Corrigendum)", "authors": "Greenwald, I. D.", "words_pool": ["corrigendum", "handl", "instruct", "macro", "techniquefor", "greenwald"], "word_count": {"corrigendum": 1, "handl": 1, "instruct": 1, "macro": 1, "techniquefor": 1, "greenwald": 1}}, "226": {"id": "226", "title": "Solution of Polynomial Equation by Bairstow-Hitchcock Method (Algorithm 3)", "authors": "Grau, A. A.", "words_pool": ["algorithm", "bairstow", "equat", "hitchcock", "method", "polynomi", "solut", "grau"], "word_count": {"algorithm": 1, "bairstow": 1, "equat": 1, "hitchcock": 1, "method": 1, "polynomi": 1, "solut": 1, "grau": 1}}, "227": {"id": "227", "title": "ROOTFINDER (Algorithm 2)", "authors": "Wegstein, J.", "words_pool": ["algorithm", "rootfind", "wegstein"], "word_count": {"algorithm": 1, "rootfind": 1, "wegstein": 1}}, "228": {"id": "228", "title": "QUADI (Algorithm 1)", "authors": "Herbold, R. J.", "words_pool": ["algorithm", "quadi", "herbold"], "word_count": {"algorithm": 1, "quadi": 1, "herbold": 1}}, "229": {"id": "229", "title": "A Terminology Proposal", "authors": "Gruenberger, F.", "words_pool": ["propos", "terminolog", "gruenberg"], "word_count": {"propos": 1, "terminolog": 1, "gruenberg": 1}}, "230": {"id": "230", "title": "A Proposal for Character Code Compatibility", "authors": "Bemer, R. W.", "words_pool": ["charact", "code", "compat", "propos", "bemer"], "word_count": {"charact": 1, "code": 1, "compat": 1, "propos": 1, "bemer": 1}}, "231": {"id": "231", "title": "A Proposal for a Set of Publication Standards for Use by the ACM", "authors": "Kent, E. R.", "words_pool": ["acm", "propos", "public", "set", "standard", "kent"], "word_count": {"acm": 1, "propos": 1, "public": 1, "set": 1, "standard": 1, "kent": 1}}, "232": {"id": "232", "title": "A High-Speed Sorting Procedure", "authors": "Frank, R. M. Lazarus, R. B.", "words_pool": ["high", "procedur", "sort", "speed", "frank", "lazaru"], "word_count": {"high": 1, "procedur": 1, "sort": 1, "speed": 1, "frank": 1, "lazaru": 1}}, "233": {"id": "233", "title": "Abstracts-Additional Nuclear Reactor Codes", "authors": "Nather, V. Sangren, W.", "words_pool": ["abstract", "addit", "code", "nuclear", "reactor", "nather", "sangren"], "word_count": {"abstract": 1, "addit": 1, "code": 1, "nuclear": 1, "reactor": 1, "nather": 1, "sangren": 1}}, "234": {"id": "234", "title": "A SAP-Like Assembly Program for the IBM 650", "authors": "Speckhard, A. E.", "words_pool": ["assembl", "ibm", "program", "sap", "speckhard"], "word_count": {"assembl": 1, "ibm": 1, "program": 1, "sap": 1, "speckhard": 1}}, "235": {"id": "235", "title": "Two Think Pieces", "authors": "Bagley, P. R.", "words_pool": ["piec", "think", "bagley"], "word_count": {"piec": 1, "think": 1, "bagley": 1}}, "236": {"id": "236", "title": "Soviet Cybernetics and Computer", "abstract": "This article records observations on Soviet research and technology in cybernetics and computer  science, made by the author during a visit to the Soviet Union as a delegate to the IFAC Congress on  Automatic Control held in Moscow in the summer of 1960.", "authors": "Feigenbaum, E. A.", "words_pool": ["articl", "author", "automat", "comput", "congress", "control", "cybernet", "deleg", "held", "ifac", "made", "moscow", "observ", "record", "research", "scienc", "soviet", "summer", "technolog", "union", "visit", "feigenbaum"], "word_count": {"articl": 1, "author": 1, "automat": 1, "comput": 1, "congress": 1, "control": 1, "cybernet": 1, "deleg": 1, "held": 1, "ifac": 1, "made": 1, "moscow": 1, "observ": 1, "record": 1, "research": 1, "scienc": 1, "soviet": 2, "summer": 1, "technolog": 1, "union": 1, "visit": 1, "feigenbaum": 1}}, "237": {"id": "237", "title": "Computer Production of Peek-A-Boo Sheets", "authors": "Robbins, D.", "words_pool": ["boo", "comput", "peek", "product", "sheet", "robbin"], "word_count": {"boo": 1, "comput": 1, "peek": 1, "product": 1, "sheet": 1, "robbin": 1}}, "238": {"id": "238", "title": "Simulation and Analysis of Biochemical Systems", "authors": "Garfinkel, D. Rutledge, J. D. Higgins, J. J.", "words_pool": ["analysi", "biochem", "simul", "system", "garfinkel", "rutledg", "higgin"], "word_count": {"analysi": 1, "biochem": 1, "simul": 1, "system": 1, "garfinkel": 1, "rutledg": 1, "higgin": 1}}, "239": {"id": "239", "title": "Inefficiency of the Use of Boolean Functions for Information Retrieval Systems", "authors": "Verhoeff, J. Goffman, W. Belzer, J.", "words_pool": ["boolean", "function", "ineffici", "inform", "retriev", "system", "verhoeff", "goffman", "belzer"], "word_count": {"boolean": 1, "function": 1, "ineffici": 1, "inform": 1, "retriev": 1, "system": 1, "verhoeff": 1, "goffman": 1, "belzer": 1}}, "240": {"id": "240", "title": "Processing Magnetic Tape Files with Variable Blocks", "authors": "Graham, J. W. Sprott, D. A.", "words_pool": ["block", "magnet", "process", "tape", "variabl", "graham", "sprott"], "word_count": {"block": 1, "magnet": 1, "process": 1, "tape": 1, "variabl": 1, "graham": 1, "sprott": 1}}, "241": {"id": "241", "title": "Machine Calculation of Moments of a Probability Distribution", "abstract": "A method is presented for the calculation on a machine of the moments of a probability distribution,  necessitating little more than n additions and n references to memory for each moment, instead of the  minimum of n multiplication, 2n additions, and 2n references to memory required by the most straightforward  method (where n is the number of entries in the probability distribution).  The method is directly applicable  when a tabulated distribution exists, as when it has been computed by repeated convolution; but in this  case it conserves both time and accuracy.", "authors": "Lechner, J. A.", "words_pool": ["2n", "accuraci", "addit", "applic", "calcul", "case", "comput", "conserv", "convolut", "directli", "distribut", "entri", "exist", "machin", "memori", "method", "minimum", "moment", "moment", "multipl", "necessit", "number", "present", "probabl", "refer", "repeat", "requir", "straightforward", "tabul", "time", "lechner"], "word_count": {"2n": 2, "accuraci": 1, "addit": 2, "applic": 1, "calcul": 1, "case": 1, "comput": 1, "conserv": 1, "convolut": 1, "directli": 1, "distribut": 3, "entri": 1, "exist": 1, "machin": 1, "memori": 2, "method": 3, "minimum": 1, "moment": 2, "multipl": 1, "necessit": 1, "number": 1, "present": 1, "probabl": 2, "refer": 2, "repeat": 1, "requir": 1, "straightforward": 1, "tabul": 1, "time": 1, "lechner": 1}}, "242": {"id": "242", "title": "Notes on Geometric Weighted Check Digit Verification", "abstract": "This note describes a method for utilizing geometric weight modulus 11 checking digits on a  computer which does not have either multiplication or division.  In addition some attempt has been made  to show some limitations of this system.", "authors": "Wilson, J. G.", "words_pool": ["addit", "attempt", "check", "check", "comput", "describ", "digit", "digit", "divis", "geometr", "limit", "made", "method", "modulu", "multipl", "note", "note", "show", "system", "util", "verif", "weight", "weight", "wilson"], "word_count": {"addit": 1, "attempt": 1, "check": 1, "comput": 1, "describ": 1, "digit": 1, "divis": 1, "geometr": 1, "limit": 1, "made": 1, "method": 1, "modulu": 1, "multipl": 1, "note": 1, "show": 1, "system": 1, "util": 1, "verif": 1, "weight": 1, "wilson": 1}}, "243": {"id": "243", "title": "N-Dimensional Codes for Detecting and Correcting Multiple Errors", "abstract": "The paper introduces a new family of codes for detecting and correcting multiple errors in  a binary-coded message.  The message itself is arranged (conceptually) into a multidimensional rectangular  array.  The processes of encoding and error detection are based upon parity evaluations along prescribed  dimensions of the array.  Effectiveness of the codes is increased by introducing a \"system check bit\",  which is essentially a parity check on the other parity bits.  Only three-dimensional codes are discussed  in this paper with parity evaluations along the horizontal, the vertical, and one main diagonal.  However,  the family of codes is not restricted to three dimensions, as evidenced by the discussion by Minnick  and Ashenhurst on a similar multidimensional single-bit selection plan used for another purpose [6].   A four-dimensional code, correcting three and detecting four errors, has been developed; the extension  to higher-dimensional codes with greater correction power is straightforward.", "authors": "Rubinoff, M.", "words_pool": ["arrang", "array", "ashenhurst", "base", "binari", "bit", "bit", "check", "code", "code", "code", "conceptu", "correct", "correct", "detect", "detect", "develop", "diagon", "dimension", "dimens", "discuss", "discuss", "effect", "encod", "error", "error", "essenti", "evalu", "evidenc", "extens", "famili", "greater", "higher", "horizont", "increas", "introduc", "introduc", "main", "messag", "minnick", "multidimension", "multipl", "paper", "pariti", "plan", "power", "prescrib", "process", "purpos", "rectangular", "restrict", "select", "similar", "singl", "straightforward", "system", "vertic", "rubinoff"], "word_count": {"arrang": 1, "array": 2, "ashenhurst": 1, "base": 1, "binari": 1, "bit": 3, "check": 2, "code": 7, "conceptu": 1, "correct": 3, "detect": 3, "develop": 1, "diagon": 1, "dimension": 3, "dimens": 2, "discuss": 2, "effect": 1, "encod": 1, "error": 3, "essenti": 1, "evalu": 2, "evidenc": 1, "extens": 1, "famili": 2, "greater": 1, "higher": 1, "horizont": 1, "increas": 1, "introduc": 2, "main": 1, "messag": 2, "minnick": 1, "multidimension": 2, "multipl": 1, "paper": 2, "pariti": 4, "plan": 1, "power": 1, "prescrib": 1, "process": 1, "purpos": 1, "rectangular": 1, "restrict": 1, "select": 1, "similar": 1, "singl": 1, "straightforward": 1, "system": 1, "vertic": 1, "rubinoff": 1}}, "244": {"id": "244", "title": "Incomplete Elliptic Integrals (Algorithm 73)", "authors": "Kriebel, D. C.", "words_pool": ["algorithm", "ellipt", "incomplet", "integr", "kriebel"], "word_count": {"algorithm": 1, "ellipt": 1, "incomplet": 1, "integr": 1, "kriebel": 1}}, "245": {"id": "245", "title": "A Set of Associate Legendre Polynomials of the Second Kind (Algorithm 62)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "associ", "kind", "legendr", "polynomi", "set", "herndon"], "word_count": {"algorithm": 1, "associ": 1, "kind": 1, "legendr": 1, "polynomi": 1, "set": 1, "herndon": 1}}, "246": {"id": "246", "title": "Least-Squares Fit by Orthogonal Polynomials (Algorithm 28)", "authors": "MacMillan, D. B.", "words_pool": ["algorithm", "fit", "orthogon", "polynomi", "squar", "macmillan"], "word_count": {"algorithm": 1, "fit": 1, "orthogon": 1, "polynomi": 1, "squar": 1, "macmillan": 1}}, "247": {"id": "247", "title": "Incomplete Elliptic Integrals (Algorithm 73)", "authors": "Jefferson, D. K.", "words_pool": ["algorithm", "ellipt", "incomplet", "integr", "jefferson"], "word_count": {"algorithm": 1, "ellipt": 1, "incomplet": 1, "integr": 1, "jefferson": 1}}, "248": {"id": "248", "title": "What is Proprietary In Mathematical Programming?-Impressions of a Panel Discussion", "abstract": "A panel discussion on \"What is Proprietary in Mathematical Programming?\" was sponsored by the  Special Interest Committee on Mathematical Programming of the ACM during a Hall of Discussion/on September  7th at the 16th National ACM meeting in Los Angeles.  This note consists solely of the impressions garnered  by the moderator of the panel and does not necessarily represent the position of any of the panelists  or other participants in the discussion.", "authors": "Smith, L. W.", "words_pool": ["16th", "7th", "acm", "angel", "committe", "consist", "discuss", "garner", "hall", "impress", "interest", "lo", "mathemat", "meet", "moder", "nation", "necessarili", "note", "panel", "panelist", "particip", "posit", "program", "proprietari", "repres", "septemb", "sole", "special", "sponsor", "smith"], "word_count": {"16th": 1, "7th": 1, "acm": 2, "angel": 1, "committe": 1, "consist": 1, "discuss": 3, "garner": 1, "hall": 1, "impress": 1, "interest": 1, "lo": 1, "mathemat": 2, "meet": 1, "moder": 1, "nation": 1, "necessarili": 1, "note": 1, "panel": 2, "panelist": 1, "particip": 1, "posit": 1, "program": 2, "proprietari": 1, "repres": 1, "septemb": 1, "sole": 1, "special": 1, "sponsor": 1, "smith": 1}}, "249": {"id": "249", "title": "Specification Languages for Mechanical Languages and Their Processors*-A Baker's Dozen", "authors": "Gorn, S.", "words_pool": ["baker", "dozen", "languag", "mechan", "processor", "specif", "gorn"], "word_count": {"baker": 1, "dozen": 1, "languag": 2, "mechan": 1, "processor": 1, "specif": 1, "gorn": 1}}, "250": {"id": "250", "title": "An Engineering Application of Logic-Structure Tables", "authors": "Nickerson, R. C.", "words_pool": ["applic", "engin", "logic", "structur", "tabl", "nickerson"], "word_count": {"applic": 1, "engin": 1, "logic": 1, "structur": 1, "tabl": 1, "nickerson": 1}}, "251": {"id": "251", "title": "Ballistic Cam Design", "abstract": "This paper presents a digital computer program for the rapid calculation of manufacturing data  essential to the design of preproduction cams which are utilized in ballistic computers of tank fire  control systems.  The cam profile generated introduces the superelevation angle required by tank main  armament for a particular type ammunition.", "authors": "Archambault, M.", "words_pool": ["ammunit", "angl", "armament", "ballist", "calcul", "cam", "cam", "comput", "comput", "control", "data", "design", "digit", "essenti", "fire", "gener", "introduc", "main", "manufactur", "paper", "preproduct", "present", "profil", "program", "rapid", "requir", "superelev", "system", "tank", "type", "util", "archambault"], "word_count": {"ammunit": 1, "angl": 1, "armament": 1, "ballist": 1, "calcul": 1, "cam": 2, "comput": 2, "control": 1, "data": 1, "design": 1, "digit": 1, "essenti": 1, "fire": 1, "gener": 1, "introduc": 1, "main": 1, "manufactur": 1, "paper": 1, "preproduct": 1, "present": 1, "profil": 1, "program": 1, "rapid": 1, "requir": 1, "superelev": 1, "system": 1, "tank": 2, "type": 1, "util": 1, "archambault": 1}}, "252": {"id": "252", "title": "Programming a Duplex Computer System", "abstract": "This paper describes a method of duplex-computer programming that has been used with two computers  in a military defense system.  The method combines special programs with a basic data processing program  package.  The duplex operation gives the system greater reliability.  After achieving the required level  of integration, both computers do similar processing on the same inputs and continually cross-check the  intermediate and final results.", "authors": "Dow, J.", "words_pool": ["achiev", "basic", "check", "combin", "comput", "comput", "continu", "cross", "data", "defens", "describ", "duplex", "final", "greater", "input", "integr", "intermedi", "level", "method", "militari", "oper", "packag", "paper", "process", "program", "program", "program", "reliabl", "requir", "result", "similar", "special", "system", "dow"], "word_count": {"achiev": 1, "basic": 1, "check": 1, "combin": 1, "comput": 3, "continu": 1, "cross": 1, "data": 1, "defens": 1, "describ": 1, "duplex": 2, "final": 1, "greater": 1, "input": 1, "integr": 1, "intermedi": 1, "level": 1, "method": 2, "militari": 1, "oper": 1, "packag": 1, "paper": 1, "process": 2, "program": 3, "reliabl": 1, "requir": 1, "result": 1, "similar": 1, "special": 1, "system": 2, "dow": 1}}, "253": {"id": "253", "title": "On a Program for Ray-Chaudhuri's Algorithm for a Minimum Cover of an Abstract Complex", "authors": "Foata, D. C.", "words_pool": ["abstract", "algorithm", "chaudhuri", "complex", "cover", "minimum", "program", "ray", "foata"], "word_count": {"abstract": 1, "algorithm": 1, "chaudhuri": 1, "complex": 1, "cover": 1, "minimum": 1, "program": 1, "ray": 1, "foata": 1}}, "254": {"id": "254", "title": "SMALGOL-61", "abstract": "Prior to and during the 1961 Western Joint Computer Conference, several people in the Joint  Users Groups had expressed interest in defining a \"smalgol\" language.  This is to be an ALGOL language  for use with compilers on relatively small size computers.  A preliminary report resulted.  At the ACM  National Conference four months later, after considering several counter proposals, a final version was  agreed upon by a subcommittee.  The recommendations of the Subcommittee for a standard subset of ALGOL  60 for use on small computers is presented here.", "authors": "Bachelork, G. A. Dempster, J. R. H. Knuth, D. E. Speroni, J.", "words_pool": ["acm", "agre", "algol", "compil", "comput", "comput", "confer", "consid", "counter", "defin", "express", "final", "group", "interest", "joint", "languag", "later", "month", "nation", "peopl", "preliminari", "present", "prior", "propos", "recommend", "report", "result", "size", "smalgol", "small", "standard", "subcommitte", "subset", "user", "version", "western", "bachelork", "dempster", "knuth", "speroni"], "word_count": {"acm": 1, "agre": 1, "algol": 2, "compil": 1, "comput": 3, "confer": 2, "consid": 1, "counter": 1, "defin": 1, "express": 1, "final": 1, "group": 1, "interest": 1, "joint": 2, "languag": 2, "later": 1, "month": 1, "nation": 1, "peopl": 1, "preliminari": 1, "present": 1, "prior": 1, "propos": 1, "recommend": 1, "report": 1, "result": 1, "size": 1, "smalgol": 1, "small": 2, "standard": 1, "subcommitte": 2, "subset": 1, "user": 1, "version": 1, "western": 1, "bachelork": 1, "dempster": 1, "knuth": 1, "speroni": 1}}, "255": {"id": "255", "title": "Augmentation (Algorithm 68)", "authors": "Breed, L. M.", "words_pool": ["algorithm", "augment", "breed"], "word_count": {"algorithm": 1, "augment": 1, "breed": 1}}, "256": {"id": "256", "title": "A Set of Test Matrices (Algorithm 52)", "authors": "Dubay, G. H.", "words_pool": ["algorithm", "matric", "set", "test", "dubay"], "word_count": {"algorithm": 1, "matric": 1, "set": 1, "test": 1, "dubay": 1}}, "257": {"id": "257", "title": "Invert (Algorithm 42)", "authors": "Knapp, A. W. Shaman, P.", "words_pool": ["algorithm", "invert", "knapp", "shaman"], "word_count": {"algorithm": 1, "invert": 1, "knapp": 1, "shaman": 1}}, "258": {"id": "258", "title": "Composition Generator (Algorithm 72)", "authors": "Hellerman, O. Ogden, S.", "words_pool": ["algorithm", "composit", "gener", "hellerman", "ogden"], "word_count": {"algorithm": 1, "composit": 1, "gener": 1, "hellerman": 1, "ogden": 1}}, "259": {"id": "259", "title": "Permutation (Algorithm 71)", "authors": "Coveyou, R. R. Sullivan, J. G.", "words_pool": ["algorithm", "permut", "covey", "sullivan"], "word_count": {"algorithm": 1, "permut": 1, "covey": 1, "sullivan": 1}}, "260": {"id": "260", "title": "Interpolation By Aitken (Algorithm 70)", "authors": "Mifsud, C. J.", "words_pool": ["aitken", "algorithm", "interpol", "mifsud"], "word_count": {"aitken": 1, "algorithm": 1, "interpol": 1, "mifsud": 1}}, "261": {"id": "261", "title": "Tape Splitting", "authors": "Moore, D. P.", "words_pool": ["split", "tape", "moor"], "word_count": {"split": 1, "tape": 1, "moor": 1}}, "262": {"id": "262", "title": "MAP", "authors": "Moore, C. L. Ruwe, M. L.", "words_pool": ["map", "moor", "ruw"], "word_count": {"map": 1, "moor": 1, "ruw": 1}}, "263": {"id": "263", "title": "Library Loading with Alternate Routine Selection", "authors": "Moore, D. P.", "words_pool": ["altern", "librari", "load", "routin", "select", "moor"], "word_count": {"altern": 1, "librari": 1, "load": 1, "routin": 1, "select": 1, "moor": 1}}, "264": {"id": "264", "title": "A Generalized Polyphase Merge Algorithm", "authors": "Reynolds, S. W.", "words_pool": ["algorithm", "gener", "merg", "polyphas", "reynold"], "word_count": {"algorithm": 1, "gener": 1, "merg": 1, "polyphas": 1, "reynold": 1}}, "265": {"id": "265", "title": "Low Level Language Subroutines for Use Within Fortran", "abstract": "This paper describes some subroutines, coded in symbolic languages and for use within Fortran  coded programs, to deal with \"special arithmetic\" (e.g. multi-precision arithmetic), symbol manipulation,  bit manipulation and expanded character set input-output, and visual display.", "authors": "Barnett, M. P.", "words_pool": ["arithmet", "bit", "charact", "code", "deal", "describ", "display", "expand", "fortran", "input", "languag", "languag", "level", "low", "manipul", "multi", "output", "paper", "precis", "program", "set", "special", "subroutin", "symbol", "symbol", "visual", "barnett"], "word_count": {"arithmet": 2, "bit": 1, "charact": 1, "code": 2, "deal": 1, "describ": 1, "display": 1, "expand": 1, "fortran": 1, "input": 1, "languag": 1, "level": 1, "low": 1, "manipul": 2, "multi": 1, "output": 1, "paper": 1, "precis": 1, "program": 1, "set": 1, "special": 1, "subroutin": 1, "symbol": 2, "visual": 1, "barnett": 1}}, "266": {"id": "266", "title": "Fitting Spheres by the Method of Least Squares", "authors": "Robinson, S. M.", "words_pool": ["fit", "method", "sphere", "squar", "robinson"], "word_count": {"fit": 1, "method": 1, "sphere": 1, "squar": 1, "robinson": 1}}, "267": {"id": "267", "title": "Some Proposals for Improving the Efficiency of ALGOL 60", "authors": "Wilkes, M. V.", "words_pool": ["algol", "effici", "improv", "propos", "wilk"], "word_count": {"algol": 1, "effici": 1, "improv": 1, "propos": 1, "wilk": 1}}, "268": {"id": "268", "title": "Stochastic Evaluation of a Static Storage Allocation", "authors": "Cohen, L. J.", "words_pool": ["alloc", "evalu", "static", "stochast", "storag", "cohen"], "word_count": {"alloc": 1, "evalu": 1, "static": 1, "stochast": 1, "storag": 1, "cohen": 1}}, "269": {"id": "269", "title": "Core Allocation Based on Probability", "authors": "Riskin, B. N.", "words_pool": ["alloc", "base", "core", "probabl", "riskin"], "word_count": {"alloc": 1, "base": 1, "core": 1, "probabl": 1, "riskin": 1}}, "270": {"id": "270", "title": "Techniques for Storage Allocation Algorithms", "authors": "Kelley Jr., J. E.", "words_pool": ["algorithm", "alloc", "storag", "techniqu", "kelley", "jr"], "word_count": {"algorithm": 1, "alloc": 1, "storag": 1, "techniqu": 1, "kelley": 1, "jr": 1}}, "271": {"id": "271", "title": "A Semi-Automatic Storage Allocation System at Loading Time", "authors": "Heising, W. P. Larner, R. A.", "words_pool": ["alloc", "automat", "load", "semi", "storag", "system", "time", "heis", "larner"], "word_count": {"alloc": 1, "automat": 1, "load": 1, "semi": 1, "storag": 1, "system": 1, "time": 1, "heis": 1, "larner": 1}}, "272": {"id": "272", "title": "A Storage Allocation Scheme for ALGOL 60", "abstract": "A storage allocation scheme for a machine with a 2048 instruction core store and a magnetic  drum is described.  The use of the drum for storing program blocks and/or data must be directed by the  programmer through auxiliary information in the ALGOL program.  The administrative routines controlling  the storage at run time are described in full.  A detailed example is given.", "authors": "Jensen, J. Mondrup, P. Naur, P.", "words_pool": ["administr", "algol", "alloc", "auxiliari", "block", "control", "core", "data", "detail", "direct", "drum", "full", "inform", "instruct", "machin", "magnet", "program", "programm", "routin", "run", "scheme", "storag", "store", "store", "time", "jensen", "mondrup", "naur"], "word_count": {"administr": 1, "algol": 1, "alloc": 1, "auxiliari": 1, "block": 1, "control": 1, "core": 1, "data": 1, "detail": 1, "direct": 1, "drum": 2, "full": 1, "inform": 1, "instruct": 1, "machin": 1, "magnet": 1, "program": 2, "programm": 1, "routin": 1, "run": 1, "scheme": 1, "storag": 2, "store": 2, "time": 1, "jensen": 1, "mondrup": 1, "naur": 1}}, "273": {"id": "273", "title": "Experience in Automatic Storage Allocation", "authors": "Collins Jr., G. O.", "words_pool": ["alloc", "automat", "experi", "storag", "collin", "jr"], "word_count": {"alloc": 1, "automat": 1, "experi": 1, "storag": 1, "collin": 1, "jr": 1}}, "274": {"id": "274", "title": "Dynamic Storage Allocation in the Atlas Computer, Including an Automatic Use of a Backing Store", "authors": "Fotheringham, J.", "words_pool": ["alloc", "atla", "automat", "back", "comput", "dynam", "includ", "storag", "store", "fotheringham"], "word_count": {"alloc": 1, "atla": 1, "automat": 1, "back": 1, "comput": 1, "dynam": 1, "includ": 1, "storag": 1, "store": 1, "fotheringham": 1}}, "275": {"id": "275", "title": "Dynamic Storage Allocation for an Information Retrieval System", "authors": "Sams, B. H.", "words_pool": ["alloc", "dynam", "inform", "retriev", "storag", "system", "sam"], "word_count": {"alloc": 1, "dynam": 1, "inform": 1, "retriev": 1, "storag": 1, "system": 1, "sam": 1}}, "276": {"id": "276", "title": "Program Organization and Record Keeping for Dynamic Storage Allocation", "abstract": "The material presented in this paper is part of the design plan of the core allocation portion  of the ASCII-MATIC Programming System.  Project ASCII-MATIC is concerned with the application of computer  techniques to the activities of certain headquarters military intelligence operations of the U.S. Army.", "authors": "Holt, A. W.", "words_pool": ["activ", "alloc", "applic", "armi", "ascii", "comput", "concern", "core", "design", "dynam", "headquart", "intellig", "keep", "materi", "matic", "militari", "oper", "organ", "paper", "part", "plan", "portion", "present", "program", "program", "project", "record", "storag", "system", "techniqu", "holt"], "word_count": {"activ": 1, "alloc": 1, "applic": 1, "armi": 1, "ascii": 2, "comput": 1, "concern": 1, "core": 1, "design": 1, "dynam": 1, "headquart": 1, "intellig": 1, "keep": 1, "materi": 1, "matic": 2, "militari": 1, "oper": 1, "organ": 1, "paper": 1, "part": 1, "plan": 1, "portion": 1, "present": 1, "program": 1, "project": 1, "record": 1, "storag": 1, "system": 1, "techniqu": 1, "holt": 1}}, "277": {"id": "277", "title": "Problems of Storage Allocation in a Multiprocessor Multiprogrammed System", "authors": "Maher, R. J.", "words_pool": ["alloc", "multiprocessor", "multiprogram", "problem", "storag", "system", "maher"], "word_count": {"alloc": 1, "multiprocessor": 1, "multiprogram": 1, "problem": 1, "storag": 1, "system": 1, "maher": 1}}, "278": {"id": "278", "title": "A General Formulation of storage Allocation", "abstract": "Formalization of a general computer storage allocation process is attempted.  With a given  computer M is associated a fictitious computer M' essentially identical to M except in respect to possession  of unbounded primary storage.  Mappings of the total storage set (internal and external) of M into the  direct address set of M' are introduced.  A program sequence P for M' is termed M-admissible (relative  to a specific execution time period) if there is a mapping underwhich P and its effective data referents  are all located in the direct address set of M.  Storage allocation is considered as a process of establishing  for an arbitrary M' program  a sequence of mappings, a decoupling of the program into M-admissible subprograms  and a linking set of interludes.  An existence proof in terms of a completely interpretive M program  as indicated.  Some special cases are discussed.  Various restrictions on generality of M' programs are  considered under which more practical realization of allocation processes becomes tractable.", "authors": "Roberts Jr., A. E.", "words_pool": ["address", "admiss", "alloc", "arbitrari", "attempt", "case", "complet", "comput", "consid", "data", "decoupl", "direct", "discuss", "effect", "essenti", "establish", "execut", "exist", "extern", "fictiti", "formal", "formul", "gener", "gener", "ident", "interlud", "intern", "interpret", "introduc", "link", "locat", "map", "map", "period", "possess", "practic", "primari", "process", "process", "program", "program", "proof", "realiz", "refer", "rel", "respect", "restrict", "sequenc", "set", "special", "specif", "storag", "subprogram", "term", "term", "time", "total", "tractabl", "unbound", "underwhich", "robert", "jr"], "word_count": {"address": 2, "admiss": 2, "alloc": 3, "arbitrari": 1, "attempt": 1, "case": 1, "complet": 1, "comput": 3, "consid": 2, "data": 1, "decoupl": 1, "direct": 2, "discuss": 1, "effect": 1, "essenti": 1, "establish": 1, "execut": 1, "exist": 1, "extern": 1, "fictiti": 1, "formal": 1, "formul": 1, "gener": 2, "ident": 1, "interlud": 1, "intern": 1, "interpret": 1, "introduc": 1, "link": 1, "locat": 1, "map": 3, "period": 1, "possess": 1, "practic": 1, "primari": 1, "process": 3, "program": 5, "proof": 1, "realiz": 1, "refer": 1, "rel": 1, "respect": 1, "restrict": 1, "sequenc": 2, "set": 4, "special": 1, "specif": 1, "storag": 4, "subprogram": 1, "term": 2, "time": 1, "total": 1, "tractabl": 1, "unbound": 1, "underwhich": 1, "robert": 1, "jr": 1}}, "279": {"id": "279", "title": "The Case for Dynamic storage Allocation", "authors": "Sams, B. H.", "words_pool": ["alloc", "case", "dynam", "storag", "sam"], "word_count": {"alloc": 1, "case": 1, "dynam": 1, "storag": 1, "sam": 1}}, "280": {"id": "280", "title": "A Preplanned Approach to a Storage Allocating Compiler", "authors": "O'Neil, R. W.", "words_pool": ["alloc", "approach", "compil", "preplan", "storag", "neil"], "word_count": {"alloc": 1, "approach": 1, "compil": 1, "preplan": 1, "storag": 1, "neil": 1}}, "281": {"id": "281", "title": "Putting a Hex on e^x", "abstract": "Recent notes on approximate natural antilogy have not considered indirect formulations for  describing e^x.  In this note we produce a particular family of very fast, high precision and eminently  practical exponential evaluation formulas derived from one such formulation.", "authors": "Feurzeig, W.", "words_pool": ["antilog", "approxim", "consid", "deriv", "describ", "emin", "evalu", "exponenti", "famili", "fast", "formula", "formul", "formul", "hex", "high", "indirect", "natur", "note", "note", "practic", "precis", "produc", "put", "recent", "feurzeig"], "word_count": {"antilog": 1, "approxim": 1, "consid": 1, "deriv": 1, "describ": 1, "emin": 1, "evalu": 1, "exponenti": 1, "famili": 1, "fast": 1, "formula": 1, "formul": 2, "hex": 1, "high": 1, "indirect": 1, "natur": 1, "note": 2, "practic": 1, "precis": 1, "produc": 1, "put": 1, "recent": 1, "feurzeig": 1}}, "282": {"id": "282", "title": "Optimum Tape-Writing Procedures", "abstract": "Consider a magnetic tape system with a read check after writing.  Where an error occurs in  writing a record, a programmed error routine may either bypass some or all of the area on tape or try  to rewrite the record on the same area.  This paper evaluates these two procedures on the basis of expected  loss of computer time and develops a decision rule for selecting the optimum procedure.  The rule depends  critically on the number of times the tape being written will be used in the future.  In the case where  the optimum procedure is to bypass an area, a second decision-the size of the area to be bypassed-is  necessary.  A formula is developed to determine the optimum area to be bypassed for each procedure.", "authors": "Hutchinson, K.", "words_pool": ["area", "basi", "bypass", "bypass", "case", "check", "comput", "consid", "critic", "decis", "depend", "determin", "develop", "develop", "error", "evalu", "expect", "formula", "futur", "loss", "magnet", "number", "occur", "optimum", "paper", "procedur", "procedur", "program", "read", "record", "rewrit", "routin", "rule", "select", "size", "system", "tape", "time", "time", "tri", "write", "written", "hutchinson"], "word_count": {"area": 5, "basi": 1, "bypass": 4, "case": 1, "check": 1, "comput": 1, "consid": 1, "critic": 1, "decis": 2, "depend": 1, "determin": 1, "develop": 2, "error": 2, "evalu": 1, "expect": 1, "formula": 1, "futur": 1, "loss": 1, "magnet": 1, "number": 1, "occur": 1, "optimum": 3, "paper": 1, "procedur": 4, "program": 1, "read": 1, "record": 2, "rewrit": 1, "routin": 1, "rule": 2, "select": 1, "size": 1, "system": 1, "tape": 3, "time": 2, "tri": 1, "write": 2, "written": 1, "hutchinson": 1}}, "283": {"id": "283", "title": "Inversion of a Complex Matrix", "authors": "Tornheim, L.", "words_pool": ["complex", "invers", "matrix", "tornheim"], "word_count": {"complex": 1, "invers": 1, "matrix": 1, "tornheim": 1}}, "284": {"id": "284", "title": "Manipulation of Algebraic Expressions", "abstract": "An algorithm for algebraically manipulating expressions of the form SUM{CiPi, i=1,...,n}; has  been developed in conjunction with the development of programs for systems analysis problems.  This algorithm  enablesus to derive over-all system transfer functions from algebraically described block diagrams of  any linear continuous multi-loop feedback system.  The machine representation of the derived expression,  is, by virtue of the algorithm, in a form which simplifies the task of compiling.  The algorithm was  developed for a particular purpose in connection with system analysis studies.  However, its application  as a mathematical device extends far beyond the confines of the original problem.", "authors": "Rom, A. R. M.", "words_pool": ["algebra", "algebra", "algorithm", "analysi", "applic", "block", "cipi", "compil", "confin", "conjunct", "connect", "continu", "deriv", "deriv", "develop", "develop", "devic", "diagram", "enablesu", "express", "express", "extend", "feedback", "form", "function", "linear", "loop", "machin", "manipul", "manipul", "mathemat", "multi", "origin", "problem", "problem", "program", "purpos", "represent", "simplifi", "studi", "sum", "system", "system", "task", "transfer", "virtu", "rom"], "word_count": {"algebra": 2, "algorithm": 4, "analysi": 2, "applic": 1, "block": 1, "cipi": 1, "compil": 1, "confin": 1, "conjunct": 1, "connect": 1, "continu": 1, "deriv": 2, "develop": 3, "devic": 1, "diagram": 1, "enablesu": 1, "express": 2, "extend": 1, "feedback": 1, "form": 2, "function": 1, "linear": 1, "loop": 1, "machin": 1, "manipul": 1, "mathemat": 1, "multi": 1, "origin": 1, "problem": 2, "program": 1, "purpos": 1, "represent": 1, "simplifi": 1, "studi": 1, "sum": 1, "system": 4, "task": 1, "transfer": 1, "virtu": 1, "rom": 1}}, "285": {"id": "285", "title": "Solution of Tridiagonal Matrices", "authors": "Wenrick, R. C. Houghton, A. V.", "words_pool": ["matric", "solut", "tridiagon", "wenrick", "houghton"], "word_count": {"matric": 1, "solut": 1, "tridiagon": 1, "wenrick": 1, "houghton": 1}}, "286": {"id": "286", "title": "An Iterative Method for Inversion of Power Series", "authors": "Bramhall, J. N.", "words_pool": ["invers", "iter", "method", "power", "seri", "bramhal"], "word_count": {"invers": 1, "iter": 1, "method": 1, "power": 1, "seri": 1, "bramhal": 1}}, "287": {"id": "287", "title": "The Generalized Important Event Technique", "authors": "Shapiro, N. Vreenegoor, H.", "words_pool": ["event", "gener", "import", "techniqu", "shapiro", "vreenegoor"], "word_count": {"event": 1, "gener": 1, "import": 1, "techniqu": 1, "shapiro": 1, "vreenegoor": 1}}, "288": {"id": "288", "title": "A Syntactical Chart of ALGOL 60", "authors": "Taylor, W. Turner, L. Waychoff, R.", "words_pool": ["algol", "chart", "syntact", "taylor", "turner", "waychoff"], "word_count": {"algol": 1, "chart": 1, "syntact": 1, "taylor": 1, "turner": 1, "waychoff": 1}}, "289": {"id": "289", "title": "Critical Path Scheduling (Algorithm 40)", "authors": "Alexander, N. P.", "words_pool": ["algorithm", "critic", "path", "schedul", "alexand"], "word_count": {"algorithm": 1, "critic": 1, "path": 1, "schedul": 1, "alexand": 1}}, "290": {"id": "290", "title": "Chain Tracing (Algorithm 69)", "authors": "Mayoh, B. H.", "words_pool": ["algorithm", "chain", "trace", "mayoh"], "word_count": {"algorithm": 1, "chain": 1, "trace": 1, "mayoh": 1}}, "291": {"id": "291", "title": "Use of MOBOL in PreparingRetrieval Programs", "authors": "Hoffman, J. Opler, A.", "words_pool": ["mobol", "preparingretriev", "program", "hoffman", "opler"], "word_count": {"mobol": 1, "preparingretriev": 1, "program": 1, "hoffman": 1, "opler": 1}}, "292": {"id": "292", "title": "An Information Retrieval Language for Legal Studies", "authors": "Kehl, W. B. Horty, J. F. Bacon, C. R. T. Mitchell, D. S.", "words_pool": ["inform", "languag", "legal", "retriev", "studi", "kehl", "horti", "bacon", "mitchel"], "word_count": {"inform": 1, "languag": 1, "legal": 1, "retriev": 1, "studi": 1, "kehl": 1, "horti": 1, "bacon": 1, "mitchel": 1}}, "293": {"id": "293", "title": "The Applied Mathematics Laboratory of the David W. Taylor Model Basin", "authors": "Richstone, M.", "words_pool": ["appli", "basin", "david", "laboratori", "mathemat", "model", "taylor", "richston"], "word_count": {"appli": 1, "basin": 1, "david": 1, "laboratori": 1, "mathemat": 1, "model": 1, "taylor": 1, "richston": 1}}, "294": {"id": "294", "title": "An Imaginary Number System", "authors": "Knuth, D.", "words_pool": ["imaginari", "number", "system", "knuth"], "word_count": {"imaginari": 1, "number": 1, "system": 1, "knuth": 1}}, "295": {"id": "295", "title": "Rational Approximations for the Error Function and for Similar Functions", "authors": "Clendenin, W. W.", "words_pool": ["approxim", "error", "function", "function", "ration", "similar", "clendenin"], "word_count": {"approxim": 1, "error": 1, "function": 2, "ration": 1, "similar": 1, "clendenin": 1}}, "296": {"id": "296", "title": "A Note on Multiple Precision Arithmetic", "authors": "Cox, A. G. Luther, H. A.", "words_pool": ["arithmet", "multipl", "note", "precis", "cox", "luther"], "word_count": {"arithmet": 1, "multipl": 1, "note": 1, "precis": 1, "cox": 1, "luther": 1}}, "297": {"id": "297", "title": "A Note on Fitting Great Circles by Least Squares", "authors": "Marcus, C. F.", "words_pool": ["circl", "fit", "great", "note", "squar", "marcu"], "word_count": {"circl": 1, "fit": 1, "great": 1, "note": 1, "squar": 1, "marcu": 1}}, "298": {"id": "298", "title": "A 48-Bit Pseudo-Random Number Generator", "abstract": "A new 48-bit pseudo-random number generator, suitable for several computers, was tested statistically  for randomness to determine its adequacy for use in Monte Carlo programs.  Frequency tests, distributions  of certain low-order moments, runs up and down, and runs above and below the mean were applied to one-half  million generated numbers lying within the interval (0,1) and to three sets of integers obtained from  specified bits within the generated numbers.  These tests substantiated the randomness of all numbers  except for the set of integers coming from the least significant bits.", "authors": "Kuehn, H. G.", "words_pool": ["adequaci", "appli", "bit", "bit", "carlo", "come", "comput", "determin", "distribut", "frequenc", "gener", "gener", "half", "integ", "interv", "low", "lie", "mean", "million", "moment", "mont", "number", "number", "obtain", "order", "program", "pseudo", "random", "random", "run", "set", "set", "signific", "statist", "substanti", "suitabl", "test", "test", "kuehn"], "word_count": {"adequaci": 1, "appli": 1, "bit": 3, "carlo": 1, "come": 1, "comput": 1, "determin": 1, "distribut": 1, "frequenc": 1, "gener": 3, "half": 1, "integ": 2, "interv": 1, "low": 1, "lie": 1, "mean": 1, "million": 1, "moment": 1, "mont": 1, "number": 4, "obtain": 1, "order": 1, "program": 1, "pseudo": 1, "random": 3, "run": 2, "set": 2, "signific": 1, "statist": 1, "substanti": 1, "suitabl": 1, "test": 3, "kuehn": 1}}, "299": {"id": "299", "title": "A Generalized Polyphase Merge Algorithm", "authors": "Reynolds, S. W.", "words_pool": ["algorithm", "gener", "merg", "polyphas", "reynold"], "word_count": {"algorithm": 1, "gener": 1, "merg": 1, "polyphas": 1, "reynold": 1}}, "300": {"id": "300", "title": "COBOL: A Sample Problem", "abstract": "A simplified Merchandise Control problem has been chosen for presenting COBOL to users and  potential users of computing systems.  A mythical department store, \"E. Language Bros., Inc.\", is programming  in the COBOL language one of the many runs on its computer.", "authors": "Mackinson, T. N.", "words_pool": ["bro", "chosen", "cobol", "comput", "comput", "control", "depart", "languag", "merchandis", "mythic", "potenti", "present", "problem", "program", "run", "sampl", "simplifi", "store", "system", "user", "mackinson"], "word_count": {"bro": 1, "chosen": 1, "cobol": 2, "comput": 2, "control": 1, "depart": 1, "languag": 2, "merchandis": 1, "mythic": 1, "potenti": 1, "present": 1, "problem": 1, "program": 1, "run": 1, "sampl": 1, "simplifi": 1, "store": 1, "system": 1, "user": 2, "mackinson": 1}}, "301": {"id": "301", "title": "A Set of Test Matrices (Algorithm 52)", "authors": "Gilbert, H. E.", "words_pool": ["algorithm", "matric", "set", "test", "gilbert"], "word_count": {"algorithm": 1, "matric": 1, "set": 1, "test": 1, "gilbert": 1}}, "302": {"id": "302", "title": "Augmentation (Algorithm 68)", "authors": "Rice, H. G.", "words_pool": ["algorithm", "augment", "rice"], "word_count": {"algorithm": 1, "augment": 1, "rice": 1}}, "303": {"id": "303", "title": "Some Basic Terminology Connected With Mechanical Languages and Their Processors", "abstract": "The suggestions in this paper are part of the terminology used in work for the University of  Pennsylvania's Office of computer Research and Education.  The work is jointly supported by the National  Science Foundation and the Air Force Office of Scientific Research.", "authors": "Gorn, S.", "words_pool": ["air", "basic", "comput", "connect", "educ", "forc", "foundat", "jointli", "languag", "mechan", "nation", "offic", "paper", "part", "pennsylvania", "processor", "research", "scienc", "scientif", "suggest", "support", "terminolog", "univers", "work", "gorn"], "word_count": {"air": 1, "basic": 1, "comput": 1, "connect": 1, "educ": 1, "forc": 1, "foundat": 1, "jointli": 1, "languag": 1, "mechan": 1, "nation": 1, "offic": 2, "paper": 1, "part": 1, "pennsylvania": 1, "processor": 1, "research": 2, "scienc": 1, "scientif": 1, "suggest": 1, "support": 1, "terminolog": 1, "univers": 1, "work": 2, "gorn": 1}}, "304": {"id": "304", "title": "Nth Roots of a Complex Number (Algorithm 53)", "authors": "Nestor Jr., C. W.", "words_pool": ["algorithm", "complex", "nth", "number", "root", "nestor", "jr"], "word_count": {"algorithm": 1, "complex": 1, "nth": 1, "number": 1, "root": 1, "nestor": 1, "jr": 1}}, "305": {"id": "305", "title": "CRAM (Algorithm 67)", "authors": "Caffrey, J.", "words_pool": ["algorithm", "cram", "caffrey"], "word_count": {"algorithm": 1, "cram": 1, "caffrey": 1}}, "306": {"id": "306", "title": "INVRS (Algorithm 66)", "authors": "Caffery, J.", "words_pool": ["algorithm", "invr", "cafferi"], "word_count": {"algorithm": 1, "invr": 1, "cafferi": 1}}, "307": {"id": "307", "title": "FIND (Algorithm 65)", "authors": "Hoare, C. A. R.", "words_pool": ["algorithm", "find", "hoar"], "word_count": {"algorithm": 1, "find": 1, "hoar": 1}}, "308": {"id": "308", "title": "QUICKSORT (Algorithm 64)", "authors": "Hoare, C. A. R.", "words_pool": ["algorithm", "quicksort", "hoar"], "word_count": {"algorithm": 1, "quicksort": 1, "hoar": 1}}, "309": {"id": "309", "title": "PARTITION (Algorithm 63)", "authors": "Hoare, C. A. R.", "words_pool": ["algorithm", "partit", "hoar"], "word_count": {"algorithm": 1, "partit": 1, "hoar": 1}}, "310": {"id": "310", "title": "A Set of Associate Legendre Polynomials of the Second Kind (Algorithm 62)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "associ", "kind", "legendr", "polynomi", "set", "herndon"], "word_count": {"algorithm": 1, "associ": 1, "kind": 1, "legendr": 1, "polynomi": 1, "set": 1, "herndon": 1}}, "311": {"id": "311", "title": "Procedures for Range Arithmetic (Algorithm 61)", "authors": "Gibb, A.", "words_pool": ["algorithm", "arithmet", "procedur", "rang", "gibb"], "word_count": {"algorithm": 1, "arithmet": 1, "procedur": 1, "rang": 1, "gibb": 1}}, "312": {"id": "312", "title": "A Further Note on Approximating e^x", "authors": "Olivier, D.", "words_pool": ["approxim", "note", "olivi"], "word_count": {"approxim": 1, "note": 1, "olivi": 1}}, "313": {"id": "313", "title": "An Iterative Method for Inversion of Power Series", "authors": "Bramhall, J. N.", "words_pool": ["invers", "iter", "method", "power", "seri", "bramhal"], "word_count": {"invers": 1, "iter": 1, "method": 1, "power": 1, "seri": 1, "bramhal": 1}}, "314": {"id": "314", "title": "A Divisionless Method of Integer Conversion", "authors": "Clarkson, W. K. Prince, B. M.", "words_pool": ["convers", "divisionless", "integ", "method", "clarkson", "princ"], "word_count": {"convers": 1, "divisionless": 1, "integ": 1, "method": 1, "clarkson": 1, "princ": 1}}, "315": {"id": "315", "title": "Solution of Tridiagonal Matrices", "authors": "Wenrick, R. C.", "words_pool": ["matric", "solut", "tridiagon", "wenrick"], "word_count": {"matric": 1, "solut": 1, "tridiagon": 1, "wenrick": 1}}, "316": {"id": "316", "title": "An Algorithm for Equivalence Declarations", "authors": "Arden, B. W. Galler, A. Graham, R. M.", "words_pool": ["algorithm", "declar", "equival", "arden", "galler", "graham"], "word_count": {"algorithm": 1, "declar": 1, "equival": 1, "arden": 1, "galler": 1, "graham": 1}}, "317": {"id": "317", "title": "On The Approximation of Curves by Line Segments Using Dynamic Programming", "authors": "Bellman, R.", "words_pool": ["approxim", "curv", "dynam", "line", "program", "segment", "bellman"], "word_count": {"approxim": 1, "curv": 1, "dynam": 1, "line": 1, "program": 1, "segment": 1, "bellman": 1}}, "318": {"id": "318", "title": "Combat Vehicle Firing Stability (Active Suspension)", "authors": "Fischer, C. M.", "words_pool": ["activ", "combat", "fire", "stabil", "suspens", "vehicl", "fischer"], "word_count": {"activ": 1, "combat": 1, "fire": 1, "stabil": 1, "suspens": 1, "vehicl": 1, "fischer": 1}}, "319": {"id": "319", "title": "On a Class of Iteration Formulas and Some Historical Notes", "abstract": "The class of iteration formulas obtainable by rational approximations of \"Euler's formula\"  is derived with the corresponding error estimates.  Some historical notes on iterative procedures are  followed by a derivation of Euler's formula with the associated error estimate in a new notation which  simplifies the error estimate and suggests generalizations.  The final section considers the Pade approximants  to the \"Euler polynomial\" and shows how a number of known formulas may be derived from this unified approach.   There is a short discussion of the \"best\" formula.", "authors": "Traub, J. F.", "words_pool": ["approach", "approxim", "approxim", "class", "consid", "deriv", "deriv", "discuss", "error", "estim", "estim", "euler", "final", "formula", "formula", "gener", "histor", "iter", "iter", "known", "notat", "note", "number", "obtain", "pade", "polynomi", "procedur", "ration", "section", "short", "show", "simplifi", "suggest", "unifi", "traub"], "word_count": {"approach": 1, "approxim": 2, "class": 1, "consid": 1, "deriv": 3, "discuss": 1, "error": 3, "estim": 3, "euler": 3, "final": 1, "formula": 5, "gener": 1, "histor": 1, "iter": 2, "known": 1, "notat": 1, "note": 1, "number": 1, "obtain": 1, "pade": 1, "polynomi": 1, "procedur": 1, "ration": 1, "section": 1, "short": 1, "show": 1, "simplifi": 1, "suggest": 1, "unifi": 1, "traub": 1}}, "320": {"id": "320", "title": "Logic-Structure Tables", "abstract": "Logic tables are an excellent way of developing and expressing the logic required in procedures,  operations, systems and circuits.  A set of rules for writing and using logic tables is explained by  means of some simple examples.  Then the logic structure of a vending machine is given in which two logic  tables are used.  Logic tables are two-dimensional in nature, enabling us to fully express and consider  both the sequential and parallel aspects of logic.  They can be compiled directly into a computer program  and so eliminate the need for flow charting and hand coding.", "authors": "Cantrell, H. N. King, J. King, F. E. H.", "words_pool": ["aspect", "chart", "circuit", "code", "compil", "comput", "consid", "develop", "dimension", "directli", "elimin", "enabl", "exampl", "excel", "explain", "express", "express", "flow", "fulli", "hand", "logic", "machin", "mean", "natur", "need", "oper", "parallel", "procedur", "program", "requir", "rule", "sequenti", "set", "simpl", "structur", "system", "tabl", "vend", "write", "cantrel", "king", "king"], "word_count": {"aspect": 1, "chart": 1, "circuit": 1, "code": 1, "compil": 1, "comput": 1, "consid": 1, "develop": 1, "dimension": 1, "directli": 1, "elimin": 1, "enabl": 1, "exampl": 1, "excel": 1, "explain": 1, "express": 2, "flow": 1, "fulli": 1, "hand": 1, "logic": 7, "machin": 1, "mean": 1, "natur": 1, "need": 1, "oper": 1, "parallel": 1, "procedur": 1, "program": 1, "requir": 1, "rule": 1, "sequenti": 1, "set": 1, "simpl": 1, "structur": 1, "system": 1, "tabl": 4, "vend": 1, "write": 1, "cantrel": 1, "king": 1}}, "321": {"id": "321", "title": "ALGOL 60 Confidential", "abstract": "The ALGOL 60 Report,* when first encountered, seems to describe a very complex language which  will be difficult to learn.  The \"metalinguistic formulae\" admirably serve the purpose of precisely specifying  a language, but they are certainly not very readable for a beginner.  However, experience has shown that  once the report is explained it is in fact easy to learn ALGOL and to write algorithms in it.  The language  is so general and powerful it can handle an enormous class of problems.  It is not hard to learn those  parts of ALGOL present in other compiler languages: how to write assignment and go to and for statements,  etc.  Indeed, a lot of the unnecessary restrictions imposed by other compiling languages have finally  been lifted.  But ALGOL also allows many unobvious things to be written, as we will see later, and herein  lies a problem: ALGOL seems to have become too general.  So many restrictions have been lifted that a  lot of technical details crop up which are hard to learn and to use correctly.  In this paper some of  the more obscure features of the language are considered and their usefulness is discussed.  Remarks  are based on the authors' interpretations of the ALGOL 60 Report.", "authors": "Knuth, D. E. Merner, J. N.", "words_pool": ["admir", "algol", "algorithm", "assign", "author", "base", "beginn", "certainli", "class", "compil", "compil", "complex", "confidenti", "consid", "correctli", "crop", "describ", "detail", "difficult", "discuss", "easi", "encount", "enorm", "experi", "explain", "fact", "featur", "final", "formula", "gener", "handl", "hard", "impos", "interpret", "languag", "languag", "later", "learn", "lie", "lift", "lot", "metalinguist", "obscur", "paper", "part", "power", "precis", "present", "problem", "problem", "purpos", "readabl", "remark", "report", "restrict", "serv", "shown", "statement", "technic", "thing", "unnecessari", "unobvi", "use", "write", "written", "knuth", "merner"], "word_count": {"admir": 1, "algol": 6, "algorithm": 1, "assign": 1, "author": 1, "base": 1, "beginn": 1, "certainli": 1, "class": 1, "compil": 2, "complex": 1, "confidenti": 1, "consid": 1, "correctli": 1, "crop": 1, "describ": 1, "detail": 1, "difficult": 1, "discuss": 1, "easi": 1, "encount": 1, "enorm": 1, "experi": 1, "explain": 1, "fact": 1, "featur": 1, "final": 1, "formula": 1, "gener": 2, "handl": 1, "hard": 2, "impos": 1, "interpret": 1, "languag": 6, "later": 1, "learn": 4, "lie": 1, "lift": 2, "lot": 2, "metalinguist": 1, "obscur": 1, "paper": 1, "part": 1, "power": 1, "precis": 1, "present": 1, "problem": 2, "purpos": 1, "readabl": 1, "remark": 1, "report": 3, "restrict": 2, "serv": 1, "shown": 1, "statement": 1, "technic": 1, "thing": 1, "unnecessari": 1, "unobvi": 1, "use": 1, "write": 2, "written": 1, "knuth": 1, "merner": 1}}, "322": {"id": "322", "title": "Operational Compatibility of Systems-CONVENTIONS", "abstract": "The General Standards Committee of the SHARE organization has devoted considerable effort to  the problem of operating a computer efficiently in view of the growing number of programming systems  available.  Each of these programming systems has been coded to utilize a fixed set of hardware components  without recognizing the fact that others may be occupying a storage medium required by the first.  These  incompatibilities are currently resolved by manually setting up the computer for each system as required.   The following set of conventions is being considered to minimize computer set-up time.  They are of  sufficiently broad interest that we feel other computer users should be aware of them. -George F. Ryckman,  Chairman", "authors": "Bright, H. S.", "words_pool": ["awar", "broad", "chairman", "code", "committe", "compat", "compon", "comput", "consider", "consid", "convent", "devot", "effici", "effort", "fact", "feel", "fix", "gener", "georg", "grow", "hardwar", "incompat", "interest", "manual", "medium", "minim", "number", "occupi", "oper", "oper", "organ", "problem", "program", "recogn", "requir", "resolv", "ryckman", "set", "set", "share", "standard", "storag", "suffici", "system", "system", "time", "user", "util", "view", "bright"], "word_count": {"awar": 1, "broad": 1, "chairman": 1, "code": 1, "committe": 1, "compat": 1, "compon": 1, "comput": 4, "consider": 1, "consid": 1, "convent": 1, "devot": 1, "effici": 1, "effort": 1, "fact": 1, "feel": 1, "fix": 1, "gener": 1, "georg": 1, "grow": 1, "hardwar": 1, "incompat": 1, "interest": 1, "manual": 1, "medium": 1, "minim": 1, "number": 1, "occupi": 1, "oper": 1, "organ": 1, "problem": 1, "program": 2, "recogn": 1, "requir": 2, "resolv": 1, "ryckman": 1, "set": 4, "share": 1, "standard": 1, "storag": 1, "suffici": 1, "system": 3, "time": 1, "user": 1, "util": 1, "view": 1, "bright": 1}}, "323": {"id": "323", "title": "The State of Digital Computer Technology in Europe", "authors": "Blachman, N. M.", "words_pool": ["comput", "digit", "europ", "state", "technolog", "blachman"], "word_count": {"comput": 1, "digit": 1, "europ": 1, "state": 1, "technolog": 1, "blachman": 1}}, "324": {"id": "324", "title": "Romberg Integration (Algorithm 60)", "authors": "Bauer, F. L.", "words_pool": ["algorithm", "integr", "romberg", "bauer"], "word_count": {"algorithm": 1, "integr": 1, "romberg": 1, "bauer": 1}}, "325": {"id": "325", "title": "Numerical Solution of the Polynomial Equation (Algorithm 30)", "authors": "Alexander, W. J.", "words_pool": ["algorithm", "equat", "numer", "polynomi", "solut", "alexand"], "word_count": {"algorithm": 1, "equat": 1, "numer": 1, "polynomi": 1, "solut": 1, "alexand": 1}}, "326": {"id": "326", "title": "MATHSORT (Algorithm 23)", "authors": "Ranshaw, R. W.", "words_pool": ["algorithm", "mathsort", "ranshaw"], "word_count": {"algorithm": 1, "mathsort": 1, "ranshaw": 1}}, "327": {"id": "327", "title": "Zeros of a Real Polynomial by Resultant Procedure (Algorithm 59)", "authors": "Bareiss, E. H. Fisherkeller, M. A.", "words_pool": ["algorithm", "polynomi", "procedur", "real", "result", "zero", "bareiss", "fisherkel"], "word_count": {"algorithm": 1, "polynomi": 1, "procedur": 1, "real": 1, "result": 1, "zero": 1, "bareiss": 1, "fisherkel": 1}}, "328": {"id": "328", "title": "Matrix Inversion (ALgorithm 58)", "authors": "Cohen, D.", "words_pool": ["algorithm", "invers", "matrix", "cohen"], "word_count": {"algorithm": 1, "invers": 1, "matrix": 1, "cohen": 1}}, "329": {"id": "329", "title": "Automatic Abstracting and Indexing Survey and Recommendations", "abstract": "In preparation for the widespread use of automatic scanners which will read documents and transmit  their contents to other machines for analysis, this report presents a new concept in automatic analysis:  the relative-frequency approach to measuring  the significance of words, word groups, and sentences.   The relative-frequency approach is discussed in detail, as is its application to problems of automatic  indexing and automatic abstracting.  Included in the report is a summary of automatic analysis studies  published as of the date of writing.  Conclusions are that point toward more sophisticated mathematical  and linguistic techniques for the solution of problems of automatic analysis.", "authors": "Edmundson, H. P. Wyllys, R. E.", "words_pool": ["abstract", "analysi", "applic", "approach", "automat", "concept", "conclus", "content", "date", "detail", "discuss", "document", "frequenc", "group", "includ", "index", "linguist", "machin", "mathemat", "measur", "point", "prepar", "present", "problem", "publish", "read", "recommend", "rel", "report", "scanner", "sentenc", "signific", "solut", "sophist", "studi", "summari", "survey", "techniqu", "transmit", "widespread", "word", "word", "write", "edmundson", "wylli"], "word_count": {"abstract": 1, "analysi": 4, "applic": 1, "approach": 2, "automat": 6, "concept": 1, "conclus": 1, "content": 1, "date": 1, "detail": 1, "discuss": 1, "document": 1, "frequenc": 2, "group": 1, "includ": 1, "index": 1, "linguist": 1, "machin": 1, "mathemat": 1, "measur": 1, "point": 1, "prepar": 1, "present": 1, "problem": 2, "publish": 1, "read": 1, "recommend": 1, "rel": 2, "report": 2, "scanner": 1, "sentenc": 1, "signific": 1, "solut": 1, "sophist": 1, "studi": 1, "summari": 1, "survey": 1, "techniqu": 1, "transmit": 1, "widespread": 1, "word": 2, "write": 1, "edmundson": 1, "wylli": 1}}, "330": {"id": "330", "title": "A Method for Evaluating the Area of the Normal Function", "authors": "Baker, F. B.", "words_pool": ["area", "evalu", "function", "method", "normal", "baker"], "word_count": {"area": 1, "evalu": 1, "function": 1, "method": 1, "normal": 1, "baker": 1}}, "331": {"id": "331", "title": "Successive Approximations and Computer Storage Problems in Ordinary Differential Equations", "authors": "Bellman, R.", "words_pool": ["approxim", "comput", "differenti", "equat", "ordinari", "problem", "storag", "success", "bellman"], "word_count": {"approxim": 1, "comput": 1, "differenti": 1, "equat": 1, "ordinari": 1, "problem": 1, "storag": 1, "success": 1, "bellman": 1}}, "332": {"id": "332", "title": "An Indirect Chaining Method for Addressing on Secondary Keys", "abstract": "Methods for entering random access files on the basis of one key are briefly surveyed.  The  widely used chaining method, based on a pseudo-random key transformation, is reviewed in more detail.   An efficient generalization of the chaining method which permits recovery on additional keys is then  presented.", "authors": "Johnson, L. R.", "words_pool": ["access", "addit", "address", "base", "basi", "briefli", "chain", "detail", "effici", "enter", "gener", "indirect", "key", "key", "method", "method", "permit", "present", "pseudo", "random", "recoveri", "review", "secondari", "survey", "transform", "wide", "johnson"], "word_count": {"access": 1, "addit": 1, "address": 1, "base": 1, "basi": 1, "briefli": 1, "chain": 2, "detail": 1, "effici": 1, "enter": 1, "gener": 1, "indirect": 1, "key": 3, "method": 3, "permit": 1, "present": 1, "pseudo": 1, "random": 2, "recoveri": 1, "review": 1, "secondari": 1, "survey": 1, "transform": 1, "wide": 1, "johnson": 1}}, "333": {"id": "333", "title": "Design of an Improved* Transmission/Data Processing Code", "authors": "Bemer, R. W. Smith Jr., H. J. Williams Jr., F. A.", "words_pool": ["code", "data", "design", "improv", "process", "transmiss", "bemer", "smith", "jr", "william", "jr"], "word_count": {"code": 1, "data": 1, "design": 1, "improv": 1, "process": 1, "transmiss": 1, "bemer": 1, "smith": 1, "jr": 1, "william": 1}}, "334": {"id": "334", "title": "Division and Square Root in the Quater-Imaginary Number System", "authors": "Nadler, M.", "words_pool": ["divis", "imaginari", "number", "quater", "root", "squar", "system", "nadler"], "word_count": {"divis": 1, "imaginari": 1, "number": 1, "quater": 1, "root": 1, "squar": 1, "system": 1, "nadler": 1}}, "335": {"id": "335", "title": "Some Numerical Experiments Using Newton's Method for Nonlinear Parabolic and EllipticBoundary-Value  Problems", "abstract": "Using a generalization of Newton's method, a nonlinear parabolic equation of the form U(t)-U(xx)=g(U)  and a nonlinear elliptic equation U(xx)+U(yy)=exp(U) are solved numerically Comparison of these results  with results obtained using the Picard iteration procedure show that in many cases the quisi linearization  method offers substantial advantages in both time and accuracy.", "authors": "Bellman, R. Juncosa, M. L. Kalaba, R.", "words_pool": ["accuraci", "advantag", "case", "comparison", "ellipt", "ellipticboundari", "equat", "exp", "experi", "form", "gener", "iter", "linear", "method", "newton", "nonlinear", "numer", "numer", "obtain", "offer", "parabol", "picard", "problem", "procedur", "quisi", "result", "show", "solv", "substanti", "time", "xx", "yy", "bellman", "juncosa", "kalaba"], "word_count": {"accuraci": 1, "advantag": 1, "case": 1, "comparison": 1, "ellipt": 1, "ellipticboundari": 1, "equat": 2, "exp": 1, "experi": 1, "form": 1, "gener": 1, "iter": 1, "linear": 1, "method": 2, "newton": 1, "nonlinear": 2, "numer": 1, "obtain": 1, "offer": 1, "parabol": 1, "picard": 1, "problem": 1, "procedur": 1, "quisi": 1, "result": 2, "show": 1, "solv": 1, "substanti": 1, "time": 1, "xx": 2, "yy": 1, "bellman": 1, "juncosa": 1, "kalaba": 1}}, "336": {"id": "336", "title": "A Practical Technique for the Determination of the Optimum Relaxation Factor of the Successive  Over-Relaxation Method", "authors": "Kulsrud, H. E.", "words_pool": ["determin", "factor", "method", "optimum", "practic", "relax", "success", "techniqu", "kulsrud"], "word_count": {"determin": 1, "factor": 1, "method": 1, "optimum": 1, "practic": 1, "relax": 2, "success": 1, "techniqu": 1, "kulsrud": 1}}, "337": {"id": "337", "title": "Further Survey of Punched Card Codes", "authors": "Ross, H. M.", "words_pool": ["card", "code", "punch", "survey", "ross"], "word_count": {"card": 1, "code": 1, "punch": 1, "survey": 1, "ross": 1}}, "338": {"id": "338", "title": "GROUT II (Algorithm 43)", "authors": "Thacher Jr., H", "words_pool": ["algorithm", "grout", "ii", "thacher", "jr"], "word_count": {"algorithm": 1, "grout": 1, "ii": 1, "thacher": 1, "jr": 1}}, "339": {"id": "339", "title": "Real Exponential Integral (Algorithm 20)", "authors": "Alexander, W. J. Thacher Jr., H. C.", "words_pool": ["algorithm", "exponenti", "integr", "real", "alexand", "thacher", "jr"], "word_count": {"algorithm": 1, "exponenti": 1, "integr": 1, "real": 1, "alexand": 1, "thacher": 1, "jr": 1}}, "340": {"id": "340", "title": "Legendre Polynomial (Algorithm 13)", "authors": "Herndon, J.", "words_pool": ["algorithm", "legendr", "polynomi", "herndon"], "word_count": {"algorithm": 1, "legendr": 1, "polynomi": 1, "herndon": 1}}, "341": {"id": "341", "title": "Chebyschev Polynomial (Algorithm 10)", "authors": "Herndon, J.", "words_pool": ["algorithm", "chebyschev", "polynomi", "herndon"], "word_count": {"algorithm": 1, "chebyschev": 1, "polynomi": 1, "herndon": 1}}, "342": {"id": "342", "title": "Solution of Polynomial Equation by Barstow-Hitchcock (Algorithm 3)", "authors": "Herndon, J.", "words_pool": ["algorithm", "barstow", "equat", "hitchcock", "polynomi", "solut", "herndon"], "word_count": {"algorithm": 1, "barstow": 1, "equat": 1, "hitchcock": 1, "polynomi": 1, "solut": 1, "herndon": 1}}, "343": {"id": "343", "title": "On Frequently Occurring Errors in ALGOL 60 Programs (Algorithm 25)", "authors": "Herndon, J.", "words_pool": ["algol", "algorithm", "error", "frequent", "occur", "program", "herndon"], "word_count": {"algol": 1, "algorithm": 1, "error": 1, "frequent": 1, "occur": 1, "program": 1, "herndon": 1}}, "344": {"id": "344", "title": "Ber or Bei Function (Algorithm 57)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "bei", "ber", "function", "herndon"], "word_count": {"algorithm": 1, "bei": 1, "ber": 1, "function": 1, "herndon": 1}}, "345": {"id": "345", "title": "Complete Elliptic Integral of the Second Kind (Algorithm 56)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "complet", "ellipt", "integr", "kind", "herndon"], "word_count": {"algorithm": 1, "complet": 1, "ellipt": 1, "integr": 1, "kind": 1, "herndon": 1}}, "346": {"id": "346", "title": "Complete Elliptic Integral of the First Kind (Algorithm 55)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "complet", "ellipt", "integr", "kind", "herndon"], "word_count": {"algorithm": 1, "complet": 1, "ellipt": 1, "integr": 1, "kind": 1, "herndon": 1}}, "347": {"id": "347", "title": "Gamma Function for Range 1 to 2 (Algorithm 54)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "function", "gamma", "rang", "herndon"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "rang": 1, "herndon": 1}}, "348": {"id": "348", "title": "Nth Roots of a Complex Number (Algorithm 53)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "complex", "nth", "number", "root", "herndon"], "word_count": {"algorithm": 1, "complex": 1, "nth": 1, "number": 1, "root": 1, "herndon": 1}}, "349": {"id": "349", "title": "A Set of Test Matrices", "authors": "Herndon, J. R.", "words_pool": ["matric", "set", "test", "herndon"], "word_count": {"matric": 1, "set": 1, "test": 1, "herndon": 1}}, "350": {"id": "350", "title": "Adjust Inverse of a Matrix When an Element is Perturbed (Algorithm 51)", "authors": "Herndon, J. R.", "words_pool": ["adjust", "algorithm", "element", "invers", "matrix", "perturb", "herndon"], "word_count": {"adjust": 1, "algorithm": 1, "element": 1, "invers": 1, "matrix": 1, "perturb": 1, "herndon": 1}}, "351": {"id": "351", "title": "Inverse of a Finite Segment of the Hilbert Matrix (Algorithm 50)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "finit", "hilbert", "invers", "matrix", "segment", "herndon"], "word_count": {"algorithm": 1, "finit": 1, "hilbert": 1, "invers": 1, "matrix": 1, "segment": 1, "herndon": 1}}, "352": {"id": "352", "title": "Spherical Neumant Function (Algorithm 49)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "function", "neumant", "spheric", "herndon"], "word_count": {"algorithm": 1, "function": 1, "neumant": 1, "spheric": 1, "herndon": 1}}, "353": {"id": "353", "title": "Logarithm of A Complex Number (Algorithm 48)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "complex", "logarithm", "number", "herndon"], "word_count": {"algorithm": 1, "complex": 1, "logarithm": 1, "number": 1, "herndon": 1}}, "354": {"id": "354", "title": "Associated Legendre Functions of the First Kind for Real or Imaginary Arguments (Algorithm 47)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "argument", "function", "imaginari", "kind", "legendr", "real", "herndon"], "word_count": {"algorithm": 1, "argument": 1, "function": 1, "imaginari": 1, "kind": 1, "legendr": 1, "real": 1, "herndon": 1}}, "355": {"id": "355", "title": "Exponential of a Complex Number (Algorithm 46)", "authors": "Herndon, J. R.", "words_pool": ["algorithm", "complex", "exponenti", "number", "herndon"], "word_count": {"algorithm": 1, "complex": 1, "exponenti": 1, "number": 1, "herndon": 1}}, "356": {"id": "356", "title": "INTEREST (Algorithm 45)", "authors": "Ingerman, P. Z.", "words_pool": ["algorithm", "interest", "ingerman"], "word_count": {"algorithm": 1, "interest": 1, "ingerman": 1}}, "357": {"id": "357", "title": "Bessel Functions Computed Recursively (Algorithm 44)", "authors": "Wojcicki, M. E.", "words_pool": ["algorithm", "bessel", "comput", "function", "recurs", "wojcicki"], "word_count": {"algorithm": 1, "bessel": 1, "comput": 1, "function": 1, "recurs": 1, "wojcicki": 1}}, "358": {"id": "358", "title": "Crout with Pivoting II (Algorithm 43)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "crout", "ii", "pivot", "thacher", "jr"], "word_count": {"algorithm": 1, "crout": 1, "ii": 1, "pivot": 1, "thacher": 1, "jr": 1}}, "359": {"id": "359", "title": "INVERT (Algorithm 42)", "authors": "Wood, T. C.", "words_pool": ["algorithm", "invert", "wood"], "word_count": {"algorithm": 1, "invert": 1, "wood": 1}}, "360": {"id": "360", "title": "Evaluation of Determinant (Algorithm 41)", "authors": "Solomon, J. G.", "words_pool": ["algorithm", "determin", "evalu", "solomon"], "word_count": {"algorithm": 1, "determin": 1, "evalu": 1, "solomon": 1}}, "361": {"id": "361", "title": "Programmed Error Correction on a Decimal Computer", "authors": "Weinberg, G. M.", "words_pool": ["comput", "correct", "decim", "error", "program", "weinberg"], "word_count": {"comput": 1, "correct": 1, "decim": 1, "error": 1, "program": 1, "weinberg": 1}}, "362": {"id": "362", "title": "Table Look-At Techniques", "authors": "Sherman, P. M.", "words_pool": ["look", "tabl", "techniqu", "sherman"], "word_count": {"look": 1, "tabl": 1, "techniqu": 1, "sherman": 1}}, "363": {"id": "363", "title": "On Approximating Transcendental Numbers by Continued Fractions", "authors": "Karst, E.", "words_pool": ["approxim", "continu", "fraction", "number", "transcendent", "karst"], "word_count": {"approxim": 1, "continu": 1, "fraction": 1, "number": 1, "transcendent": 1, "karst": 1}}, "364": {"id": "364", "title": "On the Compilation of Subscripted Variables", "authors": "Nather, R. E.", "words_pool": ["compil", "subscript", "variabl", "nather"], "word_count": {"compil": 1, "subscript": 1, "variabl": 1, "nather": 1}}, "365": {"id": "365", "title": "Bessel Functions of Integral Order and Complex Argument", "authors": "Gray, M. C.", "words_pool": ["argument", "bessel", "complex", "function", "integr", "order", "gray"], "word_count": {"argument": 1, "bessel": 1, "complex": 1, "function": 1, "integr": 1, "order": 1, "gray": 1}}, "366": {"id": "366", "title": "Eigenvalues of a Symmetric 3 x 3 Matrix", "authors": "Smith, O. K.", "words_pool": ["eigenvalu", "matrix", "symmetr", "smith"], "word_count": {"eigenvalu": 1, "matrix": 1, "symmetr": 1, "smith": 1}}, "367": {"id": "367", "title": "Topological Ordering of a List of Randomly-Numbered Elements of a Network", "abstract": "A network of directed line segments free of circular elements is assumed.  The lines are identified  by their terminal nodes and the nodes are assumed to be numbered by a non-topological system.  Given  a list of these lines in numeric order, a simple technique can be used to create at high speed a list  in topological order.", "authors": "Lasser, D. J.", "words_pool": ["assum", "circular", "creat", "direct", "element", "free", "high", "identifi", "line", "line", "list", "network", "node", "non", "number", "numer", "order", "order", "randomli", "segment", "simpl", "speed", "system", "techniqu", "termin", "topolog", "lasser"], "word_count": {"assum": 2, "circular": 1, "creat": 1, "direct": 1, "element": 1, "free": 1, "high": 1, "identifi": 1, "line": 3, "list": 2, "network": 1, "node": 2, "non": 1, "number": 1, "numer": 1, "order": 2, "randomli": 1, "segment": 1, "simpl": 1, "speed": 1, "system": 1, "techniqu": 1, "termin": 1, "topolog": 2, "lasser": 1}}, "368": {"id": "368", "title": "Real Zeros of an Arbitrary Function (Algorithm 25)", "authors": "Collinge, R. M.", "words_pool": ["algorithm", "arbitrari", "function", "real", "zero", "colling"], "word_count": {"algorithm": 1, "arbitrari": 1, "function": 1, "real": 1, "zero": 1, "colling": 1}}, "369": {"id": "369", "title": "Crout with Pivoting (Algorithm 16)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "crout", "pivot", "thacher", "jr"], "word_count": {"algorithm": 1, "crout": 1, "pivot": 1, "thacher": 1, "jr": 1}}, "370": {"id": "370", "title": "Bisection Routine (Algorithm 4)", "authors": "Rader, P. J.", "words_pool": ["algorithm", "bisect", "routin", "rader"], "word_count": {"algorithm": 1, "bisect": 1, "routin": 1, "rader": 1}}, "371": {"id": "371", "title": "Remarks on Algorithms 2 and 3, Algorithm 15 and Algorithms 25 and 26", "authors": "Wilkinson, J. H.", "words_pool": ["algorithm", "algorithm", "remark", "wilkinson"], "word_count": {"algorithm": 3, "remark": 1, "wilkinson": 1}}, "372": {"id": "372", "title": "Critical Path Scheduling (Algorithm 40)", "authors": "Leavenworth, B.", "words_pool": ["algorithm", "critic", "path", "schedul", "leavenworth"], "word_count": {"algorithm": 1, "critic": 1, "path": 1, "schedul": 1, "leavenworth": 1}}, "373": {"id": "373", "title": "Correlation Coefficients with Matrix Multiplication (Algorithm 39)", "authors": "Sassouni, P.", "words_pool": ["algorithm", "coeffici", "correl", "matrix", "multipl", "sassouni"], "word_count": {"algorithm": 1, "coeffici": 1, "correl": 1, "matrix": 1, "multipl": 1, "sassouni": 1}}, "374": {"id": "374", "title": "Telescope2 (Algorithm 38)", "authors": "Brons, K. A.", "words_pool": ["algorithm", "telescope2", "bron"], "word_count": {"algorithm": 1, "telescope2": 1, "bron": 1}}, "375": {"id": "375", "title": "Telescope1 (Algorithm 37)", "authors": "Brons, K. A.", "words_pool": ["algorithm", "telescope1", "bron"], "word_count": {"algorithm": 1, "telescope1": 1, "bron": 1}}, "376": {"id": "376", "title": "Tchebycheff (Algorithm 36)", "authors": "Gianni, A. J.", "words_pool": ["algorithm", "tchebycheff", "gianni"], "word_count": {"algorithm": 1, "tchebycheff": 1, "gianni": 1}}, "377": {"id": "377", "title": "SIEVE (Algorithm 35)", "authors": "Wood, T. C.", "words_pool": ["algorithm", "siev", "wood"], "word_count": {"algorithm": 1, "siev": 1, "wood": 1}}, "378": {"id": "378", "title": "A Generalized Technique for Symbol Manipulation and Numerical Calculation", "authors": "Ross, D. T.", "words_pool": ["calcul", "gener", "manipul", "numer", "symbol", "techniqu", "ross"], "word_count": {"calcul": 1, "gener": 1, "manipul": 1, "numer": 1, "symbol": 1, "techniqu": 1, "ross": 1}}, "379": {"id": "379", "title": "Bitwise Operations", "authors": "Strachey, C.", "words_pool": ["bitwis", "oper", "strachey"], "word_count": {"bitwis": 1, "oper": 1, "strachey": 1}}, "380": {"id": "380", "title": "Comparison of Iterative Methods for the Calculation of nth Roots", "abstract": "Three iterative methods for calculation of nth roots (including one proposed by the author)  are compared in two ways: (1) Theoretical convergence estimates are given.  (2) A new macrocompiler which  estimates machine running time is used to compare the running time of the three methods for a variety  of input data.", "authors": "Traub, J. F.", "words_pool": ["author", "calcul", "compar", "compar", "comparison", "converg", "data", "estim", "includ", "input", "iter", "machin", "macrocompil", "method", "nth", "propos", "root", "run", "theoret", "time", "varieti", "way", "traub"], "word_count": {"author": 1, "calcul": 1, "compar": 2, "comparison": 1, "converg": 1, "data": 1, "estim": 2, "includ": 1, "input": 1, "iter": 1, "machin": 1, "macrocompil": 1, "method": 2, "nth": 1, "propos": 1, "root": 1, "run": 2, "theoret": 1, "time": 2, "varieti": 1, "way": 1, "traub": 1}}, "381": {"id": "381", "title": "An Alternate Form of the \"UNCOL Diagram\"", "authors": "Bratman, H.", "words_pool": ["altern", "diagram", "form", "uncol", "bratman"], "word_count": {"altern": 1, "diagram": 1, "form": 1, "uncol": 1, "bratman": 1}}, "382": {"id": "382", "title": "Statistical Programs at the University of North Carolina", "authors": "Bush, N.", "words_pool": ["carolina", "north", "program", "statist", "univers", "bush"], "word_count": {"carolina": 1, "north": 1, "program": 1, "statist": 1, "univers": 1, "bush": 1}}, "383": {"id": "383", "title": "On Finding Minimum Routes in a Network With Turn Penalties", "authors": "Caldwell, T.", "words_pool": ["find", "minimum", "network", "penalti", "rout", "turn", "caldwel"], "word_count": {"find": 1, "minimum": 1, "network": 1, "penalti": 1, "rout": 1, "turn": 1, "caldwel": 1}}, "384": {"id": "384", "title": "Gamma Function (Algorithm 34)", "authors": "Lipp, M. F.", "words_pool": ["algorithm", "function", "gamma", "lipp"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "lipp": 1}}, "385": {"id": "385", "title": "FACTORIAL (Algorithm 33)", "authors": "Lipp, M. F.", "words_pool": ["algorithm", "factori", "lipp"], "word_count": {"algorithm": 1, "factori": 1, "lipp": 1}}, "386": {"id": "386", "title": "MULTINT (Algorithm 32)", "authors": "Freeman Jr., R. D.", "words_pool": ["algorithm", "multint", "freeman", "jr"], "word_count": {"algorithm": 1, "multint": 1, "freeman": 1, "jr": 1}}, "387": {"id": "387", "title": "Gamma Function (Algorithm 31)", "authors": "Collinge,R. M.", "words_pool": ["algorithm", "function", "gamma", "colling"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "colling": 1}}, "388": {"id": "388", "title": "Solution of Polynomial Equations by Bairstow Hitchcock Method (Algorithm 3)", "authors": "Vandergraft, J. S.", "words_pool": ["algorithm", "bairstow", "equat", "hitchcock", "method", "polynomi", "solut", "vandergraft"], "word_count": {"algorithm": 1, "bairstow": 1, "equat": 1, "hitchcock": 1, "method": 1, "polynomi": 1, "solut": 1, "vandergraft": 1}}, "389": {"id": "389", "title": "Real Exponential Integral (Algorithm 20)", "authors": "Peavy, S.", "words_pool": ["algorithm", "exponenti", "integr", "real", "peavi"], "word_count": {"algorithm": 1, "exponenti": 1, "integr": 1, "real": 1, "peavi": 1}}, "390": {"id": "390", "title": "Complex Exponential Integral (Algorithm 13)", "authors": "Rader, P. J. Thacher Jr., H. C.", "words_pool": ["algorithm", "complex", "exponenti", "integr", "rader", "thacher", "jr"], "word_count": {"algorithm": 1, "complex": 1, "exponenti": 1, "integr": 1, "rader": 1, "thacher": 1, "jr": 1}}, "391": {"id": "391", "title": "The BKS System for the Philco-2000", "authors": "Smith, R. B.", "words_pool": ["bk", "philco", "system", "smith"], "word_count": {"bk": 1, "philco": 1, "system": 1, "smith": 1}}, "392": {"id": "392", "title": "Comment on A Paper on Parallel Processing", "authors": "Nekora, M. R.", "words_pool": ["comment", "paper", "parallel", "process", "nekora"], "word_count": {"comment": 1, "paper": 1, "parallel": 1, "process": 1, "nekora": 1}}, "393": {"id": "393", "title": "Two Subroutines for Symbol Manipulation with an Algebraic Compiler", "authors": "Carr III, J. W. Hanson, J. W.", "words_pool": ["algebra", "compil", "manipul", "subroutin", "symbol", "carr", "iii", "hanson"], "word_count": {"algebra": 1, "compil": 1, "manipul": 1, "subroutin": 1, "symbol": 1, "carr": 1, "iii": 1, "hanson": 1}}, "394": {"id": "394", "title": "Multiple Programming Data Processing", "authors": "Ryle, B. L.", "words_pool": ["data", "multipl", "process", "program", "ryle"], "word_count": {"data": 1, "multipl": 1, "process": 1, "program": 1, "ryle": 1}}, "395": {"id": "395", "title": "Multiple-Precision Division", "authors": "Rabinowitz, P.", "words_pool": ["divis", "multipl", "precis", "rabinowitz"], "word_count": {"divis": 1, "multipl": 1, "precis": 1, "rabinowitz": 1}}, "396": {"id": "396", "title": "Automation of Program  Debugging", "abstract": "Automatic Debugging can substantially reduce lead-time between the coding and the effective use of a complex program. It also enforces analysis of debugging criteria, resulting in verifiably accurate programs. The programmer specifies the program to be debugged, memory areas, set of input data, maximum repetition of loops, and checkpoint information for each set of data. The executive debugging program the runs the program to be debugged, performing checking functions and creating a trace record of its own later analysis and location of errors. Applications are quite flexible, and the system can be used alone or in conjunction with other debugging techniques.", "authors": "Jacoby, K. Layton, H.", "words_pool": ["accur", "analysi", "applic", "area", "automat", "autom", "check", "checkpoint", "code", "complex", "conjunct", "creat", "criteria", "data", "debug", "debug", "effect", "enforc", "error", "execut", "flexibl", "function", "inform", "input", "later", "lead", "locat", "loop", "maximum", "memori", "perform", "program", "programm", "program", "record", "reduc", "repetit", "result", "run", "set", "specifi", "substanti", "system", "techniqu", "time", "trace", "verifi", "jacobi", "layton"], "word_count": {"accur": 1, "analysi": 2, "applic": 1, "area": 1, "automat": 1, "autom": 1, "check": 1, "checkpoint": 1, "code": 1, "complex": 1, "conjunct": 1, "creat": 1, "criteria": 1, "data": 2, "debug": 6, "effect": 1, "enforc": 1, "error": 1, "execut": 1, "flexibl": 1, "function": 1, "inform": 1, "input": 1, "later": 1, "lead": 1, "locat": 1, "loop": 1, "maximum": 1, "memori": 1, "perform": 1, "program": 5, "programm": 1, "record": 1, "reduc": 1, "repetit": 1, "result": 1, "run": 1, "set": 2, "specifi": 1, "substanti": 1, "system": 1, "techniqu": 1, "time": 1, "trace": 1, "verifi": 1, "jacobi": 1, "layton": 1}}, "397": {"id": "397", "title": "A Card Format for Reference Files in Information Processing", "abstract": "This paper proposes a card format suitable for a variety of reference files in information  processing.  An 80-column IBM card is divided into two fields-reference material field (columns 1-67)  and identification field (columns 68-80).  The format for the reference material is flexible, while the  format for the identification is rigid.  The reference material includes basically an index, title, source,  class, summary and cross reference for each entry.  The identification includes basically codes for a  matrix of descriptors, an entry number, and the kind, major interest, and source of the reference.  The  identification also provides a choice to identify material for personal as well as general files.  Since  this card format is sufficient to identify the material normally associated with reference files for  books, articles, programming terms, hardware terms, equipment, machine systems, abbreviations, etc., it  is suitable as a standard for card reference files in information processing.", "authors": "Grems, M.", "words_pool": ["abbrevi", "articl", "basic", "book", "card", "choic", "class", "code", "column", "column", "cross", "descriptor", "divid", "entri", "equip", "field", "field", "flexibl", "format", "gener", "hardwar", "ibm", "identif", "identifi", "includ", "index", "inform", "interest", "kind", "machin", "major", "materi", "matrix", "number", "paper", "person", "process", "program", "propos", "refer", "rigid", "sourc", "standard", "suffici", "suitabl", "summari", "system", "term", "titl", "varieti", "grem"], "word_count": {"abbrevi": 1, "articl": 1, "basic": 2, "book": 1, "card": 4, "choic": 1, "class": 1, "code": 1, "column": 3, "cross": 1, "descriptor": 1, "divid": 1, "entri": 2, "equip": 1, "field": 3, "flexibl": 1, "format": 4, "gener": 1, "hardwar": 1, "ibm": 1, "identif": 4, "identifi": 2, "includ": 2, "index": 1, "inform": 2, "interest": 1, "kind": 1, "machin": 1, "major": 1, "materi": 5, "matrix": 1, "number": 1, "paper": 1, "person": 1, "process": 2, "program": 1, "propos": 1, "refer": 8, "rigid": 1, "sourc": 2, "standard": 1, "suffici": 1, "suitabl": 2, "summari": 1, "system": 1, "term": 2, "titl": 1, "varieti": 1, "grem": 1}}, "398": {"id": "398", "title": "The SLANG System", "authors": "Sibley, R. A.", "words_pool": ["slang", "system", "sibley"], "word_count": {"slang": 1, "system": 1, "sibley": 1}}, "399": {"id": "399", "title": "Compiling Techniques for Boolean Expressions and Conditional Statements in ALGOL 60", "authors": "Huskey, H. D. Wattenburg, W. H.", "words_pool": ["algol", "boolean", "compil", "condit", "express", "statement", "techniqu", "huskey", "wattenburg"], "word_count": {"algol": 1, "boolean": 1, "compil": 1, "condit": 1, "express": 1, "statement": 1, "techniqu": 1, "huskey": 1, "wattenburg": 1}}, "400": {"id": "400", "title": "Comments on the Implementation of Recursive Procedures and Blocks in ALGOL 60", "authors": "Irons, E. T. Feurzeig, W.", "words_pool": ["algol", "block", "comment", "implement", "procedur", "recurs", "iron", "feurzeig"], "word_count": {"algol": 1, "block": 1, "comment": 1, "implement": 1, "procedur": 1, "recurs": 1, "iron": 1, "feurzeig": 1}}, "401": {"id": "401", "title": "Allocation of Storage for Arrays in ALGOL 60", "authors": "Sattley, K.", "words_pool": ["algol", "alloc", "array", "storag", "sattley"], "word_count": {"algol": 1, "alloc": 1, "array": 1, "storag": 1, "sattley": 1}}, "402": {"id": "402", "title": "Dynamic Declarations", "authors": "Ingerman, P. Z.", "words_pool": ["declar", "dynam", "ingerman"], "word_count": {"declar": 1, "dynam": 1, "ingerman": 1}}, "403": {"id": "403", "title": "Thunks -- A Way of Compiling Procedure Statements with Some Comments on Procedure Declarations", "authors": "Ingerman, P. Z.", "words_pool": ["comment", "compil", "declar", "procedur", "statement", "thunk", "ingerman"], "word_count": {"comment": 1, "compil": 1, "declar": 1, "procedur": 2, "statement": 1, "thunk": 1, "ingerman": 1}}, "404": {"id": "404", "title": "A Syntax Directed Compiler for ALGOL 60", "authors": "Irons, E. T.", "words_pool": ["algol", "compil", "direct", "syntax", "iron"], "word_count": {"algol": 1, "compil": 1, "direct": 1, "syntax": 1, "iron": 1}}, "405": {"id": "405", "title": "An Algorithm for Coding Efficient Arithmetic Operations", "abstract": "Most existing formula translation schemes yield inefficient coding.  A method is described  which reduces the number of store and fetch operations, evaluates constant subexpressions during compilation,  and recognizes many equivalent subexpressions.", "authors": "Floyd, R. W.", "words_pool": ["algorithm", "arithmet", "code", "compil", "constant", "effici", "equival", "evalu", "exist", "fetch", "formula", "ineffici", "method", "number", "oper", "recogn", "reduc", "scheme", "store", "subexpress", "translat", "yield", "floyd"], "word_count": {"algorithm": 1, "arithmet": 1, "code": 1, "compil": 1, "constant": 1, "effici": 1, "equival": 1, "evalu": 1, "exist": 1, "fetch": 1, "formula": 1, "ineffici": 1, "method": 1, "number": 1, "oper": 1, "recogn": 1, "reduc": 1, "scheme": 1, "store": 1, "subexpress": 2, "translat": 1, "yield": 1, "floyd": 1}}, "406": {"id": "406", "title": "The Use of Threaded Lists in Constructing a Combined ALGOL and Machine-Like Assembly Processor", "authors": "Evans Jr., A. Perlis, A. J. Van Zoeren, H.", "words_pool": ["algol", "assembl", "combin", "construct", "list", "machin", "processor", "thread", "evan", "jr", "perli", "van", "zoeren"], "word_count": {"algol": 1, "assembl": 1, "combin": 1, "construct": 1, "list": 1, "machin": 1, "processor": 1, "thread": 1, "evan": 1, "jr": 1, "perli": 1, "van": 1, "zoeren": 1}}, "407": {"id": "407", "title": "MADCAP: A Scientific Compiler for a Displayed Formula Textbook Language", "authors": "Wells, M. B.", "words_pool": ["compil", "display", "formula", "languag", "madcap", "scientif", "textbook", "well"], "word_count": {"compil": 1, "display": 1, "formula": 1, "languag": 1, "madcap": 1, "scientif": 1, "textbook": 1, "well": 1}}, "408": {"id": "408", "title": "The Internal Organization of the MAD Translator", "authors": "Arden, B. W. Galler, B. A. Graham, R. M.", "words_pool": ["intern", "mad", "organ", "translat", "arden", "galler", "graham"], "word_count": {"intern": 1, "mad": 1, "organ": 1, "translat": 1, "arden": 1, "galler": 1, "graham": 1}}, "409": {"id": "409", "title": "CL-1, An Environment for a Compiler", "abstract": "A flexible, large-scale programming system to facilitate the solution of information processing  problems and to provide intercommunication between programs and/or programmers has been developed and  realized on the IBM 709/7090 computer.  The system is based on a master file concept and has provisions  for accepting, storing, and retrieving both descriptions and instances of large and complex data sets,  as well as algorithms defined on these data sets.  Both data and algorithms may be expressed in a family  of command and descriptive languages.  The concept of distinct data descriptions and the content and  use of such descriptions are discussed in some detail.", "authors": "Cheatham Jr., T. E. Collins Jr., G. O. Leonard, G. F.", "words_pool": ["accept", "algorithm", "base", "cl", "command", "compil", "complex", "comput", "concept", "content", "data", "defin", "descript", "descript", "detail", "develop", "discuss", "distinct", "environ", "express", "facilit", "famili", "flexibl", "ibm", "inform", "instanc", "intercommun", "languag", "larg", "master", "problem", "process", "programm", "program", "program", "provid", "provis", "realiz", "retriev", "scale", "set", "solut", "store", "system", "cheatham", "jr", "collin", "jr", "leonard"], "word_count": {"accept": 1, "algorithm": 2, "base": 1, "cl": 1, "command": 1, "compil": 1, "complex": 1, "comput": 1, "concept": 2, "content": 1, "data": 4, "defin": 1, "descript": 4, "detail": 1, "develop": 1, "discuss": 1, "distinct": 1, "environ": 1, "express": 1, "facilit": 1, "famili": 1, "flexibl": 1, "ibm": 1, "inform": 1, "instanc": 1, "intercommun": 1, "languag": 1, "larg": 2, "master": 1, "problem": 1, "process": 1, "programm": 1, "program": 2, "provid": 1, "provis": 1, "realiz": 1, "retriev": 1, "scale": 1, "set": 2, "solut": 1, "store": 1, "system": 2, "cheatham": 1, "jr": 1, "collin": 1, "leonard": 1}}, "410": {"id": "410", "title": "The CLIP Translator", "authors": "Englund, D. Clark, E.", "words_pool": ["clip", "translat", "englund", "clark"], "word_count": {"clip": 1, "translat": 1, "englund": 1, "clark": 1}}, "411": {"id": "411", "title": "Use of Magnetic Tape for Data Storage in the ORACLE-ALGOL Translator", "authors": "Bottenbruch, H.", "words_pool": ["algol", "data", "magnet", "oracl", "storag", "tape", "translat", "bottenbruch"], "word_count": {"algol": 1, "data": 1, "magnet": 1, "oracl": 1, "storag": 1, "tape": 1, "translat": 1, "bottenbruch": 1}}, "412": {"id": "412", "title": "Recursive Processes and ALGOL Translation", "authors": "Gray, A. A.", "words_pool": ["algol", "process", "recurs", "translat", "gray"], "word_count": {"algol": 1, "process": 1, "recurs": 1, "translat": 1, "gray": 1}}, "413": {"id": "413", "title": "A Basic Compiler for Arithmetic Expressions", "authors": "Huskey, H. D. Wattenburg, W. H.", "words_pool": ["arithmet", "basic", "compil", "express", "huskey", "wattenburg"], "word_count": {"arithmet": 1, "basic": 1, "compil": 1, "express": 1, "huskey": 1, "wattenburg": 1}}, "414": {"id": "414", "title": "IBM 1440 Data Processing System Features Five New Units", "abstract": "The IBM 1440 data processing system, announced recently by the International Business Machines  Corporation, not only features the 1311 disk storage drive with interchangeable disk packs but four other  newly developed units.", "authors": "Wheeling, R.", "words_pool": ["announc", "busi", "corpor", "data", "develop", "disk", "drive", "featur", "ibm", "interchang", "intern", "machin", "newli", "pack", "process", "recent", "storag", "system", "unit", "wheel"], "word_count": {"announc": 1, "busi": 1, "corpor": 1, "data": 1, "develop": 1, "disk": 2, "drive": 1, "featur": 1, "ibm": 1, "interchang": 1, "intern": 1, "machin": 1, "newli": 1, "pack": 1, "process": 1, "recent": 1, "storag": 1, "system": 1, "unit": 1, "wheel": 1}}, "415": {"id": "415", "title": "The Use of Digital Computers in Western Germany", "authors": "Schuff, H. K.", "words_pool": ["comput", "digit", "germani", "western", "schuff"], "word_count": {"comput": 1, "digit": 1, "germani": 1, "western": 1, "schuff": 1}}, "416": {"id": "416", "title": "Multiple Shooting Method for Two-Point Boundary Value Problems", "authors": "Morrison, D. D. Riley, J. D. Zancanaro, J. F.", "words_pool": ["boundari", "method", "multipl", "point", "problem", "shoot", "morrison", "riley", "zancanaro"], "word_count": {"boundari": 1, "method": 1, "multipl": 1, "point": 1, "problem": 1, "shoot": 1, "morrison": 1, "riley": 1, "zancanaro": 1}}, "417": {"id": "417", "title": "Legal Implications of Computer Use", "abstract": "This paper points out a variety of ways computer systems used in business and industry can  be involved in legal entanglements and suggests that computer specialists have a responsibility to call  for assistance in forestalling or minimizing those entanglements during the planning stage.  Techniques  are suggested for making legal clearance effective with the least burden on the new technology and for  achieving a favorable legal climate for it generally.  Computer specialists also are alerted to potential  opportunities to interpret to lawyers the technical aspects of computer systems involved in legal situations.", "authors": "Freed, R. N.", "words_pool": ["achiev", "alert", "aspect", "assist", "burden", "busi", "call", "clearanc", "climat", "comput", "effect", "entangl", "favor", "forestal", "gener", "implic", "industri", "interpret", "involv", "lawyer", "legal", "make", "minim", "opportun", "paper", "plan", "point", "potenti", "respons", "situat", "specialist", "stage", "suggest", "suggest", "system", "technic", "techniqu", "technolog", "varieti", "way", "freed"], "word_count": {"achiev": 1, "alert": 1, "aspect": 1, "assist": 1, "burden": 1, "busi": 1, "call": 1, "clearanc": 1, "climat": 1, "comput": 4, "effect": 1, "entangl": 2, "favor": 1, "forestal": 1, "gener": 1, "implic": 1, "industri": 1, "interpret": 1, "involv": 2, "lawyer": 1, "legal": 4, "make": 1, "minim": 1, "opportun": 1, "paper": 1, "plan": 1, "point": 1, "potenti": 1, "respons": 1, "situat": 1, "specialist": 2, "stage": 1, "suggest": 2, "system": 2, "technic": 1, "techniqu": 1, "technolog": 1, "varieti": 1, "way": 1, "freed": 1}}, "418": {"id": "418", "title": "RANDOM (Algorithm 133)", "authors": "Behrenz, P. G.", "words_pool": ["algorithm", "random", "behrenz"], "word_count": {"algorithm": 1, "random": 1, "behrenz": 1}}, "419": {"id": "419", "title": "Magic Square (Algorithm 118)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "magic", "squar", "thacher", "jr"], "word_count": {"algorithm": 1, "magic": 1, "squar": 1, "thacher": 1, "jr": 1}}, "420": {"id": "420", "title": "PERM (Algorithm 115)", "authors": "Phillips, E. S.", "words_pool": ["algorithm", "perm", "phillip"], "word_count": {"algorithm": 1, "perm": 1, "phillip": 1}}, "421": {"id": "421", "title": "Position of Point Relative to Polygon (Algorithm 112)", "authors": "Hacker, R.", "words_pool": ["algorithm", "point", "polygon", "posit", "rel", "hacker"], "word_count": {"algorithm": 1, "point": 1, "polygon": 1, "posit": 1, "rel": 1, "hacker": 1}}, "422": {"id": "422", "title": "COMBINATION (Algorithm 94)", "authors": "Grench, R. E.", "words_pool": ["algorithm", "combin", "grench"], "word_count": {"algorithm": 1, "combin": 1, "grench": 1}}, "423": {"id": "423", "title": "Matrix Inversion (Algorithm 58)", "authors": "Behrenz, P. G.", "words_pool": ["algorithm", "invers", "matrix", "behrenz"], "word_count": {"algorithm": 1, "invers": 1, "matrix": 1, "behrenz": 1}}, "424": {"id": "424", "title": "Gamma Function (Algorithm 31)", "authors": "Behrenz, P. G.", "words_pool": ["algorithm", "function", "gamma", "behrenz"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "behrenz": 1}}, "425": {"id": "425", "title": "Complete Elliptic Integral (Algorithm 149)", "authors": "Merner, J. N.", "words_pool": ["algorithm", "complet", "ellipt", "integr", "merner"], "word_count": {"algorithm": 1, "complet": 1, "ellipt": 1, "integr": 1, "merner": 1}}, "426": {"id": "426", "title": "Term of Magic Square (Algorithm 148)", "authors": "Collison, D. M.", "words_pool": ["algorithm", "magic", "squar", "term", "collison"], "word_count": {"algorithm": 1, "magic": 1, "squar": 1, "term": 1, "collison": 1}}, "427": {"id": "427", "title": "PSIF (Algorithm 147)", "authors": "Amit, D.", "words_pool": ["algorithm", "psif", "amit"], "word_count": {"algorithm": 1, "psif": 1, "amit": 1}}, "428": {"id": "428", "title": "Multiple Integration (Algorithm 146)", "authors": "McKeeman, W. M.", "words_pool": ["algorithm", "integr", "multipl", "mckeeman"], "word_count": {"algorithm": 1, "integr": 1, "multipl": 1, "mckeeman": 1}}, "429": {"id": "429", "title": "Adaptive Nimerical Integration by Simpson's Rule (Algorithm 145)", "authors": "McKeeman, W. M.", "words_pool": ["adapt", "algorithm", "integr", "nimer", "rule", "simpson", "mckeeman"], "word_count": {"adapt": 1, "algorithm": 1, "integr": 1, "nimer": 1, "rule": 1, "simpson": 1, "mckeeman": 1}}, "430": {"id": "430", "title": "TREESORT2 (Algorithm 144)", "authors": "Kaupe Jr.,A. F.", "words_pool": ["algorithm", "treesort2", "kaup", "jr"], "word_count": {"algorithm": 1, "treesort2": 1, "kaup": 1, "jr": 1}}, "431": {"id": "431", "title": "TREESORT1 (Algorithm 143)", "authors": "Kaupe Jr., A. F.", "words_pool": ["algorithm", "treesort1", "kaup", "jr"], "word_count": {"algorithm": 1, "treesort1": 1, "kaup": 1, "jr": 1}}, "432": {"id": "432", "title": "Triangular Regression (Algorithm 142)", "authors": "Hafley, W. L. Lewis, J. S.", "words_pool": ["algorithm", "regress", "triangular", "hafley", "lewi"], "word_count": {"algorithm": 1, "regress": 1, "triangular": 1, "hafley": 1, "lewi": 1}}, "433": {"id": "433", "title": "Fixed-World-Length Arrays in Variable-Word-Length Computers", "authors": "Sonquist, J. A.", "words_pool": ["array", "comput", "fix", "length", "variabl", "word", "world", "sonquist"], "word_count": {"array": 1, "comput": 1, "fix": 1, "length": 2, "variabl": 1, "word": 1, "world": 1, "sonquist": 1}}, "434": {"id": "434", "title": "Character Manipulation in 1620 Fortran II", "authors": "Poore Jr., J. H.", "words_pool": ["charact", "fortran", "ii", "manipul", "poor", "jr"], "word_count": {"charact": 1, "fortran": 1, "ii": 1, "manipul": 1, "poor": 1, "jr": 1}}, "435": {"id": "435", "title": "A Decision Matrix as the Basis for a Simple Data Input Routine", "abstract": "Currently a great deal of time and effort is being spent on the development of bigger and better  compiler languages, multiprogram executive systems, etc.  Since the implementation of  of new methods  and procedures is not instantaneous, but rather occurs by an evolutionary process, we should be concerned  also with the problem of maintaining, improving and incorporating new ideas into existing systems.  It  is with this somewhat neglected area that the author is interested.  A method employing a decision matrix  is presented for the handling of a standard systems programming problem,that of providing a data input  routine.", "authors": "Vasilakos, G. J.", "words_pool": ["area", "author", "basi", "bigger", "compil", "concern", "data", "deal", "decis", "develop", "effort", "employ", "evolutionari", "execut", "exist", "great", "handl", "idea", "implement", "improv", "incorpor", "input", "instantan", "interest", "languag", "maintain", "matrix", "method", "method", "multiprogram", "neglect", "occur", "present", "problem", "procedur", "process", "program", "provid", "routin", "simpl", "spent", "standard", "system", "time", "vasilako"], "word_count": {"area": 1, "author": 1, "basi": 1, "bigger": 1, "compil": 1, "concern": 1, "data": 1, "deal": 1, "decis": 1, "develop": 1, "effort": 1, "employ": 1, "evolutionari": 1, "execut": 1, "exist": 1, "great": 1, "handl": 1, "idea": 1, "implement": 1, "improv": 1, "incorpor": 1, "input": 1, "instantan": 1, "interest": 1, "languag": 1, "maintain": 1, "matrix": 1, "method": 2, "multiprogram": 1, "neglect": 1, "occur": 1, "present": 1, "problem": 2, "procedur": 1, "process": 1, "program": 1, "provid": 1, "routin": 1, "simpl": 1, "spent": 1, "standard": 1, "system": 3, "time": 1, "vasilako": 1}}, "436": {"id": "436", "title": "Evaluation of Polynomials by Computer", "authors": "Knuth, D. E.", "words_pool": ["comput", "evalu", "polynomi", "knuth"], "word_count": {"comput": 1, "evalu": 1, "polynomi": 1, "knuth": 1}}, "437": {"id": "437", "title": "Compiling Matrix Operations", "authors": "Galler, B. A. Perlis, A. J.", "words_pool": ["compil", "matrix", "oper", "galler", "perli"], "word_count": {"compil": 1, "matrix": 1, "oper": 1, "galler": 1, "perli": 1}}, "438": {"id": "438", "title": "Mechanical Pragmatics: A Time-Motion Study of a Miniature Mechanical Linguistic System", "authors": "Gorn, S.", "words_pool": ["linguist", "mechan", "miniatur", "motion", "pragmat", "studi", "system", "time", "gorn"], "word_count": {"linguist": 1, "mechan": 2, "miniatur": 1, "motion": 1, "pragmat": 1, "studi": 1, "system": 1, "time": 1, "gorn": 1}}, "439": {"id": "439", "title": "On-Line Digital Computer for Measurement of a Neurological Control System", "authors": "Stark, L. Payne, R. Okabe, Y.", "words_pool": ["comput", "control", "digit", "line", "measur", "neurolog", "system", "stark", "payn", "okab"], "word_count": {"comput": 1, "control": 1, "digit": 1, "line": 1, "measur": 1, "neurolog": 1, "system": 1, "stark": 1, "payn": 1, "okab": 1}}, "440": {"id": "440", "title": "Record Linkage", "abstract": "Special difficulties are encountered in devising reliable systems for searching and updating  any large files of documents that must be identified primarily on the basis of names and other personal  particulars.  The underlying problem is that of making nearly maximum use of items of identifying information  that are individually unreliable but that may collectively be of considerable discriminating power.   Rules that can be applied generally to name retrieval systems have been developed in a methodological  study of the linkage of vital and health records into family groupings for demographic research purposes.   These rules are described, and the ways in which information utilization for matching may be optimized  are discussed.", "authors": "Newcombe, H. B. Kennedy, J. M.", "words_pool": ["appli", "basi", "collect", "consider", "demograph", "develop", "devis", "difficulti", "discrimin", "discuss", "document", "encount", "famili", "gener", "group", "health", "identifi", "identifi", "individu", "inform", "item", "larg", "linkag", "make", "match", "maximum", "methodolog", "name", "nearli", "optim", "particular", "person", "power", "primarili", "problem", "purpos", "record", "record", "reliabl", "research", "retriev", "rule", "search", "special", "studi", "system", "underli", "unreli", "updat", "util", "vital", "way", "newcomb", "kennedi"], "word_count": {"appli": 1, "basi": 1, "collect": 1, "consider": 1, "demograph": 1, "develop": 1, "devis": 1, "difficulti": 1, "discrimin": 1, "discuss": 1, "document": 1, "encount": 1, "famili": 1, "gener": 1, "group": 1, "health": 1, "identifi": 2, "individu": 1, "inform": 2, "item": 1, "larg": 1, "linkag": 1, "make": 1, "match": 1, "maximum": 1, "methodolog": 1, "name": 1, "nearli": 1, "optim": 1, "particular": 1, "person": 1, "power": 1, "primarili": 1, "problem": 1, "purpos": 1, "record": 1, "reliabl": 1, "research": 1, "retriev": 1, "rule": 2, "search": 1, "special": 1, "studi": 1, "system": 2, "underli": 1, "unreli": 1, "updat": 1, "util": 1, "vital": 1, "way": 1, "newcomb": 1, "kennedi": 1}}, "441": {"id": "441", "title": "Topological Sorting of Large Networks", "abstract": "Topological Sorting is a procedure required for many problems involving analysis of networks.   An example of one such problem is PERT.  The present paper presents a very general method for obtaining  topological order.  It permits treatment of larger networks than can be handled on present procedures  and achieves this with greater efficiency.  Although the procedure can be adapted to any machine, it  is discussed in terms of the 7090.  A PERT network of 30,000 activities can be ordered in less than one  hour of machine time.  The method was developed as a byproduct of procedures needed by Westinghouse,  Baltimore.  It has not been programmed and at present there are no plans to implement it.  In regard  to the techniques described, Westinghouse's present and anticipated needs are completely served by the  Lockheed program, which is in current use.", "authors": "Kahn, A. B.", "words_pool": ["achiev", "activ", "adapt", "analysi", "anticip", "baltimor", "byproduct", "complet", "develop", "discuss", "effici", "gener", "greater", "handl", "hour", "implement", "involv", "larg", "larger", "lockhe", "machin", "method", "need", "need", "network", "network", "obtain", "order", "order", "paper", "permit", "pert", "plan", "present", "present", "problem", "problem", "procedur", "procedur", "program", "program", "regard", "requir", "serv", "sort", "techniqu", "term", "time", "topolog", "treatment", "westinghous", "kahn"], "word_count": {"achiev": 1, "activ": 1, "adapt": 1, "analysi": 1, "anticip": 1, "baltimor": 1, "byproduct": 1, "complet": 1, "develop": 1, "discuss": 1, "effici": 1, "gener": 1, "greater": 1, "handl": 1, "hour": 1, "implement": 1, "involv": 1, "larg": 1, "larger": 1, "lockhe": 1, "machin": 2, "method": 2, "need": 2, "network": 3, "obtain": 1, "order": 2, "paper": 1, "permit": 1, "pert": 2, "plan": 1, "present": 5, "problem": 2, "procedur": 4, "program": 2, "regard": 1, "requir": 1, "serv": 1, "sort": 1, "techniqu": 1, "term": 1, "time": 1, "topolog": 2, "treatment": 1, "westinghous": 2, "kahn": 1}}, "442": {"id": "442", "title": "Crout with Equilibration and Iteration (Algorithm 135)", "authors": "McKeeman, W. M.", "words_pool": ["algorithm", "crout", "equilibr", "iter", "mckeeman"], "word_count": {"algorithm": 1, "crout": 1, "equilibr": 1, "iter": 1, "mckeeman": 1}}, "443": {"id": "443", "title": "Complex Number to a Real Power (Algorithm 106)", "authors": "Erwin Jr.,G. W.", "words_pool": ["algorithm", "complex", "number", "power", "real", "erwin", "jr"], "word_count": {"algorithm": 1, "complex": 1, "number": 1, "power": 1, "real": 1, "erwin": 1, "jr": 1}}, "444": {"id": "444", "title": "Evaluation of Jacobi Symbol (Algorithm 99)", "authors": "May, R. W.", "words_pool": ["algorithm", "evalu", "jacobi", "symbol"], "word_count": {"algorithm": 1, "evalu": 1, "jacobi": 1, "symbol": 1}}, "445": {"id": "445", "title": "COMBINATION (Algorithm 94)", "authors": "May, R. W.", "words_pool": ["algorithm", "combin"], "word_count": {"algorithm": 1, "combin": 1}}, "446": {"id": "446", "title": "Simpson's Integration (Algorithm 84)", "authors": "Behrenz, P. G.", "words_pool": ["algorithm", "integr", "simpson", "behrenz"], "word_count": {"algorithm": 1, "integr": 1, "simpson": 1, "behrenz": 1}}, "447": {"id": "447", "title": "Certification of the Calculation of Easter", "authors": "Williams, M. R.", "words_pool": ["calcul", "certif", "easter", "william"], "word_count": {"calcul": 1, "certif": 1, "easter": 1, "william": 1}}, "448": {"id": "448", "title": "Path Matrix (Algorithm 141)", "authors": "Ingerman, P. Z.", "words_pool": ["algorithm", "matrix", "path", "ingerman"], "word_count": {"algorithm": 1, "matrix": 1, "path": 1, "ingerman": 1}}, "449": {"id": "449", "title": "Matrix Inversion(Algorithm 140)", "authors": "Ingerman, P. Z.", "words_pool": ["algorithm", "invers", "matrix", "ingerman"], "word_count": {"algorithm": 1, "invers": 1, "matrix": 1, "ingerman": 1}}, "450": {"id": "450", "title": "Solution of the Diophantine Equation (Algorithm 139)", "authors": "Peck, J. E. L.", "words_pool": ["algorithm", "diophantin", "equat", "solut", "peck"], "word_count": {"algorithm": 1, "diophantin": 1, "equat": 1, "solut": 1, "peck": 1}}, "451": {"id": "451", "title": "Nesting of for Statement II (Algorithm 138)", "authors": "Dahm, D. M. Wells, M.", "words_pool": ["algorithm", "ii", "nest", "statement", "dahm", "well"], "word_count": {"algorithm": 1, "ii": 1, "nest": 1, "statement": 1, "dahm": 1, "well": 1}}, "452": {"id": "452", "title": "Nesting of for Statement I (Algorithm 137)", "authors": "Dahm, D. M. Wells, M.", "words_pool": ["algorithm", "nest", "statement", "dahm", "well"], "word_count": {"algorithm": 1, "nest": 1, "statement": 1, "dahm": 1, "well": 1}}, "453": {"id": "453", "title": "Enlargement of a Group (Algorithm 136)", "authors": "Wells, M.", "words_pool": ["algorithm", "enlarg", "group", "well"], "word_count": {"algorithm": 1, "enlarg": 1, "group": 1, "well": 1}}, "454": {"id": "454", "title": "Crout with Equilibration and Iteration (Algorithm 135)", "authors": "McKeeman, W. M.", "words_pool": ["algorithm", "crout", "equilibr", "iter", "mckeeman"], "word_count": {"algorithm": 1, "crout": 1, "equilibr": 1, "iter": 1, "mckeeman": 1}}, "455": {"id": "455", "title": "Exponentiation of Series (Algorithm 134)", "authors": "Fettis, H. E.", "words_pool": ["algorithm", "exponenti", "seri", "fetti"], "word_count": {"algorithm": 1, "exponenti": 1, "seri": 1, "fetti": 1}}, "456": {"id": "456", "title": "RANDOM (Algorithm 133)", "authors": "Behrenz, P. G.", "words_pool": ["algorithm", "random", "behrenz"], "word_count": {"algorithm": 1, "random": 1, "behrenz": 1}}, "457": {"id": "457", "title": "Quantum Mechanical Integrals Over all Slater-Type Integrals", "authors": "Browne, J. C.", "words_pool": ["integr", "mechan", "quantum", "slater", "type", "brown"], "word_count": {"integr": 2, "mechan": 1, "quantum": 1, "slater": 1, "type": 1, "brown": 1}}, "458": {"id": "458", "title": "Coefficient Determination (Algorithm 131)", "authors": "Smith, V. H. Allen, M. L.", "words_pool": ["algorithm", "coeffici", "determin", "smith", "allen"], "word_count": {"algorithm": 1, "coeffici": 1, "determin": 1, "smith": 1, "allen": 1}}, "459": {"id": "459", "title": "PERMUTE (Algorithm 130)", "authors": "Eaves, Lt. B. C.", "words_pool": ["algorithm", "permut", "eav", "lt"], "word_count": {"algorithm": 1, "permut": 1, "eav": 1, "lt": 1}}, "460": {"id": "460", "title": "MINIFUN (Algorithm 129)", "authors": "Whitley, V. W.", "words_pool": ["algorithm", "minifun", "whitley"], "word_count": {"algorithm": 1, "minifun": 1, "whitley": 1}}, "461": {"id": "461", "title": "Coding of Medical Case History Data for Computer Analysis", "authors": "Lipkin, M. Woodbury, M. A.", "words_pool": ["analysi", "case", "code", "comput", "data", "histori", "medic", "lipkin", "woodburi"], "word_count": {"analysi": 1, "case": 1, "code": 1, "comput": 1, "data": 1, "histori": 1, "medic": 1, "lipkin": 1, "woodburi": 1}}, "462": {"id": "462", "title": "Computer Pattern Recognition Techniques: Electrocardiographic Diagnosis", "abstract": "The use of programmed digital computers as general pattern classification and recognition devices  is one phase of the current lively interest in artificial intelligence.  It is important to choose a  class of signals which is, at present, undergoing a good deal of visual inspection by trained people  for the purpose of pattern recognition.  In this way comparisons between machine and human performance  may be obtained.  A practical result also serves as additional motivation.  Clinical electrocardiograms  make up such a class of signals.  The approach to the problem presented here centers upon the use of  multiple adaptive matched filters that classify normalized signals.  The present report fives some of  the background for the application of this method.", "authors": "Stark,L. Okajima, M. Whipple, G. H.", "words_pool": ["adapt", "addit", "applic", "approach", "artifici", "background", "center", "choos", "class", "classif", "classifi", "clinic", "comparison", "comput", "comput", "deal", "devic", "diagnosi", "digit", "electrocardiogram", "electrocardiograph", "filter", "five", "gener", "good", "human", "import", "inspect", "intellig", "interest", "live", "machin", "make", "match", "method", "motiv", "multipl", "normal", "obtain", "pattern", "peopl", "perform", "phase", "practic", "present", "present", "problem", "program", "purpos", "recognit", "report", "result", "serv", "signal", "techniqu", "train", "undergo", "visual", "stark", "okajima", "whippl"], "word_count": {"adapt": 1, "addit": 1, "applic": 1, "approach": 1, "artifici": 1, "background": 1, "center": 1, "choos": 1, "class": 2, "classif": 1, "classifi": 1, "clinic": 1, "comparison": 1, "comput": 1, "deal": 1, "devic": 1, "diagnosi": 1, "digit": 1, "electrocardiogram": 1, "electrocardiograph": 1, "filter": 1, "five": 1, "gener": 1, "good": 1, "human": 1, "import": 1, "inspect": 1, "intellig": 1, "interest": 1, "live": 1, "machin": 1, "make": 1, "match": 1, "method": 1, "motiv": 1, "multipl": 1, "normal": 1, "obtain": 1, "pattern": 2, "peopl": 1, "perform": 1, "phase": 1, "practic": 1, "present": 3, "problem": 1, "program": 1, "purpos": 1, "recognit": 2, "report": 1, "result": 1, "serv": 1, "signal": 3, "techniqu": 1, "train": 1, "undergo": 1, "visual": 1, "stark": 1, "okajima": 1, "whippl": 1}}, "463": {"id": "463", "title": "On Ambiguity in Phrase Structure Languages", "authors": "Floyd, R. W.", "words_pool": ["ambigu", "languag", "phrase", "structur", "floyd"], "word_count": {"ambigu": 1, "languag": 1, "phrase": 1, "structur": 1, "floyd": 1}}, "464": {"id": "464", "title": "Syntactic Analysis by Digital Computer", "abstract": "This paper provides an account of the Shadow language that is used to describe syntax and of  a corresponding subroutine that enables a computer to perform syntactic analysis.  The input to this  subroutine consists of a string to be analyzed and a description of the syntax that is to be used.  The  syntax is expressed in the Shadow language.  The output consists of a trace table that expresses the  results of the syntactic analysis in a tabular form.  Several versions of the subroutine and some associated  programs have been in use now for over three years.  The present account of the language and the subroutine  contains a summary of material that has been described previously in unpublished reports and also some  additional discussion of the work in relation to the more general questions of problem-oriented languages  and string transformations.", "authors": "Barnett, M. P. Futrelle, R. P.", "words_pool": ["account", "addit", "analysi", "analyz", "comput", "consist", "describ", "descript", "digit", "discuss", "enabl", "express", "express", "form", "gener", "input", "languag", "languag", "materi", "orient", "output", "paper", "perform", "present", "previous", "problem", "program", "question", "relat", "report", "result", "shadow", "string", "subroutin", "summari", "syntact", "syntax", "tabl", "tabular", "trace", "transform", "unpublish", "version", "work", "year", "barnett", "futrel"], "word_count": {"account": 2, "addit": 1, "analysi": 2, "analyz": 1, "comput": 1, "consist": 2, "describ": 1, "descript": 1, "digit": 1, "discuss": 1, "enabl": 1, "express": 2, "form": 1, "gener": 1, "input": 1, "languag": 4, "materi": 1, "orient": 1, "output": 1, "paper": 1, "perform": 1, "present": 1, "previous": 1, "problem": 1, "program": 1, "question": 1, "relat": 1, "report": 1, "result": 1, "shadow": 2, "string": 2, "subroutin": 4, "summari": 1, "syntact": 2, "syntax": 3, "tabl": 1, "tabular": 1, "trace": 1, "transform": 1, "unpublish": 1, "version": 1, "work": 1, "year": 1, "barnett": 1, "futrel": 1}}, "465": {"id": "465", "title": "PERM (Algorithm 115)", "authors": "Schrack, G. F.", "words_pool": ["algorithm", "perm", "schrack"], "word_count": {"algorithm": 1, "perm": 1, "schrack": 1}}, "466": {"id": "466", "title": "General Order Arithmetic (Algorithm 93)", "authors": "George, R.", "words_pool": ["algorithm", "arithmet", "gener", "order", "georg"], "word_count": {"algorithm": 1, "arithmet": 1, "gener": 1, "order": 1, "georg": 1}}, "467": {"id": "467", "title": "Permutation Generator (Algorithm 87)", "authors": "Schrack, G. F. Shimrat, M.", "words_pool": ["algorithm", "gener", "permut", "schrack", "shimrat"], "word_count": {"algorithm": 1, "gener": 1, "permut": 1, "schrack": 1, "shimrat": 1}}, "468": {"id": "468", "title": "Incomplete Elliptic Integrals (Algorithm 73)", "authors": "Jefferson, D. K.", "words_pool": ["algorithm", "ellipt", "incomplet", "integr", "jefferson"], "word_count": {"algorithm": 1, "ellipt": 1, "incomplet": 1, "integr": 1, "jefferson": 1}}, "469": {"id": "469", "title": "Critical Path Scheduling (Algorithm 40)", "authors": "Hellberg, L.", "words_pool": ["algorithm", "critic", "path", "schedul", "hellberg"], "word_count": {"algorithm": 1, "critic": 1, "path": 1, "schedul": 1, "hellberg": 1}}, "470": {"id": "470", "title": "Summation of Fourier Series (Algorithm 128)", "authors": "Wells, M.", "words_pool": ["algorithm", "fourier", "seri", "summat", "well"], "word_count": {"algorithm": 1, "fourier": 1, "seri": 1, "summat": 1, "well": 1}}, "471": {"id": "471", "title": "ORTHO (Algorithm 127)", "authors": "Walsh, P. J.", "words_pool": ["algorithm", "ortho", "walsh"], "word_count": {"algorithm": 1, "ortho": 1, "walsh": 1}}, "472": {"id": "472", "title": "Gauss' Method (Algorithm 126)", "authors": "Counts, J. W.", "words_pool": ["algorithm", "gauss", "method", "count"], "word_count": {"algorithm": 1, "gauss": 1, "method": 1, "count": 1}}, "473": {"id": "473", "title": "WEIGHTCOEFF (Algorithm 125)", "authors": "Rutishauser, H.", "words_pool": ["algorithm", "weightcoeff", "rutishaus"], "word_count": {"algorithm": 1, "weightcoeff": 1, "rutishaus": 1}}, "474": {"id": "474", "title": "Input Data Organization in Fortran", "authors": "Yarbrough, L.D.", "words_pool": ["data", "fortran", "input", "organ", "yarbrough"], "word_count": {"data": 1, "fortran": 1, "input": 1, "organ": 1, "yarbrough": 1}}, "475": {"id": "475", "title": "A Test Matrix for Inversion Procedures", "authors": "Pei, M. L.", "words_pool": ["invers", "matrix", "procedur", "test", "pei"], "word_count": {"invers": 1, "matrix": 1, "procedur": 1, "test": 1, "pei": 1}}, "476": {"id": "476", "title": "Further Remarks on Sampling a Tape File-II", "authors": "Nadler, M.", "words_pool": ["ii", "remark", "sampl", "tape", "nadler"], "word_count": {"ii": 1, "remark": 1, "sampl": 1, "tape": 1, "nadler": 1}}, "477": {"id": "477", "title": "Further Remarks on Sampling a Tape File-I", "authors": "Muller, M. E.", "words_pool": ["remark", "sampl", "tape", "muller"], "word_count": {"remark": 1, "sampl": 1, "tape": 1, "muller": 1}}, "478": {"id": "478", "title": "Implementing a Stack", "authors": "Baecker, H.D.", "words_pool": ["implement", "stack", "baecker"], "word_count": {"implement": 1, "stack": 1, "baecker": 1}}, "479": {"id": "479", "title": "A Dispersion Pass Algorithm for the Polyphase Merge", "abstract": "This paper presents a new manner of dispersing strings for a Polyphase merge.  If the number  of strings dispersed is between two levels acceptable by Polyphase merge, a more economical technique  of reaching the next level for Polyphase merge is shown and proved.", "authors": "Mendoza, A. G.", "words_pool": ["accept", "algorithm", "dispers", "dispers", "dispers", "econom", "level", "level", "manner", "merg", "number", "paper", "pass", "polyphas", "present", "prove", "reach", "shown", "string", "techniqu", "mendoza"], "word_count": {"accept": 1, "algorithm": 1, "dispers": 2, "econom": 1, "level": 2, "manner": 1, "merg": 3, "number": 1, "paper": 1, "pass": 1, "polyphas": 3, "present": 1, "prove": 1, "reach": 1, "shown": 1, "string": 2, "techniqu": 1, "mendoza": 1}}, "480": {"id": "480", "title": "Quick Calculation of Jacobian Elliptic Functions (Corrigendum)", "authors": "Salzer, H. E.", "words_pool": ["calcul", "corrigendum", "ellipt", "function", "jacobian", "quick", "salzer"], "word_count": {"calcul": 1, "corrigendum": 1, "ellipt": 1, "function": 1, "jacobian": 1, "quick": 1, "salzer": 1}}, "481": {"id": "481", "title": "A One-Day Look At Computing", "authors": "Armerding, G. W. Gruenberger, F. J. Marks, S. L. Parkin, T. R.", "words_pool": ["comput", "day", "look", "armerd", "gruenberg", "mark", "parkin"], "word_count": {"comput": 1, "day": 1, "look": 1, "armerd": 1, "gruenberg": 1, "mark": 1, "parkin": 1}}, "482": {"id": "482", "title": "TALL-A List Processor for the Philco 200 Computer", "authors": "Feldman, J.", "words_pool": ["comput", "list", "philco", "processor", "tall", "feldman"], "word_count": {"comput": 1, "list": 1, "philco": 1, "processor": 1, "tall": 1, "feldman": 1}}, "483": {"id": "483", "title": "On the Nonexistence of a Phrase Structure Grammar for ALGOL 60", "abstract": "ALGOL 60 is defined partly by formal mechanisms of phrase structure grammar, partly by informally  stated restrictions.  It is shown that no formal mechanisms of the type used are sufficient to define  ALGOL 60.", "authors": "Floyd, R. W.", "words_pool": ["algol", "defin", "defin", "formal", "grammar", "inform", "mechan", "nonexist", "partli", "phrase", "restrict", "shown", "state", "structur", "suffici", "type", "floyd"], "word_count": {"algol": 2, "defin": 2, "formal": 2, "grammar": 1, "inform": 1, "mechan": 2, "nonexist": 1, "partli": 2, "phrase": 1, "restrict": 1, "shown": 1, "state": 1, "structur": 1, "suffici": 1, "type": 1, "floyd": 1}}, "484": {"id": "484", "title": "Hankel Function (Algorithm 124)", "authors": "Schaefer, L. J.", "words_pool": ["algorithm", "function", "hankel", "schaefer"], "word_count": {"algorithm": 1, "function": 1, "hankel": 1, "schaefer": 1}}, "485": {"id": "485", "title": "Real Error Function, ERF(x) (Algorithm 123)", "authors": "Crawford, M. Techo, R.", "words_pool": ["algorithm", "erf", "error", "function", "real", "crawford", "techo"], "word_count": {"algorithm": 1, "erf": 1, "error": 1, "function": 1, "real": 1, "crawford": 1, "techo": 1}}, "486": {"id": "486", "title": "Tridiagonal Matrix (Algorithm 122)", "authors": "Dietzel, G. F.", "words_pool": ["algorithm", "matrix", "tridiagon", "dietzel"], "word_count": {"algorithm": 1, "matrix": 1, "tridiagon": 1, "dietzel": 1}}, "487": {"id": "487", "title": "NORMDEV (Algorithm 121)", "authors": "Shafer,D.", "words_pool": ["algorithm", "normdev", "shafer"], "word_count": {"algorithm": 1, "normdev": 1, "shafer": 1}}, "488": {"id": "488", "title": "A Heuristic for Page Turning In a Multiprogrammed Computer", "authors": "Weil, J. W.", "words_pool": ["comput", "heurist", "multiprogram", "page", "turn", "weil"], "word_count": {"comput": 1, "heurist": 1, "multiprogram": 1, "page": 1, "turn": 1, "weil": 1}}, "489": {"id": "489", "title": "Current Status of IPL-V for the Philco 2000 Computer (June 1962)", "authors": "Shaffer, S. S.", "words_pool": ["comput", "ipl", "june", "philco", "statu", "shaffer"], "word_count": {"comput": 1, "ipl": 1, "june": 1, "philco": 1, "statu": 1, "shaffer": 1}}, "490": {"id": "490", "title": "Programmed Methods for Printer Graphical Output", "authors": "Garfinkel, D.", "words_pool": ["graphic", "method", "output", "printer", "program", "garfinkel"], "word_count": {"graphic": 1, "method": 1, "output": 1, "printer": 1, "program": 1, "garfinkel": 1}}, "491": {"id": "491", "title": "Use of Multiprogramming in the Design of a Low Cost Digital Computer", "authors": "Penny, J. P. Pearcey, T.", "words_pool": ["comput", "cost", "design", "digit", "low", "multiprogram", "penni", "pearcey"], "word_count": {"comput": 1, "cost": 1, "design": 1, "digit": 1, "low": 1, "multiprogram": 1, "penni": 1, "pearcey": 1}}, "492": {"id": "492", "title": "Analysis of a File Addressing Method", "abstract": "This paper presents a new file addressing method based on the calculation of an address from  the identification of a record.  For large recirculating type files, it seems to be more advantageous  than customary ones.  The probability distribution of the displacement of records from their calculated  address, which is one less than the number of probes required to address a record, is computed on the  basis of a Markov chain model.  For the reader not interested in the mathematics, the introduction and  the summary should be sufficient.", "authors": "Schay Jr., G. Spruth, W. G.", "words_pool": ["address", "address", "advantag", "analysi", "base", "basi", "calcul", "calcul", "chain", "comput", "customari", "displac", "distribut", "identif", "interest", "introduct", "larg", "markov", "mathemat", "method", "model", "number", "paper", "present", "probabl", "probe", "reader", "recircul", "record", "record", "requir", "suffici", "summari", "type", "schay", "jr", "spruth"], "word_count": {"address": 4, "advantag": 1, "analysi": 1, "base": 1, "basi": 1, "calcul": 2, "chain": 1, "comput": 1, "customari": 1, "displac": 1, "distribut": 1, "identif": 1, "interest": 1, "introduct": 1, "larg": 1, "markov": 1, "mathemat": 1, "method": 1, "model": 1, "number": 1, "paper": 1, "present": 1, "probabl": 1, "probe": 1, "reader": 1, "recircul": 1, "record": 3, "requir": 1, "suffici": 1, "summari": 1, "type": 1, "schay": 1, "jr": 1, "spruth": 1}}, "493": {"id": "493", "title": "The Property Classification Method of File Design and Processing", "authors": "McGee, W. C.", "words_pool": ["classif", "design", "method", "process", "properti", "mcgee"], "word_count": {"classif": 1, "design": 1, "method": 1, "process": 1, "properti": 1, "mcgee": 1}}, "494": {"id": "494", "title": "A Finite Sequentially Compact Process for the Adjoints of Matrices Over Arbitrary Integral Domains", "authors": "Luther, H. A. Guseman Jr., L. F.", "words_pool": ["adjoint", "arbitrari", "compact", "domain", "finit", "integr", "matric", "process", "sequenti", "luther", "guseman", "jr"], "word_count": {"adjoint": 1, "arbitrari": 1, "compact": 1, "domain": 1, "finit": 1, "integr": 1, "matric": 1, "process": 1, "sequenti": 1, "luther": 1, "guseman": 1, "jr": 1}}, "495": {"id": "495", "title": "A Procedure for Inverting Large Symmetric Matrices", "abstract": "In the least squares method for simultaneous adjustment of several parameters, the coefficients  of the normal equations are the elements of a symmetric positive-definite matrix.  In order to solve  the normal equations and evaluate the precision measures of the resulting parameters, inversion of this  matrix of coefficients is required.  Many available procedures for matrix inversion do not take advantage  of the symmetry.  Thus, when programmed for a high-speed computer, all n^2 elements must be stored and  manipulated, whereas only (n + 1)/2 of them are independent.  In order to allow a computer of given memory  capacity to handle a larger matrix, the following procedure for inverting a symmetric matrix has been  devised.", "authors": "Busing, W. R. Levy, H. S.", "words_pool": ["adjust", "advantag", "allow", "capac", "coeffici", "comput", "definit", "devis", "element", "equat", "evalu", "handl", "high", "independ", "invers", "invert", "larg", "larger", "manipul", "matric", "matrix", "measur", "memori", "method", "normal", "order", "paramet", "posit", "precis", "procedur", "procedur", "program", "requir", "result", "simultan", "solv", "speed", "squar", "store", "symmetr", "symmetri", "take", "buse", "levi"], "word_count": {"adjust": 1, "advantag": 1, "allow": 1, "capac": 1, "coeffici": 2, "comput": 2, "definit": 1, "devis": 1, "element": 2, "equat": 2, "evalu": 1, "handl": 1, "high": 1, "independ": 1, "invers": 2, "invert": 1, "larg": 1, "larger": 1, "manipul": 1, "matric": 1, "matrix": 5, "measur": 1, "memori": 1, "method": 1, "normal": 2, "order": 2, "paramet": 2, "posit": 1, "precis": 1, "procedur": 2, "program": 1, "requir": 1, "result": 1, "simultan": 1, "solv": 1, "speed": 1, "squar": 1, "store": 1, "symmetr": 2, "symmetri": 1, "take": 1, "buse": 1, "levi": 1}}, "496": {"id": "496", "title": "A Set of Matrices for Testing Computer Programs", "authors": "Brenner, J. L.", "words_pool": ["comput", "matric", "program", "set", "test", "brenner"], "word_count": {"comput": 1, "matric": 1, "program": 1, "set": 1, "test": 1, "brenner": 1}}, "497": {"id": "497", "title": "Further Remarks on Line Segment Curve-Fitting Using Dynamic Programming", "abstract": "In a recent paper, Bellman showed how dynamic programming could be used to determine the solution  to a problem previously considered by Stone.  The problem comprises the determination, given N, of the  N points of subdivision of a given interval (a,B) and the corresponding line segments, that give the  best least squares fit to a function g(x) in the interval.  Bellman confined himself primarily to the  analytical derivation, suggesting briefly, however, how the solution of the equation derived for each  particular point of subdivision u(i) could be reduced to a discrete search.  In this paper, the computational  procedure is considered more fully, and the similarities to some of Stone's equations are indicated.   It is further shown that an equation for u(i) involving no minimization may be found.  In addition,  it is shown how Bellman's method may be applied to the curve-fitting problem when the additional constraints  are added that the ends of the line segments must be on the curve.", "authors": "Gluss, B.", "words_pool": ["ad", "addit", "addit", "analyt", "appli", "bellman", "briefli", "compris", "comput", "confin", "consid", "constraint", "curv", "deriv", "deriv", "determin", "determin", "discret", "dynam", "end", "equat", "equat", "fit", "fit", "found", "fulli", "function", "give", "interv", "involv", "line", "method", "minim", "paper", "point", "point", "previous", "primarili", "problem", "procedur", "program", "recent", "reduc", "remark", "search", "segment", "segment", "show", "shown", "similar", "solut", "squar", "stone", "subdivis", "suggest", "gluss"], "word_count": {"ad": 1, "addit": 2, "analyt": 1, "appli": 1, "bellman": 3, "briefli": 1, "compris": 1, "comput": 1, "confin": 1, "consid": 2, "constraint": 1, "curv": 2, "deriv": 2, "determin": 2, "discret": 1, "dynam": 1, "end": 1, "equat": 3, "fit": 2, "found": 1, "fulli": 1, "function": 1, "give": 1, "interv": 2, "involv": 1, "line": 2, "method": 1, "minim": 1, "paper": 2, "point": 2, "previous": 1, "primarili": 1, "problem": 3, "procedur": 1, "program": 1, "recent": 1, "reduc": 1, "remark": 1, "search": 1, "segment": 2, "show": 1, "shown": 2, "similar": 1, "solut": 2, "squar": 1, "stone": 2, "subdivis": 2, "suggest": 1, "gluss": 1}}, "498": {"id": "498", "title": "Magic Square (Algorithm 117 & 118)", "authors": "Collison, D. M.", "words_pool": ["algorithm", "magic", "squar", "collison"], "word_count": {"algorithm": 1, "magic": 1, "squar": 1, "collison": 1}}, "499": {"id": "499", "title": "Permutation Generator (Algorithm 87)", "authors": "Collison, D. M.", "words_pool": ["algorithm", "gener", "permut", "collison"], "word_count": {"algorithm": 1, "gener": 1, "permut": 1, "collison": 1}}, "500": {"id": "500", "title": "PERMUTE (Algorithm 86)", "authors": "Collison, D. M.", "words_pool": ["algorithm", "permut", "collison"], "word_count": {"algorithm": 1, "permut": 1, "collison": 1}}, "501": {"id": "501", "title": "JACOBI (Algorithm 85)", "authors": "Hillmore, J. S.", "words_pool": ["algorithm", "jacobi", "hillmor"], "word_count": {"algorithm": 1, "jacobi": 1, "hillmor": 1}}, "502": {"id": "502", "title": "Simpson's Integration (Algorithm 84)", "authors": "George, R.", "words_pool": ["algorithm", "integr", "simpson", "georg"], "word_count": {"algorithm": 1, "integr": 1, "simpson": 1, "georg": 1}}, "503": {"id": "503", "title": "Rational Roots of Polynomials with Integer Coefficients (Algorithm 78)", "authors": "Collison, D. M.", "words_pool": ["algorithm", "coeffici", "integ", "polynomi", "ration", "root", "collison"], "word_count": {"algorithm": 1, "coeffici": 1, "integ": 1, "polynomi": 1, "ration": 1, "root": 1, "collison": 1}}, "504": {"id": "504", "title": "FACTORS (Algorithm 75)", "authors": "Hillmore, J. S.", "words_pool": ["algorithm", "factor", "hillmor"], "word_count": {"algorithm": 1, "factor": 1, "hillmor": 1}}, "505": {"id": "505", "title": "Composition Generator (Algorithm 72)", "authors": "Collison, D. M.", "words_pool": ["algorithm", "composit", "gener", "collison"], "word_count": {"algorithm": 1, "composit": 1, "gener": 1, "collison": 1}}, "506": {"id": "506", "title": "PERMUTATION (Algorithm 71)", "authors": "Hillmore, J. S.", "words_pool": ["algorithm", "permut", "hillmor"], "word_count": {"algorithm": 1, "permut": 1, "hillmor": 1}}, "507": {"id": "507", "title": "Partition, Quicksort, Find (Algorithm 63, 64, 65)", "authors": "Hillmore, J. S.", "words_pool": ["algorithm", "find", "partit", "quicksort", "hillmor"], "word_count": {"algorithm": 1, "find": 1, "partit": 1, "quicksort": 1, "hillmor": 1}}, "508": {"id": "508", "title": "Matrix Inversion (Algorithm 58)", "authors": "George, R.", "words_pool": ["algorithm", "invers", "matrix", "georg"], "word_count": {"algorithm": 1, "invers": 1, "matrix": 1, "georg": 1}}, "509": {"id": "509", "title": "Matrix Inversion (Algorithm 58)", "authors": "Struble, G.", "words_pool": ["algorithm", "invers", "matrix", "strubl"], "word_count": {"algorithm": 1, "invers": 1, "matrix": 1, "strubl": 1}}, "510": {"id": "510", "title": "Ber or Bei Function (Algorithm 57)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "bei", "ber", "function", "thacher", "jr"], "word_count": {"algorithm": 1, "bei": 1, "ber": 1, "function": 1, "thacher": 1, "jr": 1}}, "511": {"id": "511", "title": "A Set of Test Matrices (Algorithm 52)", "authors": "Hillmore, J. S.", "words_pool": ["algorithm", "matric", "set", "test", "hillmor"], "word_count": {"algorithm": 1, "matric": 1, "set": 1, "test": 1, "hillmor": 1}}, "512": {"id": "512", "title": "Telescope 1 (Algorithm 37)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "telescop", "thacher", "jr"], "word_count": {"algorithm": 1, "telescop": 1, "thacher": 1, "jr": 1}}, "513": {"id": "513", "title": "SIEVE (Algorithm 35)", "authors": "Hillmore, J. S.", "words_pool": ["algorithm", "siev", "hillmor"], "word_count": {"algorithm": 1, "siev": 1, "hillmor": 1}}, "514": {"id": "514", "title": "Binomial Coefficients (Algorithm 19)", "authors": "George, R.", "words_pool": ["algorithm", "binomi", "coeffici", "georg"], "word_count": {"algorithm": 1, "binomi": 1, "coeffici": 1, "georg": 1}}, "515": {"id": "515", "title": "Rational Interpolation by Continued Fractions (Algorithm 18)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "continu", "fraction", "interpol", "ration", "thacher", "jr"], "word_count": {"algorithm": 1, "continu": 1, "fraction": 1, "interpol": 1, "ration": 1, "thacher": 1, "jr": 1}}, "516": {"id": "516", "title": "Matrix Inversion II (Algorithm 120)", "authors": "George, R.", "words_pool": ["algorithm", "ii", "invers", "matrix", "georg"], "word_count": {"algorithm": 1, "ii": 1, "invers": 1, "matrix": 1, "georg": 1}}, "517": {"id": "517", "title": "Evaluation of Pert Network (Algorithm 119)", "authors": "Eisenman, B. Shapiro, M.", "words_pool": ["algorithm", "evalu", "network", "pert", "eisenman", "shapiro"], "word_count": {"algorithm": 1, "evalu": 1, "network": 1, "pert": 1, "eisenman": 1, "shapiro": 1}}, "518": {"id": "518", "title": "Magic Square (Odd Order) (Algorithm 118)", "authors": "Collison, D. M.", "words_pool": ["algorithm", "magic", "odd", "order", "squar", "collison"], "word_count": {"algorithm": 1, "magic": 1, "odd": 1, "order": 1, "squar": 1, "collison": 1}}, "519": {"id": "519", "title": "Magic Square (Even Order) (Algorithm 117)", "authors": "Collison, D. M.", "words_pool": ["algorithm", "magic", "order", "squar", "collison"], "word_count": {"algorithm": 1, "magic": 1, "order": 1, "squar": 1, "collison": 1}}, "520": {"id": "520", "title": "Complex Division (Algorithm 116)", "authors": "Smith, R. L.", "words_pool": ["algorithm", "complex", "divis", "smith"], "word_count": {"algorithm": 1, "complex": 1, "divis": 1, "smith": 1}}, "521": {"id": "521", "title": "PERM (Algorithm 115)", "authors": "Trotter, H. F.", "words_pool": ["algorithm", "perm", "trotter"], "word_count": {"algorithm": 1, "perm": 1, "trotter": 1}}, "522": {"id": "522", "title": "Generation of Partitions with Constraints (Algorithm 114)", "authors": "Stockmal, F.", "words_pool": ["algorithm", "constraint", "gener", "partit", "stockmal"], "word_count": {"algorithm": 1, "constraint": 1, "gener": 1, "partit": 1, "stockmal": 1}}, "523": {"id": "523", "title": "TREESORT (Algorithm 113)", "authors": "Floyd,R. W.", "words_pool": ["algorithm", "treesort", "floyd"], "word_count": {"algorithm": 1, "treesort": 1, "floyd": 1}}, "524": {"id": "524", "title": "Position of Point Relative to Polygon (Algorithm 112)", "authors": "Shimrat, M.", "words_pool": ["algorithm", "point", "polygon", "posit", "rel", "shimrat"], "word_count": {"algorithm": 1, "point": 1, "polygon": 1, "posit": 1, "rel": 1, "shimrat": 1}}, "525": {"id": "525", "title": "A Computer Technique for Handling Analysis of Variance", "authors": "Howell, J. R.", "words_pool": ["analysi", "comput", "handl", "techniqu", "varianc", "howel"], "word_count": {"analysi": 1, "comput": 1, "handl": 1, "techniqu": 1, "varianc": 1, "howel": 1}}, "526": {"id": "526", "title": "Character Manipulation in Fortran", "authors": "Pyle, I. C.", "words_pool": ["charact", "fortran", "manipul", "pyle"], "word_count": {"charact": 1, "fortran": 1, "manipul": 1, "pyle": 1}}, "527": {"id": "527", "title": "The Description List of Concepts", "abstract": "A concept is defined as a class of objects whose members can be distinguished by processing  its properties.  Property is defined to mean a partition of the set of all objects into disjoint classes.   The formal definition of a concept is recursive in nature.  A concept is described by a list structure.   A one-to-one correspondence is established between the recursive definition of a concept and its description  list structure.  Like the definition, the description list structure of a concept is also built up from  elementary list structures by a recursive process.  The list structures obtained this way are compared  with the description list structure discussed by the author in a previous publication.", "authors": "Banerji, R. B.", "words_pool": ["author", "built", "class", "class", "compar", "concept", "concept", "correspond", "defin", "definit", "descript", "discuss", "disjoint", "distinguish", "elementari", "establish", "formal", "list", "mean", "member", "natur", "object", "obtain", "partit", "previou", "process", "process", "properti", "properti", "public", "recurs", "set", "structur", "structur", "banerji"], "word_count": {"author": 1, "built": 1, "class": 2, "compar": 1, "concept": 5, "correspond": 1, "defin": 2, "definit": 3, "descript": 3, "discuss": 1, "disjoint": 1, "distinguish": 1, "elementari": 1, "establish": 1, "formal": 1, "list": 6, "mean": 1, "member": 1, "natur": 1, "object": 2, "obtain": 1, "partit": 1, "previou": 1, "process": 2, "properti": 2, "public": 1, "recurs": 3, "set": 1, "structur": 6, "banerji": 1}}, "528": {"id": "528", "title": "FORTRAN for Business Data Processing", "authors": "Robbins, D. K.", "words_pool": ["busi", "data", "fortran", "process", "robbin"], "word_count": {"busi": 1, "data": 1, "fortran": 1, "process": 1, "robbin": 1}}, "529": {"id": "529", "title": "Regression and Coded Patterns in Data Editing", "authors": "Robison, D. E. Aroian, L. A.", "words_pool": ["code", "data", "edit", "pattern", "regress", "robison", "aroian"], "word_count": {"code": 1, "data": 1, "edit": 1, "pattern": 1, "regress": 1, "robison": 1, "aroian": 1}}, "530": {"id": "530", "title": "A Computer Method for Radiation Treatment Planning", "authors": "Siler, W. Laughlin, J. S.", "words_pool": ["comput", "method", "plan", "radiat", "treatment", "siler", "laughlin"], "word_count": {"comput": 1, "method": 1, "plan": 1, "radiat": 1, "treatment": 1, "siler": 1, "laughlin": 1}}, "531": {"id": "531", "title": "Person-Matching by Electronic Methods", "abstract": "Record linkage in the updating of files is accomplished in many establishments through the  use of a preassigned number, such as payroll number, customer number, or social security number.  In  vital and health records, however, a unique number is generally not preassigned to an individual for  purposes of reporting services received to the health department.  In order to determine whether different  physician reports refer to the same individual, name and other identification must be compared.  This  is a laborious operation which is subject to various errors because of name misspellings, changes of  name upon marriage, and other problems.  We are interested in the maintenance of a psychiatric case register  in Maryland, where many of the reports from over a hundred psychiatric agencies refer to the same patient.   These records must be linked in order to provide unduplicated counts of individuals under care and longitudinal  records of psychiatric history.  An earlier paper [1] describes our general procedures for register maintenance  by use of a digital computer (Honeywell 800).  Here we present in more detail our initial procedures  for the person-matching process in order to elicit comments and suggestions from persons who have had  experience in matching.", "authors": "Phillips Jr., W. Bahn, A. K. Miyasaki, M.", "words_pool": ["accomplish", "agenc", "care", "case", "comment", "compar", "comput", "count", "custom", "depart", "describ", "detail", "determin", "digit", "earlier", "electron", "elicit", "error", "establish", "experi", "gener", "gener", "health", "histori", "honeywel", "hundr", "identif", "individu", "individu", "initi", "interest", "labori", "linkag", "link", "longitudin", "mainten", "marriag", "maryland", "match", "method", "misspel", "number", "oper", "order", "paper", "patient", "payrol", "person", "person", "physician", "preassign", "present", "problem", "procedur", "process", "provid", "psychiatr", "purpos", "receiv", "record", "record", "refer", "regist", "report", "report", "secur", "servic", "social", "subject", "suggest", "undupl", "uniqu", "updat", "vital", "phillip", "jr", "bahn", "miyasaki"], "word_count": {"accomplish": 1, "agenc": 1, "care": 1, "case": 1, "comment": 1, "compar": 1, "comput": 1, "count": 1, "custom": 1, "depart": 1, "describ": 1, "detail": 1, "determin": 1, "digit": 1, "earlier": 1, "electron": 1, "elicit": 1, "error": 1, "establish": 1, "experi": 1, "gener": 2, "health": 2, "histori": 1, "honeywel": 1, "hundr": 1, "identif": 1, "individu": 3, "initi": 1, "interest": 1, "labori": 1, "linkag": 1, "link": 1, "longitudin": 1, "mainten": 2, "marriag": 1, "maryland": 1, "match": 2, "method": 1, "misspel": 1, "number": 5, "oper": 1, "order": 3, "paper": 1, "patient": 1, "payrol": 1, "person": 2, "physician": 1, "preassign": 2, "present": 1, "problem": 1, "procedur": 2, "process": 1, "provid": 1, "psychiatr": 3, "purpos": 1, "receiv": 1, "record": 4, "refer": 2, "regist": 2, "report": 3, "secur": 1, "servic": 1, "social": 1, "subject": 1, "suggest": 1, "undupl": 1, "uniqu": 1, "updat": 1, "vital": 1, "phillip": 1, "jr": 1, "bahn": 1, "miyasaki": 1}}, "532": {"id": "532", "title": "On the Computation of Rational Approximations to Continuous Functions", "authors": "Fraser, W. HArt, J. F.", "words_pool": ["approxim", "comput", "continu", "function", "ration", "fraser", "hart"], "word_count": {"approxim": 1, "comput": 1, "continu": 1, "function": 1, "ration": 1, "fraser": 1, "hart": 1}}, "533": {"id": "533", "title": "Digital Synthesis of Correlated Stationary Noise", "abstract": "In this note we propose a method of generating stationary noise with a prescribed auto-covariance  function by digital methods.  The need for such a technique often arises in testing the performance of  data processing and engineering systems, where inputs corrupted with correlated noise (of a known form)  are required.  The technique is quite simple and produces strict-sense stationary noise which agrees  approximately with R(t), the prescribed auto-covariance function (acf), over an interval [-T(0), T(0)].   The method consists of approximating the spectral density by a periodic process with spectral lines,  and then synthesizing the periodic noise with random phases and appropriate amplitudes.  In order to  simplify discussion of the statistical properties of the noise generated, the technique is first presented  in terms of exact harmonic analysis.  In practice, discrete harmonic analysis as presented in the third  section is used.", "authors": "Peabody, P. R. Adorno, D. S.", "words_pool": ["acf", "agre", "amplitud", "analysi", "approxim", "approxim", "aris", "auto", "consist", "correl", "corrupt", "covari", "data", "densiti", "digit", "discret", "discuss", "engin", "exact", "form", "function", "gener", "gener", "harmon", "input", "interv", "known", "line", "method", "method", "need", "nois", "note", "order", "perform", "period", "phase", "practic", "prescrib", "present", "process", "process", "produc", "properti", "propos", "random", "requir", "section", "sens", "simpl", "simplifi", "spectral", "stationari", "statist", "strict", "synthesi", "synthes", "system", "techniqu", "term", "test", "peabodi", "adorno"], "word_count": {"acf": 1, "agre": 1, "amplitud": 1, "analysi": 2, "approxim": 2, "aris": 1, "auto": 2, "consist": 1, "correl": 1, "corrupt": 1, "covari": 2, "data": 1, "densiti": 1, "digit": 1, "discret": 1, "discuss": 1, "engin": 1, "exact": 1, "form": 1, "function": 2, "gener": 2, "harmon": 2, "input": 1, "interv": 1, "known": 1, "line": 1, "method": 3, "need": 1, "nois": 5, "note": 1, "order": 1, "perform": 1, "period": 2, "phase": 1, "practic": 1, "prescrib": 2, "present": 2, "process": 2, "produc": 1, "properti": 1, "propos": 1, "random": 1, "requir": 1, "section": 1, "sens": 1, "simpl": 1, "simplifi": 1, "spectral": 2, "stationari": 2, "statist": 1, "strict": 1, "synthesi": 1, "synthes": 1, "system": 1, "techniqu": 3, "term": 1, "test": 1, "peabodi": 1, "adorno": 1}}, "534": {"id": "534", "title": "Quick Calculation of Jacobian Elliptic Functions", "authors": "Salzer, H. E.", "words_pool": ["calcul", "ellipt", "function", "jacobian", "quick", "salzer"], "word_count": {"calcul": 1, "ellipt": 1, "function": 1, "jacobian": 1, "quick": 1, "salzer": 1}}, "535": {"id": "535", "title": "Triangular Walk Pattern for the Down-hill Method of Solving a Transcendental Equation", "authors": "Onoe, M.", "words_pool": ["equat", "hill", "method", "pattern", "solv", "transcendent", "triangular", "walk", "ono"], "word_count": {"equat": 1, "hill": 1, "method": 1, "pattern": 1, "solv": 1, "transcendent": 1, "triangular": 1, "walk": 1, "ono": 1}}, "536": {"id": "536", "title": "Nonlinear Regression and the Solution of Simultaneous Equations", "abstract": "If one has a set of observables (Z1,...,Zm) which are bound in a relation with certain parameters  (A1,...,An) by an equation S(Z1,...;A1,...)=0, one frequently has the problem of determining a set of  values of the Ai which minimizes the sum of squares of differences between observed and calculated values  of a distinguished observable, say Zm.  If the solution of the above equation for Zm,  Zm=N(Z1,...;A1,...)  gives rise to a function N which is nonlinear in the Ai, then one may rely on a version of Gaussian regression  [1,2] for an iteration scheme that converges to a minimizing set of values.  It is shown here that this  same minimization technique may be used for the solution of simultaneous (not necessarily linear) equations.", "authors": "Baer, R. M.", "words_pool": ["a1", "ai", "bound", "calcul", "converg", "determin", "differ", "distinguish", "equat", "equat", "frequent", "function", "gaussian", "iter", "linear", "minim", "minim", "minim", "necessarili", "nonlinear", "observ", "observ", "observ", "paramet", "problem", "regress", "relat", "reli", "rise", "say", "scheme", "set", "shown", "simultan", "solut", "squar", "sum", "techniqu", "valu", "version", "z1", "zm", "baer"], "word_count": {"a1": 3, "ai": 2, "bound": 1, "calcul": 1, "converg": 1, "determin": 1, "differ": 1, "distinguish": 1, "equat": 3, "frequent": 1, "function": 1, "gaussian": 1, "iter": 1, "linear": 1, "minim": 3, "necessarili": 1, "nonlinear": 1, "observ": 3, "paramet": 1, "problem": 1, "regress": 1, "relat": 1, "reli": 1, "rise": 1, "say": 1, "scheme": 1, "set": 3, "shown": 1, "simultan": 1, "solut": 2, "squar": 1, "sum": 1, "techniqu": 1, "valu": 3, "version": 1, "z1": 3, "zm": 4, "baer": 1}}, "537": {"id": "537", "title": "A Machine Program for Theorem-Proving", "abstract": "The program of a proof procedure is discussed in connection with trial runs and possible improvements.", "authors": "Davis, M. Logemann, G. Loveland, D.", "words_pool": ["connect", "discuss", "improv", "machin", "procedur", "program", "proof", "prove", "run", "theorem", "trial", "davi", "logemann", "loveland"], "word_count": {"connect": 1, "discuss": 1, "improv": 1, "machin": 1, "procedur": 1, "program": 1, "proof": 1, "prove": 1, "run": 1, "theorem": 1, "trial": 1, "davi": 1, "logemann": 1, "loveland": 1}}, "538": {"id": "538", "title": "Quantum Mechanical Integrals of Slater-Type Orbitals (Algorithm 110)", "authors": "Kruglyak, Y. A. Whitman, D. R.", "words_pool": ["algorithm", "integr", "mechan", "orbit", "quantum", "slater", "type", "kruglyak", "whitman"], "word_count": {"algorithm": 1, "integr": 1, "mechan": 1, "orbit": 1, "quantum": 1, "slater": 1, "type": 1, "kruglyak": 1, "whitman": 1}}, "539": {"id": "539", "title": "Definite Exponential Integrals B (Algorithm 109)", "authors": "Kruglyak, Y. A. Whitman, D. R.", "words_pool": ["algorithm", "definit", "exponenti", "integr", "kruglyak", "whitman"], "word_count": {"algorithm": 1, "definit": 1, "exponenti": 1, "integr": 1, "kruglyak": 1, "whitman": 1}}, "540": {"id": "540", "title": "Definite Exponential Integrals A (Algorithm 108)", "authors": "Kruglyak, Y. A. Whitman, D. R.", "words_pool": ["algorithm", "definit", "exponenti", "integr", "kruglyak", "whitman"], "word_count": {"algorithm": 1, "definit": 1, "exponenti": 1, "integr": 1, "kruglyak": 1, "whitman": 1}}, "541": {"id": "541", "title": "Simpson's Integration (Algorithm 84)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "integr", "simpson", "relph"], "word_count": {"algorithm": 1, "integr": 1, "simpson": 1, "relph": 1}}, "542": {"id": "542", "title": "FACTORS (Algorithm 75)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "factor", "relph"], "word_count": {"algorithm": 1, "factor": 1, "relph": 1}}, "543": {"id": "543", "title": "Interpolation by Aitken (Algorithm 70)", "authors": "Relph, A. P.", "words_pool": ["aitken", "algorithm", "interpol", "relph"], "word_count": {"aitken": 1, "algorithm": 1, "interpol": 1, "relph": 1}}, "544": {"id": "544", "title": "Ber or Bei Function (Algorithm 57)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "bei", "ber", "function", "relph"], "word_count": {"algorithm": 1, "bei": 1, "ber": 1, "function": 1, "relph": 1}}, "545": {"id": "545", "title": "Adjust Inverse of a Matrix when an Element is Perturbed (Algorithm 51)", "authors": "George, R.", "words_pool": ["adjust", "algorithm", "element", "invers", "matrix", "perturb", "georg"], "word_count": {"adjust": 1, "algorithm": 1, "element": 1, "invers": 1, "matrix": 1, "perturb": 1, "georg": 1}}, "546": {"id": "546", "title": "Logarithm of a Complex Number (Algorithm 48)", "authors": "Johnson, M. L. Sangren, W.", "words_pool": ["algorithm", "complex", "logarithm", "number", "johnson", "sangren"], "word_count": {"algorithm": 1, "complex": 1, "logarithm": 1, "number": 1, "johnson": 1, "sangren": 1}}, "547": {"id": "547", "title": "Gamma Function (Algorithm 34)", "authors": "Johnson, M. L. Sangren, W.", "words_pool": ["algorithm", "function", "gamma", "johnson", "sangren"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "johnson": 1, "sangren": 1}}, "548": {"id": "548", "title": "Molecular-Orbital Calculation of Molecular Interactions", "authors": "Kruglyak, Y. A. Whitman, D. R.", "words_pool": ["calcul", "interact", "molecular", "orbit", "kruglyak", "whitman"], "word_count": {"calcul": 1, "interact": 1, "molecular": 2, "orbit": 1, "kruglyak": 1, "whitman": 1}}, "549": {"id": "549", "title": "Quantum Mechanical Integrals of Slater-Type Orbitals", "authors": "Kruglyak, Y. A. Whitman, D. R.", "words_pool": ["integr", "mechan", "orbit", "quantum", "slater", "type", "kruglyak", "whitman"], "word_count": {"integr": 1, "mechan": 1, "orbit": 1, "quantum": 1, "slater": 1, "type": 1, "kruglyak": 1, "whitman": 1}}, "550": {"id": "550", "title": "Definite Exponential Integrals B (Algorithm 109)", "authors": "Kruglyak, Y. A. Whitman, D. R.", "words_pool": ["algorithm", "definit", "exponenti", "integr", "kruglyak", "whitman"], "word_count": {"algorithm": 1, "definit": 1, "exponenti": 1, "integr": 1, "kruglyak": 1, "whitman": 1}}, "551": {"id": "551", "title": "Definite Exponential Integrals A (Algorithm 108)", "authors": "Kruglyak, Y. A. Whitman, D. R.", "words_pool": ["algorithm", "definit", "exponenti", "integr", "kruglyak", "whitman"], "word_count": {"algorithm": 1, "definit": 1, "exponenti": 1, "integr": 1, "kruglyak": 1, "whitman": 1}}, "552": {"id": "552", "title": "Gauss's Method (Algorithm 107)", "authors": "Counts, J. W.", "words_pool": ["algorithm", "gauss", "method", "count"], "word_count": {"algorithm": 1, "gauss": 1, "method": 1, "count": 1}}, "553": {"id": "553", "title": "Complex Number to a Real Power (Algorithm 106)", "authors": "Johnson, M. L. Sangren, W.", "words_pool": ["algorithm", "complex", "number", "power", "real", "johnson", "sangren"], "word_count": {"algorithm": 1, "complex": 1, "number": 1, "power": 1, "real": 1, "johnson": 1, "sangren": 1}}, "554": {"id": "554", "title": "Newton Maehly, (Algorithm 105)", "authors": "Bauer, F. L. Stoer, J.", "words_pool": ["algorithm", "maehli", "newton", "bauer", "stoer"], "word_count": {"algorithm": 1, "maehli": 1, "newton": 1, "bauer": 1, "stoer": 1}}, "555": {"id": "555", "title": "Reduction to Jacobi (Algorithm 104)", "authors": "Rutishausr, H.", "words_pool": ["algorithm", "jacobi", "reduct", "rutishausr"], "word_count": {"algorithm": 1, "jacobi": 1, "reduct": 1, "rutishausr": 1}}, "556": {"id": "556", "title": "On Translation of Boolean Expressions", "authors": "Bottenbirruch, H. H Grau, A. A.", "words_pool": ["boolean", "express", "translat", "bottenbirruch", "grau"], "word_count": {"boolean": 1, "express": 1, "translat": 1, "bottenbirruch": 1, "grau": 1}}, "557": {"id": "557", "title": "Simulation of Computer Timing Device", "words_pool": ["comput", "devic", "simul", "time"], "word_count": {"comput": 1, "devic": 1, "simul": 1, "time": 1}}, "558": {"id": "558", "title": "A Modified Inversion Procedure for Product Form of the Inverse Linear Programming Codes", "abstract": "This paper describes a new algorithm for the selection of the pivot row in matrix inversion  when using the product form of the inverse.  This algorithm has been developed for linear programming  codes; however, it would be valuable for the inversion of any non-dense matrix.  The procedures described  in this paper have been thoroughly tested and have been in operation on the Esso Research and Engineering  IBM 7090 computer for nine months.  Substantial computer cost savings have been realized because of this  procedure.", "authors": "Larsen, L. J.", "words_pool": ["algorithm", "code", "comput", "cost", "dens", "describ", "develop", "engin", "esso", "form", "ibm", "invers", "invers", "linear", "matrix", "modifi", "month", "non", "oper", "paper", "pivot", "procedur", "procedur", "product", "program", "realiz", "research", "row", "save", "select", "substanti", "test", "valuabl", "larsen"], "word_count": {"algorithm": 2, "code": 1, "comput": 2, "cost": 1, "dens": 1, "describ": 1, "develop": 1, "engin": 1, "esso": 1, "form": 1, "ibm": 1, "invers": 3, "linear": 1, "matrix": 2, "modifi": 1, "month": 1, "non": 1, "oper": 1, "paper": 2, "pivot": 1, "procedur": 2, "product": 1, "program": 1, "realiz": 1, "research": 1, "row": 1, "save": 1, "select": 1, "substanti": 1, "test": 1, "valuabl": 1, "larsen": 1}}, "559": {"id": "559", "title": "Solution of Eigenvalue Problems With Approximately Known Eigenvectors", "authors": "Appel, K.", "words_pool": ["approxim", "eigenvalu", "eigenvector", "known", "problem", "solut", "appel"], "word_count": {"approxim": 1, "eigenvalu": 1, "eigenvector": 1, "known": 1, "problem": 1, "solut": 1, "appel": 1}}, "560": {"id": "560", "title": "Communication Between Independently Translated Blocks", "authors": "Wegner, P.", "words_pool": ["block", "commun", "independ", "translat", "wegner"], "word_count": {"block": 1, "commun": 1, "independ": 1, "translat": 1, "wegner": 1}}, "561": {"id": "561", "title": "Analytic Differentiation By Computer", "authors": "Hanson, J. W. Caviness, J. S. Joseph, C.", "words_pool": ["analyt", "comput", "differenti", "hanson", "cavi", "joseph"], "word_count": {"analyt": 1, "comput": 1, "differenti": 1, "hanson": 1, "cavi": 1, "joseph": 1}}, "562": {"id": "562", "title": "AVINT (Algorithm 77)", "authors": "Whittier, V. E.", "words_pool": ["algorithm", "avint", "whittier"], "word_count": {"algorithm": 1, "avint": 1, "whittier": 1}}, "563": {"id": "563", "title": "Sorting Procedures (Algorithm 76)", "authors": "Randell, B.", "words_pool": ["algorithm", "procedur", "sort", "randel"], "word_count": {"algorithm": 1, "procedur": 1, "sort": 1, "randel": 1}}, "564": {"id": "564", "title": "CRAM (Algorithm 67)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "cram", "relph"], "word_count": {"algorithm": 1, "cram": 1, "relph": 1}}, "565": {"id": "565", "title": "INVRS (Algorithm 66)", "authors": "Caffrey, J.", "words_pool": ["algorithm", "invr", "caffrey"], "word_count": {"algorithm": 1, "invr": 1, "caffrey": 1}}, "566": {"id": "566", "title": "Matrix Inversion (Algorithm 58)", "authors": "Conger, R. A.", "words_pool": ["algorithm", "invers", "matrix", "conger"], "word_count": {"algorithm": 1, "invers": 1, "matrix": 1, "conger": 1}}, "567": {"id": "567", "title": "Logarithm of a Complex Number (Algorithm 48)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "complex", "logarithm", "number", "relph"], "word_count": {"algorithm": 1, "complex": 1, "logarithm": 1, "number": 1, "relph": 1}}, "568": {"id": "568", "title": "Exponential of a Complex Number (Algorithm 46)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "complex", "exponenti", "number", "relph"], "word_count": {"algorithm": 1, "complex": 1, "exponenti": 1, "number": 1, "relph": 1}}, "569": {"id": "569", "title": "Binomial Coefficients (Algorithm 19)", "authors": "Steck, B.", "words_pool": ["algorithm", "binomi", "coeffici", "steck"], "word_count": {"algorithm": 1, "binomi": 1, "coeffici": 1, "steck": 1}}, "570": {"id": "570", "title": "Simpson's Rule Integrator (Algorithm 103)", "authors": "Kuncir, G. F.", "words_pool": ["algorithm", "integr", "rule", "simpson", "kuncir"], "word_count": {"algorithm": 1, "integr": 1, "rule": 1, "simpson": 1, "kuncir": 1}}, "571": {"id": "571", "title": "Permutation in Lexicographical Order (Algorithm 102)", "authors": "Schrack, G. F. Shimrat, M.", "words_pool": ["algorithm", "lexicograph", "order", "permut", "schrack", "shimrat"], "word_count": {"algorithm": 1, "lexicograph": 1, "order": 1, "permut": 1, "schrack": 1, "shimrat": 1}}, "572": {"id": "572", "title": "Add Item to Chain-Linked List (Algorithm 100)", "authors": "Kiviat, P. J.", "words_pool": ["add", "algorithm", "chain", "item", "link", "list", "kiviat"], "word_count": {"add": 1, "algorithm": 1, "chain": 1, "item": 1, "link": 1, "list": 1, "kiviat": 1}}, "573": {"id": "573", "title": "Remove Item From Chain-Linked List (Algorithm 101)", "authors": "Kiviat, P. J.", "words_pool": ["algorithm", "chain", "item", "link", "list", "remov", "kiviat"], "word_count": {"algorithm": 1, "chain": 1, "item": 1, "link": 1, "list": 1, "remov": 1, "kiviat": 1}}, "574": {"id": "574", "title": "Evaluation of Jacobi Symbol (Algorithm 99)", "authors": "Garland, S. J. Knapp, A. W.", "words_pool": ["algorithm", "evalu", "jacobi", "symbol", "garland", "knapp"], "word_count": {"algorithm": 1, "evalu": 1, "jacobi": 1, "symbol": 1, "garland": 1, "knapp": 1}}, "575": {"id": "575", "title": "Evaluation of Definite Complex Line Integrals (Algorithm 98)", "authors": "Pfaltz, J. L.", "words_pool": ["algorithm", "complex", "definit", "evalu", "integr", "line", "pfaltz"], "word_count": {"algorithm": 1, "complex": 1, "definit": 1, "evalu": 1, "integr": 1, "line": 1, "pfaltz": 1}}, "576": {"id": "576", "title": "Shortest Path (Algorithm 97)", "authors": "Floyd, R. W.", "words_pool": ["algorithm", "path", "shortest", "floyd"], "word_count": {"algorithm": 1, "path": 1, "shortest": 1, "floyd": 1}}, "577": {"id": "577", "title": "ANCESTOR (Algorithm 96)", "authors": "Floyd, R. W.", "words_pool": ["algorithm", "ancestor", "floyd"], "word_count": {"algorithm": 1, "ancestor": 1, "floyd": 1}}, "578": {"id": "578", "title": "Generation of Partitions in Part-Count Form (Algorithm 95)", "authors": "Stockmal, F.", "words_pool": ["algorithm", "count", "form", "gener", "part", "partit", "stockmal"], "word_count": {"algorithm": 1, "count": 1, "form": 1, "gener": 1, "part": 1, "partit": 1, "stockmal": 1}}, "579": {"id": "579", "title": "COMBINATION (Algorithm 94)", "authors": "Kurtzberg, J.", "words_pool": ["algorithm", "combin", "kurtzberg"], "word_count": {"algorithm": 1, "combin": 1, "kurtzberg": 1}}, "580": {"id": "580", "title": "General Order Arithmetic (Algorithm 93)", "authors": "Perstein, M. H.", "words_pool": ["algorithm", "arithmet", "gener", "order", "perstein"], "word_count": {"algorithm": 1, "arithmet": 1, "gener": 1, "order": 1, "perstein": 1}}, "581": {"id": "581", "title": "A Note on Sampling a Tape-File", "authors": "Jones, T. G.", "words_pool": ["note", "sampl", "tape", "jone"], "word_count": {"note": 1, "sampl": 1, "tape": 1, "jone": 1}}, "582": {"id": "582", "title": "One Lost Bit", "authors": "Oster, C. A.", "words_pool": ["bit", "lost", "oster"], "word_count": {"bit": 1, "lost": 1, "oster": 1}}, "583": {"id": "583", "title": "A Redundancy Check for ALGOL Programs", "authors": "Thacher Jr., H. C.", "words_pool": ["algol", "check", "program", "redund", "thacher", "jr"], "word_count": {"algol": 1, "check": 1, "program": 1, "redund": 1, "thacher": 1, "jr": 1}}, "584": {"id": "584", "title": "Report on the Algorithmic Language FORTRAN II", "authors": "Rabinowitz, I. N.", "words_pool": ["algorithm", "fortran", "ii", "languag", "report", "rabinowitz"], "word_count": {"algorithm": 1, "fortran": 1, "ii": 1, "languag": 1, "report": 1, "rabinowitz": 1}}, "585": {"id": "585", "title": "Initial Experience With an Operating Multiprogramming System", "abstract": "The Lewis Research Center has been using various forms and degrees of program simultaneity  in the operation of its modified Sperry-Rand Univac Scientific Model 1103 computer during the last five  years.  This simultaneity has evolved from an initial achievement of self-searching input and output  to the automatic time sharing of independently coded problems.  Several important machine and program  system modifications were necessary to accomplish this evolution.  Several additional modifications,  although not required, were added to facilitate ease of coding and operation.  All modifications had  to proceed at a relatively temperate pace to insure that the basic data-reduction work load of the computing  center was completed on schedule.  Some educationally valuable mistakes were made, and their suggested  cures often pointed the way to useful future improvements or emphasized some of the basic principles  of a multiprogramming system.  The material that follows is a description of the evolution of the programming  and hardware system which has developed into the present multiprogramming system at Lewis research Center.", "authors": "Landis, N. Manos, A. Turner, L. R.", "words_pool": ["accomplish", "achiev", "ad", "addit", "automat", "basic", "center", "code", "code", "complet", "comput", "comput", "cure", "data", "degre", "descript", "develop", "eas", "educ", "emphas", "evolut", "evolv", "experi", "facilit", "follow", "form", "futur", "hardwar", "import", "improv", "independ", "initi", "input", "insur", "lewi", "load", "machin", "made", "materi", "mistak", "model", "modif", "modifi", "multiprogram", "oper", "oper", "output", "pace", "point", "present", "principl", "problem", "proceed", "program", "program", "rand", "reduct", "requir", "research", "schedul", "scientif", "search", "share", "simultan", "sperri", "suggest", "system", "temper", "time", "univac", "valuabl", "work", "year", "landi", "mano", "turner"], "word_count": {"accomplish": 1, "achiev": 1, "ad": 1, "addit": 1, "automat": 1, "basic": 2, "center": 3, "code": 2, "complet": 1, "comput": 2, "cure": 1, "data": 1, "degre": 1, "descript": 1, "develop": 1, "eas": 1, "educ": 1, "emphas": 1, "evolut": 2, "evolv": 1, "experi": 1, "facilit": 1, "follow": 1, "form": 1, "futur": 1, "hardwar": 1, "import": 1, "improv": 1, "independ": 1, "initi": 1, "input": 1, "insur": 1, "lewi": 2, "load": 1, "machin": 1, "made": 1, "materi": 1, "mistak": 1, "model": 1, "modif": 3, "modifi": 1, "multiprogram": 2, "oper": 2, "output": 1, "pace": 1, "point": 1, "present": 1, "principl": 1, "problem": 1, "proceed": 1, "program": 3, "rand": 1, "reduct": 1, "requir": 1, "research": 2, "schedul": 1, "scientif": 1, "search": 1, "share": 1, "simultan": 2, "sperri": 1, "suggest": 1, "system": 4, "temper": 1, "time": 1, "univac": 1, "valuabl": 1, "work": 1, "year": 1, "landi": 1, "mano": 1, "turner": 1}}, "586": {"id": "586", "title": "Simultaneous System of Equations and Matrix Inversion Routine (Algorithm 92)", "authors": "Roek, D. J.", "words_pool": ["algorithm", "equat", "invers", "matrix", "routin", "simultan", "system", "roek"], "word_count": {"algorithm": 1, "equat": 1, "invers": 1, "matrix": 1, "routin": 1, "simultan": 1, "system": 1, "roek": 1}}, "587": {"id": "587", "title": "Romberg Integration (Algorithm 60)", "authors": "Buchner, K. H.", "words_pool": ["algorithm", "integr", "romberg", "buchner"], "word_count": {"algorithm": 1, "integr": 1, "romberg": 1, "buchner": 1}}, "588": {"id": "588", "title": "Chebyshev Curve-Fit (Algorithm 91)", "authors": "Newhouse, A.", "words_pool": ["algorithm", "chebyshev", "curv", "fit", "newhous"], "word_count": {"algorithm": 1, "chebyshev": 1, "curv": 1, "fit": 1, "newhous": 1}}, "589": {"id": "589", "title": "Evaluation of the Fresnel Cosine Integral (Algorithm 90)", "authors": "Cundiff, J. L.", "words_pool": ["algorithm", "cosin", "evalu", "fresnel", "integr", "cundiff"], "word_count": {"algorithm": 1, "cosin": 1, "evalu": 1, "fresnel": 1, "integr": 1, "cundiff": 1}}, "590": {"id": "590", "title": "Evaluation of the Fresnel Sine Integral (Algorithm 89)", "authors": "Cundiff, J. L.", "words_pool": ["algorithm", "evalu", "fresnel", "integr", "sine", "cundiff"], "word_count": {"algorithm": 1, "evalu": 1, "fresnel": 1, "integr": 1, "sine": 1, "cundiff": 1}}, "591": {"id": "591", "title": "Evaluation of Asymptotic Expression for the Fresnel Sine and Cosine Integrals (Algorithm 88)", "authors": "Cundiff, J. L.", "words_pool": ["algorithm", "asymptot", "cosin", "evalu", "express", "fresnel", "integr", "sine", "cundiff"], "word_count": {"algorithm": 1, "asymptot": 1, "cosin": 1, "evalu": 1, "express": 1, "fresnel": 1, "integr": 1, "sine": 1, "cundiff": 1}}, "592": {"id": "592", "title": "COBOL Batching Problems", "authors": "Mullen, J. W.", "words_pool": ["batch", "cobol", "problem", "mullen"], "word_count": {"batch": 1, "cobol": 1, "problem": 1, "mullen": 1}}, "593": {"id": "593", "title": "An Introduction to a Machine-Independent Data Division", "authors": "Mullin, J. P.", "words_pool": ["data", "divis", "independ", "introduct", "machin", "mullin"], "word_count": {"data": 1, "divis": 1, "independ": 1, "introduct": 1, "machin": 1, "mullin": 1}}, "594": {"id": "594", "title": "An Advanced Input-Output System for a COBOL Compiler", "authors": "Bouman, C. A.", "words_pool": ["advanc", "cobol", "compil", "input", "output", "system", "bouman"], "word_count": {"advanc": 1, "cobol": 1, "compil": 1, "input": 1, "output": 1, "system": 1, "bouman": 1}}, "595": {"id": "595", "title": "Guides to Teaching COBOL", "abstract": "The teaching of COBOL can be divided into three main subject areas.  They are the syntax of  COBOL, the use of such syntax in solving any given problem, and programming concepts.  It is generally  accepted that some knowledge of the hardware and computer logic must be possessed by the programmer.   The teaching problem arises in determining how thoroughly a student must know the hardware and logic  for that computer for which he will write COBOL programs.  Unfortunately, historical data concerning  students' programming proficiency is almost non-existent and, at best, difficult to measure.  How then  might we approach solving this problem?", "authors": "Greene, I.", "words_pool": ["accept", "approach", "area", "aris", "cobol", "comput", "concept", "concern", "data", "determin", "difficult", "divid", "exist", "gener", "guid", "hardwar", "histor", "know", "knowledg", "logic", "main", "measur", "non", "possess", "problem", "profici", "programm", "program", "program", "solv", "student", "student", "subject", "syntax", "teach", "unfortun", "write", "green"], "word_count": {"accept": 1, "approach": 1, "area": 1, "aris": 1, "cobol": 3, "comput": 2, "concept": 1, "concern": 1, "data": 1, "determin": 1, "difficult": 1, "divid": 1, "exist": 1, "gener": 1, "guid": 1, "hardwar": 2, "histor": 1, "know": 1, "knowledg": 1, "logic": 2, "main": 1, "measur": 1, "non": 1, "possess": 1, "problem": 3, "profici": 1, "programm": 1, "program": 3, "solv": 2, "student": 2, "subject": 1, "syntax": 2, "teach": 2, "unfortun": 1, "write": 1, "green": 1}}, "596": {"id": "596", "title": "Floating-Point Arithmetic in COBOL", "abstract": "In this paper the basic operations of floating-point arithmetic are examined and COBOL procedures  for carrying these out are given, along with specification of working storage.  The paper concludes with  an example in which these procedures are used.", "authors": "Kesner, O.", "words_pool": ["arithmet", "basic", "carri", "cobol", "conclud", "examin", "float", "oper", "paper", "point", "procedur", "specif", "storag", "work", "kesner"], "word_count": {"arithmet": 1, "basic": 1, "carri": 1, "cobol": 1, "conclud": 1, "examin": 1, "float": 1, "oper": 1, "paper": 2, "point": 1, "procedur": 2, "specif": 1, "storag": 1, "work": 1, "kesner": 1}}, "597": {"id": "597", "title": "Modular Data Processing Systems Written in COBOL", "authors": "Emery, J. C.", "words_pool": ["cobol", "data", "modular", "process", "system", "written", "emeri"], "word_count": {"cobol": 1, "data": 1, "modular": 1, "process": 1, "system": 1, "written": 1, "emeri": 1}}, "598": {"id": "598", "title": "The COBOL Librarian - A Key to Object Program Efficiency", "abstract": "Many answers to the question \"How may a COBOL Compiler be forced into the generation of an  efficient object program?\"  The purpose of this article is to present one possible answer: the creation  and full utilization of a well-constructed COBOL Library.", "authors": "Hicks, W.", "words_pool": ["answer", "answer", "articl", "cobol", "compil", "construct", "creation", "effici", "effici", "forc", "full", "gener", "key", "librarian", "librari", "object", "present", "program", "purpos", "question", "util", "hick"], "word_count": {"answer": 2, "articl": 1, "cobol": 2, "compil": 1, "construct": 1, "creation": 1, "effici": 1, "forc": 1, "full": 1, "gener": 1, "key": 1, "librarian": 1, "librari": 1, "object": 1, "present": 1, "program": 1, "purpos": 1, "question": 1, "util": 1, "hick": 1}}, "599": {"id": "599", "title": "A Report Writer For COBOL", "authors": "Donally, W. L.", "words_pool": ["cobol", "report", "writer", "donal"], "word_count": {"cobol": 1, "report": 1, "writer": 1, "donal": 1}}, "600": {"id": "600", "title": "Syntactical Charts of COBOL 61", "authors": "Berman, R. Sharp, J. Sturges, L.", "words_pool": ["chart", "cobol", "syntact", "berman", "sharp", "sturg"], "word_count": {"chart": 1, "cobol": 1, "syntact": 1, "berman": 1, "sharp": 1, "sturg": 1}}, "601": {"id": "601", "title": "Interim Report on Bureau of Ships COBOL Evaluation Program", "authors": "Siegel, M. Smith, A. E.", "words_pool": ["bureau", "cobol", "evalu", "interim", "program", "report", "ship", "siegel", "smith"], "word_count": {"bureau": 1, "cobol": 1, "evalu": 1, "interim": 1, "program": 1, "report": 1, "ship": 1, "siegel": 1, "smith": 1}}, "602": {"id": "602", "title": "COBOL and Compatibility", "authors": "Lippitt, A.", "words_pool": ["cobol", "compat", "lippitt"], "word_count": {"cobol": 1, "compat": 1, "lippitt": 1}}, "603": {"id": "603", "title": "Basic Elements of COBOL 61", "authors": "Sammet, J. E.", "words_pool": ["basic", "cobol", "element", "sammet"], "word_count": {"basic": 1, "cobol": 1, "element": 1, "sammet": 1}}, "604": {"id": "604", "title": "Why COBOL?", "authors": "Cunningham, J. F.", "words_pool": ["cobol", "cunningham"], "word_count": {"cobol": 1, "cunningham": 1}}, "605": {"id": "605", "title": "Computer Simulation Of City Traffic", "abstract": "In simulating traffic flow on city streets, the National Bureau of Standards has used data  processing techniques to tabulate and make motion pictures of vehicle movements in the model.  Each vehicle  is assigned a digital identification giving points of entry and exit, type of vehicle, desired speed,  and actual speed, in proportions simulating field data.  Changes in the model can be made to observe  their consequences and to determine the ability of a real street to carry loads expected in the future.", "words_pool": ["abil", "actual", "assign", "bureau", "carri", "citi", "comput", "consequ", "data", "desir", "determin", "digit", "entri", "exit", "expect", "field", "flow", "futur", "give", "identif", "load", "made", "make", "model", "motion", "movement", "nation", "observ", "pictur", "point", "process", "proport", "real", "simul", "simul", "speed", "standard", "street", "street", "tabul", "techniqu", "traffic", "type", "vehicl"], "word_count": {"abil": 1, "actual": 1, "assign": 1, "bureau": 1, "carri": 1, "citi": 1, "comput": 1, "consequ": 1, "data": 2, "desir": 1, "determin": 1, "digit": 1, "entri": 1, "exit": 1, "expect": 1, "field": 1, "flow": 1, "futur": 1, "give": 1, "identif": 1, "load": 1, "made": 1, "make": 1, "model": 2, "motion": 1, "movement": 1, "nation": 1, "observ": 1, "pictur": 1, "point": 1, "process": 1, "proport": 1, "real": 1, "simul": 2, "speed": 2, "standard": 1, "street": 2, "tabul": 1, "techniqu": 1, "traffic": 1, "type": 1, "vehicl": 3}}, "606": {"id": "606", "title": "A Method for Eliminating Ambiguity Due to Signal Coincidence in Digital Design", "authors": "Kaiser, C. J.", "words_pool": ["ambigu", "coincid", "design", "digit", "due", "elimin", "method", "signal", "kaiser"], "word_count": {"ambigu": 1, "coincid": 1, "design": 1, "digit": 1, "due": 1, "elimin": 1, "method": 1, "signal": 1, "kaiser": 1}}, "607": {"id": "607", "title": "The Calculation of Easter...", "authors": "Knuth, D.", "words_pool": ["calcul", "easter", "knuth"], "word_count": {"calcul": 1, "easter": 1, "knuth": 1}}, "608": {"id": "608", "title": "Permutation (Algorithm 71)", "authors": "Peck, J. E. L. Schrack, G. F.", "words_pool": ["algorithm", "permut", "peck", "schrack"], "word_count": {"algorithm": 1, "permut": 1, "peck": 1, "schrack": 1}}, "609": {"id": "609", "title": "Permutation (Algorithm 71)", "authors": "Brown, P. J.", "words_pool": ["algorithm", "permut", "brown"], "word_count": {"algorithm": 1, "permut": 1, "brown": 1}}, "610": {"id": "610", "title": "SIEVE (Algorithm 35)", "authors": "Brown, P. J.", "words_pool": ["algorithm", "siev", "brown"], "word_count": {"algorithm": 1, "siev": 1, "brown": 1}}, "611": {"id": "611", "title": "Permutation Generator (Algorithm 87)", "authors": "Howell, J. R.", "words_pool": ["algorithm", "gener", "permut", "howel"], "word_count": {"algorithm": 1, "gener": 1, "permut": 1, "howel": 1}}, "612": {"id": "612", "title": "Permute (Algorithm 86)", "authors": "Peck, J. E. L. Schrack, G. F.", "words_pool": ["algorithm", "permut", "peck", "schrack"], "word_count": {"algorithm": 1, "permut": 1, "peck": 1, "schrack": 1}}, "613": {"id": "613", "title": "JACOBI (Algorithm 85)", "authors": "Evans, T. G.", "words_pool": ["algorithm", "jacobi", "evan"], "word_count": {"algorithm": 1, "jacobi": 1, "evan": 1}}, "614": {"id": "614", "title": "Simpson's Integration (Algorithm 84)", "authors": "Hennion, P. E.", "words_pool": ["algorithm", "integr", "simpson", "hennion"], "word_count": {"algorithm": 1, "integr": 1, "simpson": 1, "hennion": 1}}, "615": {"id": "615", "title": "Addressing Multidimensional Arrays", "abstract": "A useful method of representing a function of n variables is to consider the function to assume  its values at selected points in n-dimensional space.  Although this picture is of value to the analyst,  the elements of an n-dimensional array must exist in conventional storage as a linear array or vector.   The means of performing the transformation of a set of indices locating on array element in n-space  to the location (address) of the element in its storage vector is the subject of this paper.  It is noted  that the index address transformation is computationally identical to the conversion of a number from  a fixed to a mixed radix number system.  Several ways of implementing the transformation are described.", "authors": "Hellerman, H.", "words_pool": ["address", "address", "analyst", "array", "array", "assum", "comput", "consid", "convent", "convers", "dimension", "element", "element", "exist", "fix", "function", "ident", "implement", "index", "indic", "linear", "locat", "locat", "mean", "method", "mix", "multidimension", "note", "number", "paper", "perform", "pictur", "point", "radix", "repres", "select", "set", "space", "storag", "subject", "system", "transform", "valu", "variabl", "vector", "way", "hellerman"], "word_count": {"address": 2, "analyst": 1, "array": 3, "assum": 1, "comput": 1, "consid": 1, "convent": 1, "convers": 1, "dimension": 2, "element": 3, "exist": 1, "fix": 1, "function": 2, "ident": 1, "implement": 1, "index": 1, "indic": 1, "linear": 1, "locat": 2, "mean": 1, "method": 1, "mix": 1, "multidimension": 1, "note": 1, "number": 2, "paper": 1, "perform": 1, "pictur": 1, "point": 1, "radix": 1, "repres": 1, "select": 1, "set": 1, "space": 2, "storag": 2, "subject": 1, "system": 1, "transform": 3, "valu": 1, "variabl": 1, "vector": 2, "way": 1, "hellerman": 1}}, "616": {"id": "616", "title": "An Information Algebra - Phase I Report-Language Structure Group of the CODASYL Development Committee", "abstract": "This report represents the results of the first phase of the work of the Language Structure  Group.  The goal of this work is to arrive at a proper structure for a machine-independent problem-defining  language, at the systems level of data processing.  The report is based, for the most part, on a mathematical  model called \"An Information Algebra\" developed primarily by R. Bosak.  It is hoped that this report  will be read (a) with avid interest by programming language designers and implementors, and all those  interested in developing a theoretical approach to data processing; (b) with interest and understanding  by professional programmers and systems analysts; and (c) with appreciation by the businessman-analyst-manager.   The authors have not attempted an exhaustive discourse in this report.  Rather, they have tried to present  a philosophy to the professional people who are vitally concerned with providing a working language for  the systems analyst's use.  They trust that the ideas in this report will stimulate others to think along  similar lines.  Questions and comments will be welcomed, and can be addressed to any of the members of  the Language Structure Group:  Robert Bosak, System Development Corporation;  Richard F. Clippinger,  Honeywell EDP Division;  Carey Dobbs, Remington Rand Univac Division;  Roy Goldfinger (Chairman), IBM  Corporation;  Renee B. Jasper, Navy Management Office;  William Keating, National Cash Register;  George  Kendrick, General Electric Company;  Jean E. Sammet, IBM Corporation.", "words_pool": ["address", "algebra", "analyst", "analyst", "appreci", "approach", "arriv", "attempt", "author", "avid", "base", "bosak", "businessman", "call", "carey", "cash", "chairman", "clipping", "codasyl", "comment", "committe", "compani", "concern", "corpor", "data", "defin", "design", "develop", "develop", "develop", "discours", "divis", "dobb", "edp", "electr", "exhaust", "gener", "georg", "goal", "goldfing", "group", "honeywel", "hope", "ibm", "idea", "implementor", "independ", "inform", "interest", "interest", "jasper", "jean", "keat", "kendrick", "languag", "level", "line", "machin", "manag", "manag", "mathemat", "member", "model", "nation", "navi", "offic", "part", "peopl", "phase", "philosophi", "present", "primarili", "problem", "process", "profession", "programm", "program", "proper", "provid", "question", "rand", "read", "regist", "remington", "rene", "report", "repres", "result", "richard", "robert", "roy", "sammet", "similar", "stimul", "structur", "system", "system", "theoret", "think", "tri", "trust", "understand", "univac", "vital", "welcom", "william", "work", "work"], "word_count": {"address": 1, "algebra": 1, "analyst": 3, "appreci": 1, "approach": 1, "arriv": 1, "attempt": 1, "author": 1, "avid": 1, "base": 1, "bosak": 2, "businessman": 1, "call": 1, "carey": 1, "cash": 1, "chairman": 1, "clipping": 1, "codasyl": 1, "comment": 1, "committe": 1, "compani": 1, "concern": 1, "corpor": 3, "data": 2, "defin": 1, "design": 1, "develop": 3, "discours": 1, "divis": 2, "dobb": 1, "edp": 1, "electr": 1, "exhaust": 1, "gener": 1, "georg": 1, "goal": 1, "goldfing": 1, "group": 2, "honeywel": 1, "hope": 1, "ibm": 2, "idea": 1, "implementor": 1, "independ": 1, "inform": 1, "interest": 3, "jasper": 1, "jean": 1, "keat": 1, "kendrick": 1, "languag": 5, "level": 1, "line": 1, "machin": 1, "manag": 2, "mathemat": 1, "member": 1, "model": 1, "nation": 1, "navi": 1, "offic": 1, "part": 1, "peopl": 1, "phase": 1, "philosophi": 1, "present": 1, "primarili": 1, "problem": 1, "process": 2, "profession": 2, "programm": 1, "program": 1, "proper": 1, "provid": 1, "question": 1, "rand": 1, "read": 1, "regist": 1, "remington": 1, "rene": 1, "report": 5, "repres": 1, "result": 1, "richard": 1, "robert": 1, "roy": 1, "sammet": 1, "similar": 1, "stimul": 1, "structur": 3, "system": 4, "theoret": 1, "think": 1, "tri": 1, "trust": 1, "understand": 1, "univac": 1, "vital": 1, "welcom": 1, "william": 1, "work": 3}}, "617": {"id": "617", "title": "POSEIDON", "abstract": "Any computer that forms part of a control system-whether completely automatic or partly human-must  work at the same speed as the control system.  It must perform its calculations or data processing fast  enough for the results to be available at the required instants in the action of the control system.   This known as working in \"real time.\"", "authors": "Wheeling, R. F.", "words_pool": ["action", "automat", "calcul", "complet", "comput", "control", "data", "fast", "form", "human", "instant", "known", "part", "partli", "perform", "poseidon", "process", "real", "requir", "result", "speed", "system", "time", "work", "work", "wheel"], "word_count": {"action": 1, "automat": 1, "calcul": 1, "complet": 1, "comput": 1, "control": 3, "data": 1, "fast": 1, "form": 1, "human": 1, "instant": 1, "known": 1, "part": 1, "partli": 1, "perform": 1, "poseidon": 1, "process": 1, "real": 1, "requir": 1, "result": 1, "speed": 1, "system": 3, "time": 1, "work": 2, "wheel": 1}}, "618": {"id": "618", "title": "Computers- The Key to Total Systems Control: An Industrial Viewpoint", "abstract": "Man-Man-machine processes are characterized in five main types, and the markets for each type are  shown for 1950 and 1960 and estimated for 1970.", "authors": "Carlson, W. M.", "words_pool": ["character", "comput", "control", "estim", "industri", "key", "machin", "main", "man", "market", "process", "shown", "system", "total", "type", "type", "viewpoint", "carlson"], "word_count": {"character": 1, "comput": 1, "control": 1, "estim": 1, "industri": 1, "key": 1, "machin": 1, "main": 1, "man": 2, "market": 1, "process": 1, "shown": 1, "system": 1, "total": 1, "type": 2, "viewpoint": 1, "carlson": 1}}, "619": {"id": "619", "title": "Retrieval of Misspelled Names in an Airlines Passenger Record System", "abstract": "This paper discusses the limited problem of recognition and retrieval of a given misspelled  name from among a roster of several hundred names, such as the reservation inventory for a given flight  of a large jet airliner.  A program has been developed and operated on the Telefile (a stored-program  core and drum memory solid-state computer) which will retrieve passengers' records successfully, despite  significant misspellings either at original entry time or at retrieval time.  The procedure involves  an automatic scoring technique which matches the names in a condensed form. Only those few names most  closely resembling the requested name, with their phone numbers annexed, are presented for the agents  final manual selecton.  The program has successfully isolated and retrieved names which were subjected  to a number of unusual (as well as usual) misspellings.", "authors": "Davidson, L.", "words_pool": ["agent", "airlin", "airlin", "annex", "automat", "close", "comput", "condens", "core", "despit", "develop", "discuss", "drum", "entri", "final", "flight", "form", "hundr", "inventori", "involv", "isol", "jet", "larg", "limit", "match", "memori", "misspel", "misspel", "name", "number", "number", "oper", "origin", "paper", "passeng", "passeng", "phone", "present", "problem", "procedur", "program", "recognit", "record", "record", "request", "resembl", "reserv", "retriev", "retriev", "retriev", "roster", "score", "selecton", "signific", "solid", "state", "store", "subject", "success", "system", "techniqu", "telefil", "time", "unusu", "usual", "davidson"], "word_count": {"agent": 1, "airlin": 1, "annex": 1, "automat": 1, "close": 1, "comput": 1, "condens": 1, "core": 1, "despit": 1, "develop": 1, "discuss": 1, "drum": 1, "entri": 1, "final": 1, "flight": 1, "form": 1, "hundr": 1, "inventori": 1, "involv": 1, "isol": 1, "jet": 1, "larg": 1, "limit": 1, "match": 1, "memori": 1, "misspel": 3, "name": 4, "number": 2, "oper": 1, "origin": 1, "paper": 1, "passeng": 1, "phone": 1, "present": 1, "problem": 1, "procedur": 1, "program": 3, "recognit": 1, "record": 1, "request": 1, "resembl": 1, "reserv": 1, "retriev": 4, "roster": 1, "score": 1, "selecton": 1, "signific": 1, "solid": 1, "state": 1, "store": 1, "subject": 1, "success": 2, "system": 1, "techniqu": 1, "telefil": 1, "time": 2, "unusu": 1, "usual": 1, "davidson": 1}}, "620": {"id": "620", "title": "RATFACT (Algorithm 78)", "authors": "Halstead, M. H.", "words_pool": ["algorithm", "ratfact", "halstead"], "word_count": {"algorithm": 1, "ratfact": 1, "halstead": 1}}, "621": {"id": "621", "title": "Romberg Integration (Algorithm 60)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "integr", "romberg", "thacher", "jr"], "word_count": {"algorithm": 1, "integr": 1, "romberg": 1, "thacher": 1, "jr": 1}}, "622": {"id": "622", "title": "Optimal Classification of Objects (Algorithm 83)", "authors": "Mayoh, B. H.", "words_pool": ["algorithm", "classif", "object", "optim", "mayoh"], "word_count": {"algorithm": 1, "classif": 1, "object": 1, "optim": 1, "mayoh": 1}}, "623": {"id": "623", "title": "Economising a Sequence 2 (Algorithm 82)", "authors": "Mayoh, B. H.", "words_pool": ["algorithm", "economis", "sequenc", "mayoh"], "word_count": {"algorithm": 1, "economis": 1, "sequenc": 1, "mayoh": 1}}, "624": {"id": "624", "title": "Economising a Sequence 1 (Algorithm 81)", "authors": "Mayoh, B. H.", "words_pool": ["algorithm", "economis", "sequenc", "mayoh"], "word_count": {"algorithm": 1, "economis": 1, "sequenc": 1, "mayoh": 1}}, "625": {"id": "625", "title": "Reciprocal Gamma Function of Real Argument (Algorithm 80)", "authors": "Holsten, W.", "words_pool": ["algorithm", "argument", "function", "gamma", "real", "reciproc", "holsten"], "word_count": {"algorithm": 1, "argument": 1, "function": 1, "gamma": 1, "real": 1, "reciproc": 1, "holsten": 1}}, "626": {"id": "626", "title": "A Method of Representation, Storage and Retrieval of 13 Random Codes in a 4-Digit Number or 16  Random Codes in a 5-Digit Number", "authors": "Foster, M. B.", "words_pool": ["code", "digit", "method", "number", "random", "represent", "retriev", "storag", "foster"], "word_count": {"code": 2, "digit": 2, "method": 1, "number": 2, "random": 2, "represent": 1, "retriev": 1, "storag": 1, "foster": 1}}, "627": {"id": "627", "title": "Knotted List Structures", "authors": "Weizenbaum, J.", "words_pool": ["knot", "list", "structur", "weizenbaum"], "word_count": {"knot": 1, "list": 1, "structur": 1, "weizenbaum": 1}}, "628": {"id": "628", "title": "On a Floating-Point Number Representation For Use with Algorithmic Languages", "authors": "Grau, A. A.", "words_pool": ["algorithm", "float", "languag", "number", "point", "represent", "grau"], "word_count": {"algorithm": 1, "float": 1, "languag": 1, "number": 1, "point": 1, "represent": 1, "grau": 1}}, "629": {"id": "629", "title": "On a Wired-In Binary-to-Decimal Conversion Scheme", "authors": "Lynch, W. C.", "words_pool": ["binari", "convers", "decim", "scheme", "wire", "lynch"], "word_count": {"binari": 1, "convers": 1, "decim": 1, "scheme": 1, "wire": 1, "lynch": 1}}, "630": {"id": "630", "title": "An Evaluation of Autocode Readability", "abstract": "Of the many requirements of an autocode, the pair of requirements \"easy to read\" and \"easy  to write\" are not often compatible.  This paper argues that readability can be added automatically in  the translation process so that the programmer can enjoy the utmost economy of expression, while for  management a full and valid COBOL version is printed to give all the advantages of readability and compatibility.", "authors": "Ellis, P. V.", "words_pool": ["ad", "advantag", "argu", "autocod", "cobol", "compat", "compat", "easi", "economi", "enjoy", "evalu", "express", "full", "give", "manag", "pair", "paper", "print", "process", "programm", "read", "readabl", "requir", "translat", "utmost", "valid", "version", "write", "elli"], "word_count": {"ad": 1, "advantag": 1, "argu": 1, "autocod": 1, "cobol": 1, "compat": 2, "easi": 2, "economi": 1, "enjoy": 1, "evalu": 1, "express": 1, "full": 1, "give": 1, "manag": 1, "pair": 1, "paper": 1, "print": 1, "process": 1, "programm": 1, "read": 1, "readabl": 2, "requir": 2, "translat": 1, "utmost": 1, "valid": 1, "version": 1, "write": 1, "elli": 1}}, "631": {"id": "631", "title": "Automatic-Programming-Language Translation Through Syntactical Analysis*", "authors": "Ledley, R.S. Wilson, J. B.", "words_pool": ["analysi", "automat", "languag", "program", "syntact", "translat", "ledley", "wilson"], "word_count": {"analysi": 1, "automat": 1, "languag": 1, "program": 1, "syntact": 1, "translat": 1, "ledley": 1, "wilson": 1}}, "632": {"id": "632", "title": "Vectorcardiographic Diagnosis With The Aid of ALGOL", "authors": "Forsythe, G. E. Von Der Groeben, J. Toole, J. G.", "words_pool": ["aid", "algol", "diagnosi", "vectorcardiograph", "forsyth", "von", "der", "groeben", "tool"], "word_count": {"aid": 1, "algol": 1, "diagnosi": 1, "vectorcardiograph": 1, "forsyth": 1, "von": 1, "der": 1, "groeben": 1, "tool": 1}}, "633": {"id": "633", "title": "Simulation and Analysis of Biochemical Systems (III. Analysis and Pattern Recognition)", "authors": "Garfinkel, D. Polk, W. Higgins, J. J. Ochser, R. T.", "words_pool": ["analysi", "biochem", "iii", "pattern", "recognit", "simul", "system", "garfinkel", "polk", "higgin", "ochser"], "word_count": {"analysi": 2, "biochem": 1, "iii": 1, "pattern": 1, "recognit": 1, "simul": 1, "system": 1, "garfinkel": 1, "polk": 1, "higgin": 1, "ochser": 1}}, "634": {"id": "634", "title": "Manipulation of Trees in Information Retrieval*", "authors": "Salton, G.", "words_pool": ["inform", "manipul", "retriev", "tree", "salton"], "word_count": {"inform": 1, "manipul": 1, "retriev": 1, "tree": 1, "salton": 1}}, "635": {"id": "635", "title": "A Note on Multiplying Boolean Matrices", "authors": "Baker, J. J.", "words_pool": ["boolean", "matric", "multipli", "note", "baker"], "word_count": {"boolean": 1, "matric": 1, "multipli": 1, "note": 1, "baker": 1}}, "636": {"id": "636", "title": "Tape Splitting in an Iterative Program", "authors": "Weisert, C.", "words_pool": ["iter", "program", "split", "tape", "weisert"], "word_count": {"iter": 1, "program": 1, "split": 1, "tape": 1, "weisert": 1}}, "637": {"id": "637", "title": "A NELIAC-Generated 7090-1401 Compiler", "abstract": "NELIAC systems for several different machines have been generated using the original NELIAC  system developed at the Naval Electronics Laboratory, San Diego, in 1958.  A basic \"bootstrap\" process  was used to generate all but the first, i.e. the systems were described in the NELIAC language and generated  by an existing NELIAC compiler.  This experience has shown there is no inherent difficulty in \"building  compilers with compilers\"; indeed, it pointed out many advantages in using a POL for constructing programming  systems.  This report presents the results of a project completed in May, 1961 in which the NELIAC system  was used to generate a compiler for the IBM 1401.  The 1401 compiler, which runs on the 7090 and produces  1401 programs, was described in the NELIAC language and generated with 7090 NELIAC system.  The reduction  in programming time and the improvement in documentation of the system were very significant.", "authors": "Watt, J. B. Wattenburg, W. H.", "words_pool": ["advantag", "basic", "bootstrap", "build", "compil", "compil", "complet", "construct", "develop", "diego", "difficulti", "document", "electron", "exist", "experi", "gener", "gener", "ibm", "improv", "inher", "laboratori", "languag", "machin", "naval", "neliac", "origin", "point", "pol", "present", "process", "produc", "program", "program", "project", "reduct", "report", "result", "run", "san", "shown", "signific", "system", "system", "time", "watt", "wattenburg"], "word_count": {"advantag": 1, "basic": 1, "bootstrap": 1, "build": 1, "compil": 5, "complet": 1, "construct": 1, "develop": 1, "diego": 1, "difficulti": 1, "document": 1, "electron": 1, "exist": 1, "experi": 1, "gener": 5, "ibm": 1, "improv": 1, "inher": 1, "laboratori": 1, "languag": 2, "machin": 1, "naval": 1, "neliac": 7, "origin": 1, "point": 1, "pol": 1, "present": 1, "process": 1, "produc": 1, "program": 3, "project": 1, "reduct": 1, "report": 1, "result": 1, "run": 1, "san": 1, "shown": 1, "signific": 1, "system": 7, "time": 1, "watt": 1, "wattenburg": 1}}, "638": {"id": "638", "title": "SURGE: A Recoding of the COBOL Merchandise Control Algorithm", "authors": "Longo, L. F.", "words_pool": ["algorithm", "cobol", "control", "merchandis", "recod", "surg", "longo"], "word_count": {"algorithm": 1, "cobol": 1, "control": 1, "merchandis": 1, "recod": 1, "surg": 1, "longo": 1}}, "639": {"id": "639", "title": "Difference Expression Coefficients (Algorithm 79)", "authors": "Giammo, T. P.", "words_pool": ["algorithm", "coeffici", "differ", "express", "giammo"], "word_count": {"algorithm": 1, "coeffici": 1, "differ": 1, "express": 1, "giammo": 1}}, "640": {"id": "640", "title": "Rational Roots of Polynomials with Integer Coefficients (Algorithm 78)", "authors": "Perry, C.", "words_pool": ["algorithm", "coeffici", "integ", "polynomi", "ration", "root", "perri"], "word_count": {"algorithm": 1, "coeffici": 1, "integ": 1, "polynomi": 1, "ration": 1, "root": 1, "perri": 1}}, "641": {"id": "641", "title": "Interpolation, Differentiation, and Integration (Algorithm 77)", "authors": "Hennion, P. E.", "words_pool": ["algorithm", "differenti", "integr", "interpol", "hennion"], "word_count": {"algorithm": 1, "differenti": 1, "integr": 1, "interpol": 1, "hennion": 1}}, "642": {"id": "642", "title": "An Introduction to ALGOL", "authors": "Schwarz, H. R.", "words_pool": ["algol", "introduct", "schwarz"], "word_count": {"algol": 1, "introduct": 1, "schwarz": 1}}, "643": {"id": "643", "title": "Simulation and Analysis of Biochemcial Systems (II. Solution of Differential Equations)", "authors": "Larson, R. Sellers, P. Meyer, R.", "words_pool": ["analysi", "biochemci", "differenti", "equat", "ii", "simul", "solut", "system", "larson", "seller", "meyer"], "word_count": {"analysi": 1, "biochemci": 1, "differenti": 1, "equat": 1, "ii": 1, "simul": 1, "solut": 1, "system": 1, "larson": 1, "seller": 1, "meyer": 1}}, "644": {"id": "644", "title": "A String Language for Symbol Manipulation Based on ALGOL 60", "abstract": "An artificial computer programming language is proposed for describing the manipulation of  strings of characters and symbols.  The concept of strings, introduced in the ALGOL 60 report, is extended  by adding: (1) the declaration of strings, substrings, and string arrays with explicit lengths; (2) the  ability to concatenate and shift strings; and (3) the ranking of symbols for comparing stings in Boolean  relations.  A primer or informal description of the language is followed by examples, a description of  experiments with the language on an IBM 704 computer, and a formal description which, taken with the  ALGOL 60 Report, defines the proposed string language.", "authors": "Wegstein, J. H. Youden, W. W.", "words_pool": ["abil", "ad", "algol", "array", "artifici", "base", "boolean", "charact", "compar", "comput", "concaten", "concept", "declar", "defin", "describ", "descript", "exampl", "experi", "explicit", "extend", "formal", "ibm", "inform", "introduc", "languag", "length", "manipul", "primer", "program", "propos", "rank", "relat", "report", "shift", "sting", "string", "string", "substr", "symbol", "symbol", "wegstein", "youden"], "word_count": {"abil": 1, "ad": 1, "algol": 2, "array": 1, "artifici": 1, "base": 1, "boolean": 1, "charact": 1, "compar": 1, "comput": 2, "concaten": 1, "concept": 1, "declar": 1, "defin": 1, "describ": 1, "descript": 3, "exampl": 1, "experi": 1, "explicit": 1, "extend": 1, "formal": 1, "ibm": 1, "inform": 1, "introduc": 1, "languag": 4, "length": 1, "manipul": 1, "primer": 1, "program": 1, "propos": 2, "rank": 1, "relat": 1, "report": 2, "shift": 1, "sting": 1, "string": 6, "substr": 1, "symbol": 2, "wegstein": 1, "youden": 1}}, "645": {"id": "645", "title": "INVRS (Algorithm 66)", "authors": "Randell, B. Broyden, C. G.", "words_pool": ["algorithm", "invr", "randel", "broyden"], "word_count": {"algorithm": 1, "invr": 1, "randel": 1, "broyden": 1}}, "646": {"id": "646", "title": "Inverse of a Finite Segment of the Hilbert Matrix (Algorithm 50)", "authors": "Randell, B.", "words_pool": ["algorithm", "finit", "hilbert", "invers", "matrix", "segment", "randel"], "word_count": {"algorithm": 1, "finit": 1, "hilbert": 1, "invers": 1, "matrix": 1, "segment": 1, "randel": 1}}, "647": {"id": "647", "title": "Numerical Solution of the Polynomial Equation (Algorithm 30)", "authors": "Cohen, K. J.", "words_pool": ["algorithm", "equat", "numer", "polynomi", "solut", "cohen"], "word_count": {"algorithm": 1, "equat": 1, "numer": 1, "polynomi": 1, "solut": 1, "cohen": 1}}, "648": {"id": "648", "title": "Sorting Procedures (Algorithm 76)", "authors": "Flores, I.", "words_pool": ["algorithm", "procedur", "sort", "flore"], "word_count": {"algorithm": 1, "procedur": 1, "sort": 1, "flore": 1}}, "649": {"id": "649", "title": "FACTORS (Algorithm 75)", "authors": "Peck, J. E. L.", "words_pool": ["algorithm", "factor", "peck"], "word_count": {"algorithm": 1, "factor": 1, "peck": 1}}, "650": {"id": "650", "title": "Curve Fitting with Constraints (Algorithm 74)", "authors": "Peck, J. E. L.", "words_pool": ["algorithm", "constraint", "curv", "fit", "peck"], "word_count": {"algorithm": 1, "constraint": 1, "curv": 1, "fit": 1, "peck": 1}}, "651": {"id": "651", "title": "A Survey of Languages and Systems for Information Retrieval", "authors": "Grems, M.", "words_pool": ["inform", "languag", "retriev", "survey", "system", "grem"], "word_count": {"inform": 1, "languag": 1, "retriev": 1, "survey": 1, "system": 1, "grem": 1}}, "652": {"id": "652", "title": "Use of Semantic Structure in Information Systems", "authors": "Sable, J. D.", "words_pool": ["inform", "semant", "structur", "system", "sabl"], "word_count": {"inform": 1, "semant": 1, "structur": 1, "system": 1, "sabl": 1}}, "653": {"id": "653", "title": "Translation of Retrieval Requests Couched in a \"Semiformal\" English-Like Language*", "authors": "Cheatham Jr., T. E. Warshall, S.", "words_pool": ["couch", "english", "languag", "request", "retriev", "semiform", "translat", "cheatham", "jr", "warshal"], "word_count": {"couch": 1, "english": 1, "languag": 1, "request": 1, "retriev": 1, "semiform": 1, "translat": 1, "cheatham": 1, "jr": 1, "warshal": 1}}, "654": {"id": "654", "title": "Language Problems Posed by Heavily Structured Data", "authors": "Barnes, R. F.", "words_pool": ["data", "heavili", "languag", "pose", "problem", "structur", "barn"], "word_count": {"data": 1, "heavili": 1, "languag": 1, "pose": 1, "problem": 1, "structur": 1, "barn": 1}}, "655": {"id": "655", "title": "COMIT as an IR Language", "abstract": "Many of the features that make COMIT a good all around symbol manipulation language also render  it well suited to various types of information retrieval programs.  Presented here is a general discussion  of this unique and different programming language and an examination of some of its applications.", "authors": "Yngve, V. H.", "words_pool": ["applic", "comit", "discuss", "examin", "featur", "gener", "good", "inform", "ir", "languag", "make", "manipul", "present", "program", "program", "render", "retriev", "suit", "symbol", "type", "uniqu", "yngve"], "word_count": {"applic": 1, "comit": 1, "discuss": 1, "examin": 1, "featur": 1, "gener": 1, "good": 1, "inform": 1, "ir": 1, "languag": 2, "make": 1, "manipul": 1, "present": 1, "program": 2, "render": 1, "retriev": 1, "suit": 1, "symbol": 1, "type": 1, "uniqu": 1, "yngve": 1}}, "656": {"id": "656", "title": "An Information System With The Ability To Extract Intelligence From Data", "authors": "Wang, T. L.", "words_pool": ["abil", "data", "extract", "inform", "intellig", "system", "wang"], "word_count": {"abil": 1, "data": 1, "extract": 1, "inform": 1, "intellig": 1, "system": 1, "wang": 1}}, "657": {"id": "657", "title": "Information Structures for Processing and Retrieving", "authors": "Colilla, R. A. Sams, B. H.", "words_pool": ["inform", "process", "retriev", "structur", "colilla", "sam"], "word_count": {"inform": 1, "process": 1, "retriev": 1, "structur": 1, "colilla": 1, "sam": 1}}, "658": {"id": "658", "title": "Discussion-The Pros and Cons of a Special IR Language", "authors": "Sammet, J. E. Ohlman, H. Bohnest, H. G.", "words_pool": ["con", "discuss", "ir", "languag", "pro", "special", "sammet", "ohlman", "bohnest"], "word_count": {"con": 1, "discuss": 1, "ir": 1, "languag": 1, "pro": 1, "special": 1, "sammet": 1, "ohlman": 1, "bohnest": 1}}, "659": {"id": "659", "title": "Reversion of Series (Algorithm 193)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "revers", "seri", "thacher", "jr"], "word_count": {"algorithm": 1, "revers": 1, "seri": 1, "thacher": 1, "jr": 1}}, "660": {"id": "660", "title": "More Test Matrices for Determinants and Inverses (Pracnique)", "authors": "Englar, T. S.", "words_pool": ["determin", "invers", "matric", "pracniqu", "test", "englar"], "word_count": {"determin": 1, "invers": 1, "matric": 1, "pracniqu": 1, "test": 1, "englar": 1}}, "661": {"id": "661", "title": "Indexing and the Lambda-Notation", "abstract": "Some methods of indexing sequentially stored elements of sparse multi-dimensional arrays are  described in the scheme A notation.", "authors": "Barnett, M. P.", "words_pool": ["array", "dimension", "element", "index", "lambda", "method", "multi", "notat", "scheme", "sequenti", "spars", "store", "barnett"], "word_count": {"array": 1, "dimension": 1, "element": 1, "index": 1, "lambda": 1, "method": 1, "multi": 1, "notat": 1, "scheme": 1, "sequenti": 1, "spars": 1, "store": 1, "barnett": 1}}, "662": {"id": "662", "title": "Shuttle Sort (Algorithm 175)", "authors": "Juelich, O. C.", "words_pool": ["algorithm", "shuttl", "sort", "juelich"], "word_count": {"algorithm": 1, "shuttl": 1, "sort": 1, "juelich": 1}}, "663": {"id": "663", "title": "Determinant (Algorithm 159)", "authors": "Lapidus, A.", "words_pool": ["algorithm", "determin", "lapidu"], "word_count": {"algorithm": 1, "determin": 1, "lapidu": 1}}, "664": {"id": "664", "title": "Assignment (Algorithm 27)", "authors": "Witty, R. D.", "words_pool": ["algorithm", "assign", "witti"], "word_count": {"algorithm": 1, "assign": 1, "witti": 1}}, "665": {"id": "665", "title": "Gauss-Seidel (Algorithm 220)", "authors": "Shantz, P. W.", "words_pool": ["algorithm", "gauss", "seidel", "shantz"], "word_count": {"algorithm": 1, "gauss": 1, "seidel": 1, "shantz": 1}}, "666": {"id": "666", "title": "Topological Ordering for Pert Networks (Algorithm 219)", "authors": "Kase, R. H.", "words_pool": ["algorithm", "network", "order", "pert", "topolog", "kase"], "word_count": {"algorithm": 1, "network": 1, "order": 1, "pert": 1, "topolog": 1, "kase": 1}}, "667": {"id": "667", "title": "Kutta Merson (Algorithm 218)", "authors": "Lukehart, P. M.", "words_pool": ["algorithm", "kutta", "merson", "lukehart"], "word_count": {"algorithm": 1, "kutta": 1, "merson": 1, "lukehart": 1}}, "668": {"id": "668", "title": "Minimum Excess Cost Curve (Algorithm 217)", "authors": "Briggs, W. A.", "words_pool": ["algorithm", "cost", "curv", "excess", "minimum", "brigg"], "word_count": {"algorithm": 1, "cost": 1, "curv": 1, "excess": 1, "minimum": 1, "brigg": 1}}, "669": {"id": "669", "title": "A Specification of JOVIAL", "authors": "Shaw, C. J.", "words_pool": ["jovial", "specif", "shaw"], "word_count": {"jovial": 1, "specif": 1, "shaw": 1}}, "670": {"id": "670", "title": "Some Legal Implications of the Use of Computers in the Banking Business", "abstract": "The introduction of computers in to the banking business has a wide variety of legal implications  that merit careful attention at this very early stage.  The industry is highly regulated by government  and, hence, is subject to many statutes and regulations.  It also is affected by important common law  rules established by courts.  The legal ramifications involve not only the mechanization itself, but  also the very significant, economically attractive phenomenon of off premises processing.  It is essential  to identify and provide for many legal aspects right now, before systems and practices crystallize, in  order to avoid the later impact of unanticipated physical complications and expense.  The legal aspects  of computerization in the banking business are especially diverse.  In some states, there might be the  basic question whether banks are authorized by law to invest in the new facilities, either directly or  through cooperatives.  More challenging are questions relating to off-premises processors, particularly  with respect to the obligation not to disclose information concerning a bank's customers, the adequacy  of fidelity bond coverage, the extent of liability for improper refusal to pay a check, and susceptibility  to regulation by government agencies.  Also pertinent is the propriety of data processing by banks for  nonbank entities and particularly of the rendering of that service without charge for bank depositors.", "authors": "Freed, R. N.", "words_pool": ["adequaci", "affect", "agenc", "aspect", "attent", "attract", "author", "avoid", "bank", "bank", "bank", "basic", "bond", "busi", "care", "challeng", "charg", "check", "common", "complic", "computer", "comput", "concern", "cooper", "court", "coverag", "crystal", "custom", "data", "depositor", "directli", "disclos", "divers", "earli", "econom", "entiti", "especi", "essenti", "establish", "expens", "extent", "facil", "fidel", "govern", "highli", "identifi", "impact", "implic", "import", "improp", "industri", "inform", "introduct", "invest", "involv", "later", "law", "legal", "liabil", "mechan", "merit", "nonbank", "oblig", "order", "pay", "pertin", "phenomenon", "physic", "practic", "premis", "process", "processor", "proprieti", "provid", "question", "question", "ramif", "refus", "regul", "regul", "regul", "relat", "render", "respect", "rule", "servic", "signific", "stage", "state", "statut", "subject", "suscept", "system", "unanticip", "varieti", "wide", "freed"], "word_count": {"adequaci": 1, "affect": 1, "agenc": 1, "aspect": 2, "attent": 1, "attract": 1, "author": 1, "avoid": 1, "bank": 6, "basic": 1, "bond": 1, "busi": 2, "care": 1, "challeng": 1, "charg": 1, "check": 1, "common": 1, "complic": 1, "computer": 1, "comput": 1, "concern": 1, "cooper": 1, "court": 1, "coverag": 1, "crystal": 1, "custom": 1, "data": 1, "depositor": 1, "directli": 1, "disclos": 1, "divers": 1, "earli": 1, "econom": 1, "entiti": 1, "especi": 1, "essenti": 1, "establish": 1, "expens": 1, "extent": 1, "facil": 1, "fidel": 1, "govern": 2, "highli": 1, "identifi": 1, "impact": 1, "implic": 1, "import": 1, "improp": 1, "industri": 1, "inform": 1, "introduct": 1, "invest": 1, "involv": 1, "later": 1, "law": 2, "legal": 4, "liabil": 1, "mechan": 1, "merit": 1, "nonbank": 1, "oblig": 1, "order": 1, "pay": 1, "pertin": 1, "phenomenon": 1, "physic": 1, "practic": 1, "premis": 2, "process": 2, "processor": 1, "proprieti": 1, "provid": 1, "question": 2, "ramif": 1, "refus": 1, "regul": 3, "relat": 1, "render": 1, "respect": 1, "rule": 1, "servic": 1, "signific": 1, "stage": 1, "state": 1, "statut": 1, "subject": 1, "suscept": 1, "system": 1, "unanticip": 1, "varieti": 1, "wide": 1, "freed": 1}}, "671": {"id": "671", "title": "TELEFILE-A Case Study of an On-Line Savings Bank Application", "abstract": "The development of an on-line computer system for a savings bank institution is traced from  the early conceptual needs of the bank to the consummation of design by The Teleregister Corporation.   Both bank and equipment criteria are specified which led to the development of the Telefile System of  The Teleregister Corporation.  Operation of the on-line and off-line programs are described and statistics  are cited for reliability and performance of the system.  Benefits to the bank are discussed from the  banker's point of view; an indication of future trends in the on-line savings bank field is also discussed.", "authors": "Sanders, M.", "words_pool": ["applic", "bank", "banker", "benefit", "case", "cite", "comput", "conceptu", "consumm", "corpor", "criteria", "design", "develop", "discuss", "earli", "equip", "field", "futur", "indic", "institut", "led", "line", "need", "oper", "perform", "point", "program", "reliabl", "save", "statist", "studi", "system", "telefil", "teleregist", "trace", "trend", "view", "sander"], "word_count": {"applic": 1, "bank": 5, "banker": 1, "benefit": 1, "case": 1, "cite": 1, "comput": 1, "conceptu": 1, "consumm": 1, "corpor": 2, "criteria": 1, "design": 1, "develop": 2, "discuss": 2, "earli": 1, "equip": 1, "field": 1, "futur": 1, "indic": 1, "institut": 1, "led": 1, "line": 4, "need": 1, "oper": 1, "perform": 1, "point": 1, "program": 1, "reliabl": 1, "save": 2, "statist": 1, "studi": 1, "system": 3, "telefil": 1, "teleregist": 2, "trace": 1, "trend": 1, "view": 1, "sander": 1}}, "672": {"id": "672", "title": "Recent Developments Affecting ADP in Tax Administration", "authors": "Leibowitz, G. J.", "words_pool": ["administr", "adp", "affect", "develop", "recent", "tax", "leibowitz"], "word_count": {"administr": 1, "adp": 1, "affect": 1, "develop": 1, "recent": 1, "tax": 1, "leibowitz": 1}}, "673": {"id": "673", "title": "Account Classification at Automating Banks", "authors": "Eckert, J. B.", "words_pool": ["account", "autom", "bank", "classif", "eckert"], "word_count": {"account": 1, "autom": 1, "bank": 1, "classif": 1, "eckert": 1}}, "674": {"id": "674", "title": "Application of IBM 1620 EDP Methods to the Calculation of the Formation Constants of Complex  Irons", "authors": "Andrews, A. C. Hassler, J. DeCou, F.", "words_pool": ["applic", "calcul", "complex", "constant", "edp", "format", "ibm", "iron", "method", "andrew", "hassler", "decou"], "word_count": {"applic": 1, "calcul": 1, "complex": 1, "constant": 1, "edp": 1, "format": 1, "ibm": 1, "iron": 1, "method": 1, "andrew": 1, "hassler": 1, "decou": 1}}, "675": {"id": "675", "title": "Coding Clinical Laboratory Data For Automatic Storage and Retrieval", "abstract": "A series of clinical laboratory codes have been developed to accept and store urin analysis, blood  chemistry, and hematology test results for automatic data processing.  The codes, although constructed  as part of a computerized hospital simulation, have been able to handle the results of every laboratory  test that they have encountered.  The unique feature of these codes is that they can accept conventionally  recorded qualitative as well as quantitative test results.  Consequently, clinical test results need  not be arbitrarily stratified, standardized, or altered in any way to be coded.  This paper describes  how the codes were developed and presents a listing of the urin analysis codes.  Five criteria used in developing  the codes are outlined and the problem of multiple-synonymous terminology is discussed.  A solution to  the problem is described.  Flexible, computer-produced, composite laboratory reports are also discussed,  along with reproduction of such a report. The paper concludes that even though many problems remain unsolved,  the next ten years could witness the emergence of a practical automated information system in the laboratory.", "authors": "Gross, L. D.", "words_pool": ["abl", "accept", "alter", "analysi", "arbitrarili", "autom", "automat", "blood", "chemistri", "clinic", "code", "code", "code", "composit", "comput", "computer", "conclud", "construct", "convent", "criteria", "data", "describ", "develop", "develop", "discuss", "emerg", "encount", "featur", "flexibl", "handl", "hematolog", "hospit", "inform", "laboratori", "list", "multipl", "need", "outlin", "paper", "part", "practic", "present", "problem", "problem", "process", "produc", "qualit", "quantit", "record", "remain", "report", "report", "reproduct", "result", "retriev", "seri", "simul", "solut", "standard", "storag", "store", "stratifi", "synonym", "system", "ten", "terminolog", "test", "uniqu", "unsolv", "urin", "wit", "year", "gross"], "word_count": {"abl": 1, "accept": 2, "alter": 1, "analysi": 2, "arbitrarili": 1, "autom": 1, "automat": 1, "blood": 1, "chemistri": 1, "clinic": 2, "code": 7, "composit": 1, "comput": 1, "computer": 1, "conclud": 1, "construct": 1, "convent": 1, "criteria": 1, "data": 1, "describ": 1, "develop": 3, "discuss": 2, "emerg": 1, "encount": 1, "featur": 1, "flexibl": 1, "handl": 1, "hematolog": 1, "hospit": 1, "inform": 1, "laboratori": 4, "list": 1, "multipl": 1, "need": 1, "outlin": 1, "paper": 2, "part": 1, "practic": 1, "present": 1, "problem": 3, "process": 1, "produc": 1, "qualit": 1, "quantit": 1, "record": 1, "remain": 1, "report": 2, "reproduct": 1, "result": 4, "retriev": 1, "seri": 1, "simul": 1, "solut": 1, "standard": 1, "storag": 1, "store": 1, "stratifi": 1, "synonym": 1, "system": 1, "ten": 1, "terminolog": 1, "test": 4, "uniqu": 1, "unsolv": 1, "urin": 2, "wit": 1, "year": 1, "gross": 1}}, "676": {"id": "676", "title": "On the Computation of a Certain Type of IncompleteBeta Functions", "authors": "Tang, I. C.", "words_pool": ["comput", "function", "incompletebeta", "type", "tang"], "word_count": {"comput": 1, "function": 1, "incompletebeta": 1, "type": 1, "tang": 1}}, "677": {"id": "677", "title": "Length of Strings for a Merge Sort", "abstract": "Detailed statistics are given on the length of maximal sorted strings which result form the  first (internal sort) phase of a merge sort onto tapes.  It is shown that the strings produced by an  alternating method (i.e. one which produces ascending and descending strings alternately) tend to be  only three-fourths as long as those in a method which produces only ascending strings, contrary to statements  which have appeared previously in the literature.  A slight modification of the read-backward polyphase  merge algorithm is therefore suggested.", "authors": "Knuth, D. E.", "words_pool": ["algorithm", "altern", "altern", "appear", "ascend", "backward", "contrari", "descend", "detail", "form", "fourth", "intern", "length", "literatur", "long", "maxim", "merg", "method", "modif", "phase", "polyphas", "previous", "produc", "produc", "read", "result", "shown", "slight", "sort", "sort", "statement", "statist", "string", "suggest", "tape", "tend", "knuth"], "word_count": {"algorithm": 1, "altern": 2, "appear": 1, "ascend": 2, "backward": 1, "contrari": 1, "descend": 1, "detail": 1, "form": 1, "fourth": 1, "intern": 1, "length": 1, "literatur": 1, "long": 1, "maxim": 1, "merg": 2, "method": 2, "modif": 1, "phase": 1, "polyphas": 1, "previous": 1, "produc": 3, "read": 1, "result": 1, "shown": 1, "slight": 1, "sort": 3, "statement": 1, "statist": 1, "string": 4, "suggest": 1, "tape": 1, "tend": 1, "knuth": 1}}, "678": {"id": "678", "title": "Optimizing Bit-time Computer Simulation", "abstract": "A major component of a bit-time computer simulation program is the Boolean compiler.  The compiler  accepts the Boolean functions representing the simulated computer's digital circuits, and generates corresponding  sets of machine instructions which are subsequently executed on the \"host\" computer.  Techniques are  discussed for increasing the sophistication of the Boolean compiler so as to optimize bit-time computer  simulation.  The techniques are applicable to any general-purpose computer.", "authors": "Katz,J. H.", "words_pool": ["accept", "applic", "bit", "boolean", "circuit", "compil", "compon", "comput", "digit", "discuss", "execut", "function", "gener", "gener", "host", "increas", "instruct", "machin", "major", "optim", "optim", "program", "purpos", "repres", "set", "simul", "simul", "sophist", "subsequ", "techniqu", "time", "katz"], "word_count": {"accept": 1, "applic": 1, "bit": 2, "boolean": 3, "circuit": 1, "compil": 3, "compon": 1, "comput": 5, "digit": 1, "discuss": 1, "execut": 1, "function": 1, "gener": 2, "host": 1, "increas": 1, "instruct": 1, "machin": 1, "major": 1, "optim": 1, "program": 1, "purpos": 1, "repres": 1, "set": 1, "simul": 3, "sophist": 1, "subsequ": 1, "techniqu": 2, "time": 2, "katz": 1}}, "679": {"id": "679", "title": "Recent Improvements in MADCAP", "abstract": "MADCAP is a programming language admitting subscripts, superscripts and certain forms of displayed  formulas.  The basic implementation of this language was described in a previous paper [MADCAP: A scientific  compiler for a displayed formula textbook language, Comm. ACM 4 (Jan. 61), 31-36].  This paper discusses  recent improvements in the language in three areas: complex display, logical control, and subprogramming.   In the area of complex display, the most prominent improvements are a notation for integration and for  the binomial coefficients.  In the area of logical control the chief new feature is a notation for variably  nested looping.  The discussion of subprogramming is focused on MADCAP's notation for and use of \"procedures.\"", "authors": "Wells, M. B.", "words_pool": ["acm", "admit", "area", "area", "basic", "binomi", "chief", "coeffici", "comm", "compil", "complex", "control", "discuss", "discuss", "display", "display", "featur", "focus", "form", "formula", "formula", "implement", "improv", "integr", "jan", "languag", "logic", "loop", "madcap", "nest", "notat", "paper", "previou", "procedur", "program", "promin", "recent", "scientif", "subprogram", "subscript", "superscript", "textbook", "variabl", "well"], "word_count": {"acm": 1, "admit": 1, "area": 3, "basic": 1, "binomi": 1, "chief": 1, "coeffici": 1, "comm": 1, "compil": 1, "complex": 2, "control": 2, "discuss": 2, "display": 4, "featur": 1, "focus": 1, "form": 1, "formula": 2, "implement": 1, "improv": 2, "integr": 1, "jan": 1, "languag": 4, "logic": 2, "loop": 1, "madcap": 3, "nest": 1, "notat": 3, "paper": 2, "previou": 1, "procedur": 1, "program": 1, "promin": 1, "recent": 1, "scientif": 1, "subprogram": 2, "subscript": 1, "superscript": 1, "textbook": 1, "variabl": 1, "well": 1}}, "680": {"id": "680", "title": "An Error-Correcting Parse Algorithm", "authors": "Irons, E. T.", "words_pool": ["algorithm", "correct", "error", "pars", "iron"], "word_count": {"algorithm": 1, "correct": 1, "error": 1, "pars": 1, "iron": 1}}, "681": {"id": "681", "title": "Flexible Abbreviation of Words in a Computer Language", "authors": "Lomis, R. G. Rubin, J.", "words_pool": ["abbrevi", "comput", "flexibl", "languag", "word", "lomi", "rubin"], "word_count": {"abbrevi": 1, "comput": 1, "flexibl": 1, "languag": 1, "word": 1, "lomi": 1, "rubin": 1}}, "682": {"id": "682", "title": "Recursive programming in FORTRAN II", "authors": "Ayers, J. A.", "words_pool": ["fortran", "ii", "program", "recurs", "ayer"], "word_count": {"fortran": 1, "ii": 1, "program": 1, "recurs": 1, "ayer": 1}}, "683": {"id": "683", "title": "A Serial Technique to Determine Minimum Paths", "authors": "Weimer, D. L.", "words_pool": ["determin", "minimum", "path", "serial", "techniqu", "weimer"], "word_count": {"determin": 1, "minimum": 1, "path": 1, "serial": 1, "techniqu": 1, "weimer": 1}}, "684": {"id": "684", "title": "Interpolation, Differentiation, and Integration (Algorithm 77)", "authors": "Hennion, P. E.", "words_pool": ["algorithm", "differenti", "integr", "interpol", "hennion"], "word_count": {"algorithm": 1, "differenti": 1, "integr": 1, "interpol": 1, "hennion": 1}}, "685": {"id": "685", "title": "Euler Summation (Algorithm 8)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "euler", "summat", "thacher", "jr"], "word_count": {"algorithm": 1, "euler": 1, "summat": 1, "thacher": 1, "jr": 1}}, "686": {"id": "686", "title": "Smooth (Algorithm 216)", "authors": "George, R.", "words_pool": ["algorithm", "smooth", "georg"], "word_count": {"algorithm": 1, "smooth": 1, "georg": 1}}, "687": {"id": "687", "title": "Shanks (Algorithm 215)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "shank", "thacher", "jr"], "word_count": {"algorithm": 1, "shank": 1, "thacher": 1, "jr": 1}}, "688": {"id": "688", "title": "q-Bessel Functions In(t)(Algorithm 214)", "authors": "Simoes Pereira, J. M. S.", "words_pool": ["algorithm", "bessel", "function", "simo", "pereira"], "word_count": {"algorithm": 1, "bessel": 1, "function": 1, "simo": 1, "pereira": 1}}, "689": {"id": "689", "title": "Report of a Visit to Discuss Common Programming Languages in Czechoslovakia and Poland, 1963", "authors": "Gosden, J. A. Merner, J. N. Gay, R. E. Jones, J. L. Christopher, J. S.", "words_pool": ["common", "czechoslovakia", "discuss", "languag", "poland", "program", "report", "visit", "gosden", "merner", "gay", "jone", "christoph"], "word_count": {"common": 1, "czechoslovakia": 1, "discuss": 1, "languag": 1, "poland": 1, "program": 1, "report": 1, "visit": 1, "gosden": 1, "merner": 1, "gay": 1, "jone": 1, "christoph": 1}}, "690": {"id": "690", "title": "USA Participation in an International Standard glossary on Information Processing", "authors": "Traub, J. F.", "words_pool": ["glossari", "inform", "intern", "particip", "process", "standard", "usa", "traub"], "word_count": {"glossari": 1, "inform": 1, "intern": 1, "particip": 1, "process": 1, "standard": 1, "usa": 1, "traub": 1}}, "691": {"id": "691", "title": "A Description of the APT Language", "abstract": "The APT (Automatically Programmed Tools) language for numerical control programming is described  using the metalinguistic notation introduced in the ALGOL 60 report.  Examples of APT usage are included.   Presented also are an historical summary of the development of APT and a statement concerning its present  status.", "authors": "Brown, S. A. Drayton, C. E. Mittman, B.", "words_pool": ["algol", "apt", "concern", "control", "descript", "develop", "exampl", "histor", "includ", "introduc", "languag", "metalinguist", "notat", "numer", "present", "present", "program", "program", "report", "statement", "statu", "summari", "tool", "usag", "brown", "drayton", "mittman"], "word_count": {"algol": 1, "apt": 3, "concern": 1, "control": 1, "descript": 1, "develop": 1, "exampl": 1, "histor": 1, "includ": 1, "introduc": 1, "languag": 1, "metalinguist": 1, "notat": 1, "numer": 1, "present": 2, "program": 2, "report": 1, "statement": 1, "statu": 1, "summari": 1, "tool": 1, "usag": 1, "brown": 1, "drayton": 1, "mittman": 1}}, "692": {"id": "692", "title": "On the Inverse of a Test Matrix", "authors": "Stockmal, F. J.", "words_pool": ["invers", "matrix", "test", "stockmal"], "word_count": {"invers": 1, "matrix": 1, "test": 1, "stockmal": 1}}, "693": {"id": "693", "title": "An Extension of Fibonaccian Search To Several Variables", "abstract": "A technique which uses Fibonaccian search concepts has been developed to solve optimization  problems involving unimodal functions of several variables.  The technique has not been proven to be  optimal in the sense that the one-dimensional Fibonaccian search is.  However, it is valuable for certain  kinds of calculations.", "authors": "Krolak, P. Cooper, L.", "words_pool": ["calcul", "concept", "develop", "dimension", "extens", "fibonaccian", "function", "involv", "kind", "optim", "optim", "problem", "proven", "search", "sens", "solv", "techniqu", "unimod", "valuabl", "variabl", "krolak", "cooper"], "word_count": {"calcul": 1, "concept": 1, "develop": 1, "dimension": 1, "extens": 1, "fibonaccian": 2, "function": 1, "involv": 1, "kind": 1, "optim": 2, "problem": 1, "proven": 1, "search": 2, "sens": 1, "solv": 1, "techniqu": 2, "unimod": 1, "valuabl": 1, "variabl": 1, "krolak": 1, "cooper": 1}}, "694": {"id": "694", "title": "A Comparison of Disks and Tapes", "abstract": "The principal characteristics of current magnetic disks and tape units are summarized and compared.   Some of the characteristics of disk files are illustrated in a sorting example and compared to a tapesort.   The conclusion is presented that disk files are competitive to tapes in some important applications.", "authors": "Hess, H.", "words_pool": ["applic", "characterist", "compar", "comparison", "competit", "conclus", "disk", "disk", "illustr", "import", "magnet", "present", "princip", "sort", "summar", "tape", "tape", "tapesort", "unit", "hess"], "word_count": {"applic": 1, "characterist": 2, "compar": 2, "comparison": 1, "competit": 1, "conclus": 1, "disk": 3, "illustr": 1, "import": 1, "magnet": 1, "present": 1, "princip": 1, "sort": 1, "summar": 1, "tape": 2, "tapesort": 1, "unit": 1, "hess": 1}}, "695": {"id": "695", "title": "Use of the Disk File on Stretch", "abstract": "The paper begins by briefly describing the Stretch (IBM 7030) computer with special emphasis  given to the organization and operation of its input-output equipment.  Physical characteristics of the  two-disk system (4,194,304 72-bit words, 8 usec-per-word transmission rate, etc.) are noted.  Timing  limitations due to arm motion and disk rotation are discussed.  Applications of disk usage are discussed  separately for problem programs and for systems programs such as compilers and the supervisory program.  Approximately 260,000 words of disk storage are reserved for the storage of systems programs and the  subroutine library.  Problem programs, however, are not currently filed on the disk.  Certain programming  techniques are discussed for transmitting words between disk and core storage with minimum delaying and  interruption of the arithmetic unit.  Dumps on disk are considered for both recovery from computer malfunction  and for mathematical or physical developments during the calculation.  Some comments are made regarding  the reliability, economics, utility and weaknesses or limitations of the disk system.  Several possible  future applications are noted which appear to have disk connotations.", "authors": "Carlson, B. G. Voorhes, E. A.", "words_pool": ["applic", "approxim", "arithmet", "arm", "begin", "bit", "briefli", "calcul", "characterist", "comment", "compil", "comput", "connot", "consid", "core", "delay", "describ", "develop", "discuss", "disk", "due", "dump", "econom", "emphasi", "equip", "file", "futur", "ibm", "input", "interrupt", "librari", "limit", "made", "malfunct", "mathemat", "minimum", "motion", "note", "oper", "organ", "output", "paper", "physic", "problem", "program", "program", "program", "rate", "recoveri", "regard", "reliabl", "reserv", "rotat", "separ", "special", "storag", "stretch", "subroutin", "supervisori", "system", "system", "techniqu", "time", "transmiss", "transmit", "unit", "usag", "usec", "util", "weak", "word", "word", "carlson", "voorh"], "word_count": {"applic": 2, "approxim": 1, "arithmet": 1, "arm": 1, "begin": 1, "bit": 1, "briefli": 1, "calcul": 1, "characterist": 1, "comment": 1, "compil": 1, "comput": 2, "connot": 1, "consid": 1, "core": 1, "delay": 1, "describ": 1, "develop": 1, "discuss": 3, "disk": 9, "due": 1, "dump": 1, "econom": 1, "emphasi": 1, "equip": 1, "file": 1, "futur": 1, "ibm": 1, "input": 1, "interrupt": 1, "librari": 1, "limit": 2, "made": 1, "malfunct": 1, "mathemat": 1, "minimum": 1, "motion": 1, "note": 2, "oper": 1, "organ": 1, "output": 1, "paper": 1, "physic": 2, "problem": 2, "program": 6, "rate": 1, "recoveri": 1, "regard": 1, "reliabl": 1, "reserv": 1, "rotat": 1, "separ": 1, "special": 1, "storag": 3, "stretch": 1, "subroutin": 1, "supervisori": 1, "system": 4, "techniqu": 1, "time": 1, "transmiss": 1, "transmit": 1, "unit": 1, "usag": 1, "usec": 1, "util": 1, "weak": 1, "word": 4, "carlson": 1, "voorh": 1}}, "696": {"id": "696", "title": "An Automatic Data Acquisition and Inquiry System Using Disk Files", "abstract": "Lockheed Missiles and Space Company has installed a large-scale Automatic Data Acquisition  (ADA) system which ties together the Company's manufacturing facilities located in Van Nuys and Sunnyvale,  California.  The system includes over 200 remote Input Stations which collect and transmit Company operating  data to a central Data Processing Center.  Two RCA 301 EDP Systems are used to record and control the  flow of data transmitted to the Data Processing Center.  A large capacity RCA 366 Data Disc File is used  to store information required to provide up-to-date information in response to inquiries received from  remotely located Inquiry Stations.  In addition to storage of data on the disk files, the system automatically  records all incoming and outgoing data on magnetic tape to be used as input to the Company's conventional  off-line business data processing applications.", "authors": "Edwards, J. D.", "words_pool": ["acquisit", "ada", "addit", "applic", "automat", "busi", "california", "capac", "center", "central", "collect", "compani", "control", "convent", "data", "date", "disc", "disk", "edp", "facil", "flow", "includ", "incom", "inform", "input", "inquiri", "inquiri", "instal", "larg", "line", "locat", "lockhe", "magnet", "manufactur", "missil", "nuy", "oper", "outgo", "process", "provid", "rca", "receiv", "record", "record", "remot", "remot", "requir", "respons", "scale", "space", "station", "storag", "store", "sunnyval", "system", "system", "tape", "tie", "transmit", "transmit", "van", "edward"], "word_count": {"acquisit": 1, "ada": 1, "addit": 1, "applic": 1, "automat": 1, "busi": 1, "california": 1, "capac": 1, "center": 2, "central": 1, "collect": 1, "compani": 4, "control": 1, "convent": 1, "data": 9, "date": 1, "disc": 1, "disk": 1, "edp": 1, "facil": 1, "flow": 1, "includ": 1, "incom": 1, "inform": 2, "input": 2, "inquiri": 2, "instal": 1, "larg": 2, "line": 1, "locat": 2, "lockhe": 1, "magnet": 1, "manufactur": 1, "missil": 1, "nuy": 1, "oper": 1, "outgo": 1, "process": 3, "provid": 1, "rca": 2, "receiv": 1, "record": 2, "remot": 2, "requir": 1, "respons": 1, "scale": 1, "space": 1, "station": 2, "storag": 1, "store": 1, "sunnyval": 1, "system": 4, "tape": 1, "tie": 1, "transmit": 2, "van": 1, "edward": 1}}, "697": {"id": "697", "title": "A Numerical Method for the Determination of Moving Field Isodose Curves for Treatment Planning  in Radiotherapy", "authors": "Dalrymple, G. V. Perez-Tamayo, R.", "words_pool": ["curv", "determin", "field", "isodos", "method", "move", "numer", "plan", "radiotherapi", "treatment", "dalrympl", "perez", "tamayo"], "word_count": {"curv": 1, "determin": 1, "field": 1, "isodos": 1, "method": 1, "move": 1, "numer": 1, "plan": 1, "radiotherapi": 1, "treatment": 1, "dalrympl": 1, "perez": 1, "tamayo": 1}}, "698": {"id": "698", "title": "DATA-DIAL: Two-Way Communication with Computers From Ordinary dial Telephones", "abstract": "An operating system is described which allows users to call up a remotely located computer  from ordinary dial telephones.  No special hardware or connections are required at the users' telephones.   Input to the computer is through the telephone dial;output from the computer is in spoken form.  Results  of a test with telephones in the Boston area are reported.", "authors": "Marill, T. Edwards, D. Feurzeig, W.", "words_pool": ["area", "boston", "call", "commun", "comput", "comput", "connect", "data", "dial", "form", "hardwar", "input", "locat", "oper", "ordinari", "output", "remot", "report", "requir", "result", "special", "spoken", "system", "telephon", "telephon", "test", "user", "maril", "edward", "feurzeig"], "word_count": {"area": 1, "boston": 1, "call": 1, "commun": 1, "comput": 3, "connect": 1, "data": 1, "dial": 2, "form": 1, "hardwar": 1, "input": 1, "locat": 1, "oper": 1, "ordinari": 1, "output": 1, "remot": 1, "report": 1, "requir": 1, "result": 1, "special": 1, "spoken": 1, "system": 1, "telephon": 4, "test": 1, "user": 2, "maril": 1, "edward": 1, "feurzeig": 1}}, "699": {"id": "699", "title": "A Contour-Map Program for X-Ray Crystallography", "abstract": "A FORTRAN program is described for use with the IBM 7090 system and an X, Y-plotter to produce  a contour map.  A matrix of points evenly spaced in each dimension is contoured.  Scale factors along  the axes may be different and the axes need not be perpendicular.", "authors": "Dayhoff, M. O.", "words_pool": ["axe", "contour", "contour", "crystallographi", "dimens", "evenli", "factor", "fortran", "ibm", "map", "matrix", "need", "perpendicular", "plotter", "point", "produc", "program", "ray", "scale", "space", "system", "dayhoff"], "word_count": {"axe": 2, "contour": 2, "crystallographi": 1, "dimens": 1, "evenli": 1, "factor": 1, "fortran": 1, "ibm": 1, "map": 1, "matrix": 1, "need": 1, "perpendicular": 1, "plotter": 1, "point": 1, "produc": 1, "program": 1, "ray": 1, "scale": 1, "space": 1, "system": 1, "dayhoff": 1}}, "700": {"id": "700", "title": "Hermite Interpolation (Algorithm 210)", "authors": "Dwyer, T. A.", "words_pool": ["algorithm", "hermit", "interpol", "dwyer"], "word_count": {"algorithm": 1, "hermit": 1, "interpol": 1, "dwyer": 1}}, "701": {"id": "701", "title": "Shuttle Sort (Algorithm 175)", "authors": "Schubert, G. R.", "words_pool": ["algorithm", "shuttl", "sort", "schubert"], "word_count": {"algorithm": 1, "shuttl": 1, "sort": 1, "schubert": 1}}, "702": {"id": "702", "title": "Assign (Algorithm 173)", "authors": "Filsak, Z. Vrchovecka, L.", "words_pool": ["algorithm", "assign", "filsak", "vrchovecka"], "word_count": {"algorithm": 1, "assign": 1, "filsak": 1, "vrchovecka": 1}}, "703": {"id": "703", "title": "Assign (Algorithm 173)", "authors": "Scowen, R. S.", "words_pool": ["algorithm", "assign", "scowen"], "word_count": {"algorithm": 1, "assign": 1, "scowen": 1}}, "704": {"id": "704", "title": "Combinatorial of M Things Taken One At A Time Two At A Time, Up To N At A Time (Algorithm 161)", "authors": "Collins, D. H.", "words_pool": ["algorithm", "combinatori", "thing", "time", "collin"], "word_count": {"algorithm": 1, "combinatori": 1, "thing": 1, "time": 3, "collin": 1}}, "705": {"id": "705", "title": "Combinatorial Of M Things Taken N At A Time (Algorithm 160)", "authors": "Blakely, R. E.", "words_pool": ["algorithm", "combinatori", "thing", "time", "blake"], "word_count": {"algorithm": 1, "combinatori": 1, "thing": 1, "time": 1, "blake": 1}}, "706": {"id": "706", "title": "Fourier Series Approximation (Algorithm 157)", "authors": "Schubert, G. R.", "words_pool": ["algorithm", "approxim", "fourier", "seri", "schubert"], "word_count": {"algorithm": 1, "approxim": 1, "fourier": 1, "seri": 1, "schubert": 1}}, "707": {"id": "707", "title": "Erf(x) (Algorithm 123)", "authors": "Ibbetson, D.", "words_pool": ["algorithm", "erf", "ibbetson"], "word_count": {"algorithm": 1, "erf": 1, "ibbetson": 1}}, "708": {"id": "708", "title": "Evaluation of the Fresnel Integrals (Algorithm 88, 89, 90)", "authors": "Gray, M. D.", "words_pool": ["algorithm", "evalu", "fresnel", "integr", "gray"], "word_count": {"algorithm": 1, "evalu": 1, "fresnel": 1, "integr": 1, "gray": 1}}, "709": {"id": "709", "title": "Assignment (Algorithm 27)", "authors": "Newhouse, A.", "words_pool": ["algorithm", "assign", "newhous"], "word_count": {"algorithm": 1, "assign": 1, "newhous": 1}}, "710": {"id": "710", "title": "Fresnel Integrals (Algorithm 213)", "authors": "Gray, M. D.", "words_pool": ["algorithm", "fresnel", "integr", "gray"], "word_count": {"algorithm": 1, "fresnel": 1, "integr": 1, "gray": 1}}, "711": {"id": "711", "title": "Frequency Distribution (Algorithm 212)", "authors": "Gray, M. D.", "words_pool": ["algorithm", "distribut", "frequenc", "gray"], "word_count": {"algorithm": 1, "distribut": 1, "frequenc": 1, "gray": 1}}, "712": {"id": "712", "title": "Hermite Interpolation (Algorithm 211)", "authors": "Schubert, G. R.", "words_pool": ["algorithm", "hermit", "interpol", "schubert"], "word_count": {"algorithm": 1, "hermit": 1, "interpol": 1, "schubert": 1}}, "713": {"id": "713", "title": "Lagrangian Interpolation (Algorithm 210)", "authors": "Schubert, G. R.", "words_pool": ["algorithm", "interpol", "lagrangian", "schubert"], "word_count": {"algorithm": 1, "interpol": 1, "lagrangian": 1, "schubert": 1}}, "714": {"id": "714", "title": "Gauss (Algorithm 209)", "authors": "Ibbetson, D.", "words_pool": ["algorithm", "gauss", "ibbetson"], "word_count": {"algorithm": 1, "gauss": 1, "ibbetson": 1}}, "715": {"id": "715", "title": "Discrete Convolution (Algorithm 208)", "authors": "Foreman Jr., W. T.", "words_pool": ["algorithm", "convolut", "discret", "foreman", "jr"], "word_count": {"algorithm": 1, "convolut": 1, "discret": 1, "foreman": 1, "jr": 1}}, "716": {"id": "716", "title": "Stringsort (Algorithm 207)", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "stringsort", "boothroyd"], "word_count": {"algorithm": 1, "stringsort": 1, "boothroyd": 1}}, "717": {"id": "717", "title": "Partitioning Algorithms for Finite Sets", "abstract": "The partitions of a set with n elements are represented by certain n-tuples of positive integers.   Algorithm are described which generate without repetitions the n-tuples corresponding to: (1) all partitions  of the given set, (2) all partitions of the given set into m or fewer sets (1 <= m <= n), and (3) all  partitions of the given set into exactly m sets (1 <= m <= n).", "authors": "Hutchinson, G.", "words_pool": ["algorithm", "algorithm", "element", "exactli", "fewer", "finit", "gener", "integ", "partit", "partit", "posit", "repetit", "repres", "set", "set", "tupl", "hutchinson"], "word_count": {"algorithm": 1, "element": 1, "exactli": 1, "fewer": 1, "finit": 1, "gener": 1, "integ": 1, "partit": 4, "posit": 1, "repetit": 1, "repres": 1, "set": 6, "tupl": 2, "hutchinson": 1}}, "718": {"id": "718", "title": "An Experiment in Automatic Verification of Programs", "abstract": "How effective is a compiler at replacing explicit verification, and what is the cost of this  technique?", "authors": "Weinberg, G. M. Gressett, G. L.", "words_pool": ["automat", "compil", "cost", "effect", "experi", "explicit", "program", "replac", "techniqu", "verif", "weinberg", "gressett"], "word_count": {"automat": 1, "compil": 1, "cost": 1, "effect": 1, "experi": 1, "explicit": 1, "program": 1, "replac": 1, "techniqu": 1, "verif": 1, "weinberg": 1, "gressett": 1}}, "719": {"id": "719", "title": "Variable Width Stacks", "abstract": "Character addressable, variable field computers permit ready establishment and manipulation  of variable width stacks.  Single machine commands may push variable field items down into such stacks  or pop them up.  The availability of a variety of field delimiters allows the machine to push down or  pop up more than one variable width item with one command.  Since these stacking operations can be made  the basis of compiler decoding algorithms the proper use of machines of this class for compilation has  advantages over machines with fixed-length words.", "authors": "Rotenberg, N. Opler, A.", "words_pool": ["address", "advantag", "algorithm", "avail", "basi", "charact", "class", "command", "command", "compil", "compil", "comput", "decod", "delimit", "establish", "field", "fix", "item", "item", "length", "machin", "machin", "made", "manipul", "oper", "permit", "pop", "proper", "push", "readi", "singl", "stack", "stack", "variabl", "varieti", "width", "word", "rotenberg", "opler"], "word_count": {"address": 1, "advantag": 1, "algorithm": 1, "avail": 1, "basi": 1, "charact": 1, "class": 1, "command": 2, "compil": 2, "comput": 1, "decod": 1, "delimit": 1, "establish": 1, "field": 3, "fix": 1, "item": 2, "length": 1, "machin": 4, "made": 1, "manipul": 1, "oper": 1, "permit": 1, "pop": 2, "proper": 1, "push": 2, "readi": 1, "singl": 1, "stack": 3, "variabl": 4, "varieti": 1, "width": 2, "word": 1, "rotenberg": 1, "opler": 1}}, "720": {"id": "720", "title": "Format-Free Input in FORTRAN", "authors": "Bailey, M. J. Barnett, M. P. Futrelle, R. P.", "words_pool": ["format", "fortran", "free", "input", "bailey", "barnett", "futrel"], "word_count": {"format": 1, "fortran": 1, "free": 1, "input": 1, "bailey": 1, "barnett": 1, "futrel": 1}}, "721": {"id": "721", "title": "Report on Proposed American Standard Flowchart Symbols for Information Processing", "abstract": "This paper presents the essential contents of the Proposed American Standard Flowchart Symbols  for Information Processing.  This is the first proposed standard prepared by Subcommittee X3.6 on Problem  Description and Analysis of the American Standards Association (ASA).", "authors": "Rossheim, R. J.", "words_pool": ["american", "analysi", "asa", "associ", "content", "descript", "essenti", "flowchart", "inform", "paper", "prepar", "present", "problem", "process", "propos", "report", "standard", "standard", "subcommitte", "symbol", "x3", "rossheim"], "word_count": {"american": 2, "analysi": 1, "asa": 1, "associ": 1, "content": 1, "descript": 1, "essenti": 1, "flowchart": 1, "inform": 1, "paper": 1, "prepar": 1, "present": 1, "problem": 1, "process": 1, "propos": 2, "report": 1, "standard": 3, "subcommitte": 1, "symbol": 1, "x3": 1, "rossheim": 1}}, "722": {"id": "722", "title": "ALCOR Group Representation of ALGOL Symbols", "words_pool": ["alcor", "algol", "group", "represent", "symbol"], "word_count": {"alcor": 1, "algol": 1, "group": 1, "represent": 1, "symbol": 1}}, "723": {"id": "723", "title": "ECMA Subset of ALGOL 60", "words_pool": ["algol", "ecma", "subset"], "word_count": {"algol": 1, "ecma": 1, "subset": 1}}, "724": {"id": "724", "title": "A Profile of the Programmer", "abstract": "Synopsis: 549 members of the ACM participated in a study concerned primarily with the attitudes  of programmers toward their careers and jobs.  A very high percentage of programmers have apparently  entered their careers by accident; it has proven a happy choice for most and they expect to remain in  the field during the next five years.  Their principal job satisfactions relate to the nature of their  work, and mostfind their jobs offer high level of professional interest and good working conditions.   Salary and advancement prospects, however,are not as satisfactory.  More than half report a positive  attitude toward programmers and programming on the part of their organizations.  Turnover among themselves  is attributed primarily to poor management-salary is seen as the principal motivating factor in turnover  among other programmers.  Nature of the work offered and salary are principal determinants in accepting  a new job.  Programmers are less mobile than expected.  Programmers tend to see their colleagues in a  favorable light, on the whole.  Personalities seem to vary with function, systems programmers differing  from applications programmers.  Four principal problems for programming in the immediate future are listed  by participants: languages, personnel, various specific applications and techniques, and building programming  as a profession.", "words_pool": ["accept", "accid", "acm", "advanc", "appar", "applic", "attitud", "attitud", "attribut", "build", "career", "choic", "colleagu", "concern", "condit", "determin", "differ", "enter", "expect", "expect", "factor", "favor", "field", "function", "futur", "good", "half", "happi", "high", "interest", "job", "job", "languag", "level", "light", "list", "manag", "member", "mobil", "mostfind", "motiv", "natur", "offer", "offer", "organ", "part", "particip", "particip", "percentag", "person", "personnel", "poor", "posit", "primarili", "princip", "problem", "profess", "profession", "profil", "programm", "programm", "program", "prospect", "proven", "relat", "remain", "report", "salari", "satisfact", "satisfactori", "seen", "specif", "studi", "synopsi", "system", "techniqu", "tend", "turnov", "vari", "work", "work", "year"], "word_count": {"accept": 1, "accid": 1, "acm": 1, "advanc": 1, "appar": 1, "applic": 2, "attitud": 2, "attribut": 1, "build": 1, "career": 2, "choic": 1, "colleagu": 1, "concern": 1, "condit": 1, "determin": 1, "differ": 1, "enter": 1, "expect": 2, "factor": 1, "favor": 1, "field": 1, "function": 1, "futur": 1, "good": 1, "half": 1, "happi": 1, "high": 2, "interest": 1, "job": 4, "languag": 1, "level": 1, "light": 1, "list": 1, "manag": 1, "member": 1, "mobil": 1, "mostfind": 1, "motiv": 1, "natur": 2, "offer": 2, "organ": 1, "part": 1, "particip": 2, "percentag": 1, "person": 1, "personnel": 1, "poor": 1, "posit": 1, "primarili": 2, "princip": 4, "problem": 1, "profess": 1, "profession": 1, "profil": 1, "programm": 8, "program": 3, "prospect": 1, "proven": 1, "relat": 1, "remain": 1, "report": 1, "salari": 3, "satisfact": 1, "satisfactori": 1, "seen": 1, "specif": 1, "studi": 1, "synopsi": 1, "system": 1, "techniqu": 1, "tend": 1, "turnov": 2, "vari": 1, "work": 3, "year": 1}}, "725": {"id": "725", "title": "Group Participation Computer Demonstration", "authors": "McCormick, E. M.", "words_pool": ["comput", "demonstr", "group", "particip", "mccormick"], "word_count": {"comput": 1, "demonstr": 1, "group": 1, "particip": 1, "mccormick": 1}}, "726": {"id": "726", "title": "A General Program for the Analysis of Square and Rectangular Lattice Designs", "abstract": "This paper describes a general-purpose program that will handle those incomplete block designs  known as square and rectangular lattices.  Flow diagrams are given so that the method of calculation  may be programmed for any digital computer.", "authors": "Smillie, K. W.", "words_pool": ["analysi", "block", "calcul", "comput", "describ", "design", "diagram", "digit", "flow", "gener", "handl", "incomplet", "known", "lattic", "lattic", "method", "paper", "program", "program", "purpos", "rectangular", "squar", "smilli"], "word_count": {"analysi": 1, "block": 1, "calcul": 1, "comput": 1, "describ": 1, "design": 1, "diagram": 1, "digit": 1, "flow": 1, "gener": 1, "handl": 1, "incomplet": 1, "known": 1, "lattic": 1, "method": 1, "paper": 1, "program": 2, "purpos": 1, "rectangular": 1, "squar": 1, "smilli": 1}}, "727": {"id": "727", "title": "On the Approximate Solution of Delta(u)=F(u)", "abstract": "Three-dimensional Dirichlet problems for Delta(u)=F(u), Fu >= 0, are treated numerically by  an exceptionally fast, exceptionally accurate numerical method.  Programming details, numerous examples  and mathematical theory are supplied.Extension of the method in a natural way to n-dimensional problems  is indicated by means of a 4-dimensional example.", "authors": "Greenspan, D. Yohe, M.", "words_pool": ["accur", "approxim", "delta", "detail", "dimension", "dirichlet", "exampl", "except", "extens", "fast", "fu", "mathemat", "mean", "method", "natur", "numer", "numer", "numer", "problem", "program", "solut", "suppli", "theori", "treat", "greenspan", "yohe"], "word_count": {"accur": 1, "approxim": 1, "delta": 1, "detail": 1, "dimension": 3, "dirichlet": 1, "exampl": 1, "except": 2, "extens": 1, "fast": 1, "fu": 1, "mathemat": 1, "mean": 1, "method": 2, "natur": 1, "numer": 3, "problem": 2, "program": 1, "solut": 1, "suppli": 1, "theori": 1, "treat": 1, "greenspan": 1, "yohe": 1}}, "728": {"id": "728", "title": "Computer-Drawn Flowcharts*", "abstract": "To meet the need for improved documentation of written computer programs, a simple system for  effective communication is presented, which has shown great promise.  The programmer describes his program  in a simple format, and the computer prepares flow charts and other cross-referenced listings from this  input.  The description can be kept up-to-date easily, and the final output clearly explains the original  program.  The system has also proved to be a valuable debugging and coding aid.", "authors": "Knuth, D. E.", "words_pool": ["aid", "chart", "clearli", "code", "commun", "comput", "cross", "date", "debug", "describ", "descript", "document", "drawn", "easili", "effect", "explain", "final", "flow", "flowchart", "format", "great", "improv", "input", "list", "meet", "need", "origin", "output", "prepar", "present", "program", "programm", "program", "promis", "prove", "referenc", "shown", "simpl", "system", "valuabl", "written", "knuth"], "word_count": {"aid": 1, "chart": 1, "clearli": 1, "code": 1, "commun": 1, "comput": 2, "cross": 1, "date": 1, "debug": 1, "describ": 1, "descript": 1, "document": 1, "drawn": 1, "easili": 1, "effect": 1, "explain": 1, "final": 1, "flow": 1, "flowchart": 1, "format": 1, "great": 1, "improv": 1, "input": 1, "list": 1, "meet": 1, "need": 1, "origin": 1, "output": 1, "prepar": 1, "present": 1, "program": 3, "programm": 1, "promis": 1, "prove": 1, "referenc": 1, "shown": 1, "simpl": 2, "system": 2, "valuabl": 1, "written": 1, "knuth": 1}}, "729": {"id": "729", "title": "A Generalization of ALGOL", "authors": "Wirth, N.", "words_pool": ["algol", "gener", "wirth"], "word_count": {"algol": 1, "gener": 1, "wirth": 1}}, "730": {"id": "730", "title": "MIRFAG: A Compiler Based on Standard Mathematical Notation And Plain English", "abstract": "A pilot version of the compiler MIRFAG, now in operation, is described.  The chief features  of the system, which is intended for the solution of scientific problems, are the presentation of mathematical  formulas entirely in standard textbook notation.  The use of plain English for organizational instructions,  automatic error diagnosis indicating the actual location of the error in the uncompiled program, and  an attempt to minimize that fragmentation of the original problem statement which is a normal feature  of programming systems.", "authors": "Gawlik, H. J.", "words_pool": ["actual", "attempt", "automat", "base", "chief", "compil", "diagnosi", "english", "entir", "error", "featur", "featur", "formula", "fragment", "indic", "instruct", "intend", "locat", "mathemat", "minim", "mirfag", "normal", "notat", "oper", "organiz", "origin", "pilot", "plain", "present", "problem", "problem", "program", "program", "scientif", "solut", "standard", "statement", "system", "system", "textbook", "uncompil", "version", "gawlik"], "word_count": {"actual": 1, "attempt": 1, "automat": 1, "base": 1, "chief": 1, "compil": 1, "diagnosi": 1, "english": 1, "entir": 1, "error": 2, "featur": 2, "formula": 1, "fragment": 1, "indic": 1, "instruct": 1, "intend": 1, "locat": 1, "mathemat": 1, "minim": 1, "mirfag": 1, "normal": 1, "notat": 1, "oper": 1, "organiz": 1, "origin": 1, "pilot": 1, "plain": 1, "present": 1, "problem": 2, "program": 2, "scientif": 1, "solut": 1, "standard": 1, "statement": 1, "system": 2, "textbook": 1, "uncompil": 1, "version": 1, "gawlik": 1}}, "731": {"id": "731", "title": "Symmetric List Processor", "abstract": "A list processing system in which each list cell contains both a forward and a backward link  as well as a datum is described.  This system is intended for imbeding in higher level languages capable  of calling functions and subroutines coded in machine language.  The presentation is in the form of FORTRAN  programs depending on only a limited set of FORTRAN programs depending on only a limited set of \"primitive\"  machine language subroutines which are also defined.  Finally, a set of field, particularly character,  manipulation primitives are given to round out the system.", "authors": "Weizenbaum, J.", "words_pool": ["backward", "call", "capabl", "cell", "charact", "code", "datum", "defin", "depend", "field", "final", "form", "fortran", "forward", "function", "higher", "imbed", "intend", "languag", "languag", "level", "limit", "link", "list", "machin", "manipul", "present", "primit", "primit", "process", "processor", "program", "round", "set", "subroutin", "symmetr", "system", "weizenbaum"], "word_count": {"backward": 1, "call": 1, "capabl": 1, "cell": 1, "charact": 1, "code": 1, "datum": 1, "defin": 1, "depend": 2, "field": 1, "final": 1, "form": 1, "fortran": 2, "forward": 1, "function": 1, "higher": 1, "imbed": 1, "intend": 1, "languag": 3, "level": 1, "limit": 2, "link": 1, "list": 2, "machin": 2, "manipul": 1, "present": 1, "primit": 2, "process": 1, "processor": 1, "program": 2, "round": 1, "set": 3, "subroutin": 2, "symmetr": 1, "system": 3, "weizenbaum": 1}}, "732": {"id": "732", "title": "Monte Carlo Inverse (Algorithm 166)", "authors": "Rodman,R. D.", "words_pool": ["algorithm", "carlo", "invers", "mont", "rodman"], "word_count": {"algorithm": 1, "carlo": 1, "invers": 1, "mont": 1, "rodman": 1}}, "733": {"id": "733", "title": "Newton Interpolation with Forward Divided Differences (Algorithm 169)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "differ", "divid", "forward", "interpol", "newton", "thacher", "jr"], "word_count": {"algorithm": 1, "differ": 1, "divid": 1, "forward": 1, "interpol": 1, "newton": 1, "thacher": 1, "jr": 1}}, "734": {"id": "734", "title": "Newton Interpolation with Backward Divided Differences (Algorithm 168)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "backward", "differ", "divid", "interpol", "newton", "thacher", "jr"], "word_count": {"algorithm": 1, "backward": 1, "differ": 1, "divid": 1, "interpol": 1, "newton": 1, "thacher": 1, "jr": 1}}, "735": {"id": "735", "title": "Calculation of Confluent Divided Differences (Algorithm 167)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "calcul", "confluent", "differ", "divid", "thacher", "jr"], "word_count": {"algorithm": 1, "calcul": 1, "confluent": 1, "differ": 1, "divid": 1, "thacher": 1, "jr": 1}}, "736": {"id": "736", "title": "Modified Hankel Functions (Algorithm 163)", "authors": "Thacher Jr.,H. C.", "words_pool": ["algorithm", "function", "hankel", "modifi", "thacher", "jr"], "word_count": {"algorithm": 1, "function": 1, "hankel": 1, "modifi": 1, "thacher": 1, "jr": 1}}, "737": {"id": "737", "title": "Exponentiation of Series (Algorithm 158)", "authors": "Lawrence, J. D.", "words_pool": ["algorithm", "exponenti", "seri", "lawrenc"], "word_count": {"algorithm": 1, "exponenti": 1, "seri": 1, "lawrenc": 1}}, "738": {"id": "738", "title": "Fourier Series Approximation (Algorithm 157)", "authors": "George, R.", "words_pool": ["algorithm", "approxim", "fourier", "seri", "georg"], "word_count": {"algorithm": 1, "approxim": 1, "fourier": 1, "seri": 1, "georg": 1}}, "739": {"id": "739", "title": "MINIFUN (Algorithm 129)", "authors": "Wasscher, E. J.", "words_pool": ["algorithm", "minifun", "wasscher"], "word_count": {"algorithm": 1, "minifun": 1, "wasscher": 1}}, "740": {"id": "740", "title": "INTEREST (Algorithm 45)", "authors": "Wright, C. B.", "words_pool": ["algorithm", "interest", "wright"], "word_count": {"algorithm": 1, "interest": 1, "wright": 1}}, "741": {"id": "741", "title": "Evaluation of Determinant (Algorithm 41)", "authors": "Freed, B. H.", "words_pool": ["algorithm", "determin", "evalu", "freed"], "word_count": {"algorithm": 1, "determin": 1, "evalu": 1, "freed": 1}}, "742": {"id": "742", "title": "Evaluation of Determinant (Algorithm 41)", "authors": "Freed, B. H.", "words_pool": ["algorithm", "determin", "evalu", "freed"], "word_count": {"algorithm": 1, "determin": 1, "evalu": 1, "freed": 1}}, "743": {"id": "743", "title": "ARCCOSIN (Algorithm 206)", "authors": "Konda, M.", "words_pool": ["algorithm", "arccosin", "konda"], "word_count": {"algorithm": 1, "arccosin": 1, "konda": 1}}, "744": {"id": "744", "title": "ATIVE (Algorithm 205)", "authors": "Haubrich, J. G. A.", "words_pool": ["algorithm", "ativ", "haubrich"], "word_count": {"algorithm": 1, "ativ": 1, "haubrich": 1}}, "745": {"id": "745", "title": "STEEP2 (Algorithm 204)", "authors": "Wasscher, E. J.", "words_pool": ["algorithm", "steep2", "wasscher"], "word_count": {"algorithm": 1, "steep2": 1, "wasscher": 1}}, "746": {"id": "746", "title": "STEEP1 (Algorithm 203)", "authors": "Wasscher, E. J.", "words_pool": ["algorithm", "steep1", "wasscher"], "word_count": {"algorithm": 1, "steep1": 1, "wasscher": 1}}, "747": {"id": "747", "title": "Generation of Permutations in Lexicographical Order (Algorithm 202)", "authors": "Shen, M. K.", "words_pool": ["algorithm", "gener", "lexicograph", "order", "permut", "shen"], "word_count": {"algorithm": 1, "gener": 1, "lexicograph": 1, "order": 1, "permut": 1, "shen": 1}}, "748": {"id": "748", "title": "A Semi-Iterative Process for Evaluating Arctangents", "authors": "Chu, W. H. Saathoff, D. R.", "words_pool": ["arctang", "evalu", "iter", "process", "semi", "chu", "saathoff"], "word_count": {"arctang": 1, "evalu": 1, "iter": 1, "process": 1, "semi": 1, "chu": 1, "saathoff": 1}}, "749": {"id": "749", "title": "Note onStochastic Matrices", "authors": "Dumey, A. I.", "words_pool": ["matric", "note", "onstochast", "dumey"], "word_count": {"matric": 1, "note": 1, "onstochast": 1, "dumey": 1}}, "750": {"id": "750", "title": "PEI Matrix Eigenvectors", "authors": "Newbery, A. C. R.", "words_pool": ["eigenvector", "matrix", "pei", "newberi"], "word_count": {"eigenvector": 1, "matrix": 1, "pei": 1, "newberi": 1}}, "751": {"id": "751", "title": "A Note on a Set of Test Matrices for Inversion", "authors": "Rodman, R. D.", "words_pool": ["invers", "matric", "note", "set", "test", "rodman"], "word_count": {"invers": 1, "matric": 1, "note": 1, "set": 1, "test": 1, "rodman": 1}}, "752": {"id": "752", "title": "Closing Out a Print Tape", "authors": "Moore, D. P.", "words_pool": ["close", "print", "tape", "moor"], "word_count": {"close": 1, "print": 1, "tape": 1, "moor": 1}}, "753": {"id": "753", "title": "A Procedure for Converting Logic Table Conditions into an Efficient Sequence of Test Instructions", "authors": "Egler, J. F.", "words_pool": ["condit", "convert", "effici", "instruct", "logic", "procedur", "sequenc", "tabl", "test", "egler"], "word_count": {"condit": 1, "convert": 1, "effici": 1, "instruct": 1, "logic": 1, "procedur": 1, "sequenc": 1, "tabl": 1, "test": 1, "egler": 1}}, "754": {"id": "754", "title": "Ye Indiscreet Monitor", "authors": "Blatt, J. M.", "words_pool": ["indiscreet", "monitor", "ye", "blatt"], "word_count": {"indiscreet": 1, "monitor": 1, "ye": 1, "blatt": 1}}, "755": {"id": "755", "title": "An Exponential Method of Numerical Integration of Ordinary Differential Equations", "abstract": "A formula for numerical integration is prepared, which involves an exponential term.  This  formula is compared to two standard integration methods, and it is shown that for a large class of differential  equations, the exponential formula has superior stability properties for large step sizes.  Thus this  formula may be used with a large step size to decrease the total computing time for a solution significantly,  particularly in those engineering problems where high accuracy is not needed.", "authors": "Pope, D. A.", "words_pool": ["accuraci", "class", "compar", "comput", "decreas", "differenti", "engin", "equat", "exponenti", "formula", "high", "integr", "involv", "larg", "method", "method", "need", "numer", "ordinari", "prepar", "problem", "properti", "shown", "significantli", "size", "size", "solut", "stabil", "standard", "step", "superior", "term", "time", "total", "pope"], "word_count": {"accuraci": 1, "class": 1, "compar": 1, "comput": 1, "decreas": 1, "differenti": 1, "engin": 1, "equat": 1, "exponenti": 2, "formula": 4, "high": 1, "integr": 2, "involv": 1, "larg": 3, "method": 1, "need": 1, "numer": 1, "ordinari": 1, "prepar": 1, "problem": 1, "properti": 1, "shown": 1, "significantli": 1, "size": 2, "solut": 1, "stabil": 1, "standard": 1, "step": 2, "superior": 1, "term": 1, "time": 1, "total": 1, "pope": 1}}, "756": {"id": "756", "title": "A Computer Program for Editing the News", "authors": "Danielson, W. A. Briggs, B.", "words_pool": ["comput", "edit", "news", "program", "danielson", "brigg"], "word_count": {"comput": 1, "edit": 1, "news": 1, "program": 1, "danielson": 1, "brigg": 1}}, "757": {"id": "757", "title": "Simulation of a Traffic Network", "authors": "Katz, J. H.", "words_pool": ["network", "simul", "traffic", "katz"], "word_count": {"network": 1, "simul": 1, "traffic": 1, "katz": 1}}, "758": {"id": "758", "title": "Skeletal Structure of PERT and CPA Computer Programs", "abstract": "An introduction to the inner mechanics of PERT and CPA computer programs is provided.  The  major components of these programs as well as their purposes and interrelationships are outlined.", "authors": "Kahn, A. B.", "words_pool": ["compon", "comput", "cpa", "interrelationship", "introduct", "major", "mechan", "outlin", "pert", "program", "provid", "purpos", "skelet", "structur", "kahn"], "word_count": {"compon": 1, "comput": 1, "cpa": 1, "interrelationship": 1, "introduct": 1, "major": 1, "mechan": 1, "outlin": 1, "pert": 1, "program": 2, "provid": 1, "purpos": 1, "skelet": 1, "structur": 1, "kahn": 1}}, "759": {"id": "759", "title": "Continued Operation Notation for Symbol Manipulation and Array Processing", "abstract": "A brief account is given of a notational device that is very useful in the formal representation  of syntaxes, string relationships and string transformation procedures and also of computing procedures  that deal with arrays of functions of many variables.  The device consists of the use of certain \"continued  operation\" or \"collective\" symbols that are analogous to the summation symbol (Sigma) and continued multiplication  symbol (Pi) of conventional mathematics.", "authors": "Barnett, M. P.", "words_pool": ["account", "analog", "array", "array", "collect", "comput", "consist", "continu", "convent", "deal", "devic", "formal", "function", "manipul", "mathemat", "multipl", "notat", "notat", "oper", "pi", "procedur", "process", "relationship", "represent", "sigma", "string", "summat", "symbol", "symbol", "syntax", "transform", "variabl", "barnett"], "word_count": {"account": 1, "analog": 1, "array": 1, "collect": 1, "comput": 1, "consist": 1, "continu": 2, "convent": 1, "deal": 1, "devic": 2, "formal": 1, "function": 1, "manipul": 1, "mathemat": 1, "multipl": 1, "notat": 1, "oper": 1, "pi": 1, "procedur": 2, "process": 1, "relationship": 1, "represent": 1, "sigma": 1, "string": 2, "summat": 1, "symbol": 3, "syntax": 1, "transform": 1, "variabl": 1, "barnett": 1}}, "760": {"id": "760", "title": "Dialects of FORTRAN", "authors": "Pyle, I. C.", "words_pool": ["dialect", "fortran", "pyle"], "word_count": {"dialect": 1, "fortran": 1, "pyle": 1}}, "761": {"id": "761", "title": "A Note on the Dangling Else in ALGOL 60", "abstract": "Some revisions of ALGOL 60 are proposed, which not only eliminate certain ambiguous statements  but also add some convenience to the language.  A discussion of the background of the problem and a sketch  of a proof that the ambiguities have been removed is included.", "authors": "Kaupe Jr., A. F.", "words_pool": ["add", "algol", "ambigu", "ambigu", "background", "conveni", "dangl", "discuss", "elimin", "includ", "languag", "note", "problem", "proof", "propos", "remov", "revis", "sketch", "statement", "kaup", "jr"], "word_count": {"add": 1, "algol": 1, "ambigu": 2, "background": 1, "conveni": 1, "dangl": 1, "discuss": 1, "elimin": 1, "includ": 1, "languag": 1, "note": 1, "problem": 1, "proof": 1, "propos": 1, "remov": 1, "revis": 1, "sketch": 1, "statement": 1, "kaup": 1, "jr": 1}}, "762": {"id": "762", "title": "Some Remarks on the Syntax of Symbolic Programming Languages", "authors": "DiForino, A. C.", "words_pool": ["languag", "program", "remark", "symbol", "syntax", "diforino"], "word_count": {"languag": 1, "program": 1, "remark": 1, "symbol": 1, "syntax": 1, "diforino": 1}}, "763": {"id": "763", "title": "A Syntax Controlled Generator of Formal Language Processors", "authors": "Eickel, J. Bauer, F. L. Paul, M. Samelson, K.", "words_pool": ["control", "formal", "gener", "languag", "processor", "syntax", "eickel", "bauer", "paul", "samelson"], "word_count": {"control": 1, "formal": 1, "gener": 1, "languag": 1, "processor": 1, "syntax": 1, "eickel": 1, "bauer": 1, "paul": 1, "samelson": 1}}, "764": {"id": "764", "title": "Reduction of a Matrix Containing Polynomial Elements (Algorithm 170)", "authors": "Hennion, P. E.", "words_pool": ["algorithm", "element", "matrix", "polynomi", "reduct", "hennion"], "word_count": {"algorithm": 1, "element": 1, "matrix": 1, "polynomi": 1, "reduct": 1, "hennion": 1}}, "765": {"id": "765", "title": "Orthogonal Polynomial Least Squares Surface Fit (Algorithm 164)", "authors": "Bitterli, C. V.", "words_pool": ["algorithm", "fit", "orthogon", "polynomi", "squar", "surfac", "bitterli"], "word_count": {"algorithm": 1, "fit": 1, "orthogon": 1, "polynomi": 1, "squar": 1, "surfac": 1, "bitterli": 1}}, "766": {"id": "766", "title": "XY-move Plotting (Algorithm 162)", "authors": "Fletcher, W. E.", "words_pool": ["algorithm", "move", "plot", "xy", "fletcher"], "word_count": {"algorithm": 1, "move": 1, "plot": 1, "xy": 1, "fletcher": 1}}, "767": {"id": "767", "title": "Certification of Algorithm 161 Combinatorial of M Things Taken One at a Time, Two at a Time, Up to N at a Time [M. L. Wolfson and H. V. Wright, Comm. ACM, Apr. 1963]", "authors": "Thoro, D.", "words_pool": ["acm", "algorithm", "apr", "certif", "combinatori", "comm", "thing", "time", "wolfson", "wright", "thoro"], "word_count": {"acm": 1, "algorithm": 1, "apr": 1, "certif": 1, "combinatori": 1, "comm": 1, "thing": 1, "time": 3, "wolfson": 1, "wright": 1, "thoro": 1}}, "768": {"id": "768", "title": "Certification of Algorithm 160 Combinatorial of M Things Taken N at a Time [M. L. Wolfson and H. V. Wright, Comm. ACM, Apr. 1963]", "authors": "Thoro, D.", "words_pool": ["acm", "algorithm", "apr", "certif", "combinatori", "comm", "thing", "time", "wolfson", "wright", "thoro"], "word_count": {"acm": 1, "algorithm": 1, "apr": 1, "certif": 1, "combinatori": 1, "comm": 1, "thing": 1, "time": 1, "wolfson": 1, "wright": 1, "thoro": 1}}, "769": {"id": "769", "title": "Algebra of Sets (Algorithm 156)", "authors": "Bosworth, K. M.", "words_pool": ["algebra", "algorithm", "set", "bosworth"], "word_count": {"algebra": 1, "algorithm": 1, "set": 1, "bosworth": 1}}, "770": {"id": "770", "title": "Combination in Any Order (Algorithm 155)", "authors": "Bosworth, K. M.", "words_pool": ["algorithm", "combin", "order", "bosworth"], "word_count": {"algorithm": 1, "combin": 1, "order": 1, "bosworth": 1}}, "771": {"id": "771", "title": "Combination in Lexicographical Order (Algorithm 154)", "authors": "Bosworth, K. M.", "words_pool": ["algorithm", "combin", "lexicograph", "order", "bosworth"], "word_count": {"algorithm": 1, "combin": 1, "lexicograph": 1, "order": 1, "bosworth": 1}}, "772": {"id": "772", "title": "GOMORY (Algorithm 153)", "authors": "Lefkowitz, B. D'Esopo, D. A.", "words_pool": ["algorithm", "gomori", "lefkowitz", "esopo"], "word_count": {"algorithm": 1, "gomori": 1, "lefkowitz": 1, "esopo": 1}}, "773": {"id": "773", "title": "Matrix Inversion (Algorithm 140)", "authors": "George, R.", "words_pool": ["algorithm", "invers", "matrix", "georg"], "word_count": {"algorithm": 1, "invers": 1, "matrix": 1, "georg": 1}}, "774": {"id": "774", "title": "Jacobi (Algorithm 85)", "authors": "Naur, P.", "words_pool": ["algorithm", "jacobi", "naur"], "word_count": {"algorithm": 1, "jacobi": 1, "naur": 1}}, "775": {"id": "775", "title": "Interpolation, Differentiation, and Integration (Algorithm 77)", "authors": "Hennion, P. E.", "words_pool": ["algorithm", "differenti", "integr", "interpol", "hennion"], "word_count": {"algorithm": 1, "differenti": 1, "integr": 1, "interpol": 1, "hennion": 1}}, "776": {"id": "776", "title": "Partition, Quicksort, and Find (Algorithm 62, 64, & 65)", "authors": "Randell, B. Russell, L. J.", "words_pool": ["algorithm", "find", "partit", "quicksort", "randel", "russel"], "word_count": {"algorithm": 1, "find": 1, "partit": 1, "quicksort": 1, "randel": 1, "russel": 1}}, "777": {"id": "777", "title": "A Set of Test Matrices (Algorithm 52)", "authors": "Naur, P.", "words_pool": ["algorithm", "matric", "set", "test", "naur"], "word_count": {"algorithm": 1, "matric": 1, "set": 1, "test": 1, "naur": 1}}, "778": {"id": "778", "title": "Associated Legendre Functions of the First Kind for Real or Imaginary Arguments (Algorithm 47)", "authors": "George, R.", "words_pool": ["algorithm", "argument", "function", "imaginari", "kind", "legendr", "real", "georg"], "word_count": {"algorithm": 1, "argument": 1, "function": 1, "imaginari": 1, "kind": 1, "legendr": 1, "real": 1, "georg": 1}}, "779": {"id": "779", "title": "CROUT II (Algorithm 43)", "authors": "Domingo, C. Rodriguez-Gil, F.", "words_pool": ["algorithm", "crout", "ii", "domingo", "rodriguez", "gil"], "word_count": {"algorithm": 1, "crout": 1, "ii": 1, "domingo": 1, "rodriguez": 1, "gil": 1}}, "780": {"id": "780", "title": "Algorithm 42 INVERT, Alg.107 Gauss's Method, Alg.120 Inversion II, and gjr", "authors": "Naur, P.", "words_pool": ["alg", "algorithm", "gauss", "gjr", "ii", "invers", "invert", "method", "naur"], "word_count": {"alg": 2, "algorithm": 1, "gauss": 1, "gjr": 1, "ii": 1, "invers": 1, "invert": 1, "method": 1, "naur": 1}}, "781": {"id": "781", "title": "Telescope 2 (Algorithm 38)", "authors": "Bridges, J. F.", "words_pool": ["algorithm", "telescop", "bridg"], "word_count": {"algorithm": 1, "telescop": 1, "bridg": 1}}, "782": {"id": "782", "title": "Telescope 1 (Algorithm 37)", "authors": "Bridges, J. F.", "words_pool": ["algorithm", "telescop", "bridg"], "word_count": {"algorithm": 1, "telescop": 1, "bridg": 1}}, "783": {"id": "783", "title": "Shellsort (Algorithm 201)", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "shellsort", "boothroyd"], "word_count": {"algorithm": 1, "shellsort": 1, "boothroyd": 1}}, "784": {"id": "784", "title": "Normal Random (Algorithm 200)", "authors": "George, R.", "words_pool": ["algorithm", "normal", "random", "georg"], "word_count": {"algorithm": 1, "normal": 1, "random": 1, "georg": 1}}, "785": {"id": "785", "title": "Conversions Between Calendar Date And Julian day Number (Algorithm 199)", "authors": "Tantzen, R. G.", "words_pool": ["algorithm", "calendar", "convers", "date", "day", "julian", "number", "tantzen"], "word_count": {"algorithm": 1, "calendar": 1, "convers": 1, "date": 1, "day": 1, "julian": 1, "number": 1, "tantzen": 1}}, "786": {"id": "786", "title": "Adaptive Integration and Multiple Integration (Algorithm 198)", "authors": "McKeeman, W. M.", "words_pool": ["adapt", "algorithm", "integr", "multipl", "mckeeman"], "word_count": {"adapt": 1, "algorithm": 1, "integr": 2, "multipl": 1, "mckeeman": 1}}, "787": {"id": "787", "title": "Matrix Division (Algorithm 197)", "authors": "Wells, M.", "words_pool": ["algorithm", "divis", "matrix", "well"], "word_count": {"algorithm": 1, "divis": 1, "matrix": 1, "well": 1}}, "788": {"id": "788", "title": "Muller's Method for Finding Roots of an Arbitrary Function (Algorithm 196)", "authors": "Roman, R. D.", "words_pool": ["algorithm", "arbitrari", "find", "function", "method", "muller", "root", "roman"], "word_count": {"algorithm": 1, "arbitrari": 1, "find": 1, "function": 1, "method": 1, "muller": 1, "root": 1, "roman": 1}}, "789": {"id": "789", "title": "Bandsolve (Algorithm 195)", "authors": "Thurnau, D. H.", "words_pool": ["algorithm", "bandsolv", "thurnau"], "word_count": {"algorithm": 1, "bandsolv": 1, "thurnau": 1}}, "790": {"id": "790", "title": "Zersol (Algorithm 194)", "authors": "Domingo, C.", "words_pool": ["algorithm", "zersol", "domingo"], "word_count": {"algorithm": 1, "zersol": 1, "domingo": 1}}, "791": {"id": "791", "title": "Character Manipulation in 7090 Fortran", "authors": "Smith, D. D.", "words_pool": ["charact", "fortran", "manipul", "smith"], "word_count": {"charact": 1, "fortran": 1, "manipul": 1, "smith": 1}}, "792": {"id": "792", "title": "Multiple-Precision Binary-To-Decimal Integer Conversion Using Only Addition And Subtraction", "authors": "Keyes, D. F. Moore, D. P.", "words_pool": ["addit", "binari", "convers", "decim", "integ", "multipl", "precis", "subtract", "key", "moor"], "word_count": {"addit": 1, "binari": 1, "convers": 1, "decim": 1, "integ": 1, "multipl": 1, "precis": 1, "subtract": 1, "key": 1, "moor": 1}}, "793": {"id": "793", "title": "Mapped List Structures", "authors": "Baecker, H. D.", "words_pool": ["list", "map", "structur", "baecker"], "word_count": {"list": 1, "map": 1, "structur": 1, "baecker": 1}}, "794": {"id": "794", "title": "A List-Type Storage Technique for Alphameric Information", "abstract": "A method which is economic in terms of space and time is proposed for the storage and manipulation  of character strings of arbitrary length in a fixed word-length computer.  The method is illustrated  in an application to Algol-type identifiers in an Algol-like block structure.", "authors": "Bowlden, H. J.", "words_pool": ["algol", "alphamer", "applic", "arbitrari", "block", "charact", "comput", "econom", "fix", "identifi", "illustr", "inform", "length", "list", "manipul", "method", "propos", "space", "storag", "string", "structur", "techniqu", "term", "time", "type", "word", "bowlden"], "word_count": {"algol": 2, "alphamer": 1, "applic": 1, "arbitrari": 1, "block": 1, "charact": 1, "comput": 1, "econom": 1, "fix": 1, "identifi": 1, "illustr": 1, "inform": 1, "length": 2, "list": 1, "manipul": 1, "method": 2, "propos": 1, "space": 1, "storag": 1, "string": 1, "structur": 1, "techniqu": 1, "term": 1, "time": 1, "type": 1, "word": 1, "bowlden": 1}}, "795": {"id": "795", "title": "Debugging Systems at the Source Language Level", "authors": "Ferguson, H. E. Berner, E.", "words_pool": ["debug", "languag", "level", "sourc", "system", "ferguson", "berner"], "word_count": {"debug": 1, "languag": 1, "level": 1, "sourc": 1, "system": 1, "ferguson": 1, "berner": 1}}, "796": {"id": "796", "title": "SABRAG, A Time-Sharing Low-Cost Computer", "abstract": "The serial SABRAC computer designed and built in the Scientific Department of the Israel defense  Ministry has a 5000-location magnetic drum, main store.  To avoid a need to resort to optimum programming  techniques and to increase its overall efficiency the computer has also been given a 224-word ferrite  core store from which the program is obeyed.  Transfers between the core and drum stores and to and from  the twin paper-tape input and output channels are all available autonomously (concurrently, time-shared).   Multiplication and division orders are also autonomous, so that the machine may be executing up to three  orders simultaneously.  All functions naturally are interlocked.  A number of other advanced orders and  facilities are also incorporated", "words_pool": ["advanc", "autonom", "autonom", "avoid", "built", "channel", "comput", "concurr", "core", "cost", "defens", "depart", "design", "divis", "drum", "effici", "execut", "facil", "ferrit", "function", "incorpor", "increas", "input", "interlock", "israel", "locat", "low", "machin", "magnet", "main", "ministri", "multipl", "natur", "need", "number", "obey", "optimum", "order", "output", "paper", "program", "program", "resort", "sabrac", "sabrag", "scientif", "serial", "share", "share", "simultan", "store", "store", "tape", "techniqu", "time", "transfer", "twin", "word"], "word_count": {"advanc": 1, "autonom": 2, "avoid": 1, "built": 1, "channel": 1, "comput": 2, "concurr": 1, "core": 2, "cost": 1, "defens": 1, "depart": 1, "design": 1, "divis": 1, "drum": 2, "effici": 1, "execut": 1, "facil": 1, "ferrit": 1, "function": 1, "incorpor": 1, "increas": 1, "input": 1, "interlock": 1, "israel": 1, "locat": 1, "low": 1, "machin": 1, "magnet": 1, "main": 1, "ministri": 1, "multipl": 1, "natur": 1, "need": 1, "number": 1, "obey": 1, "optimum": 1, "order": 3, "output": 1, "paper": 1, "program": 2, "resort": 1, "sabrac": 1, "sabrag": 1, "scientif": 1, "serial": 1, "share": 1, "simultan": 1, "store": 3, "tape": 1, "techniqu": 1, "time": 1, "transfer": 1, "twin": 1, "word": 1}}, "n particular, an \"Execute\" order permits a temporary jump for up  to four orders and a second modifier register permits double modification in general and relative addressing  of subroutines in particular.  Thus the overall effective speed of the machine is muchhigher than its  basic specification would lead one to expect and its design indicates one way in which the concepts of  time sharing may be incorporated in \"low-cost\" computers.": {"id": "n particular, an \"Execute\" order permits a temporary jump for up  to four orders and a second modifier register permits double modification in general and relative addressing  of subroutines in particular.  Thus the overall effective speed of the machine is muchhigher than its  basic specification would lead one to expect and its design indicates one way in which the concepts of  time sharing may be incorporated in \"low-cost\" computers.", "authors": "Lehman, M. Netter, Z. Eshed, R.", "words_pool": ["lehman", "netter", "esh"], "word_count": {"lehman": 1, "netter": 1, "esh": 1}}, "797": {"id": "797", "title": "American Standard Code for Information Interchange", "words_pool": ["american", "code", "inform", "interchang", "standard"], "word_count": {"american": 1, "code": 1, "inform": 1, "interchang": 1, "standard": 1}}, "798": {"id": "798", "title": "A Catalogue Entry Retrieval System", "authors": "Scheff, B. H.", "words_pool": ["catalogu", "entri", "retriev", "system", "scheff"], "word_count": {"catalogu": 1, "entri": 1, "retriev": 1, "system": 1, "scheff": 1}}, "799": {"id": "799", "title": "Design of a Separable Transition-Diagram Compiler*", "abstract": "A COBOL compiler design is presented which is compact enough to permit rapid, one-pass compilation  of a large subset of COBOL on a moderately large computer.  Versions of the same compiler for smaller  machines require only two working tapes plus a compiler tape.  The methods given are largely applicable  to the construction of ALGOL compilers.", "authors": "Conway, M. E.", "words_pool": ["algol", "applic", "cobol", "compact", "compil", "compil", "compil", "comput", "construct", "design", "diagram", "larg", "larg", "machin", "method", "moder", "pass", "permit", "present", "rapid", "requir", "separ", "smaller", "subset", "tape", "tape", "transit", "version", "work", "conway"], "word_count": {"algol": 1, "applic": 1, "cobol": 2, "compact": 1, "compil": 5, "comput": 1, "construct": 1, "design": 1, "diagram": 1, "larg": 3, "machin": 1, "method": 1, "moder": 1, "pass": 1, "permit": 1, "present": 1, "rapid": 1, "requir": 1, "separ": 1, "smaller": 1, "subset": 1, "tape": 2, "transit": 1, "version": 1, "work": 1, "conway": 1}}, "800": {"id": "800", "title": "The Linking Segment Subprogram Language and Linking Loader", "authors": "McCarthy, J. Corbato, F. J. Daggett, M. M.", "words_pool": ["languag", "link", "loader", "segment", "subprogram", "mccarthi", "corbato", "daggett"], "word_count": {"languag": 1, "link": 2, "loader": 1, "segment": 1, "subprogram": 1, "mccarthi": 1, "corbato": 1, "daggett": 1}}, "801": {"id": "801", "title": "Least Squares Solution with Constraints (Algorithm 177)", "authors": "Synge, M. J.", "words_pool": ["algorithm", "constraint", "solut", "squar", "syng"], "word_count": {"algorithm": 1, "constraint": 1, "solut": 1, "squar": 1, "syng": 1}}, "802": {"id": "802", "title": "SYMINV2 (Algorithm 150)", "authors": "Rutishauser, H.", "words_pool": ["algorithm", "syminv2", "rutishaus"], "word_count": {"algorithm": 1, "syminv2": 1, "rutishaus": 1}}, "803": {"id": "803", "title": "Syminv2 (Algorithm 150)", "authors": "Evans Jr., A.", "words_pool": ["algorithm", "syminv2", "evan", "jr"], "word_count": {"algorithm": 1, "syminv2": 1, "evan": 1, "jr": 1}}, "804": {"id": "804", "title": "Exponentiation of Series (Algorithms 134)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "exponenti", "seri", "thacher", "jr"], "word_count": {"algorithm": 1, "exponenti": 1, "seri": 1, "thacher": 1, "jr": 1}}, "805": {"id": "805", "title": "Newton Maehly (Algorithm 105)", "authors": "Kondo, J.", "words_pool": ["algorithm", "maehli", "newton", "kondo"], "word_count": {"algorithm": 1, "maehli": 1, "newton": 1, "kondo": 1}}, "806": {"id": "806", "title": "Remark on Certification of Matrix Inversion Procedures", "authors": "Moler, C.", "words_pool": ["certif", "invers", "matrix", "procedur", "remark", "moler"], "word_count": {"certif": 1, "invers": 1, "matrix": 1, "procedur": 1, "remark": 1, "moler": 1}}, "807": {"id": "807", "title": "Reversion of Series (Algorithm 193)", "authors": "Fettis, H. E.", "words_pool": ["algorithm", "revers", "seri", "fetti"], "word_count": {"algorithm": 1, "revers": 1, "seri": 1, "fetti": 1}}, "808": {"id": "808", "title": "Confluent Hypergeometric (Algorithm 192)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "confluent", "hypergeometr", "relph"], "word_count": {"algorithm": 1, "confluent": 1, "hypergeometr": 1, "relph": 1}}, "809": {"id": "809", "title": "Hypergeometric (Algorithm 191)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "hypergeometr", "relph"], "word_count": {"algorithm": 1, "hypergeometr": 1, "relph": 1}}, "810": {"id": "810", "title": "Complex Power (Algorithm 190)", "authors": "Relph, A. P.", "words_pool": ["algorithm", "complex", "power", "relph"], "word_count": {"algorithm": 1, "complex": 1, "power": 1, "relph": 1}}, "811": {"id": "811", "title": "Smoothing 2 (Algorithm 189)", "authors": "Rodriguez Gil, F.", "words_pool": ["algorithm", "smooth", "rodriguez", "gil"], "word_count": {"algorithm": 1, "smooth": 1, "rodriguez": 1, "gil": 1}}, "812": {"id": "812", "title": "Smoothing 1 (Algorithm 188)", "authors": "Rodriguez-Gil, F.", "words_pool": ["algorithm", "smooth", "rodriguez", "gil"], "word_count": {"algorithm": 1, "smooth": 1, "rodriguez": 1, "gil": 1}}, "813": {"id": "813", "title": "Differences and Derivatives (Algorithm 187)", "authors": "Vande Riet, R. P.", "words_pool": ["algorithm", "deriv", "differ", "vand", "riet"], "word_count": {"algorithm": 1, "deriv": 1, "differ": 1, "vand": 1, "riet": 1}}, "814": {"id": "814", "title": "Complex Arithmetic (Algorithm 186)", "authors": "Vande Riet, R. P.", "words_pool": ["algorithm", "arithmet", "complex", "vand", "riet"], "word_count": {"algorithm": 1, "arithmet": 1, "complex": 1, "vand": 1, "riet": 1}}, "815": {"id": "815", "title": "Normal Probability for Curve Fitting (Algorithm 185)", "authors": "Colker, A.", "words_pool": ["algorithm", "curv", "fit", "normal", "probabl", "colker"], "word_count": {"algorithm": 1, "curv": 1, "fit": 1, "normal": 1, "probabl": 1, "colker": 1}}, "816": {"id": "816", "title": "Erlang Probability for Curve Fitting (Algorithm 184)", "authors": "Colker, A.", "words_pool": ["algorithm", "curv", "erlang", "fit", "probabl", "colker"], "word_count": {"algorithm": 1, "curv": 1, "erlang": 1, "fit": 1, "probabl": 1, "colker": 1}}, "817": {"id": "817", "title": "Nexcom (Algorithm 152)", "authors": "Hopley, J.", "words_pool": ["algorithm", "nexcom", "hopley"], "word_count": {"algorithm": 1, "nexcom": 1, "hopley": 1}}, "818": {"id": "818", "title": "Realizing Boolean Connectives on The IBM 1620", "authors": "Hellerman, H. Senzig, D. N.", "words_pool": ["boolean", "connect", "ibm", "realiz", "hellerman", "senzig"], "word_count": {"boolean": 1, "connect": 1, "ibm": 1, "realiz": 1, "hellerman": 1, "senzig": 1}}, "819": {"id": "819", "title": "Polynomial Evaluation Revised", "authors": "Eisman, S. H.", "words_pool": ["evalu", "polynomi", "revis", "eisman"], "word_count": {"evalu": 1, "polynomi": 1, "revis": 1, "eisman": 1}}, "820": {"id": "820", "title": "Checking for Loops in Networks", "authors": "Gordon, R. M.", "words_pool": ["check", "loop", "network", "gordon"], "word_count": {"check": 1, "loop": 1, "network": 1, "gordon": 1}}, "821": {"id": "821", "title": "Further Remarks on Sampling a Tape File-III", "authors": "Juelich, O. C.", "words_pool": ["iii", "remark", "sampl", "tape", "juelich"], "word_count": {"iii": 1, "remark": 1, "sampl": 1, "tape": 1, "juelich": 1}}, "822": {"id": "822", "title": "Real-Time Programming Specifications", "abstract": "Problems in the implementation of large real-time applications are treated, and suggested guidelines  for both program and file specifications are developed.  The problems delineated also occur in systems  programming.", "authors": "Head, R. V.", "words_pool": ["applic", "delin", "develop", "guidelin", "implement", "larg", "occur", "problem", "program", "program", "real", "specif", "suggest", "system", "time", "treat", "head"], "word_count": {"applic": 1, "delin": 1, "develop": 1, "guidelin": 1, "implement": 1, "larg": 1, "occur": 1, "problem": 2, "program": 2, "real": 1, "specif": 1, "suggest": 1, "system": 1, "time": 1, "treat": 1, "head": 1}}, "823": {"id": "823", "title": "A Syntactic Description of BC NELLIAC", "authors": "Huskey, H. D. Love, R. Wirth, N.", "words_pool": ["bc", "descript", "nelliac", "syntact", "huskey", "love", "wirth"], "word_count": {"bc": 1, "descript": 1, "nelliac": 1, "syntact": 1, "huskey": 1, "love": 1, "wirth": 1}}, "824": {"id": "824", "title": "DESCRIPTRAN-Automated Descriptive Geometry*", "abstract": "Descriptive geometry consists of procedures originally designed to solve 3-space geometry problems  by graphical constructions and measurement instead of by computation.  However, in addition to this it  unifies and simplifies the approach to many such problems.  When one can call subroutines that compute  new coordinates that correspond to those obtainable from the graphical constructions, there is the three-way  advantage of the approach of descriptive geometry, the accuracy of computation and the speed of the digital  computer.  DESCRIPTRAN makes it possible to program many problems in 3-space with a few statements; it  consists of 15 subroutines analogous to the procedures of descriptive geometry.", "authors": "Kliphardt, R. A.", "words_pool": ["accuraci", "addit", "advantag", "analog", "approach", "autom", "call", "comput", "comput", "comput", "consist", "construct", "coordin", "correspond", "descript", "descriptran", "design", "digit", "geometri", "graphic", "make", "measur", "obtain", "origin", "problem", "procedur", "program", "simplifi", "solv", "space", "speed", "statement", "subroutin", "unifi", "kliphardt"], "word_count": {"accuraci": 1, "addit": 1, "advantag": 1, "analog": 1, "approach": 2, "autom": 1, "call": 1, "comput": 4, "consist": 2, "construct": 2, "coordin": 1, "correspond": 1, "descript": 3, "descriptran": 1, "design": 1, "digit": 1, "geometri": 4, "graphic": 2, "make": 1, "measur": 1, "obtain": 1, "origin": 1, "problem": 3, "procedur": 2, "program": 1, "simplifi": 1, "solv": 1, "space": 2, "speed": 1, "statement": 1, "subroutin": 2, "unifi": 1, "kliphardt": 1}}, "825": {"id": "825", "title": "PIP: A Photo-Interpretive Program for the Analysis of Spark-Chamber Data*", "abstract": "An operating computer program that processes photographically recorded data is described.   The input to the program consists of spark-chamber photographs on which tracks of high-energy particles  are recorded.  The program automatically scans, measures and performs the preliminary interpretation  of these photographs.  In continuous operation a processing rate of 5,000 photographic frames per hour  is achieved.", "authors": "Rudloe, H. Deutsch, M. Marill, T.", "words_pool": ["achiev", "analysi", "chamber", "comput", "consist", "continu", "data", "energi", "frame", "high", "hour", "input", "interpret", "interpret", "measur", "oper", "oper", "particl", "perform", "photo", "photograph", "photograph", "photograph", "pip", "preliminari", "process", "process", "program", "rate", "record", "scan", "spark", "track", "rudlo", "deutsch", "maril"], "word_count": {"achiev": 1, "analysi": 1, "chamber": 1, "comput": 1, "consist": 1, "continu": 1, "data": 1, "energi": 1, "frame": 1, "high": 1, "hour": 1, "input": 1, "interpret": 1, "measur": 1, "oper": 2, "particl": 1, "perform": 1, "photo": 1, "photograph": 4, "pip": 1, "preliminari": 1, "process": 2, "program": 3, "rate": 1, "record": 2, "scan": 1, "spark": 1, "track": 1, "rudlo": 1, "deutsch": 1, "maril": 1}}, "826": {"id": "826", "title": "Remarks on Fortran Subroutines for Time Series Analysis", "authors": "Bennett, C. M.", "words_pool": ["analysi", "fortran", "remark", "seri", "subroutin", "time", "bennett"], "word_count": {"analysi": 1, "fortran": 1, "remark": 1, "seri": 1, "subroutin": 1, "time": 1, "bennett": 1}}, "827": {"id": "827", "title": "Disk File Sorting", "abstract": "Sorting techniques using an IBM 1401 with a random access storage device are evaluated.", "authors": "Schick, T.", "words_pool": ["access", "devic", "disk", "evalu", "ibm", "random", "sort", "storag", "techniqu", "schick"], "word_count": {"access": 1, "devic": 1, "disk": 1, "evalu": 1, "ibm": 1, "random": 1, "sort": 1, "storag": 1, "techniqu": 1, "schick": 1}}, "828": {"id": "828", "title": "Incompressible flow Network Calculations", "abstract": "A general method for the calculation of flows and pressures in fluid flow networks is presented.   The method is applicable to computer use.", "authors": "Cantrell, H. N.", "words_pool": ["applic", "calcul", "calcul", "comput", "flow", "flow", "fluid", "gener", "incompress", "method", "network", "network", "present", "pressur", "cantrel"], "word_count": {"applic": 1, "calcul": 1, "comput": 1, "flow": 2, "fluid": 1, "gener": 1, "incompress": 1, "method": 2, "network": 1, "present": 1, "pressur": 1, "cantrel": 1}}, "829": {"id": "829", "title": "The External Language KLIPA For the URAL-2 Digital computer", "authors": "Greniewski, M, Turski, W.", "words_pool": ["comput", "digit", "extern", "klipa", "languag", "ural", "greniewski", "turski"], "word_count": {"comput": 1, "digit": 1, "extern": 1, "klipa": 1, "languag": 1, "ural": 1, "greniewski": 1, "turski": 1}}, "830": {"id": "830", "title": "CORC-The Cornell Computing Language", "authors": "Conway, R. W. Maxwell, W. L.", "words_pool": ["comput", "corc", "cornel", "languag", "conway", "maxwel"], "word_count": {"comput": 1, "corc": 1, "cornel": 1, "languag": 1, "conway": 1, "maxwel": 1}}, "831": {"id": "831", "title": "Real Error Function, ERF (Algorithm 123)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "erf", "error", "function", "real", "thacher", "jr"], "word_count": {"algorithm": 1, "erf": 1, "error": 1, "function": 1, "real": 1, "thacher": 1, "jr": 1}}, "832": {"id": "832", "title": "Curve Fitting with Constraints (Algorithm 74)", "authors": "Isoda, K.", "words_pool": ["algorithm", "constraint", "curv", "fit", "isoda"], "word_count": {"algorithm": 1, "constraint": 1, "curv": 1, "fit": 1, "isoda": 1}}, "833": {"id": "833", "title": "Reduction of a Symmetric Bandmatrix to Triple Diagonal Form", "authors": "Schwartz, H. R.", "words_pool": ["bandmatrix", "diagon", "form", "reduct", "symmetr", "tripl", "schwartz"], "word_count": {"bandmatrix": 1, "diagon": 1, "form": 1, "reduct": 1, "symmetr": 1, "tripl": 1, "schwartz": 1}}, "834": {"id": "834", "title": "Nonrecursive Adaptive Integration (Algorithm 182)", "authors": "McKeeman, W. M. Tesler, L.", "words_pool": ["adapt", "algorithm", "integr", "nonrecurs", "mckeeman", "tesler"], "word_count": {"adapt": 1, "algorithm": 1, "integr": 1, "nonrecurs": 1, "mckeeman": 1, "tesler": 1}}, "835": {"id": "835", "title": "Complementary Error Function-Large X (Algorithm 181)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "complementari", "error", "function", "larg", "thacher", "jr"], "word_count": {"algorithm": 1, "complementari": 1, "error": 1, "function": 1, "larg": 1, "thacher": 1, "jr": 1}}, "836": {"id": "836", "title": "Error Function-Large X (Algorithm 180)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "error", "function", "larg", "thacher", "jr"], "word_count": {"algorithm": 1, "error": 1, "function": 1, "larg": 1, "thacher": 1, "jr": 1}}, "837": {"id": "837", "title": "Incomplete Beta Ratio (Algorithm 179)", "authors": "Ludwig, O. G.", "words_pool": ["algorithm", "beta", "incomplet", "ratio", "ludwig"], "word_count": {"algorithm": 1, "beta": 1, "incomplet": 1, "ratio": 1, "ludwig": 1}}, "838": {"id": "838", "title": "Direct Search (Algorithm 178)", "authors": "Kaupe Jr., A. F.", "words_pool": ["algorithm", "direct", "search", "kaup", "jr"], "word_count": {"algorithm": 1, "direct": 1, "search": 1, "kaup": 1, "jr": 1}}, "839": {"id": "839", "title": "Least Squares Solution with Constraints (Algorithm 177)", "authors": "Synge, M. J.", "words_pool": ["algorithm", "constraint", "solut", "squar", "syng"], "word_count": {"algorithm": 1, "constraint": 1, "solut": 1, "squar": 1, "syng": 1}}, "840": {"id": "840", "title": "Least Squares Surface Fit (Algorithm 176)", "authors": "Arthurs, T. D.", "words_pool": ["algorithm", "fit", "squar", "surfac", "arthur"], "word_count": {"algorithm": 1, "fit": 1, "squar": 1, "surfac": 1, "arthur": 1}}, "841": {"id": "841", "title": "Shuttle Sort (Algorithm 175)", "authors": "Shaw, C. J. Trimble, T. N.", "words_pool": ["algorithm", "shuttl", "sort", "shaw", "trimbl"], "word_count": {"algorithm": 1, "shuttl": 1, "sort": 1, "shaw": 1, "trimbl": 1}}, "842": {"id": "842", "title": "A Posteriori Bounds on a Zero of a Polynomial (Algorithm 174)", "authors": "Gibb, A.", "words_pool": ["algorithm", "bound", "polynomi", "posteriori", "gibb"], "word_count": {"algorithm": 1, "bound": 1, "polynomi": 1, "posteriori": 1, "gibb": 1}}, "843": {"id": "843", "title": "Assign (Algorithm 173)", "authors": "Hajek, O.", "words_pool": ["algorithm", "assign", "hajek"], "word_count": {"algorithm": 1, "assign": 1, "hajek": 1}}, "844": {"id": "844", "title": "1410 Fortran Edit Feature", "authors": "Fedako,J. E.", "words_pool": ["edit", "featur", "fortran", "fedako"], "word_count": {"edit": 1, "featur": 1, "fortran": 1, "fedako": 1}}, "845": {"id": "845", "title": "Another Test Matrix for Determinants and Inverses", "authors": "Caffrey, J.", "words_pool": ["determin", "invers", "matrix", "test", "caffrey"], "word_count": {"determin": 1, "invers": 1, "matrix": 1, "test": 1, "caffrey": 1}}, "846": {"id": "846", "title": "Self-Inverse Conversion Table", "authors": "Sanborn, T. G.", "words_pool": ["convers", "invers", "tabl", "sanborn"], "word_count": {"convers": 1, "invers": 1, "tabl": 1, "sanborn": 1}}, "847": {"id": "847", "title": "A Penny-Matching Program", "abstract": "The logic of a penny-matching program written for the CSX-1 is described.", "authors": "Wall, E. Brown, R. M.", "words_pool": ["csx", "logic", "match", "penni", "program", "written", "wall", "brown"], "word_count": {"csx": 1, "logic": 1, "match": 1, "penni": 1, "program": 1, "written": 1, "wall": 1, "brown": 1}}, "848": {"id": "848", "title": "A Note on Range Transformations for Square Root and Logarithm", "abstract": "There was the germ of an idea in two previous papers [1,2] which no one seems to have picked  up in almost five years.  For certain functions it seems desirable to transform the argument to a short  range symmetric about 10.1 will give examples of this usage for the square root and logarithm function  for both binary and decimal machines.", "authors": "Bemer, R. W.", "words_pool": ["argument", "binari", "decim", "desir", "exampl", "function", "function", "germ", "give", "idea", "logarithm", "machin", "note", "paper", "pick", "previou", "rang", "root", "short", "squar", "symmetr", "transform", "transform", "usag", "year", "bemer"], "word_count": {"argument": 1, "binari": 1, "decim": 1, "desir": 1, "exampl": 1, "function": 2, "germ": 1, "give": 1, "idea": 1, "logarithm": 1, "machin": 1, "note": 1, "paper": 1, "pick": 1, "previou": 1, "rang": 1, "root": 1, "short": 1, "squar": 1, "symmetr": 1, "transform": 1, "usag": 1, "year": 1, "bemer": 1}}, "849": {"id": "849", "title": "Use of Tree Structures for Processing Files", "abstract": "In data processing problems, files are frequently used which must both be searched and altered.   Binary search techniques are efficient for searching large files, but the associated file organization  is not readily adapted to the file alterations.  Conversely, a chained file allocation permits efficient  alteration but cannot be searched efficiently. A file organized into a tree-like structure is discussed,  and it is shown that such a file may both be searched and altered with times proportional to slog(s)N,  where N is the number of file items and s is a parameter of the tree.  It is also shown that optimizing  the value of s leads to a search time which is only 25 per cent slower than the binary search.  The tree  organization employs two data chains and may be considered to be a compromise between the organizations  for the binary search and the chained file.  The relation of the tree organization to multidimensional  indexing and to the trie structure is also discussed.", "authors": "Sussenguth Jr., E. H.", "words_pool": ["adapt", "alloc", "alter", "alter", "alter", "binari", "cent", "chain", "chain", "compromis", "consid", "convers", "data", "discuss", "effici", "effici", "employ", "frequent", "index", "item", "larg", "lead", "multidimension", "number", "optim", "organ", "organ", "organ", "paramet", "permit", "problem", "process", "proport", "readili", "relat", "search", "search", "search", "shown", "slog", "slower", "structur", "structur", "techniqu", "time", "time", "tree", "trie", "sussenguth", "jr"], "word_count": {"adapt": 1, "alloc": 1, "alter": 4, "binari": 3, "cent": 1, "chain": 3, "compromis": 1, "consid": 1, "convers": 1, "data": 2, "discuss": 2, "effici": 3, "employ": 1, "frequent": 1, "index": 1, "item": 1, "larg": 1, "lead": 1, "multidimension": 1, "number": 1, "optim": 1, "organ": 5, "paramet": 1, "permit": 1, "problem": 1, "process": 1, "proport": 1, "readili": 1, "relat": 1, "search": 8, "shown": 2, "slog": 1, "slower": 1, "structur": 2, "techniqu": 1, "time": 2, "tree": 4, "trie": 1, "sussenguth": 1, "jr": 1}}, "850": {"id": "850", "title": "Conversion, Reconversion and Comparison Techniques In Variable-Length Sorting", "abstract": "The logic is described for converting highly variable input records into a format that can  be easily and efficiently processed by a sorting program.  The internal record formats are discussed  in relation to (1) their conversion from input formats, (2) their reconversion to output formats, and  (3) comparison techniques between internal formats.", "authors": "Waks, D. J.", "words_pool": ["comparison", "convers", "convert", "discuss", "easili", "effici", "format", "format", "highli", "input", "intern", "length", "logic", "output", "process", "program", "reconvers", "record", "record", "relat", "sort", "techniqu", "variabl", "wak"], "word_count": {"comparison": 1, "convers": 1, "convert": 1, "discuss": 1, "easili": 1, "effici": 1, "format": 5, "highli": 1, "input": 2, "intern": 2, "length": 1, "logic": 1, "output": 1, "process": 1, "program": 1, "reconvers": 1, "record": 2, "relat": 1, "sort": 1, "techniqu": 1, "variabl": 1, "wak": 1}}, "851": {"id": "851", "title": "Design and Characteristics of a Variable-Length Record Sort Using New Fixed-Length Record Sorting  Techniques", "abstract": "This paper describes the application of several new techniques for sorting fixed-length records  to the problems of variable-length record sorting.  The techniques have been implemented on a Sylvania  9400 computer system with 32,000 fixed-length words of memory.  Specifically, the techniques sequence  variable-length records of unrestricted size, produce long initial strings of data, merge strings of  data at the power of T-1, where T is the number of work tapes in a system, and do not restrict the volume  of input data.", "authors": "Goetz, M. A.", "words_pool": ["applic", "characterist", "comput", "data", "describ", "design", "fix", "implement", "initi", "input", "length", "long", "memori", "merg", "number", "paper", "power", "problem", "produc", "record", "record", "restrict", "sequenc", "size", "sort", "sort", "specif", "string", "sylvania", "system", "tape", "techniqu", "unrestrict", "variabl", "volum", "word", "work", "goetz"], "word_count": {"applic": 1, "characterist": 1, "comput": 1, "data": 3, "describ": 1, "design": 1, "fix": 2, "implement": 1, "initi": 1, "input": 1, "length": 4, "long": 1, "memori": 1, "merg": 1, "number": 1, "paper": 1, "power": 1, "problem": 1, "produc": 1, "record": 3, "restrict": 1, "sequenc": 1, "size": 1, "sort": 2, "specif": 1, "string": 2, "sylvania": 1, "system": 2, "tape": 1, "techniqu": 3, "unrestrict": 1, "variabl": 2, "volum": 1, "word": 1, "work": 1, "goetz": 1}}, "852": {"id": "852", "title": "A Method of Comparing the Time Requirements of Sorting Methods", "authors": "Hall, M. H.", "words_pool": ["compar", "method", "method", "requir", "sort", "time", "hall"], "word_count": {"compar": 1, "method": 2, "requir": 1, "sort": 1, "time": 1, "hall": 1}}, "853": {"id": "853", "title": "The COBOL Sort Verb", "authors": "Paterson, J. B.", "words_pool": ["cobol", "sort", "verb", "paterson"], "word_count": {"cobol": 1, "sort": 1, "verb": 1, "paterson": 1}}, "854": {"id": "854", "title": "Some Characteristics of Sorting in Computing Systems Using Random Access Storage Devices", "abstract": "The substantial differences in characteristics of random access storage and tape devices dictate  that concepts and objectives of computer program design be considered from the viewpoint of the external  file medium used.  This is particularly true in the case of sorting.  In a tape-oriented system, the  major sorting problem is that of minimizing merge time despite the limited orders of merge possible.   In contrast, sorting in a random access-oriented system encourages the selection of the optimum order  of merge from many possible orders.  The latter problem is discussed in this paper, along with criteria  developed for determining the optimum order of merge according to the various properties of random access  storage devices.  Attention is also given to the problem of key sorting versus record sorting and the  possibly serious disadvantage of key sorting on a random access system.", "authors": "Hubbard, G. U.", "words_pool": ["access", "accord", "attent", "case", "characterist", "comput", "comput", "concept", "consid", "contrast", "criteria", "design", "despit", "determin", "develop", "devic", "dictat", "differ", "disadvantag", "discuss", "encourag", "extern", "key", "limit", "major", "medium", "merg", "minim", "object", "optimum", "order", "order", "orient", "paper", "possibl", "problem", "program", "properti", "random", "record", "select", "sort", "storag", "substanti", "system", "system", "tape", "time", "true", "versu", "viewpoint", "hubbard"], "word_count": {"access": 4, "accord": 1, "attent": 1, "case": 1, "characterist": 1, "comput": 1, "concept": 1, "consid": 1, "contrast": 1, "criteria": 1, "design": 1, "despit": 1, "determin": 1, "develop": 1, "devic": 2, "dictat": 1, "differ": 1, "disadvantag": 1, "discuss": 1, "encourag": 1, "extern": 1, "key": 2, "limit": 1, "major": 1, "medium": 1, "merg": 4, "minim": 1, "object": 1, "optimum": 2, "order": 4, "orient": 2, "paper": 1, "possibl": 1, "problem": 3, "program": 1, "properti": 1, "random": 4, "record": 1, "select": 1, "sort": 6, "storag": 2, "substanti": 1, "system": 3, "tape": 2, "time": 1, "true": 1, "versu": 1, "viewpoint": 1, "hubbard": 1}}, "855": {"id": "855", "title": "Organization and Structure of Dataon Disk File Memory Systems for Efficient Sorting and Other  Data Processing Programs", "abstract": "An approach to the organization and structure of data on Bryant Disc File Memory Systems for  sorting and performing other data processing functions is presented.  The following areas are covered:  characteristics of Bryant Disc File Systems on the Bendix G-20 and RCA 301; two proposed \"chaining\" structures  for data; and functions of a Disk File Executive Routine.  The concepts for sorting and performing file  maintenance processing using the proposed structure and executive routine are discussed.  Additionally,  it is shown that sorting can be accomplished without the use of disk storage work areas.", "authors": "Goetz, M. A.", "words_pool": ["accomplish", "addit", "approach", "area", "bendix", "bryant", "chain", "characterist", "concept", "cover", "data", "dataon", "disc", "discuss", "disk", "effici", "execut", "function", "mainten", "memori", "organ", "perform", "present", "process", "program", "propos", "rca", "routin", "shown", "sort", "storag", "structur", "structur", "system", "work", "goetz"], "word_count": {"accomplish": 1, "addit": 1, "approach": 1, "area": 2, "bendix": 1, "bryant": 2, "chain": 1, "characterist": 1, "concept": 1, "cover": 1, "data": 3, "dataon": 1, "disc": 2, "discuss": 1, "disk": 2, "effici": 1, "execut": 2, "function": 2, "mainten": 1, "memori": 1, "organ": 1, "perform": 2, "present": 1, "process": 2, "program": 1, "propos": 2, "rca": 1, "routin": 2, "shown": 1, "sort": 3, "storag": 1, "structur": 3, "system": 2, "work": 1, "goetz": 1}}, "856": {"id": "856", "title": "Sorting with Large Volume, Random Access, Drum Storage", "abstract": "An approach to sorting records is described using random access drum memory.  The Sort program  described is designed to be a generalized, self-generating sort, applicable to a variety of record statements.   This description is divided into three parts.  The first part presents the operating environment; the  second defines the general solution; the third part describes the internal sort-merge technique.", "authors": "Falkin, J. Savastano Jr., S.", "words_pool": ["access", "applic", "approach", "defin", "describ", "descript", "design", "divid", "drum", "environ", "gener", "gener", "gener", "intern", "larg", "memori", "merg", "oper", "part", "part", "present", "program", "random", "record", "record", "solut", "sort", "sort", "statement", "storag", "techniqu", "varieti", "volum", "falkin", "savastano", "jr"], "word_count": {"access": 1, "applic": 1, "approach": 1, "defin": 1, "describ": 1, "descript": 1, "design": 1, "divid": 1, "drum": 1, "environ": 1, "gener": 3, "intern": 1, "larg": 1, "memori": 1, "merg": 1, "oper": 1, "part": 3, "present": 1, "program": 1, "random": 1, "record": 2, "solut": 1, "sort": 4, "statement": 1, "storag": 1, "techniqu": 1, "varieti": 1, "volum": 1, "falkin": 1, "savastano": 1, "jr": 1}}, "857": {"id": "857", "title": "Sorting Nonredundant Files-Techniques Used in the FACT Compiler", "abstract": "Some typical file structures, including some called \"non-redundant,\" are examined,and the  methods used in FACT to sort such files are discussed.", "authors": "Glore, J. B.", "words_pool": ["call", "compil", "discuss", "examin", "fact", "includ", "method", "non", "nonredund", "redund", "sort", "sort", "structur", "techniqu", "typic", "glore"], "word_count": {"call": 1, "compil": 1, "discuss": 1, "examin": 1, "fact": 1, "includ": 1, "method": 1, "non": 1, "nonredund": 1, "redund": 1, "sort": 1, "structur": 1, "techniqu": 1, "typic": 1, "glore": 1}}, "858": {"id": "858", "title": "A Tape File Merge Pattern Generator", "abstract": "A routine is presented which specifies the sequence of merge cycles to effect the merging of  sorted tape files.  The routine is designed to minimize elapsed computer time by varying the power of  the merge cycles, so as to use all the available tape drives, with its characteristic of assigning one  drive to a single-reel file and two drives to each multiple-reel file.", "authors": "Cooke, W. S.", "words_pool": ["assign", "characterist", "comput", "cycl", "design", "drive", "drive", "effect", "elaps", "gener", "merg", "merg", "minim", "multipl", "pattern", "power", "present", "reel", "routin", "sequenc", "singl", "sort", "specifi", "tape", "time", "vari", "cook"], "word_count": {"assign": 1, "characterist": 1, "comput": 1, "cycl": 2, "design": 1, "drive": 3, "effect": 1, "elaps": 1, "gener": 1, "merg": 3, "minim": 1, "multipl": 1, "pattern": 1, "power": 1, "present": 1, "reel": 2, "routin": 2, "sequenc": 1, "singl": 1, "sort": 1, "specifi": 1, "tape": 2, "time": 1, "vari": 1, "cook": 1}}, "859": {"id": "859", "title": "Computer Planned Collates", "authors": "French, N", "words_pool": ["collat", "comput", "plan", "french"], "word_count": {"collat": 1, "comput": 1, "plan": 1, "french": 1}}, "860": {"id": "860", "title": "A Comparison Between the Polyphase and Oscillating Sort Techniques", "abstract": "A comparison between the Oscillating and Polyphase Sort techniques is developed for computer  systems having from four to ten tape drives.  The basis for the comparison is the total reading and writing  required for various number of input strings and tape drives for the two techniques.", "authors": "Goetz, M. A. Toth, G. S.", "words_pool": ["basi", "comparison", "comput", "develop", "drive", "input", "number", "oscil", "polyphas", "read", "requir", "sort", "string", "system", "tape", "techniqu", "ten", "total", "write", "goetz", "toth"], "word_count": {"basi": 1, "comparison": 2, "comput": 1, "develop": 1, "drive": 2, "input": 1, "number": 1, "oscil": 1, "polyphas": 1, "read": 1, "requir": 1, "sort": 1, "string": 1, "system": 1, "tape": 2, "techniqu": 2, "ten": 1, "total": 1, "write": 1, "goetz": 1, "toth": 1}}, "861": {"id": "861", "title": "Read-Backward Polyphase Sorting", "abstract": "Read-backward Polyphase sorting provides more efficient use of the tapes available to a sort  than most other sorting techniques.  Backward Polyphase produces a continuous merging process from n-1  tapes where n is the total number of tapes being used in the sorting process.  Any of the available presorting  techniques may be used in conjunction with the Polyphase merge sort provided that the presort has the  capability of producing both ascending and descending strings and distributing the strings on the various  tapes as required by the Polyphase Merge.", "authors": "Gilstad, R. L.", "words_pool": ["ascend", "backward", "capabl", "conjunct", "continu", "descend", "distribut", "effici", "merg", "merg", "number", "polyphas", "presort", "presort", "process", "produc", "produc", "provid", "read", "requir", "sort", "sort", "string", "tape", "techniqu", "total", "gilstad"], "word_count": {"ascend": 1, "backward": 2, "capabl": 1, "conjunct": 1, "continu": 1, "descend": 1, "distribut": 1, "effici": 1, "merg": 3, "number": 1, "polyphas": 4, "presort": 2, "process": 2, "produc": 2, "provid": 1, "read": 1, "requir": 1, "sort": 5, "string": 2, "tape": 4, "techniqu": 2, "total": 1, "gilstad": 1}}, "862": {"id": "862", "title": "String Distribution for the Polyphase Sort", "authors": "Malcolm Jr., W. D.", "words_pool": ["distribut", "polyphas", "sort", "string", "malcolm", "jr"], "word_count": {"distribut": 1, "polyphas": 1, "sort": 1, "string": 1, "malcolm": 1, "jr": 1}}, "863": {"id": "863", "title": "Multiphase Sorting", "authors": "Manker, H. H.", "words_pool": ["multiphas", "sort", "manker"], "word_count": {"multiphas": 1, "sort": 1, "manker": 1}}, "864": {"id": "864", "title": "An Empirical Study of Minimal Storage Sorting", "authors": "Hibbard, T. N.", "words_pool": ["empir", "minim", "sort", "storag", "studi", "hibbard"], "word_count": {"empir": 1, "minim": 1, "sort": 1, "storag": 1, "studi": 1, "hibbard": 1}}, "865": {"id": "865", "title": "Internal and Tape Sorting Using the Replacement-Selection Technique", "abstract": "A general technique for sequencing unsorted records is presented.  The technique is shown to  be applicable for the first stage of a generalized sort program (the formation of initial strings) as  well as for sorting records within a memory storage (an internal sort).  It is shown that given N records  in memory storage, records are sequenced using 1+log2 N tests per record, that initial string lengths  will average 2N for random input records, and that reading, writing and processing can be accomplished  simultaneously if the computer permits such overlap.", "authors": "Goetz, M. A.", "words_pool": ["2n", "accomplish", "applic", "averag", "comput", "format", "gener", "gener", "initi", "input", "intern", "length", "log2", "memori", "overlap", "permit", "present", "process", "program", "random", "read", "record", "record", "replac", "select", "sequenc", "sequenc", "shown", "simultan", "sort", "sort", "stage", "storag", "string", "string", "tape", "techniqu", "test", "unsort", "write", "goetz"], "word_count": {"2n": 1, "accomplish": 1, "applic": 1, "averag": 1, "comput": 1, "format": 1, "gener": 2, "initi": 2, "input": 1, "intern": 1, "length": 1, "log2": 1, "memori": 2, "overlap": 1, "permit": 1, "present": 1, "process": 1, "program": 1, "random": 1, "read": 1, "record": 6, "replac": 1, "select": 1, "sequenc": 2, "shown": 2, "simultan": 1, "sort": 3, "stage": 1, "storag": 2, "string": 2, "tape": 1, "techniqu": 2, "test": 1, "unsort": 1, "write": 1, "goetz": 1}}, "866": {"id": "866", "title": "Sorting on Computers", "authors": "Gotlieb, C. C.", "words_pool": ["comput", "sort", "gotlieb"], "word_count": {"comput": 1, "sort": 1, "gotlieb": 1}}, "867": {"id": "867", "title": "Least Squares Fitting of Planes to Surfaces Using Dynamic Programming", "abstract": "Dynamic programming has recently been used by Stone, by Bellman and by Gluss to determine the  closet fit of broken line segments to a curve in an interval under the constraint that the number of  segments is fixed.  In the present paper successive models are developed to extend the method to the  fitting of broken plane segments to surfaces z=g(x,y) defined over certain types of subareas of the (x,y)-space.   The first model considers a rectangular area, with the constraint that the plane segments are defined  over a grid in the (x,y)-space.  It is then shown how this model may be incorporated into an algorithm  that provides successive approximations to optimal fits for any type of closed area.  Finally, applications  are briefly described.", "authors": "Gluss, B.", "words_pool": ["algorithm", "applic", "approxim", "area", "bellman", "briefli", "broken", "close", "closet", "consid", "constraint", "curv", "defin", "determin", "develop", "dynam", "extend", "final", "fit", "fit", "fit", "fix", "gluss", "grid", "incorpor", "interv", "line", "method", "model", "model", "number", "optim", "paper", "plane", "plane", "present", "program", "recent", "rectangular", "segment", "shown", "space", "squar", "stone", "subarea", "success", "surfac", "type", "type", "gluss"], "word_count": {"algorithm": 1, "applic": 1, "approxim": 1, "area": 2, "bellman": 1, "briefli": 1, "broken": 2, "close": 1, "closet": 1, "consid": 1, "constraint": 2, "curv": 1, "defin": 2, "determin": 1, "develop": 1, "dynam": 1, "extend": 1, "final": 1, "fit": 3, "fix": 1, "gluss": 1, "grid": 1, "incorpor": 1, "interv": 1, "line": 1, "method": 1, "model": 3, "number": 1, "optim": 1, "paper": 1, "plane": 2, "present": 1, "program": 1, "recent": 1, "rectangular": 1, "segment": 4, "shown": 1, "space": 2, "squar": 1, "stone": 1, "subarea": 1, "success": 2, "surfac": 1, "type": 2}}, "868": {"id": "868", "title": "A Suggested Method of Making Fuller Use of Strings in ALGOL 60", "authors": "Shoffner, M. G. Brown, P. J.", "words_pool": ["algol", "fuller", "make", "method", "string", "suggest", "shoffner", "brown"], "word_count": {"algol": 1, "fuller": 1, "make": 1, "method": 1, "string": 1, "suggest": 1, "shoffner": 1, "brown": 1}}, "869": {"id": "869", "title": "Term of Magic Square (Algorithm 148)", "authors": "Thoro, D.", "words_pool": ["algorithm", "magic", "squar", "term", "thoro"], "word_count": {"algorithm": 1, "magic": 1, "squar": 1, "term": 1, "thoro": 1}}, "870": {"id": "870", "title": "Term of Magic Square (Algorithm 148)", "authors": "Barnecut, J. N. R.", "words_pool": ["algorithm", "magic", "squar", "term", "barnecut"], "word_count": {"algorithm": 1, "magic": 1, "squar": 1, "term": 1, "barnecut": 1}}, "871": {"id": "871", "title": "PSIF (Algorithm 147)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "psif", "thacher", "jr"], "word_count": {"algorithm": 1, "psif": 1, "thacher": 1, "jr": 1}}, "872": {"id": "872", "title": "Adaptive Numerical Integration by Simpson's Rule (Algorithm 145)", "authors": "McKeeman, W. M.", "words_pool": ["adapt", "algorithm", "integr", "numer", "rule", "simpson", "mckeeman"], "word_count": {"adapt": 1, "algorithm": 1, "integr": 1, "numer": 1, "rule": 1, "simpson": 1, "mckeeman": 1}}, "873": {"id": "873", "title": "Random (Algorithm 133)", "authors": "Poore Jr., J. H.", "words_pool": ["algorithm", "random", "poor", "jr"], "word_count": {"algorithm": 1, "random": 1, "poor": 1, "jr": 1}}, "874": {"id": "874", "title": "Chebyshev Curvefit (Algorithm 91)", "authors": "Hale, R. P.", "words_pool": ["algorithm", "chebyshev", "curvefit", "hale"], "word_count": {"algorithm": 1, "chebyshev": 1, "curvefit": 1, "hale": 1}}, "875": {"id": "875", "title": "Incomplete Elliptic Integrals (Algorithm 73)", "authors": "van De Riet, R. P.", "words_pool": ["algorithm", "ellipt", "incomplet", "integr", "van", "de", "riet"], "word_count": {"algorithm": 1, "ellipt": 1, "incomplet": 1, "integr": 1, "van": 1, "de": 1, "riet": 1}}, "876": {"id": "876", "title": "Complete Elliptic Integral (Algorithm 149)", "authors": "Thacher, H. C.", "words_pool": ["algorithm", "complet", "ellipt", "integr", "thacher"], "word_count": {"algorithm": 1, "complet": 1, "ellipt": 1, "integr": 1, "thacher": 1}}, "877": {"id": "877", "title": "Complete Elliptic Integral of the First Kind (Algorithm 55)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "complet", "ellipt", "integr", "kind", "thacher", "jr"], "word_count": {"algorithm": 1, "complet": 1, "ellipt": 1, "integr": 1, "kind": 1, "thacher": 1, "jr": 1}}, "878": {"id": "878", "title": "Reduction of a Matrix Containing Polynomial Elements (Algorithm 170)", "authors": "Hennion, P. E.", "words_pool": ["algorithm", "element", "matrix", "polynomi", "reduct", "hennion"], "word_count": {"algorithm": 1, "element": 1, "matrix": 1, "polynomi": 1, "reduct": 1, "hennion": 1}}, "879": {"id": "879", "title": "Newton Interpolation with Forward Divided Differences (Algorithm 169)", "authors": "Kahan, W. Farkas, I.", "words_pool": ["algorithm", "differ", "divid", "forward", "interpol", "newton", "kahan", "farka"], "word_count": {"algorithm": 1, "differ": 1, "divid": 1, "forward": 1, "interpol": 1, "newton": 1, "kahan": 1, "farka": 1}}, "880": {"id": "880", "title": "Newton Interpolation with Backward Divided Differences", "authors": "Kahan, W. Farkas, I.", "words_pool": ["backward", "differ", "divid", "interpol", "newton", "kahan", "farka"], "word_count": {"backward": 1, "differ": 1, "divid": 1, "interpol": 1, "newton": 1, "kahan": 1, "farka": 1}}, "881": {"id": "881", "title": "Calculation of Confluent Divided Differences (Algorithm 167)", "authors": "Kahan, W. Farkas, I.", "words_pool": ["algorithm", "calcul", "confluent", "differ", "divid", "kahan", "farka"], "word_count": {"algorithm": 1, "calcul": 1, "confluent": 1, "differ": 1, "divid": 1, "kahan": 1, "farka": 1}}, "882": {"id": "882", "title": "Monte Carlo (Algorithm 166)", "authors": "Rodman, R. D.", "words_pool": ["algorithm", "carlo", "mont", "rodman"], "word_count": {"algorithm": 1, "carlo": 1, "mont": 1, "rodman": 1}}, "883": {"id": "883", "title": "Complete Elliptic Integrals (Algorithm 165)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "complet", "ellipt", "integr", "thacher", "jr"], "word_count": {"algorithm": 1, "complet": 1, "ellipt": 1, "integr": 1, "thacher": 1, "jr": 1}}, "884": {"id": "884", "title": "Orthogonal Polynomial Least Squares Surface Fit (Algorithm 164)", "authors": "Clark, R. E. Kubik, R. N. Phillips, L. P.", "words_pool": ["algorithm", "fit", "orthogon", "polynomi", "squar", "surfac", "clark", "kubik", "phillip"], "word_count": {"algorithm": 1, "fit": 1, "orthogon": 1, "polynomi": 1, "squar": 1, "surfac": 1, "clark": 1, "kubik": 1, "phillip": 1}}, "885": {"id": "885", "title": "Modified Hankel Function (Algorithm 163)", "authors": "Fettis, H. E.", "words_pool": ["algorithm", "function", "hankel", "modifi", "fetti"], "word_count": {"algorithm": 1, "function": 1, "hankel": 1, "modifi": 1, "fetti": 1}}, "886": {"id": "886", "title": "XY-move Plotting (Algorithm 162)", "authors": "Stockton, F. G.", "words_pool": ["algorithm", "move", "plot", "xy", "stockton"], "word_count": {"algorithm": 1, "move": 1, "plot": 1, "xy": 1, "stockton": 1}}, "887": {"id": "887", "title": "Combinatorial of M Things Taken One at a Time, Two at a Time, Up to N at a Time (Algorithm 161)", "authors": "Wright, H. V. Wolfson, M. L.", "words_pool": ["algorithm", "combinatori", "thing", "time", "wright", "wolfson"], "word_count": {"algorithm": 1, "combinatori": 1, "thing": 1, "time": 3, "wright": 1, "wolfson": 1}}, "888": {"id": "888", "title": "Algorithm 160 Combinatorial of M Things Taken N at A Time", "authors": "Wolfson, M. L. Wright, H. V.", "words_pool": ["algorithm", "combinatori", "thing", "time", "wolfson", "wright"], "word_count": {"algorithm": 1, "combinatori": 1, "thing": 1, "time": 1, "wolfson": 1, "wright": 1}}, "889": {"id": "889", "title": "Official Actions and Responses to ALGOL As a Programming Language", "words_pool": ["action", "algol", "languag", "offici", "program", "respons"], "word_count": {"action": 1, "algol": 1, "languag": 1, "offici": 1, "program": 1, "respons": 1}}, "890": {"id": "890", "title": "Selected Definitions", "abstract": "A selection of the definitions prepared by the ACM Standards Committee's Subcommittee on Programming  Terminology is presented for review by the ACM membership.", "authors": "Fritz, W. B.", "words_pool": ["acm", "committe", "definit", "membership", "prepar", "present", "program", "review", "select", "select", "standard", "subcommitte", "terminolog", "fritz"], "word_count": {"acm": 2, "committe": 1, "definit": 1, "membership": 1, "prepar": 1, "present": 1, "program": 1, "review": 1, "select": 1, "standard": 1, "subcommitte": 1, "terminolog": 1, "fritz": 1}}, "891": {"id": "891", "title": "Everyman's Information Retrieval System", "abstract": "The information retrieval problem whose solution is presented here was posed by a technical  library with limited bubget and personnel.  The solution, however, is quite general and is applicable  to many different types of retrieval problems.  Further,the method of solution makes it possible for  many groups who have previously dismissed an information retrieval program as expensive and difficult  (from a programming stand-point) to reconsider their position, for the present solution makes it possible  to install an information retrieval program in less than three months, and with relatively little equipment.", "authors": "Whitley, V. W.", "words_pool": ["applic", "bubget", "difficult", "dismiss", "equip", "everyman", "expens", "gener", "group", "inform", "instal", "librari", "limit", "make", "method", "month", "personnel", "point", "pose", "posit", "present", "present", "previous", "problem", "problem", "program", "program", "reconsid", "retriev", "solut", "stand", "system", "technic", "type", "whitley"], "word_count": {"applic": 1, "bubget": 1, "difficult": 1, "dismiss": 1, "equip": 1, "everyman": 1, "expens": 1, "gener": 1, "group": 1, "inform": 3, "instal": 1, "librari": 1, "limit": 1, "make": 2, "method": 1, "month": 1, "personnel": 1, "point": 1, "pose": 1, "posit": 1, "present": 2, "previous": 1, "problem": 2, "program": 3, "reconsid": 1, "retriev": 4, "solut": 4, "stand": 1, "system": 1, "technic": 1, "type": 1, "whitley": 1}}, "892": {"id": "892", "title": "RECOL-A Retrieval Command Language", "abstract": "An interrogation scheme is described for the retrieval and manipulation of data file records.   The language of the interrogation scheme allows for selecting file records with the are of logical condition  statements, defining record classes, associating file records, editing printed output, and summarizing  the results of the above operations.  Some examples of a typical file application and the more significant  features of a particular machine implementation are given.", "authors": "Climenson, W. D.", "words_pool": ["applic", "associ", "class", "command", "condit", "data", "defin", "edit", "exampl", "featur", "implement", "interrog", "languag", "logic", "machin", "manipul", "oper", "output", "print", "recol", "record", "record", "result", "retriev", "scheme", "select", "signific", "statement", "summar", "typic", "climenson"], "word_count": {"applic": 1, "associ": 1, "class": 1, "command": 1, "condit": 1, "data": 1, "defin": 1, "edit": 1, "exampl": 1, "featur": 1, "implement": 1, "interrog": 2, "languag": 1, "logic": 1, "machin": 1, "manipul": 1, "oper": 1, "output": 1, "print": 1, "recol": 1, "record": 4, "result": 1, "retriev": 1, "scheme": 2, "select": 1, "signific": 1, "statement": 1, "summar": 1, "typic": 1, "climenson": 1}}, "893": {"id": "893", "title": "Significance Arithmetic on a Digital Computer", "abstract": "The 7090 at NYU has been modified to include a \"Significance Mode\" of operation which is intended  to facilitate the identification of significant bits in the results of floating-point arithmetic operations.   The manner in which floating-point arithmetic is handled in this mode is discussed.  Several numerical  experiments using this mode are described and comparisons are made with the ordinary \"normalized mode.\"   Examples include power series evaluation, linear equations solution, determinant evaluation and matrix  inversion.", "authors": "Goldstein, M.", "words_pool": ["arithmet", "bit", "comparison", "comput", "determin", "digit", "discuss", "equat", "evalu", "exampl", "experi", "facilit", "float", "handl", "identif", "includ", "intend", "invers", "linear", "made", "manner", "matrix", "mode", "modifi", "normal", "numer", "nyu", "oper", "oper", "ordinari", "point", "power", "result", "seri", "signific", "signific", "solut", "goldstein"], "word_count": {"arithmet": 2, "bit": 1, "comparison": 1, "comput": 1, "determin": 1, "digit": 1, "discuss": 1, "equat": 1, "evalu": 2, "exampl": 1, "experi": 1, "facilit": 1, "float": 2, "handl": 1, "identif": 1, "includ": 2, "intend": 1, "invers": 1, "linear": 1, "made": 1, "manner": 1, "matrix": 1, "mode": 4, "modifi": 1, "normal": 1, "numer": 1, "nyu": 1, "oper": 2, "ordinari": 1, "point": 2, "power": 1, "result": 1, "seri": 1, "signific": 2, "solut": 1, "goldstein": 1}}, "894": {"id": "894", "title": "An Iterative Factorization Technique for Polynomials", "abstract": "An iterative technique is displayed whereby factors of arbitrary degree can be found for polynomials  in one variable.  Convergence is shown to occur always if a certain Jacobian does not vanish and if the  initial approximation to a factor is near enough to an actual factor.  The process is simply programmed,  and preliminary results indicate it to be well adapted to use with digital computers.  For factors of  degree two, the technique is similar to that of Bairstow, the present method being somewhat simpler.", "authors": "Luther, H. A.", "words_pool": ["actual", "adapt", "approxim", "arbitrari", "bairstow", "comput", "converg", "degre", "digit", "display", "factor", "factor", "factor", "found", "initi", "iter", "jacobian", "method", "occur", "polynomi", "preliminari", "present", "process", "program", "result", "shown", "similar", "simpler", "simpli", "techniqu", "vanish", "variabl", "luther"], "word_count": {"actual": 1, "adapt": 1, "approxim": 1, "arbitrari": 1, "bairstow": 1, "comput": 1, "converg": 1, "degre": 2, "digit": 1, "display": 1, "factor": 4, "found": 1, "initi": 1, "iter": 1, "jacobian": 1, "method": 1, "occur": 1, "polynomi": 1, "preliminari": 1, "present": 1, "process": 1, "program": 1, "result": 1, "shown": 1, "similar": 1, "simpler": 1, "simpli": 1, "techniqu": 2, "vanish": 1, "variabl": 1, "luther": 1}}, "895": {"id": "895", "title": "A Computational Extension of the Variate Difference Method", "abstract": "Presented here is a computational extension of the variate difference method as developed by  G. Tintner [1].", "authors": "Scheinok, P. A.", "words_pool": ["comput", "develop", "differ", "extens", "method", "present", "tintner", "variat", "scheinok"], "word_count": {"comput": 1, "develop": 1, "differ": 1, "extens": 1, "method": 1, "present": 1, "tintner": 1, "variat": 1, "scheinok": 1}}, "896": {"id": "896", "title": "Characteristic Values and Vectors of Defective Matrices", "authors": "Thompson, G. T.", "words_pool": ["characterist", "defect", "matric", "valu", "vector", "thompson"], "word_count": {"characterist": 1, "defect": 1, "matric": 1, "valu": 1, "vector": 1, "thompson": 1}}, "897": {"id": "897", "title": "Note on the Proof of the Non-existence of a Phrase Structure Grammar for ALGOL 60", "authors": "Brown, P. J.", "words_pool": ["algol", "exist", "grammar", "non", "note", "phrase", "proof", "structur", "brown"], "word_count": {"algol": 1, "exist": 1, "grammar": 1, "non": 1, "note": 1, "phrase": 1, "proof": 1, "structur": 1, "brown": 1}}, "898": {"id": "898", "title": "Random (Algorithm 133)", "authors": "Laughlin, D. L.", "words_pool": ["algorithm", "random", "laughlin"], "word_count": {"algorithm": 1, "random": 1, "laughlin": 1}}, "899": {"id": "899", "title": "Magic Square (Algorithm 117 & 118)", "authors": "Bosworth, K. M.", "words_pool": ["algorithm", "magic", "squar", "bosworth"], "word_count": {"algorithm": 1, "magic": 1, "squar": 1, "bosworth": 1}}, "900": {"id": "900", "title": "Ancestor (Algorithm 79)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "ancestor", "thacher", "jr"], "word_count": {"algorithm": 1, "ancestor": 1, "thacher": 1, "jr": 1}}, "901": {"id": "901", "title": "Difference Expression Coefficients (Algorithm 79)", "authors": "Clark, E. S.", "words_pool": ["algorithm", "coeffici", "differ", "express", "clark"], "word_count": {"algorithm": 1, "coeffici": 1, "differ": 1, "express": 1, "clark": 1}}, "902": {"id": "902", "title": "Determinant (Algorithm 159)", "authors": "Digby, D. W.", "words_pool": ["algorithm", "determin", "digbi"], "word_count": {"algorithm": 1, "determin": 1, "digbi": 1}}, "903": {"id": "903", "title": "Exponentiation of Series (Algorithm 134 )", "authors": "Fettis, H. E.", "words_pool": ["algorithm", "exponenti", "seri", "fetti"], "word_count": {"algorithm": 1, "exponenti": 1, "seri": 1, "fetti": 1}}, "904": {"id": "904", "title": "Fourier Series Approximation (Algorithm 157)", "authors": "Mifsud, C. J.", "words_pool": ["algorithm", "approxim", "fourier", "seri", "mifsud"], "word_count": {"algorithm": 1, "approxim": 1, "fourier": 1, "seri": 1, "mifsud": 1}}, "905": {"id": "905", "title": "Algebra of Sets (Algorithm 156)", "authors": "Mifsud, C. J.", "words_pool": ["algebra", "algorithm", "set", "mifsud"], "word_count": {"algebra": 1, "algorithm": 1, "set": 1, "mifsud": 1}}, "906": {"id": "906", "title": "Combination in any Order (Algorithm 155)", "authors": "Mifsud, C. J.", "words_pool": ["algorithm", "combin", "order", "mifsud"], "word_count": {"algorithm": 1, "combin": 1, "order": 1, "mifsud": 1}}, "907": {"id": "907", "title": "Combination in Lexicographical Order (Algorithm 154)", "authors": "Mifsud, C. J.", "words_pool": ["algorithm", "combin", "lexicograph", "order", "mifsud"], "word_count": {"algorithm": 1, "combin": 1, "lexicograph": 1, "order": 1, "mifsud": 1}}, "908": {"id": "908", "title": "Test Matrix for Inversion", "authors": "LaSor, W. S.", "words_pool": ["invers", "matrix", "test", "lasor"], "word_count": {"invers": 1, "matrix": 1, "test": 1, "lasor": 1}}, "909": {"id": "909", "title": "Arithmetizing Declarations (Corrigendum)", "authors": "Conway, M. E. Speroni, J.", "words_pool": ["arithmet", "corrigendum", "declar", "conway", "speroni"], "word_count": {"arithmet": 1, "corrigendum": 1, "declar": 1, "conway": 1, "speroni": 1}}, "910": {"id": "910", "title": "Selective Instruction Trap for the 7090", "authors": "Mayer, R. J.", "words_pool": ["instruct", "select", "trap", "mayer"], "word_count": {"instruct": 1, "select": 1, "trap": 1, "mayer": 1}}, "911": {"id": "911", "title": "A Variant Method of File Searching", "authors": "McIlroy, M. D.", "words_pool": ["method", "search", "variant", "mcilroy"], "word_count": {"method": 1, "search": 1, "variant": 1, "mcilroy": 1}}, "912": {"id": "912", "title": "Addressing an Array Yi in k-Dimensions by Fortran for Analysis of Variance", "authors": "Garber, M. J.", "words_pool": ["address", "analysi", "array", "dimens", "fortran", "varianc", "yi", "garber"], "word_count": {"address": 1, "analysi": 1, "array": 1, "dimens": 1, "fortran": 1, "varianc": 1, "yi": 1, "garber": 1}}, "913": {"id": "913", "title": "Neliac", "authors": "Halstead, M. H.", "words_pool": ["neliac", "halstead"], "word_count": {"neliac": 1, "halstead": 1}}, "914": {"id": "914", "title": "Jovial and Its Documentation", "authors": "Shaw, C. J.", "words_pool": ["document", "jovial", "shaw"], "word_count": {"document": 1, "jovial": 1, "shaw": 1}}, "915": {"id": "915", "title": "Documentation of IPL-V", "authors": "Newell, A.", "words_pool": ["document", "ipl", "newel"], "word_count": {"document": 1, "ipl": 1, "newel": 1}}, "916": {"id": "916", "title": "FORTRAN", "authors": "Heising, W. P.", "words_pool": ["fortran", "heis"], "word_count": {"fortran": 1, "heis": 1}}, "917": {"id": "917", "title": "COMIT", "authors": "Yngve, V. H.", "words_pool": ["comit", "yngve"], "word_count": {"comit": 1, "yngve": 1}}, "918": {"id": "918", "title": "COBOL", "authors": "Cunningham, J. F.", "words_pool": ["cobol", "cunningham"], "word_count": {"cobol": 1, "cunningham": 1}}, "919": {"id": "919", "title": "Documentation Problems: ALGOL 60", "authors": "Naur, P.", "words_pool": ["algol", "document", "problem", "naur"], "word_count": {"algol": 1, "document": 1, "problem": 1, "naur": 1}}, "920": {"id": "920", "title": "Toward Better Documentation of Programming Languages", "authors": "Yngve, V. H. Sammet, J. E.", "words_pool": ["document", "languag", "program", "yngve", "sammet"], "word_count": {"document": 1, "languag": 1, "program": 1, "yngve": 1, "sammet": 1}}, "921": {"id": "921", "title": "Incomplete Elliptic Integrals (Algorithm 73)", "authors": "Meyer, N. A.", "words_pool": ["algorithm", "ellipt", "incomplet", "integr", "meyer"], "word_count": {"algorithm": 1, "ellipt": 1, "incomplet": 1, "integr": 1, "meyer": 1}}, "922": {"id": "922", "title": "Multint (Algorithm 32)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "multint", "thacher", "jr"], "word_count": {"algorithm": 1, "multint": 1, "thacher": 1, "jr": 1}}, "923": {"id": "923", "title": "Gomory (Algorithm 153)", "authors": "Bauer, F. L.", "words_pool": ["algorithm", "gomori", "bauer"], "word_count": {"algorithm": 1, "gomori": 1, "bauer": 1}}, "924": {"id": "924", "title": "Nexcom (Algorithm 152)", "authors": "Hopley, J.", "words_pool": ["algorithm", "nexcom", "hopley"], "word_count": {"algorithm": 1, "nexcom": 1, "hopley": 1}}, "925": {"id": "925", "title": "Location of a Vector in a Lexicographically Ordered ListAlgorithm 151)", "authors": "Walter, H. F.", "words_pool": ["lexicograph", "listalgorithm", "locat", "order", "vector", "walter"], "word_count": {"lexicograph": 1, "listalgorithm": 1, "locat": 1, "order": 1, "vector": 1, "walter": 1}}, "926": {"id": "926", "title": "Syminv2 (Algorithm 150)", "authors": "Rutishauser, H.", "words_pool": ["algorithm", "syminv2", "rutishaus"], "word_count": {"algorithm": 1, "syminv2": 1, "rutishaus": 1}}, "927": {"id": "927", "title": "Linear Programming Applied to Ultraviolet Absorption Spectroscopy", "authors": "White, W. C. Shapiro, B. Pratt, A. W.", "words_pool": ["absorpt", "appli", "linear", "program", "spectroscopi", "ultraviolet", "white", "shapiro", "pratt"], "word_count": {"absorpt": 1, "appli": 1, "linear": 1, "program": 1, "spectroscopi": 1, "ultraviolet": 1, "white": 1, "shapiro": 1, "pratt": 1}}, "928": {"id": "928", "title": "Character Manipulation in FORTRAN", "authors": "Lewis, T. S.", "words_pool": ["charact", "fortran", "manipul", "lewi"], "word_count": {"charact": 1, "fortran": 1, "manipul": 1, "lewi": 1}}, "929": {"id": "929", "title": "Glossary Construction", "authors": "Grems, M.", "words_pool": ["construct", "glossari", "grem"], "word_count": {"construct": 1, "glossari": 1, "grem": 1}}, "930": {"id": "930", "title": "Decimal-to-Binary Conversion of Short Fields", "authors": "Yarbrough, L. D.", "words_pool": ["binari", "convers", "decim", "field", "short", "yarbrough"], "word_count": {"binari": 1, "convers": 1, "decim": 1, "field": 1, "short": 1, "yarbrough": 1}}, "931": {"id": "931", "title": "Systematic Mistake Analysis of Digital Computer Programs", "authors": "Miller, J. C. Maloney, C. J.", "words_pool": ["analysi", "comput", "digit", "mistak", "program", "systemat", "miller", "maloney"], "word_count": {"analysi": 1, "comput": 1, "digit": 1, "mistak": 1, "program": 1, "systemat": 1, "miller": 1, "maloney": 1}}, "932": {"id": "932", "title": "Matrix Inversion by Gauss-Jordan Inversion II (Algorithm 120)", "authors": "Naur, P.", "words_pool": ["algorithm", "gauss", "ii", "invers", "jordan", "matrix", "naur"], "word_count": {"algorithm": 1, "gauss": 1, "ii": 1, "invers": 2, "jordan": 1, "matrix": 1, "naur": 1}}, "933": {"id": "933", "title": "Magic Squares (Algorithm 117 & 118)", "authors": "Naur, P.", "words_pool": ["algorithm", "magic", "squar", "naur"], "word_count": {"algorithm": 1, "magic": 1, "squar": 1, "naur": 1}}, "934": {"id": "934", "title": "Gauss's Method (Algorithm 107)", "authors": "Naur, P.", "words_pool": ["algorithm", "gauss", "method", "naur"], "word_count": {"algorithm": 1, "gauss": 1, "method": 1, "naur": 1}}, "935": {"id": "935", "title": "Calculating Primes by Means of GPS (Algorithm)", "authors": "Naur, P.", "words_pool": ["algorithm", "calcul", "gp", "mean", "prime", "naur"], "word_count": {"algorithm": 1, "calcul": 1, "gp": 1, "mean": 1, "prime": 1, "naur": 1}}, "936": {"id": "936", "title": "A Set of Test Matrices (Algorithm 52)", "authors": "Naur, P.", "words_pool": ["algorithm", "matric", "set", "test", "naur"], "word_count": {"algorithm": 1, "matric": 1, "set": 1, "test": 1, "naur": 1}}, "937": {"id": "937", "title": "Inverse of a Finite Segment of the Hilbert Matrix (Algorithm 50)", "authors": "Naur, P.", "words_pool": ["algorithm", "finit", "hilbert", "invers", "matrix", "segment", "naur"], "word_count": {"algorithm": 1, "finit": 1, "hilbert": 1, "invers": 1, "matrix": 1, "segment": 1, "naur": 1}}, "938": {"id": "938", "title": "Invert (Algorithm 42)", "authors": "Naur, P.", "words_pool": ["algorithm", "invert", "naur"], "word_count": {"algorithm": 1, "invert": 1, "naur": 1}}, "939": {"id": "939", "title": "Gamma Function (Algorithm 31)", "authors": "Behrenz, P. G.", "words_pool": ["algorithm", "function", "gamma", "behrenz"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "behrenz": 1}}, "940": {"id": "940", "title": "Generating Discrete Random Variables in a Computer", "abstract": "This note is concerned with details of how to instruct a computer to choose one from many things  with assigned probabilities.  The method uses a uniform variable to direct the computer to a memory location;  if this is done by a sequence of appropriately chosen conditional probabilities, efficient use of memory  space and quite fast programs will result.", "authors": "Marsaglia, G.", "words_pool": ["appropri", "assign", "choos", "chosen", "comput", "concern", "condit", "detail", "direct", "discret", "effici", "fast", "gener", "instruct", "locat", "memori", "method", "note", "probabl", "program", "random", "result", "sequenc", "space", "thing", "uniform", "variabl", "variabl", "marsaglia"], "word_count": {"appropri": 1, "assign": 1, "choos": 1, "chosen": 1, "comput": 2, "concern": 1, "condit": 1, "detail": 1, "direct": 1, "discret": 1, "effici": 1, "fast": 1, "gener": 1, "instruct": 1, "locat": 1, "memori": 2, "method": 1, "note": 1, "probabl": 2, "program": 1, "random": 1, "result": 1, "sequenc": 1, "space": 1, "thing": 1, "uniform": 1, "variabl": 1, "marsaglia": 1}}, "941": {"id": "941", "title": "A Recursive Program for the General n-Dimensional Integral", "abstract": "A general program is outlined for n-dimensional integration with variable limits.  The program  is of a recursive nature and uses Simpson's rule combined with repeated bisection to attain the required  accuracy.  It was developed in the Ferranti Mercury Autocode Scheme.", "authors": "Cadwell, J. H.", "words_pool": ["accuraci", "attain", "autocod", "bisect", "combin", "develop", "dimension", "ferranti", "gener", "integr", "integr", "limit", "mercuri", "natur", "outlin", "program", "recurs", "repeat", "requir", "rule", "scheme", "simpson", "variabl", "cadwel"], "word_count": {"accuraci": 1, "attain": 1, "autocod": 1, "bisect": 1, "combin": 1, "develop": 1, "dimension": 1, "ferranti": 1, "gener": 1, "integr": 1, "limit": 1, "mercuri": 1, "natur": 1, "outlin": 1, "program": 2, "recurs": 1, "repeat": 1, "requir": 1, "rule": 1, "scheme": 1, "simpson": 1, "variabl": 1, "cadwel": 1}}, "942": {"id": "942", "title": "FORTRAN Subroutines for Time Series Analysis", "abstract": "The authors have recently been concerned in a time-series study that constituted a fairly typical  piece of applied statistical research, involving extensive computations on a moderately large quantity  of data.  Wehave found that the many different numerical processes that were required could be built  up almost completely from a small number of basic operations, and a set of FORTRAN subroutines has been  written to perform these.  The main purpose of this note is to describe these subroutines, but since  the question of general statistical programs is topical [1], we include some general remarks.", "authors": "Healy, M. J. R. Bogert, B. P.", "words_pool": ["analysi", "appli", "author", "basic", "built", "complet", "comput", "concern", "constitut", "data", "describ", "extens", "fairli", "fortran", "found", "gener", "includ", "involv", "larg", "main", "moder", "note", "number", "numer", "oper", "perform", "piec", "process", "program", "purpos", "quantiti", "question", "recent", "remark", "requir", "research", "seri", "set", "small", "statist", "studi", "subroutin", "time", "topic", "typic", "wehav", "written", "heali", "bogert"], "word_count": {"analysi": 1, "appli": 1, "author": 1, "basic": 1, "built": 1, "complet": 1, "comput": 1, "concern": 1, "constitut": 1, "data": 1, "describ": 1, "extens": 1, "fairli": 1, "fortran": 1, "found": 1, "gener": 2, "includ": 1, "involv": 1, "larg": 1, "main": 1, "moder": 1, "note": 1, "number": 1, "numer": 1, "oper": 1, "perform": 1, "piec": 1, "process": 1, "program": 1, "purpos": 1, "quantiti": 1, "question": 1, "recent": 1, "remark": 1, "requir": 1, "research": 1, "seri": 1, "set": 1, "small": 1, "statist": 2, "studi": 1, "subroutin": 2, "time": 1, "topic": 1, "typic": 1, "wehav": 1, "written": 1, "heali": 1, "bogert": 1}}, "943": {"id": "943", "title": "Terms Frequently Combined in Problem Description", "authors": "Grems, M.", "words_pool": ["combin", "descript", "frequent", "problem", "term", "grem"], "word_count": {"combin": 1, "descript": 1, "frequent": 1, "problem": 1, "term": 1, "grem": 1}}, "944": {"id": "944", "title": "Storage and Search Properties of a Tree-Organized Memory System", "abstract": "A memory with list properties [1] may be used to construct numeric, alphabetic or alphanumeric  trees.  Such trees have information storage and retrieval properties applicable to problems involving  large quantities of data or to problems where the quantity, word length and distribution of stored information  is not known a priori, or changes rapidly during the processing.  The purpose of this paper is to examine  the storage and search properties of a tree-organized storage system assuming that a memory possessing  certain list properties is available.  Of prime interest is the application where a symbol table, dictionary  or similar file is to be stored and searched.", "authors": "Scidmore, A. K. Weinberg, B. L.", "words_pool": ["alphabet", "alphanumer", "applic", "applic", "assum", "construct", "data", "dictionari", "distribut", "examin", "inform", "interest", "involv", "known", "larg", "length", "list", "memori", "numer", "organ", "paper", "possess", "prime", "priori", "problem", "process", "properti", "purpos", "quantiti", "quantiti", "rapidli", "retriev", "search", "search", "similar", "storag", "store", "symbol", "system", "tabl", "tree", "tree", "word", "scidmor", "weinberg"], "word_count": {"alphabet": 1, "alphanumer": 1, "applic": 2, "assum": 1, "construct": 1, "data": 1, "dictionari": 1, "distribut": 1, "examin": 1, "inform": 2, "interest": 1, "involv": 1, "known": 1, "larg": 1, "length": 1, "list": 2, "memori": 2, "numer": 1, "organ": 1, "paper": 1, "possess": 1, "prime": 1, "priori": 1, "problem": 2, "process": 1, "properti": 4, "purpos": 1, "quantiti": 2, "rapidli": 1, "retriev": 1, "search": 2, "similar": 1, "storag": 3, "store": 2, "symbol": 1, "system": 1, "tabl": 1, "tree": 3, "word": 1, "scidmor": 1, "weinberg": 1}}, "945": {"id": "945", "title": "Arithmetizing Declarations: An Application to COBOL", "authors": "Conway, M. E. Speroni, J.", "words_pool": ["applic", "arithmet", "cobol", "declar", "conway", "speroni"], "word_count": {"applic": 1, "arithmet": 1, "cobol": 1, "declar": 1, "conway": 1, "speroni": 1}}, "946": {"id": "946", "title": "Suggestions on ALGOL 60 (ROME) Issues - A Report by the American Standards Association Subcommittee X3.4.2", "authors": "Utman, R. E.", "words_pool": ["algol", "american", "associ", "issu", "report", "rome", "standard", "subcommitte", "suggest", "x3", "utman"], "word_count": {"algol": 1, "american": 1, "associ": 1, "issu": 1, "report": 1, "rome": 1, "standard": 1, "subcommitte": 1, "suggest": 1, "x3": 1, "utman": 1}}, "947": {"id": "947", "title": "Supplement to the ALGOL 60 Report", "authors": "Woodger, M.", "words_pool": ["algol", "report", "supplement", "woodger"], "word_count": {"algol": 1, "report": 1, "supplement": 1, "woodger": 1}}, "948": {"id": "948", "title": "Note on the Use of Procedures", "authors": "Healy, M. J. R.", "words_pool": ["note", "procedur", "heali"], "word_count": {"note": 1, "procedur": 1, "heali": 1}}, "949": {"id": "949", "title": "Integer and Signed Constants in ALGOL", "abstract": "A few remarks are given on the relations between syntax and semantics in the programming languages.   The aim is to point out that, if it is true that the grammar of a context-free language should be conceived  not only as a strings-generating device but also as a method for expressing a meaning, then the grammar  of ALGOL is open to some criticism.", "authors": "Petrone, L. Vandoni, C. E.", "words_pool": ["aim", "algol", "conceiv", "constant", "context", "critic", "devic", "express", "free", "gener", "grammar", "integ", "languag", "languag", "mean", "method", "open", "point", "program", "relat", "remark", "semant", "sign", "string", "syntax", "true", "petron", "vandoni"], "word_count": {"aim": 1, "algol": 1, "conceiv": 1, "constant": 1, "context": 1, "critic": 1, "devic": 1, "express": 1, "free": 1, "gener": 1, "grammar": 2, "integ": 1, "languag": 2, "mean": 1, "method": 1, "open": 1, "point": 1, "program": 1, "relat": 1, "remark": 1, "semant": 1, "sign": 1, "string": 1, "syntax": 1, "true": 1, "petron": 1, "vandoni": 1}}, "950": {"id": "950", "title": "Parallel Methods for Integrating Ordinary Differential Equations", "abstract": "This paper is dedicated to the proposition that, in order to take full advantage for real-time  computations of highly parallel computers as can be expected to be available in the near future, much  of numerical analysis will have to be recast in a more \"parallel\" form.  By this is meant that serial  algorithms ought to be replaced by algorithm which consist of several subtasks which can be computed  without knowledge of the results of the other subtasks.  As an example, a method is proposed for \"parallelizing\"  the numerical integration of an ordinary differential equation, which process, by all standard methods,  is entirely serial.", "authors": "Nievergelt, J.", "words_pool": ["advantag", "algorithm", "algorithm", "analysi", "comput", "comput", "comput", "consist", "dedic", "differenti", "entir", "equat", "equat", "expect", "form", "full", "futur", "highli", "integr", "integr", "knowledg", "meant", "method", "method", "numer", "order", "ordinari", "paper", "parallel", "parallel", "process", "propos", "proposit", "real", "recast", "replac", "result", "serial", "standard", "subtask", "take", "time", "nievergelt"], "word_count": {"advantag": 1, "algorithm": 2, "analysi": 1, "comput": 3, "consist": 1, "dedic": 1, "differenti": 1, "entir": 1, "equat": 1, "expect": 1, "form": 1, "full": 1, "futur": 1, "highli": 1, "integr": 1, "knowledg": 1, "meant": 1, "method": 2, "numer": 2, "order": 1, "ordinari": 1, "paper": 1, "parallel": 3, "process": 1, "propos": 1, "proposit": 1, "real": 1, "recast": 1, "replac": 1, "result": 1, "serial": 2, "standard": 1, "subtask": 2, "take": 1, "time": 1, "nievergelt": 1}}, "951": {"id": "951", "title": "Rational Chebyshev Approximations to the Bessel Function Integrals Kis(x)", "abstract": "The second Remes algorithm is used to approximate the integrals Kis by rational functions.  The related coefficients for the approximations of Ki1, Ki2, Ki3 are given for different precisions.", "authors": "Gargantini, I. Pomentale, T.", "words_pool": ["algorithm", "approxim", "approxim", "bessel", "chebyshev", "coeffici", "function", "function", "integr", "ki1", "ki2", "ki3", "ki", "precis", "ration", "relat", "reme", "gargantini", "pomental"], "word_count": {"algorithm": 1, "approxim": 2, "bessel": 1, "chebyshev": 1, "coeffici": 1, "function": 1, "integr": 1, "ki1": 1, "ki2": 1, "ki3": 1, "ki": 1, "precis": 1, "ration": 1, "relat": 1, "reme": 1, "gargantini": 1, "pomental": 1}}, "952": {"id": "952", "title": "Another use of FORTRAN II Chaining", "authors": "Drath, D. G.", "words_pool": ["chain", "fortran", "ii", "drath"], "word_count": {"chain": 1, "fortran": 1, "ii": 1, "drath": 1}}, "953": {"id": "953", "title": "Scanning Text with a 1401", "authors": "Baker, J. J.", "words_pool": ["scan", "text", "baker"], "word_count": {"scan": 1, "text": 1, "baker": 1}}, "954": {"id": "954", "title": "A Note on the Calculation of Probabilities in an F-Distribution", "authors": "Smillie, K. W. Anstey, T. H.", "words_pool": ["calcul", "distribut", "note", "probabl", "smilli", "anstey"], "word_count": {"calcul": 1, "distribut": 1, "note": 1, "probabl": 1, "smilli": 1, "anstey": 1}}, "955": {"id": "955", "title": "A Class of Matrices to Test Inversion Procedures", "authors": "Cline, R. E.", "words_pool": ["class", "invers", "matric", "procedur", "test", "cline"], "word_count": {"class": 1, "invers": 1, "matric": 1, "procedur": 1, "test": 1, "cline": 1}}, "956": {"id": "956", "title": "A Family of Test Matrices", "authors": "Newbery, A. C. R.", "words_pool": ["famili", "matric", "test", "newberi"], "word_count": {"famili": 1, "matric": 1, "test": 1, "newberi": 1}}, "957": {"id": "957", "title": "Method for Partial Rewriting of Magnetic Tape", "authors": "Miller, J. A.", "words_pool": ["magnet", "method", "partial", "rewrit", "tape", "miller"], "word_count": {"magnet": 1, "method": 1, "partial": 1, "rewrit": 1, "tape": 1, "miller": 1}}, "958": {"id": "958", "title": "A Case of too Much Precision", "authors": "Synge, M. J.", "words_pool": ["case", "precis", "syng"], "word_count": {"case": 1, "precis": 1, "syng": 1}}, "959": {"id": "959", "title": "Mark Sense and Port-A-Punch Programming Inputs", "authors": "Lubbert, W. F.", "words_pool": ["input", "mark", "port", "program", "punch", "sens", "lubbert"], "word_count": {"input": 1, "mark": 1, "port": 1, "program": 1, "punch": 1, "sens": 1, "lubbert": 1}}, "960": {"id": "960", "title": "Curve Fitting with Format Fortran", "authors": "Garber, M. J.", "words_pool": ["curv", "fit", "format", "fortran", "garber"], "word_count": {"curv": 1, "fit": 1, "format": 1, "fortran": 1, "garber": 1}}, "961": {"id": "961", "title": "Limited Bit Manipulation Using FORTRAN II", "abstract": "Techniques are developed for manipulating bits using only FORTRAN II.  These techniques allow  individual bits to be tested, certain fields to be shifted, and numbers coded in BCD to be converted  to Binary.", "authors": "Oster, C. A.", "words_pool": ["allow", "bcd", "binari", "bit", "bit", "code", "convert", "develop", "field", "fortran", "ii", "individu", "limit", "manipul", "manipul", "number", "shift", "techniqu", "test", "oster"], "word_count": {"allow": 1, "bcd": 1, "binari": 1, "bit": 2, "code": 1, "convert": 1, "develop": 1, "field": 1, "fortran": 1, "ii": 1, "individu": 1, "limit": 1, "manipul": 1, "number": 1, "shift": 1, "techniqu": 2, "test": 1, "oster": 1}}, "962": {"id": "962", "title": "Double-Precision Squares Root for The CDC-3600", "abstract": "In January of 1960, the late Hans J. Maehly completed a summary of approximations to the elementary  functions for the CDC-1604 computer.  The approximations and techniques suggested by Maehly are equally  applicable to the second large computer in the CDC line, the 3600.  Unlike the 1604, however, the 3600  has built-in double-precision floating-point arithmetic.  The present work, largely inspired by the successes  of Maehly and his associates, concerns the extension of one of Maehly's ideas to a double-precision subroutine  for the 3600.", "authors": "Cody, W. J.", "words_pool": ["applic", "approxim", "arithmet", "associ", "built", "cdc", "complet", "comput", "concern", "doubl", "elementari", "equal", "extens", "float", "function", "han", "idea", "inspir", "januari", "larg", "larg", "late", "line", "maehli", "point", "precis", "present", "root", "squar", "subroutin", "success", "suggest", "summari", "techniqu", "unlik", "work", "codi"], "word_count": {"applic": 1, "approxim": 2, "arithmet": 1, "associ": 1, "built": 1, "cdc": 2, "complet": 1, "comput": 2, "concern": 1, "doubl": 2, "elementari": 1, "equal": 1, "extens": 1, "float": 1, "function": 1, "han": 1, "idea": 1, "inspir": 1, "januari": 1, "larg": 2, "late": 1, "line": 1, "maehli": 4, "point": 1, "precis": 2, "present": 1, "root": 1, "squar": 1, "subroutin": 1, "success": 1, "suggest": 1, "summari": 1, "techniqu": 1, "unlik": 1, "work": 1, "codi": 1}}, "963": {"id": "963", "title": "Relative Effects of Central Processor and Input-Output Speeds Upon Throughput on the Large Computer", "abstract": "Presented in this paper is a technique for determining the relative effects of the internal  speed of the computer and the speed of the input-output units upon the overall speed of the system. Equations  are derived which permit the determination of these effects from hardware usage measurements.", "authors": "White, P.", "words_pool": ["central", "comput", "deriv", "determin", "determin", "effect", "equat", "hardwar", "input", "intern", "larg", "measur", "output", "paper", "permit", "present", "processor", "rel", "speed", "speed", "system", "techniqu", "throughput", "unit", "usag", "white"], "word_count": {"central": 1, "comput": 1, "deriv": 1, "determin": 2, "effect": 2, "equat": 1, "hardwar": 1, "input": 1, "intern": 1, "larg": 1, "measur": 1, "output": 1, "paper": 1, "permit": 1, "present": 1, "processor": 1, "rel": 1, "speed": 3, "system": 1, "techniqu": 1, "throughput": 1, "unit": 1, "usag": 1, "white": 1}}, "964": {"id": "964", "title": "Mechanization of Tedious Algebra-the e Coefficients of Theoretical Chemistry", "abstract": "A table of formulas for certain integrals involving Legendre functions has been constructed  mechanically by a program which performed algebraic operations.  The formulas are all rational algebraic  expressions in a single variable and were constructed by a recurrence procedure.  They are of interest  in molecular quantum chemistry.  Trivial coding techniques were used to write the relevant programs in  FORTRAN.  The results were photo composed on a Photon S-560 system, that was controlled by tapes which  were punched directly from the computer output, so avoiding manual keyboarding, transcription errors  and keyboarded correction.", "authors": "Wactlar, H. D. Barnett, M. P.", "words_pool": ["algebra", "algebra", "avoid", "chemistri", "code", "coeffici", "compos", "comput", "construct", "control", "correct", "directli", "error", "express", "formula", "fortran", "function", "integr", "interest", "involv", "keyboard", "keyboard", "legendr", "mechan", "mechan", "molecular", "oper", "output", "perform", "photo", "photon", "procedur", "program", "program", "punch", "quantum", "ration", "recurr", "relev", "result", "singl", "system", "tabl", "tape", "techniqu", "tediou", "theoret", "transcript", "trivial", "variabl", "write", "wactlar", "barnett"], "word_count": {"algebra": 2, "avoid": 1, "chemistri": 1, "code": 1, "coeffici": 1, "compos": 1, "comput": 1, "construct": 2, "control": 1, "correct": 1, "directli": 1, "error": 1, "express": 1, "formula": 2, "fortran": 1, "function": 1, "integr": 1, "interest": 1, "involv": 1, "keyboard": 2, "legendr": 1, "mechan": 1, "molecular": 1, "oper": 1, "output": 1, "perform": 1, "photo": 1, "photon": 1, "procedur": 1, "program": 2, "punch": 1, "quantum": 1, "ration": 1, "recurr": 1, "relev": 1, "result": 1, "singl": 1, "system": 1, "tabl": 1, "tape": 1, "techniqu": 1, "tediou": 1, "theoret": 1, "transcript": 1, "trivial": 1, "variabl": 1, "write": 1, "wactlar": 1, "barnett": 1}}, "965": {"id": "965", "title": "Greatest Common Divisor (Algorithm 237 [A1])", "authors": "Bray, T. A.", "words_pool": ["a1", "algorithm", "common", "divisor", "greatest", "bray"], "word_count": {"a1": 1, "algorithm": 1, "common": 1, "divisor": 1, "greatest": 1, "bray": 1}}, "966": {"id": "966", "title": "Evaluation of Determinant (Algorithm 224 [F3])", "authors": "Hasselblad, V. Rulifson, J.", "words_pool": ["algorithm", "determin", "evalu", "f3", "hasselblad", "rulifson"], "word_count": {"algorithm": 1, "determin": 1, "evalu": 1, "f3": 1, "hasselblad": 1, "rulifson": 1}}, "967": {"id": "967", "title": "Complementary Error Function (Algorithm 181 [S15])", "authors": "Clausen, I. Hansson,L.", "words_pool": ["algorithm", "complementari", "error", "function", "s15", "clausen", "hansson"], "word_count": {"algorithm": 1, "complementari": 1, "error": 1, "function": 1, "s15": 1, "clausen": 1, "hansson": 1}}, "968": {"id": "968", "title": "Radical-Inverse Quasi-Random Point Sequence (Algorithm 247 [G5])", "authors": "Halton, J. H. Smith, G. B.", "words_pool": ["algorithm", "g5", "invers", "point", "quasi", "radic", "random", "sequenc", "halton", "smith"], "word_count": {"algorithm": 1, "g5": 1, "invers": 1, "point": 1, "quasi": 1, "radic": 1, "random": 1, "sequenc": 1, "halton": 1, "smith": 1}}, "969": {"id": "969", "title": "Graycode (Algorithm 246 [Z])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "graycod", "boothroyd"], "word_count": {"algorithm": 1, "graycod": 1, "boothroyd": 1}}, "970": {"id": "970", "title": "Treesort 3 (Algorithm [M1])", "authors": "Floyd, R. W.", "words_pool": ["algorithm", "m1", "treesort", "floyd"], "word_count": {"algorithm": 1, "m1": 1, "treesort": 1, "floyd": 1}}, "971": {"id": "971", "title": "Time Sharing in a Traffic Control Program", "abstract": "The Toronto traffic signal control system consists of a variety of logically distinct computer  programs, all competing for machine time.  To satisfy these demands, a time-sharing program has been  written whose purpose is to execute, in the order of a predefined priority, the various subprograms within  the real-time system.  In this paper the more interesting aspects of the time-sharing program are outlined.", "authors": "Green, L. E. S.", "words_pool": ["aspect", "compet", "comput", "consist", "control", "demand", "distinct", "execut", "interest", "logic", "machin", "order", "outlin", "paper", "predefin", "prioriti", "program", "program", "purpos", "real", "satisfi", "share", "signal", "subprogram", "system", "time", "toronto", "traffic", "varieti", "written", "green"], "word_count": {"aspect": 1, "compet": 1, "comput": 1, "consist": 1, "control": 1, "demand": 1, "distinct": 1, "execut": 1, "interest": 1, "logic": 1, "machin": 1, "order": 1, "outlin": 1, "paper": 1, "predefin": 1, "prioriti": 1, "program": 3, "purpos": 1, "real": 1, "satisfi": 1, "share": 2, "signal": 1, "subprogram": 1, "system": 2, "time": 4, "toronto": 1, "traffic": 1, "varieti": 1, "written": 1, "green": 1}}, "972": {"id": "972", "title": "An Executive System Implemented as a Finite-State Automaton", "abstract": "The 473L command and control system used by the Air Force permits many operators to access  large data files through the use of a computer.  The man-machine interface is satisfied by several communication  consoles from which operators may enter queries and view replies.  A data link permits remote stations  to send messages, status reports and inventories directly to the computer.  The information received  over the on-line data link is used to update the data files which are stored on disk.  The 473L programming  system is divided into an Executive Control Program and five components with different processing priorities.   These priorities permit the system to be most sensitive to the console inputs and permit the operators  at all the consoles to time share the central processor.  The Executive Control Program provides for  the orderly transitions of control among the programming system components. The major emphasis of the  paper is on the technique of using the definition of a finite-state automaton for organizing the Executive  Control Program.", "authors": "Heistand, R. E.", "words_pool": ["473l", "access", "air", "automaton", "central", "command", "commun", "compon", "comput", "consol", "consol", "control", "data", "definit", "directli", "disk", "divid", "emphasi", "enter", "execut", "finit", "forc", "implement", "inform", "input", "interfac", "inventori", "larg", "line", "link", "machin", "major", "man", "messag", "oper", "orderli", "organ", "paper", "permit", "permit", "prioriti", "process", "processor", "program", "program", "queri", "receiv", "remot", "repli", "report", "satisfi", "send", "sensit", "share", "state", "station", "statu", "store", "system", "techniqu", "time", "transit", "updat", "view", "heistand"], "word_count": {"473l": 2, "access": 1, "air": 1, "automaton": 1, "central": 1, "command": 1, "commun": 1, "compon": 2, "comput": 2, "consol": 3, "control": 5, "data": 4, "definit": 1, "directli": 1, "disk": 1, "divid": 1, "emphasi": 1, "enter": 1, "execut": 3, "finit": 1, "forc": 1, "implement": 1, "inform": 1, "input": 1, "interfac": 1, "inventori": 1, "larg": 1, "line": 1, "link": 2, "machin": 1, "major": 1, "man": 1, "messag": 1, "oper": 3, "orderli": 1, "organ": 1, "paper": 1, "permit": 4, "prioriti": 2, "process": 1, "processor": 1, "program": 5, "queri": 1, "receiv": 1, "remot": 1, "repli": 1, "report": 1, "satisfi": 1, "send": 1, "sensit": 1, "share": 1, "state": 1, "station": 1, "statu": 1, "store": 1, "system": 4, "techniqu": 1, "time": 1, "transit": 1, "updat": 1, "view": 1, "heistand": 1}}, "973": {"id": "973", "title": "Estimation of Heart Parameters Using Skin Potential Measurements", "abstract": "A fundamental problem of vector cardiography is the estimation of the state of the heart on  the basis of skin potential measurements.  A mathematical model relating ventricular dipoles to surface  potentials is sketched.  Then it is shown that the inverse problem-that of determining electrical heart  parameters on the basis of skin potential measurements-may be viewed as a nonlinear multipoint boundary  value problem.  A feasible solution, employing quasilinearization and high-speed digital computers, is  given.", "authors": "Bellman, R. Collier, C. Kagiwada, H. Kalaba, R. Selvester, R.", "words_pool": ["basi", "boundari", "cardiographi", "comput", "determin", "digit", "dipol", "electr", "employ", "estim", "feasibl", "fundament", "heart", "high", "invers", "mathemat", "measur", "model", "multipoint", "nonlinear", "paramet", "potenti", "potenti", "problem", "quasilinear", "relat", "shown", "sketch", "skin", "solut", "speed", "state", "surfac", "vector", "ventricular", "view", "bellman", "collier", "kagiwada", "kalaba", "selvest"], "word_count": {"basi": 2, "boundari": 1, "cardiographi": 1, "comput": 1, "determin": 1, "digit": 1, "dipol": 1, "electr": 1, "employ": 1, "estim": 1, "feasibl": 1, "fundament": 1, "heart": 2, "high": 1, "invers": 1, "mathemat": 1, "measur": 2, "model": 1, "multipoint": 1, "nonlinear": 1, "paramet": 1, "potenti": 3, "problem": 3, "quasilinear": 1, "relat": 1, "shown": 1, "sketch": 1, "skin": 2, "solut": 1, "speed": 1, "state": 1, "surfac": 1, "vector": 1, "ventricular": 1, "view": 1, "bellman": 1, "collier": 1, "kagiwada": 1, "kalaba": 1, "selvest": 1}}, "974": {"id": "974", "title": "A Technique for Reading Gapless Tapes Makes Electrocardiograph Analysis Feasible on the IBM 7090", "abstract": "To study arrhythmias and higher frequency components of the electrocardiogram, long series  of patient heart cycles must be examined before valid comparison of different heart beats can be made.  A technique is presented for the automatic analysis of long series heart cycles via a digital computer.", "authors": "Maher, A. S.", "words_pool": ["analysi", "arrhythmia", "automat", "beat", "comparison", "compon", "comput", "cycl", "digit", "electrocardiogram", "electrocardiograph", "examin", "feasibl", "frequenc", "gapless", "heart", "higher", "ibm", "long", "made", "make", "patient", "present", "read", "seri", "studi", "tape", "techniqu", "valid", "maher"], "word_count": {"analysi": 1, "arrhythmia": 1, "automat": 1, "beat": 1, "comparison": 1, "compon": 1, "comput": 1, "cycl": 2, "digit": 1, "electrocardiogram": 1, "electrocardiograph": 1, "examin": 1, "feasibl": 1, "frequenc": 1, "gapless": 1, "heart": 3, "higher": 1, "ibm": 1, "long": 2, "made": 1, "make": 1, "patient": 1, "present": 1, "read": 1, "seri": 2, "studi": 1, "tape": 1, "techniqu": 1, "valid": 1, "maher": 1}}, "975": {"id": "975", "title": "The New Program of Work for the International Standard Vocabulary in Computers and Information Processing", "authors": "Traub, J. F.", "words_pool": ["comput", "inform", "intern", "process", "program", "standard", "vocabulari", "work", "traub"], "word_count": {"comput": 1, "inform": 1, "intern": 1, "process": 1, "program": 1, "standard": 1, "vocabulari": 1, "work": 1, "traub": 1}}, "976": {"id": "976", "title": "Fresnel Integrals (Algorithm 213 [S20])", "authors": "Gray, M.", "words_pool": ["algorithm", "fresnel", "integr", "s20", "gray"], "word_count": {"algorithm": 1, "fresnel": 1, "integr": 1, "s20": 1, "gray": 1}}, "977": {"id": "977", "title": "Conversions Between Calendar Date and Julian Day Number (Algorithm 199 [Z])", "authors": "Oppenheim, D. K.", "words_pool": ["algorithm", "calendar", "convers", "date", "day", "julian", "number", "oppenheim"], "word_count": {"algorithm": 1, "calendar": 1, "convers": 1, "date": 1, "day": 1, "julian": 1, "number": 1, "oppenheim": 1}}, "978": {"id": "978", "title": "Fresnel Integrals (Algorithm 244 [S20])", "authors": "Lotsch, H.", "words_pool": ["algorithm", "fresnel", "integr", "s20", "lotsch"], "word_count": {"algorithm": 1, "fresnel": 1, "integr": 1, "s20": 1, "lotsch": 1}}, "979": {"id": "979", "title": "Logarithm of a Complex Number (Algorithm 243 [B3])", "authors": "Collens, D. S.", "words_pool": ["algorithm", "b3", "complex", "logarithm", "number", "collen"], "word_count": {"algorithm": 1, "b3": 1, "complex": 1, "logarithm": 1, "number": 1, "collen": 1}}, "980": {"id": "980", "title": "Multiple-Precision Arithmetic and the Exact Calculation of the 3-j, 6-j and 9-j Symbols", "abstract": "Described in this paper is a system of general-purpose multiple-precision fixed-point routines  and their use in subroutines which calculate exactly the quantum-mechanical 3-j, 6-j and 9-j symbols  of large arguments.", "authors": "Maer, R. M. Redlich, M. G.", "words_pool": ["argument", "arithmet", "calcul", "calcul", "exact", "exactli", "fix", "gener", "larg", "mechan", "multipl", "paper", "point", "precis", "purpos", "quantum", "routin", "subroutin", "symbol", "system", "maer", "redlich"], "word_count": {"argument": 1, "arithmet": 1, "calcul": 1, "exact": 1, "exactli": 1, "fix": 1, "gener": 1, "larg": 1, "mechan": 1, "multipl": 1, "paper": 1, "point": 1, "precis": 1, "purpos": 1, "quantum": 1, "routin": 1, "subroutin": 1, "symbol": 1, "system": 1, "maer": 1, "redlich": 1}}, "981": {"id": "981", "title": "Rounding Problems in Commercial Data Processing", "abstract": "A common requirement in commercial data processing is that the sum of a set of numbers, rounded  in a generally understood manner, be equal to the sum of the numbers rounded individually.  Four rounding  procedures are described to accomplish this.  The particular procedure that is appropriate depends upon  whether the numbers being accumulated can vary in sign, whether their sum can vary in sign, and whether  the last number being summed can be recognized as such prior to its rounding.", "authors": "Kelley, T. B.", "words_pool": ["accomplish", "accumul", "commerci", "common", "data", "depend", "equal", "gener", "individu", "manner", "number", "number", "prior", "problem", "procedur", "procedur", "process", "recogn", "requir", "round", "round", "set", "sign", "sum", "sum", "understood", "vari", "kelley"], "word_count": {"accomplish": 1, "accumul": 1, "commerci": 1, "common": 1, "data": 1, "depend": 1, "equal": 1, "gener": 1, "individu": 1, "manner": 1, "number": 4, "prior": 1, "problem": 1, "procedur": 2, "process": 1, "recogn": 1, "requir": 1, "round": 4, "set": 1, "sign": 2, "sum": 4, "understood": 1, "vari": 2, "kelley": 1}}, "982": {"id": "982", "title": "An Inductive Approach to Language Translation", "abstract": "The possibility of natural language translation by means of fixed operations on example translations  is considered.  The conception of sentence translation which motivates the work is informally presented,  and the measurement of physical similarity in pairs of strings is discussed, a notion which plays a central  role in the proposed type of translator.  Experimental evidence is presented in support of the premise  upon which this conception is based.", "authors": "Faulk, R. D.", "words_pool": ["approach", "base", "central", "concept", "consid", "discuss", "evid", "experiment", "fix", "induct", "inform", "languag", "mean", "measur", "motiv", "natur", "notion", "oper", "pair", "physic", "play", "possibl", "premis", "present", "propos", "role", "sentenc", "similar", "string", "support", "translat", "translat", "translat", "type", "work", "faulk"], "word_count": {"approach": 1, "base": 1, "central": 1, "concept": 2, "consid": 1, "discuss": 1, "evid": 1, "experiment": 1, "fix": 1, "induct": 1, "inform": 1, "languag": 1, "mean": 1, "measur": 1, "motiv": 1, "natur": 1, "notion": 1, "oper": 1, "pair": 1, "physic": 1, "play": 1, "possibl": 1, "premis": 1, "present": 2, "propos": 1, "role": 1, "sentenc": 1, "similar": 1, "string": 1, "support": 1, "translat": 4, "type": 1, "work": 1, "faulk": 1}}, "983": {"id": "983", "title": "Take-up reels for One-Inch Perforated Tape for Information Interchange (Proposed American Standard)", "words_pool": ["american", "inch", "inform", "interchang", "perfor", "propos", "reel", "standard", "take", "tape"], "word_count": {"american": 1, "inch": 1, "inform": 1, "interchang": 1, "perfor": 1, "propos": 1, "reel": 1, "standard": 1, "take": 1, "tape": 1}}, "984": {"id": "984", "title": "Report on Input-Output Procedures for ALGOL 60 (IFIP)", "words_pool": ["algol", "ifip", "input", "output", "procedur", "report"], "word_count": {"algol": 1, "ifip": 1, "input": 1, "output": 1, "procedur": 1, "report": 1}}, "985": {"id": "985", "title": "Report on SUBSET ALGOL 60 (IFIP)", "words_pool": ["algol", "ifip", "report", "subset"], "word_count": {"algol": 1, "ifip": 1, "report": 1, "subset": 1}}, "986": {"id": "986", "title": "Proposed Amendment to Proposed American Standard on Specification for General-Purpose Paper Cards  for Information Processing", "words_pool": ["amend", "american", "card", "gener", "inform", "paper", "process", "propos", "purpos", "specif", "standard"], "word_count": {"amend": 1, "american": 1, "card": 1, "gener": 1, "inform": 1, "paper": 1, "process": 1, "propos": 2, "purpos": 1, "specif": 1, "standard": 1}}, "987": {"id": "987", "title": "FORTRAN vs. Basic FORTRAN (A Programming Language for Information Processing on Automatic Data  Processing Systems)", "words_pool": ["automat", "basic", "data", "fortran", "inform", "languag", "process", "program", "system"], "word_count": {"automat": 1, "basic": 1, "data": 1, "fortran": 2, "inform": 1, "languag": 1, "process": 2, "program": 1, "system": 1}}, "988": {"id": "988", "title": "History and Summary of FORTRAN Standardization Development for the ASA", "authors": "Heising, W. P.", "words_pool": ["asa", "develop", "fortran", "histori", "standard", "summari", "heis"], "word_count": {"asa": 1, "develop": 1, "fortran": 1, "histori": 1, "standard": 1, "summari": 1, "heis": 1}}, "989": {"id": "989", "title": "A Method of Syntax Specification", "authors": "Iverson, K. E.", "words_pool": ["method", "specif", "syntax", "iverson"], "word_count": {"method": 1, "specif": 1, "syntax": 1, "iverson": 1}}, "990": {"id": "990", "title": "Constraint-Type Statements in Programming Languages", "abstract": "A proposal is made for including in a programming language statements which imply relations  between variables but which are not explicit assignment statements.  The compiler sets up a Newtonian  iteration making use for the purpose of a routine for formal differentiation.", "authors": "Wilkes, M. V.", "words_pool": ["assign", "compil", "constraint", "differenti", "explicit", "formal", "impli", "includ", "iter", "languag", "languag", "made", "make", "newtonian", "program", "propos", "purpos", "relat", "routin", "set", "statement", "type", "variabl", "wilk"], "word_count": {"assign": 1, "compil": 1, "constraint": 1, "differenti": 1, "explicit": 1, "formal": 1, "impli": 1, "includ": 1, "iter": 1, "languag": 1, "made": 1, "make": 1, "newtonian": 1, "program": 1, "propos": 1, "purpos": 1, "relat": 1, "routin": 1, "set": 1, "statement": 2, "type": 1, "variabl": 1, "wilk": 1}}, "991": {"id": "991", "title": "Gamma Function with Controller Accuracy (Algorithm 225 [S14])", "authors": "Bray, T. A.", "words_pool": ["accuraci", "algorithm", "control", "function", "gamma", "s14", "bray"], "word_count": {"accuraci": 1, "algorithm": 1, "control": 1, "function": 1, "gamma": 1, "s14": 1, "bray": 1}}, "992": {"id": "992", "title": "Gamma Function (Algorithm 221 [S14])", "authors": "McCombs, V. K.", "words_pool": ["algorithm", "function", "gamma", "s14", "mccomb"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "s14": 1, "mccomb": 1}}, "993": {"id": "993", "title": "Kutta Merson (Algorithm 218 [D2])", "authors": "Priebe, K. B.", "words_pool": ["algorithm", "d2", "kutta", "merson", "prieb"], "word_count": {"algorithm": 1, "d2": 1, "kutta": 1, "merson": 1, "prieb": 1}}, "994": {"id": "994", "title": "Stringsort (Algorithm 207 [M1])", "authors": "Blair, C. R.", "words_pool": ["algorithm", "m1", "stringsort", "blair"], "word_count": {"algorithm": 1, "m1": 1, "stringsort": 1, "blair": 1}}, "995": {"id": "995", "title": "Steep1 (Algorithm 203 [E4])", "authors": "Wallack, P.", "words_pool": ["algorithm", "e4", "steep1", "wallack"], "word_count": {"algorithm": 1, "e4": 1, "steep1": 1, "wallack": 1}}, "996": {"id": "996", "title": "Permutations of a Set with Repetitions (Algorithm 242 [G6])", "authors": "Sag, T. W.", "words_pool": ["algorithm", "g6", "permut", "repetit", "set", "sag"], "word_count": {"algorithm": 1, "g6": 1, "permut": 1, "repetit": 1, "set": 1, "sag": 1}}, "997": {"id": "997", "title": "Patent Protection of Computer Programs", "authors": "Jacobs, M. C.", "words_pool": ["comput", "patent", "program", "protect", "jacob"], "word_count": {"comput": 1, "patent": 1, "program": 1, "protect": 1, "jacob": 1}}, "998": {"id": "998", "title": "Computer Programs are Patentable", "authors": "Hamlin, K. B.", "words_pool": ["comput", "patent", "program", "hamlin"], "word_count": {"comput": 1, "patent": 1, "program": 1, "hamlin": 1}}, "999": {"id": "999", "title": "Joint Inventorship of Computers", "authors": "Hauptman, G. A.", "words_pool": ["comput", "inventorship", "joint", "hauptman"], "word_count": {"comput": 1, "inventorship": 1, "joint": 1, "hauptman": 1}}, "1000": {"id": "1000", "title": "Computer Patent Disclosures", "authors": "Kates, J. P.", "words_pool": ["comput", "disclosur", "patent", "kate"], "word_count": {"comput": 1, "disclosur": 1, "patent": 1, "kate": 1}}, "1001": {"id": "1001", "title": "Copyright Aspects of Computer Usage", "abstract": "This paper is concerned with the question of what constitutes infringement of a copyright on  a book or other nondramatic literary work when the work is fed into a computer and is indexed, analyzed,  partially reprinted, or otherwise utilized by the computer to produce eye-readable output.  The question  of copyrightability of programs and infringement of copyrights on programs is also discussed.  The paper  is directed primarily to a discussion of the present law.  Some aspects of the proposed new copyright  law are also included.  General recommendations are made with respect to the proposed revision of the  copyright law.", "authors": "Lawlor, R. C.", "words_pool": ["analyz", "aspect", "book", "comput", "concern", "constitut", "copyright", "copyright", "copyright", "direct", "discuss", "discuss", "eye", "fed", "gener", "includ", "index", "infring", "law", "literari", "made", "nondramat", "output", "paper", "partial", "present", "primarili", "produc", "program", "propos", "question", "readabl", "recommend", "reprint", "respect", "revis", "usag", "util", "work", "lawlor"], "word_count": {"analyz": 1, "aspect": 1, "book": 1, "comput": 2, "concern": 1, "constitut": 1, "copyright": 5, "direct": 1, "discuss": 2, "eye": 1, "fed": 1, "gener": 1, "includ": 1, "index": 1, "infring": 2, "law": 3, "literari": 1, "made": 1, "nondramat": 1, "output": 1, "paper": 2, "partial": 1, "present": 1, "primarili": 1, "produc": 1, "program": 2, "propos": 2, "question": 2, "readabl": 1, "recommend": 1, "reprint": 1, "respect": 1, "revis": 1, "usag": 1, "util": 1, "work": 2, "lawlor": 1}}, "1002": {"id": "1002", "title": "A Rapid Method for Digital Filtering", "abstract": "Since much of the computer time spent in time-series analysis is used for multiplications,  a minimum multiplication method was devised for digital filtering, with the expectation that it would  be useful in the on line, real-time analysis of biological data.  The filters are constructed from a succession  of readily analyzable components in a manner that facilitates cascading.  The repertoire of frequency  response curves includes relatively good low-pass and band-pass designs.  Programs are available for  implementing both the synthesis of these filters, and their application on computers whose assemblers  allow the definition of recursive macros.", "authors": "Whittlesey, J. R. B.", "words_pool": ["allow", "analysi", "analyz", "applic", "assembl", "band", "biolog", "cascad", "compon", "comput", "comput", "construct", "curv", "data", "definit", "design", "devis", "digit", "expect", "facilit", "filter", "filter", "frequenc", "good", "implement", "includ", "line", "low", "macro", "manner", "method", "minimum", "multipl", "multipl", "pass", "program", "rapid", "readili", "real", "recurs", "repertoir", "respons", "seri", "spent", "success", "synthesi", "time", "whittlesey"], "word_count": {"allow": 1, "analysi": 2, "analyz": 1, "applic": 1, "assembl": 1, "band": 1, "biolog": 1, "cascad": 1, "compon": 1, "comput": 2, "construct": 1, "curv": 1, "data": 1, "definit": 1, "design": 1, "devis": 1, "digit": 1, "expect": 1, "facilit": 1, "filter": 3, "frequenc": 1, "good": 1, "implement": 1, "includ": 1, "line": 1, "low": 1, "macro": 1, "manner": 1, "method": 1, "minimum": 1, "multipl": 2, "pass": 2, "program": 1, "rapid": 1, "readili": 1, "real": 1, "recurs": 1, "repertoir": 1, "respons": 1, "seri": 1, "spent": 1, "success": 1, "synthesi": 1, "time": 3, "whittlesey": 1}}, "1003": {"id": "1003", "title": "A Computer Analysis Method For Thermal Diffusion in Biochemical Systems", "abstract": "In the thermal detection of rapid biochemical reactions it is necessary to correct the temperature  data for transient heat conduction losses in a cylindrical calorimeter.  To handle the complexities arising  from varying thermal-relaxation times of concentric insulating layers, a computer program was developed  which gives the temperature distribution of the system as a function of radius and time.  This distribution  is corrected at each step by a subroutine which calculates the instantaneous chemical state of there  action, as well as the heat produced by this reaction.  The program is based on a direct statement of  Fourier's law of heat conduction and the chemical rate equation to provide a \"bookkeeping law\" to follow  the reactants and the flow of heat packets, in such a way that the computer continually stores the heat  distribution.  A computer analysis method is here regarded as one in which the physical laws of a process  are used explicitly in the program. Usually this results in by passing much of the mathematical procedures  conventionally used.  The program was tested against some known exact solutions of the heat equation  and gave identical results, and compared well with experimental data of a known biochemical reaction.   The construction of computer programs based on the direct statement of the physical laws is a principle  of general applicability which has been applied to several other physical phenomena.", "authors": "Davids, N. Berger, R. L.", "words_pool": ["action", "analysi", "applic", "appli", "aris", "base", "biochem", "bookkeep", "calcul", "calorimet", "chemic", "compar", "complex", "comput", "concentr", "conduct", "construct", "continu", "convent", "correct", "correct", "cylindr", "data", "detect", "develop", "diffus", "direct", "distribut", "equat", "exact", "experiment", "explicitli", "flow", "follow", "fourier", "function", "gave", "gener", "handl", "heat", "ident", "instantan", "insul", "known", "law", "law", "layer", "loss", "mathemat", "method", "packet", "pass", "phenomena", "physic", "principl", "procedur", "process", "produc", "program", "program", "provid", "radiu", "rapid", "rate", "reactant", "reaction", "reaction", "regard", "relax", "result", "solut", "state", "statement", "step", "store", "subroutin", "system", "system", "temperatur", "test", "thermal", "time", "time", "transient", "vari", "david", "berger"], "word_count": {"action": 1, "analysi": 1, "applic": 1, "appli": 1, "aris": 1, "base": 2, "biochem": 2, "bookkeep": 1, "calcul": 1, "calorimet": 1, "chemic": 2, "compar": 1, "complex": 1, "comput": 4, "concentr": 1, "conduct": 2, "construct": 1, "continu": 1, "convent": 1, "correct": 2, "cylindr": 1, "data": 2, "detect": 1, "develop": 1, "diffus": 1, "direct": 2, "distribut": 3, "equat": 2, "exact": 1, "experiment": 1, "explicitli": 1, "flow": 1, "follow": 1, "fourier": 1, "function": 1, "gave": 1, "gener": 1, "handl": 1, "heat": 6, "ident": 1, "instantan": 1, "insul": 1, "known": 2, "law": 4, "layer": 1, "loss": 1, "mathemat": 1, "method": 1, "packet": 1, "pass": 1, "phenomena": 1, "physic": 3, "principl": 1, "procedur": 1, "process": 1, "produc": 1, "program": 5, "provid": 1, "radiu": 1, "rapid": 1, "rate": 1, "reactant": 1, "reaction": 3, "regard": 1, "relax": 1, "result": 2, "solut": 1, "state": 1, "statement": 2, "step": 1, "store": 1, "subroutin": 1, "system": 1, "temperatur": 2, "test": 1, "thermal": 2, "time": 2, "transient": 1, "vari": 1, "david": 1, "berger": 1}}, "1004": {"id": "1004", "title": "Arctangent (Algorithm [B1])", "authors": "Mills, K. W.", "words_pool": ["algorithm", "arctang", "b1", "mill"], "word_count": {"algorithm": 1, "arctang": 1, "b1": 1, "mill": 1}}, "1005": {"id": "1005", "title": "Coordinates on an Ellipsoid (Algorithm 240 [Z])", "authors": "Dorrer, E.", "words_pool": ["algorithm", "coordin", "ellipsoid", "dorrer"], "word_count": {"algorithm": 1, "coordin": 1, "ellipsoid": 1, "dorrer": 1}}, "1006": {"id": "1006", "title": "A Storage Allocation and Reference Structure", "abstract": "A method is proposed and discussed which allows a subscripted-variable capability (in the FORTRAN  sense) to be added to AUTOCODER-Type assembly systems.", "authors": "Fitzwater, D. R.", "words_pool": ["ad", "alloc", "assembl", "autocod", "capabl", "discuss", "fortran", "method", "propos", "refer", "sens", "storag", "structur", "subscript", "system", "type", "variabl", "fitzwat"], "word_count": {"ad": 1, "alloc": 1, "assembl": 1, "autocod": 1, "capabl": 1, "discuss": 1, "fortran": 1, "method": 1, "propos": 1, "refer": 1, "sens": 1, "storag": 1, "structur": 1, "subscript": 1, "system": 1, "type": 1, "variabl": 1, "fitzwat": 1}}, "1007": {"id": "1007", "title": "Extension of Existing Compilers By Sophisticated Use of Macros", "abstract": "A description is presented of an application in which macros and string concatenation were  employed to add a new facility to BELFAP.", "authors": "Benett, R. K. Neumann, H. D.", "words_pool": ["add", "applic", "belfap", "compil", "concaten", "descript", "employ", "exist", "extens", "facil", "macro", "present", "sophist", "string", "benett", "neumann"], "word_count": {"add": 1, "applic": 1, "belfap": 1, "compil": 1, "concaten": 1, "descript": 1, "employ": 1, "exist": 1, "extens": 1, "facil": 1, "macro": 1, "present": 1, "sophist": 1, "string": 1, "benett": 1, "neumann": 1}}, "1008": {"id": "1008", "title": "Scheduling Meetings with a Computer", "abstract": "Computer scheduling of papers as it was developed for the 1960 meeting of the Federation of  American Societies for Experimental Biology (FASEB) is described.  The FASEB meeting is the largest scientific  meeting held in the United States each year.  The technique developed for FASEB can be applied to schedule  any meeting with parallel sessions.", "authors": "Schultz, C. K. Brooks, A. Schwartz, P.", "words_pool": ["american", "appli", "biolog", "comput", "develop", "experiment", "faseb", "feder", "held", "largest", "meet", "meet", "paper", "parallel", "schedul", "schedul", "scientif", "session", "societi", "state", "techniqu", "unit", "year", "schultz", "brook", "schwartz"], "word_count": {"american": 1, "appli": 1, "biolog": 1, "comput": 1, "develop": 2, "experiment": 1, "faseb": 3, "feder": 1, "held": 1, "largest": 1, "meet": 4, "paper": 1, "parallel": 1, "schedul": 2, "scientif": 1, "session": 1, "societi": 1, "state": 1, "techniqu": 1, "unit": 1, "year": 1, "schultz": 1, "brook": 1, "schwartz": 1}}, "1009": {"id": "1009", "title": "Solution of Combinatorial Problems Using Generating Functions on a Variable-Field Computer", "abstract": "The utility of generating functions in solving combinatorial problems is discussed.  Particular  implementation results are presented and evaluated.", "authors": "Weinberg, G. M.", "words_pool": ["combinatori", "comput", "discuss", "evalu", "field", "function", "gener", "implement", "present", "problem", "result", "solut", "solv", "util", "variabl", "weinberg"], "word_count": {"combinatori": 1, "comput": 1, "discuss": 1, "evalu": 1, "field": 1, "function": 1, "gener": 1, "implement": 1, "present": 1, "problem": 1, "result": 1, "solut": 1, "solv": 1, "util": 1, "variabl": 1, "weinberg": 1}}, "1010": {"id": "1010", "title": "A Multiuser Computation Facility for Education and Research", "abstract": "Present-day computing facilities are limited in their value for scientific research by inability  to interact strongly with users.  The full power of a research computing instrument should be available  at many terminals that give each user the ability to generate, correct and operate any procedure he wishes,  either simple or complex.  Implementation is described for a small-scale multiuser computer system that  permits several users to work independently with the machine, and to obtain satisfactory response using  typewriter communication.", "authors": "Dennis, J. B.", "words_pool": ["abil", "commun", "complex", "comput", "comput", "comput", "correct", "day", "educ", "facil", "facil", "full", "gener", "give", "implement", "inabl", "independ", "instrument", "interact", "limit", "machin", "multius", "obtain", "oper", "permit", "power", "present", "procedur", "research", "respons", "satisfactori", "scale", "scientif", "simpl", "small", "strongli", "system", "termin", "typewrit", "user", "user", "wish", "work", "denni"], "word_count": {"abil": 1, "commun": 1, "complex": 1, "comput": 3, "correct": 1, "day": 1, "educ": 1, "facil": 1, "full": 1, "gener": 1, "give": 1, "implement": 1, "inabl": 1, "independ": 1, "instrument": 1, "interact": 1, "limit": 1, "machin": 1, "multius": 1, "obtain": 1, "oper": 1, "permit": 1, "power": 1, "present": 1, "procedur": 1, "research": 2, "respons": 1, "satisfactori": 1, "scale": 1, "scientif": 1, "simpl": 1, "small": 1, "strongli": 1, "system": 1, "termin": 1, "typewrit": 1, "user": 3, "wish": 1, "work": 1, "denni": 1}}, "1011": {"id": "1011", "title": "Logarithm of a Complex Number (Algorithm 48 [B3])", "authors": "Collens, D. S.", "words_pool": ["algorithm", "b3", "complex", "logarithm", "number", "collen"], "word_count": {"algorithm": 1, "b3": 1, "complex": 1, "logarithm": 1, "number": 1, "collen": 1}}, "1012": {"id": "1012", "title": "Formal Parsing Systems", "abstract": "Automatic syntactic analysis has recently become important for both natural language data processing  and syntax-directed compilers.  A formal parsing system G = (V,u,T,R) consists of two finite disjoint  vocabularies, V and T, a many-many map, u, from V onto T, and a recursive set R of strings in T called  syntactic sentence classes.  Every program for automatic syntactic analysis determines a formal parsing  system.  A directed production analyzer (I,T,X,p) is a nondeterministic pushdown-store machine with internal  vocabulary I, input vocabulary T, and all productions of p in the form:  (Z,a) -> aY1 ... Ym where  Z,  Yi are elements of the set I and a is an element of the set T.  Every context-free language can be analyzed  by a directed production analyzer.  The Kuno-Oettinger multiple-path syntactic analyzer for English is  a concrete example of a directed production analyzer and of a working parsing algorithm.  The connection  between structures assigned by the analyzer and those of a conventional phrase structure grammar is examined  in this paper.", "authors": "Greibach, S. A.", "words_pool": ["algorithm", "analysi", "analyz", "analyz", "assign", "automat", "ay1", "call", "class", "compil", "concret", "connect", "consist", "context", "convent", "data", "determin", "direct", "disjoint", "element", "element", "english", "examin", "finit", "form", "formal", "free", "grammar", "import", "input", "intern", "kuno", "languag", "machin", "map", "multipl", "natur", "nondeterminist", "oetting", "paper", "pars", "path", "phrase", "process", "product", "product", "program", "pushdown", "recent", "recurs", "sentenc", "set", "store", "string", "structur", "structur", "syntact", "syntax", "system", "system", "vocabulari", "vocabulari", "work", "yi", "ym", "greibach"], "word_count": {"algorithm": 1, "analysi": 2, "analyz": 6, "assign": 1, "automat": 2, "ay1": 1, "call": 1, "class": 1, "compil": 1, "concret": 1, "connect": 1, "consist": 1, "context": 1, "convent": 1, "data": 1, "determin": 1, "direct": 4, "disjoint": 1, "element": 2, "english": 1, "examin": 1, "finit": 1, "form": 1, "formal": 2, "free": 1, "grammar": 1, "import": 1, "input": 1, "intern": 1, "kuno": 1, "languag": 2, "machin": 1, "map": 1, "multipl": 1, "natur": 1, "nondeterminist": 1, "oetting": 1, "paper": 1, "pars": 3, "path": 1, "phrase": 1, "process": 1, "product": 4, "program": 1, "pushdown": 1, "recent": 1, "recurs": 1, "sentenc": 1, "set": 3, "store": 1, "string": 1, "structur": 2, "syntact": 4, "syntax": 1, "system": 2, "vocabulari": 3, "work": 1, "yi": 1, "ym": 1, "greibach": 1}}, "1013": {"id": "1013", "title": "Final Examination Scheduling", "abstract": "A method for scheduling final examinations to yield a minimal number of student conflicts is  described.  The \"minimization\" is achieved by repetitively evaluating a nonlinear set of equations.   Imbeded in the process is a random or Monte Carlo selection of assignments.  As in such heuristic techniques,  the solution may not be optimum and many solutions may be found which yield locally minimal results.   Computer programs are described and empirical results given.", "authors": "Broder, S.", "words_pool": ["achiev", "assign", "carlo", "comput", "conflict", "empir", "equat", "evalu", "examin", "examin", "final", "found", "heurist", "imbed", "local", "method", "minim", "minim", "mont", "nonlinear", "number", "optimum", "process", "program", "random", "repetit", "result", "schedul", "select", "set", "solut", "solut", "student", "techniqu", "yield", "broder"], "word_count": {"achiev": 1, "assign": 1, "carlo": 1, "comput": 1, "conflict": 1, "empir": 1, "equat": 1, "evalu": 1, "examin": 1, "final": 1, "found": 1, "heurist": 1, "imbed": 1, "local": 1, "method": 1, "minim": 3, "mont": 1, "nonlinear": 1, "number": 1, "optimum": 1, "process": 1, "program": 1, "random": 1, "repetit": 1, "result": 2, "schedul": 1, "select": 1, "set": 1, "solut": 2, "student": 1, "techniqu": 1, "yield": 2, "broder": 1}}, "1014": {"id": "1014", "title": "Machine Controls for Analysis of Variance", "abstract": "A major problem in using the analysis of variance, as the number of factors increases, is the  exponential rise in the number of interactions.  Even though the experimenter may not be interested in  these interactions it is impossible to ignore them in most experimental designs because of the problem  of getting error terms.  It is natural therefore to look to the computer to handle the bulk of work involved  in computing the interactions.  A program device to get the computer to do this is described.", "authors": "Weldon, R. J.", "words_pool": ["analysi", "bulk", "comput", "comput", "control", "design", "devic", "error", "experiment", "experiment", "exponenti", "factor", "get", "handl", "ignor", "imposs", "increas", "interact", "interest", "involv", "look", "machin", "major", "natur", "number", "problem", "program", "rise", "term", "varianc", "work", "weldon"], "word_count": {"analysi": 1, "bulk": 1, "comput": 3, "control": 1, "design": 1, "devic": 1, "error": 1, "experiment": 2, "exponenti": 1, "factor": 1, "get": 1, "handl": 1, "ignor": 1, "imposs": 1, "increas": 1, "interact": 3, "interest": 1, "involv": 1, "look": 1, "machin": 1, "major": 1, "natur": 1, "number": 2, "problem": 2, "program": 1, "rise": 1, "term": 1, "varianc": 1, "work": 1, "weldon": 1}}, "1015": {"id": "1015", "title": "Near-Minimax Polynomial Approximations and Partitioning of Intervals", "abstract": "A method of near-minimax polynomial approximation is described.  As a by-product, this method  provides a formula for an estimate of the maximum error associated with a given degree of approximation.   Using this formula, a partitioning algorithm is obtained for dividing a basic interval into subintervals  for which approximations of equal degree give equal maximum error.", "authors": "Fraser, W. Hart, J. F.", "words_pool": ["algorithm", "approxim", "approxim", "basic", "degre", "divid", "equal", "error", "estim", "formula", "give", "interv", "interv", "maximum", "method", "minimax", "obtain", "partit", "polynomi", "product", "subinterv", "fraser", "hart"], "word_count": {"algorithm": 1, "approxim": 3, "basic": 1, "degre": 2, "divid": 1, "equal": 2, "error": 2, "estim": 1, "formula": 2, "give": 1, "interv": 1, "maximum": 2, "method": 2, "minimax": 1, "obtain": 1, "partit": 1, "polynomi": 1, "product": 1, "subinterv": 1, "fraser": 1, "hart": 1}}, "1016": {"id": "1016", "title": "Interchangcable Perforated Tape Variable Block Formats for Positioning and Straight Cut (RS-273)  and Contouring and Contouring/Positioning (RS-274) Numerically Controlled Machine Tools (Proposed American  Standards)", "words_pool": ["american", "block", "contour", "control", "cut", "format", "interchangc", "machin", "numer", "perfor", "posit", "propos", "rs", "standard", "straight", "tape", "tool", "variabl"], "word_count": {"american": 1, "block": 1, "contour": 2, "control": 1, "cut": 1, "format": 1, "interchangc": 1, "machin": 1, "numer": 1, "perfor": 1, "posit": 2, "propos": 1, "rs": 2, "standard": 1, "straight": 1, "tape": 1, "tool": 1, "variabl": 1}}, "1017": {"id": "1017", "title": "Comments on Bit-Sequencing of the ASCII in Serial-by-Bit Data Transmission", "authors": "Bemer, R. W. Booth, J.", "words_pool": ["ascii", "bit", "comment", "data", "sequenc", "serial", "transmiss", "bemer", "booth"], "word_count": {"ascii": 1, "bit": 2, "comment": 1, "data": 1, "sequenc": 1, "serial": 1, "transmiss": 1, "bemer": 1, "booth": 1}}, "1018": {"id": "1018", "title": "Gauss (Algorithm 209 [S15])", "authors": "Pike, M. C.", "words_pool": ["algorithm", "gauss", "s15", "pike"], "word_count": {"algorithm": 1, "gauss": 1, "s15": 1, "pike": 1}}, "1019": {"id": "1019", "title": "XY move Plotting (Algorithm 162 [J6])", "authors": "Cavin, D. K.", "words_pool": ["algorithm", "j6", "move", "plot", "xy", "cavin"], "word_count": {"algorithm": 1, "j6": 1, "move": 1, "plot": 1, "xy": 1, "cavin": 1}}, "1020": {"id": "1020", "title": "Free Field Read (Algorithm 239 [I5])", "authors": "McKeeman, W. M.", "words_pool": ["algorithm", "field", "free", "i5", "read", "mckeeman"], "word_count": {"algorithm": 1, "field": 1, "free": 1, "i5": 1, "read": 1, "mckeeman": 1}}, "1021": {"id": "1021", "title": "Conjugate Gradient Method (Algorithm 238 [F4])", "authors": "Reeves, C. M.", "words_pool": ["algorithm", "conjug", "f4", "gradient", "method", "reev"], "word_count": {"algorithm": 1, "conjug": 1, "f4": 1, "gradient": 1, "method": 1, "reev": 1}}, "1022": {"id": "1022", "title": "Greatest Common Divisor (Algorithm 237 [A1])", "authors": "Peck, J. E. L.", "words_pool": ["a1", "algorithm", "common", "divisor", "greatest", "peck"], "word_count": {"a1": 1, "algorithm": 1, "common": 1, "divisor": 1, "greatest": 1, "peck": 1}}, "1023": {"id": "1023", "title": "Bessel Functions of the First Kind (Algorithm 236 [S17])", "authors": "Gautschi, W.", "words_pool": ["algorithm", "bessel", "function", "kind", "s17", "gautschi"], "word_count": {"algorithm": 1, "bessel": 1, "function": 1, "kind": 1, "s17": 1, "gautschi": 1}}, "1024": {"id": "1024", "title": "A Note on the Formation of Free List", "authors": "Waite, W. M.", "words_pool": ["format", "free", "list", "note", "wait"], "word_count": {"format": 1, "free": 1, "list": 1, "note": 1, "wait": 1}}, "1025": {"id": "1025", "title": "A Method of Syntax-Checking ALGOL 60", "abstract": "A syntax checker was designed based on the syntax of ALGOL as described in the ALGOL 60 Report  [Communications of the ACM, May, 1960].  Since the definition of the elements of the language is recursive  it seemed most desirable to design the syntax checker as a set of mutually recursive processors tied  together by subroutines which perform certain bookkeeping functions.  Because of the recursive nature  of the language and of the syntax checker the problem of recovery after an error required much attention.   A method was devised which permits most programs to be checked completely despite errors.", "authors": "Lietzke, M. P.", "words_pool": ["acm", "algol", "attent", "base", "bookkeep", "check", "checker", "check", "commun", "complet", "definit", "design", "design", "desir", "despit", "devis", "element", "error", "error", "function", "languag", "method", "mutual", "natur", "perform", "permit", "problem", "processor", "program", "recoveri", "recurs", "report", "requir", "set", "subroutin", "syntax", "tie", "lietzk"], "word_count": {"acm": 1, "algol": 2, "attent": 1, "base": 1, "bookkeep": 1, "check": 1, "checker": 3, "commun": 1, "complet": 1, "definit": 1, "design": 2, "desir": 1, "despit": 1, "devis": 1, "element": 1, "error": 2, "function": 1, "languag": 2, "method": 1, "mutual": 1, "natur": 1, "perform": 1, "permit": 1, "problem": 1, "processor": 1, "program": 1, "recoveri": 1, "recurs": 3, "report": 1, "requir": 1, "set": 1, "subroutin": 1, "syntax": 4, "tie": 1, "lietzk": 1}}, "1026": {"id": "1026", "title": "Divide-and-Correct Methods for Multiple Precision Division", "abstract": "A division problem is defined and notation to relate it to the problem of multiple precision  operation in a digital computer is introduced.  A basic divide-and-correct method for multiple precision  division is formulated and its known properties briefly reviewed.  Of particular interest is the fact  that the method produces at each step a set of precisely three estimates for the desired result, one  of which is exact.", "authors": "Stein, M. L.", "words_pool": ["basic", "briefli", "comput", "correct", "defin", "desir", "digit", "divid", "divis", "estim", "exact", "fact", "formul", "interest", "introduc", "known", "method", "method", "multipl", "notat", "oper", "precis", "precis", "problem", "produc", "properti", "relat", "result", "review", "set", "step", "stein"], "word_count": {"basic": 1, "briefli": 1, "comput": 1, "correct": 1, "defin": 1, "desir": 1, "digit": 1, "divid": 1, "divis": 2, "estim": 1, "exact": 1, "fact": 1, "formul": 1, "interest": 1, "introduc": 1, "known": 1, "method": 2, "multipl": 2, "notat": 1, "oper": 1, "precis": 3, "problem": 2, "produc": 1, "properti": 1, "relat": 1, "result": 1, "review": 1, "set": 1, "step": 1, "stein": 1}}, "1027": {"id": "1027", "title": "An Alternate Checksum Method", "authors": "Newhall, N. S.", "words_pool": ["altern", "checksum", "method", "newhal"], "word_count": {"altern": 1, "checksum": 1, "method": 1, "newhal": 1}}, "1028": {"id": "1028", "title": "Investigation of a New Analytical Method for Numerical Derivative Evaluation", "abstract": "A recently proposed analytical approach to numerical derivative evaluation is discussed.  The  technique is shown to be both accurate and easy to apply, though certain indicated modifications are  required.  Its use should greatly facilitate the writing and debugging of programs requiring derivatives  of highly complex functions.", "authors": "Wilkins, R. D.", "words_pool": ["accur", "analyt", "appli", "approach", "complex", "debug", "deriv", "deriv", "discuss", "easi", "evalu", "facilit", "function", "greatli", "highli", "investig", "method", "modif", "numer", "program", "propos", "recent", "requir", "requir", "shown", "techniqu", "write", "wilkin"], "word_count": {"accur": 1, "analyt": 1, "appli": 1, "approach": 1, "complex": 1, "debug": 1, "deriv": 2, "discuss": 1, "easi": 1, "evalu": 1, "facilit": 1, "function": 1, "greatli": 1, "highli": 1, "investig": 1, "method": 1, "modif": 1, "numer": 1, "program": 1, "propos": 1, "recent": 1, "requir": 2, "shown": 1, "techniqu": 1, "write": 1, "wilkin": 1}}, "1029": {"id": "1029", "title": "A Simple Automatic Derivative Evaluation Program", "abstract": "A procedure for automatic evaluation of total/partial derivatives of arbitrary algebraic functions  is presented.  The technique permits computation of numerical values of derivatives without developing  analytical expressions for the derivatives.  The key to the method is the decomposition of the given  function, by introduction of intermediate variables, into a series of elementary functional steps.  A  library of elementary function subroutines is provided for the automatic evaluation and differentiation  of these new variables.  The final step in this process produces the desired function's derivative.   The main feature of this approach is its simplicity.  It can be used as a quick-reaction tool where the  derivation of analytical derivatives is laborious and also as a debugging tool for programs which contain  derivatives.", "authors": "Wengert, R. E.", "words_pool": ["algebra", "analyt", "approach", "arbitrari", "automat", "comput", "debug", "decomposit", "deriv", "deriv", "deriv", "desir", "develop", "differenti", "elementari", "evalu", "express", "featur", "final", "function", "function", "function", "intermedi", "introduct", "key", "labori", "librari", "main", "method", "numer", "partial", "permit", "present", "procedur", "process", "produc", "program", "program", "provid", "quick", "reaction", "seri", "simpl", "simplic", "step", "step", "subroutin", "techniqu", "tool", "total", "valu", "variabl", "wengert"], "word_count": {"algebra": 1, "analyt": 2, "approach": 1, "arbitrari": 1, "automat": 2, "comput": 1, "debug": 1, "decomposit": 1, "deriv": 7, "desir": 1, "develop": 1, "differenti": 1, "elementari": 2, "evalu": 2, "express": 1, "featur": 1, "final": 1, "function": 5, "intermedi": 1, "introduct": 1, "key": 1, "labori": 1, "librari": 1, "main": 1, "method": 1, "numer": 1, "partial": 1, "permit": 1, "present": 1, "procedur": 1, "process": 1, "produc": 1, "program": 1, "provid": 1, "quick": 1, "reaction": 1, "seri": 1, "simpl": 1, "simplic": 1, "step": 2, "subroutin": 1, "techniqu": 1, "tool": 2, "total": 1, "valu": 1, "variabl": 2, "wengert": 1}}, "1030": {"id": "1030", "title": "Techniques for the Simulation of Computer Logic", "abstract": "The simulation of a digital computer is an integral part of most computer design automation  systems.  The evaluation of the Boolean functions which characterize the computer being simulated constitutes  one major portion of a simulation system.  Four general procedural classes for evaluating these functions  are defined.  Toward greatly increased efficiency of a simulation system, methods are presented for simultaneously  evaluating many functions for one set of values of the variables,and for evaluating simultaneously one  function for many sets of values for the variables.", "authors": "Breuer,M. A.", "words_pool": ["autom", "boolean", "character", "class", "comput", "constitut", "defin", "design", "digit", "effici", "evalu", "evalu", "function", "function", "gener", "greatli", "increas", "integr", "logic", "major", "method", "part", "portion", "present", "procedur", "set", "set", "simul", "simul", "simultan", "system", "system", "techniqu", "valu", "variabl", "breuer"], "word_count": {"autom": 1, "boolean": 1, "character": 1, "class": 1, "comput": 3, "constitut": 1, "defin": 1, "design": 1, "digit": 1, "effici": 1, "evalu": 4, "function": 4, "gener": 1, "greatli": 1, "increas": 1, "integr": 1, "logic": 1, "major": 1, "method": 1, "part": 1, "portion": 1, "present": 1, "procedur": 1, "set": 2, "simul": 4, "simultan": 2, "system": 3, "techniqu": 1, "valu": 2, "variabl": 2, "breuer": 1}}, "1031": {"id": "1031", "title": "A Note on Starting the Newton-Raphson Method", "abstract": "Determination of a suitable initial estimate for a root of an equation f(x) = 0 by means of  computing the roots of a sequence of related equations is described.", "authors": "Beyer, W. A.", "words_pool": ["comput", "determin", "equat", "equat", "estim", "initi", "mean", "method", "newton", "note", "raphson", "relat", "root", "root", "sequenc", "start", "suitabl", "beyer"], "word_count": {"comput": 1, "determin": 1, "equat": 2, "estim": 1, "initi": 1, "mean": 1, "method": 1, "newton": 1, "note": 1, "raphson": 1, "relat": 1, "root": 2, "sequenc": 1, "start": 1, "suitabl": 1, "beyer": 1}}, "1032": {"id": "1032", "title": "Theoretical Considerations in Information Retrieval Systems", "abstract": "Information storage and retrieval systems are composed of three major components: (a) identification  of information and tagging it for effective retrieval, (b) searching strategy, how to enter the file  to circumvent the scanning of nonrelevant material, and (c) file organization to make access to information  efficient.  For identification of information the paper suggests that a metalanguage (recently discussed  in a paper by Goffman, Verhoeff and Belzer) associated with an object language be used.  For searching  strategy, a linear model for an evaluation function of relevancy is developed which rewards the system  for retrieving relevant documents and not retrieving the nonrelevant, and penalizes the system for the  escaped relevant documents and false drops.  The inadequacies of a linear model are indicated.  Two approaches  to file organization are discussed.  One is self-organization of the file based on its history and past  performance, and the second is a self-generating subset of the file with a high probability of being  relevant.", "authors": "Belzer, J. Goffman, W.", "words_pool": ["access", "approach", "base", "belzer", "circumv", "compon", "compos", "consider", "develop", "discuss", "document", "drop", "effect", "effici", "enter", "escap", "evalu", "fals", "function", "gener", "goffman", "high", "histori", "identif", "inadequaci", "inform", "languag", "linear", "major", "make", "materi", "metalanguag", "model", "nonrelev", "object", "organ", "paper", "past", "penal", "perform", "probabl", "recent", "relev", "relev", "retriev", "retriev", "reward", "scan", "search", "storag", "strategi", "subset", "suggest", "system", "system", "tag", "theoret", "verhoeff", "belzer", "goffman"], "word_count": {"access": 1, "approach": 1, "base": 1, "belzer": 1, "circumv": 1, "compon": 1, "compos": 1, "consider": 1, "develop": 1, "discuss": 2, "document": 2, "drop": 1, "effect": 1, "effici": 1, "enter": 1, "escap": 1, "evalu": 1, "fals": 1, "function": 1, "gener": 1, "goffman": 1, "high": 1, "histori": 1, "identif": 2, "inadequaci": 1, "inform": 4, "languag": 1, "linear": 2, "major": 1, "make": 1, "materi": 1, "metalanguag": 1, "model": 2, "nonrelev": 2, "object": 1, "organ": 3, "paper": 2, "past": 1, "penal": 1, "perform": 1, "probabl": 1, "recent": 1, "relev": 4, "retriev": 4, "reward": 1, "scan": 1, "search": 2, "storag": 1, "strategi": 2, "subset": 1, "suggest": 1, "system": 3, "tag": 1, "theoret": 1, "verhoeff": 1}}, "1033": {"id": "1033", "title": "Experimental Personalized Array Translator System", "abstract": "A system designed for intimate man-machine interaction in a general-purpose problem-solving  environment is experimentally operational.  The system utilizers an array-oriented symbolic source language  containing powerful statement types.  These include numeric, Boolean, relational and selection operators  on operands which can be entire arrays.  The system also permits simple specification of test and argument  arrays in single statements.  The completely symbolic operating system includes display and entry of  program and data.  Sequence control is aided by an interrupt switch which allows the user to interact  with the program during execution. In addition to normal stored program sequencing, the system provides  trace options and the ability to enter any statement for immediate execution.  Present implementation  of the system is with an interpretive translator on an IBM 1620 computer.", "authors": "Hellerman, H.", "words_pool": ["abil", "addit", "aid", "argument", "array", "array", "boolean", "complet", "comput", "control", "data", "design", "display", "enter", "entir", "entri", "environ", "execut", "experiment", "experiment", "gener", "ibm", "implement", "includ", "includ", "interact", "interact", "interpret", "interrupt", "intim", "languag", "machin", "man", "normal", "numer", "operand", "oper", "oper", "oper", "option", "orient", "permit", "person", "power", "present", "problem", "program", "purpos", "relat", "select", "sequenc", "sequenc", "simpl", "singl", "solv", "sourc", "specif", "statement", "statement", "store", "switch", "symbol", "system", "test", "trace", "translat", "type", "user", "util", "hellerman"], "word_count": {"abil": 1, "addit": 1, "aid": 1, "argument": 1, "array": 3, "boolean": 1, "complet": 1, "comput": 1, "control": 1, "data": 1, "design": 1, "display": 1, "enter": 1, "entir": 1, "entri": 1, "environ": 1, "execut": 2, "experiment": 1, "gener": 1, "ibm": 1, "implement": 1, "includ": 2, "interact": 2, "interpret": 1, "interrupt": 1, "intim": 1, "languag": 1, "machin": 1, "man": 1, "normal": 1, "numer": 1, "operand": 1, "oper": 3, "option": 1, "orient": 1, "permit": 1, "person": 1, "power": 1, "present": 1, "problem": 1, "program": 3, "purpos": 1, "relat": 1, "select": 1, "sequenc": 2, "simpl": 1, "singl": 1, "solv": 1, "sourc": 1, "specif": 1, "statement": 3, "store": 1, "switch": 1, "symbol": 2, "system": 6, "test": 1, "trace": 1, "translat": 1, "type": 1, "user": 1, "util": 1, "hellerman": 1}}, "1034": {"id": "1034", "title": "Autosate", "abstract": "An automated data system analysis technique is described. The technique is designed to alleviate  some of the principal problems that beset current analysis-large data workloads, long span of time between  project inception and system operational date, the lack of explicit directions for conducting data system  analysis and using the results, and the lack of a technique to control data system changes throughout  its lifetime. The analysis is geared to determining workload, relationships and storage characteristics  of documents in the information network automatically.", "authors": "Gatto, O. T.", "words_pool": ["allevi", "analysi", "autom", "autos", "beset", "characterist", "conduct", "control", "data", "date", "design", "determin", "direct", "document", "explicit", "gear", "incept", "inform", "lack", "larg", "lifetim", "long", "network", "oper", "princip", "problem", "project", "relationship", "result", "span", "storag", "system", "techniqu", "time", "workload", "workload", "gatto"], "word_count": {"allevi": 1, "analysi": 4, "autom": 1, "autos": 1, "beset": 1, "characterist": 1, "conduct": 1, "control": 1, "data": 4, "date": 1, "design": 1, "determin": 1, "direct": 1, "document": 1, "explicit": 1, "gear": 1, "incept": 1, "inform": 1, "lack": 2, "larg": 1, "lifetim": 1, "long": 1, "network": 1, "oper": 1, "princip": 1, "problem": 1, "project": 1, "relationship": 1, "result": 1, "span": 1, "storag": 1, "system": 4, "techniqu": 3, "time": 1, "workload": 2, "gatto": 1}}, "1035": {"id": "1035", "title": "Characteristics of the FORTRAN CEP Language", "abstract": "The FORTRAN CEP languages differs from FORTRAN II mainly because: (1) it extends the variety  of the modes for real quantities; (2) it allows suitable mixtures, in an input/output list or in an expression,  of quantities that occur under different modes; (3) it makes it possible to address a greater number  of input/output equipment; and (4) it removes the restrictions on the complexity of the list of quantities  to be transmitted between the magnetic core memory and the drum or the magnetic tape units.", "authors": "Mancino. O. G.", "words_pool": ["address", "cep", "characterist", "complex", "core", "differ", "drum", "equip", "express", "extend", "fortran", "greater", "ii", "input", "languag", "languag", "list", "magnet", "mainli", "make", "memori", "mixtur", "mode", "number", "occur", "output", "quantiti", "real", "remov", "restrict", "suitabl", "tape", "transmit", "unit", "varieti", "mancino"], "word_count": {"address": 1, "cep": 1, "characterist": 1, "complex": 1, "core": 1, "differ": 1, "drum": 1, "equip": 1, "express": 1, "extend": 1, "fortran": 2, "greater": 1, "ii": 1, "input": 2, "languag": 1, "list": 2, "magnet": 2, "mainli": 1, "make": 1, "memori": 1, "mixtur": 1, "mode": 2, "number": 1, "occur": 1, "output": 2, "quantiti": 3, "real": 1, "remov": 1, "restrict": 1, "suitabl": 1, "tape": 1, "transmit": 1, "unit": 1, "varieti": 1, "mancino": 1}}, "1036": {"id": "1036", "title": "Remark on Further Generalization of ALGOL", "authors": "Garwick, J. V.", "words_pool": ["algol", "gener", "remark", "garwick"], "word_count": {"algol": 1, "gener": 1, "remark": 1, "garwick": 1}}, "1037": {"id": "1037", "title": "Reduction of a Matrix Containing Polynomial Elements (Algorithm 170 [F3])", "authors": "Priebe, K. B.", "words_pool": ["algorithm", "element", "f3", "matrix", "polynomi", "reduct", "prieb"], "word_count": {"algorithm": 1, "element": 1, "f3": 1, "matrix": 1, "polynomi": 1, "reduct": 1, "prieb": 1}}, "1038": {"id": "1038", "title": "Crout with Equilibration and Iteration (Algorithm 135 [F4])", "authors": "McKeeman, W. M.", "words_pool": ["algorithm", "crout", "equilibr", "f4", "iter", "mckeeman"], "word_count": {"algorithm": 1, "crout": 1, "equilibr": 1, "f4": 1, "iter": 1, "mckeeman": 1}}, "1039": {"id": "1039", "title": "Summation of Fourier Series (Algorithm 128 [C6])", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "c6", "fourier", "seri", "summat", "thacher", "jr"], "word_count": {"algorithm": 1, "c6": 1, "fourier": 1, "seri": 1, "summat": 1, "thacher": 1, "jr": 1}}, "1040": {"id": "1040", "title": "Romberg Integration(Algorithm 60 [D1])", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "d1", "integr", "romberg", "thacher", "jr"], "word_count": {"algorithm": 1, "d1": 1, "integr": 1, "romberg": 1, "thacher": 1, "jr": 1}}, "1041": {"id": "1041", "title": "Random Permutation (Algorithm 235 [G6])", "authors": "Durstenfeld, R.", "words_pool": ["algorithm", "g6", "permut", "random", "durstenfeld"], "word_count": {"algorithm": 1, "g6": 1, "permut": 1, "random": 1, "durstenfeld": 1}}, "1042": {"id": "1042", "title": "Poisson-Charlier Polynomials (Algorithm 234 [S23])", "authors": "Simoes Pereira, J. M. S.", "words_pool": ["algorithm", "charlier", "poisson", "polynomi", "s23", "simo", "pereira"], "word_count": {"algorithm": 1, "charlier": 1, "poisson": 1, "polynomi": 1, "s23": 1, "simo": 1, "pereira": 1}}, "1043": {"id": "1043", "title": "Talk-A High-Level Source Language Debugging Technique With Real-Time Data Extraction", "abstract": "TALK, meaning Take A Look, is a debugging technique which aids substantially in debugging complex  real-time programming systems by interrupting the users program at desired points to extract previously  specified data.  The extracted data is later edited, listing the associated data with its high-level  source language identification.", "authors": "verSteeg, R. L.", "words_pool": ["aid", "complex", "data", "debug", "desir", "edit", "extract", "extract", "extract", "high", "identif", "interrupt", "languag", "later", "level", "list", "look", "mean", "point", "previous", "program", "program", "real", "sourc", "substanti", "system", "take", "talk", "techniqu", "time", "user", "versteeg"], "word_count": {"aid": 1, "complex": 1, "data": 3, "debug": 2, "desir": 1, "edit": 1, "extract": 2, "high": 1, "identif": 1, "interrupt": 1, "languag": 1, "later": 1, "level": 1, "list": 1, "look": 1, "mean": 1, "point": 1, "previous": 1, "program": 2, "real": 1, "sourc": 1, "substanti": 1, "system": 1, "take": 1, "talk": 1, "techniqu": 1, "time": 1, "user": 1, "versteeg": 1}}, "1044": {"id": "1044", "title": "An Automatic Loader for Subroutine Nests", "abstract": "A method for automatic loading of library subroutines, which can be adapted to operate in conjunction  with any conventional two-pass assembler is described.  The method is specifically designed to cope with  a nested library structure.", "authors": "Kanner, H.", "words_pool": ["adapt", "assembl", "automat", "conjunct", "convent", "cope", "design", "librari", "loader", "load", "method", "nest", "nest", "oper", "pass", "specif", "structur", "subroutin", "subroutin", "kanner"], "word_count": {"adapt": 1, "assembl": 1, "automat": 1, "conjunct": 1, "convent": 1, "cope": 1, "design": 1, "librari": 2, "loader": 1, "load": 1, "method": 2, "nest": 1, "oper": 1, "pass": 1, "specif": 1, "structur": 1, "subroutin": 1, "kanner": 1}}, "1045": {"id": "1045", "title": "Programming Analysis of Variance by Sequences of Operators and Isomorphic Mappings", "abstract": "A special operator calculus developed by Hartley in 1956 together with a new mapping scheme  has been found to be efficient in programming analysis of variance for multifactor experiments. The operator  calculus and the mapping scheme are described in detail.", "authors": "Peng, K. C.", "words_pool": ["analysi", "calculu", "detail", "develop", "effici", "experi", "found", "hartley", "isomorph", "map", "map", "multifactor", "oper", "oper", "program", "scheme", "sequenc", "special", "varianc", "peng"], "word_count": {"analysi": 1, "calculu": 2, "detail": 1, "develop": 1, "effici": 1, "experi": 1, "found": 1, "hartley": 1, "isomorph": 1, "map": 2, "multifactor": 1, "oper": 2, "program": 1, "scheme": 2, "sequenc": 1, "special": 1, "varianc": 1, "peng": 1}}, "1046": {"id": "1046", "title": "A Compiler-Building System Developed by Brooker and Morris", "abstract": "In a number of articles published during the past two years, R. A. Brooker and D. Morris (joined  by J.S. Rohl in their most recent paper have presented a very interesting programming system that they  have developed for the Ferranti Atlas computer.  The present paper describes some of the major features  of their system. it expands on some points that the original authors cover briefly, and treats only very  lightly some topics to which they devote considerable space.  The purpose of this paper is purely expository.   Except in some very small details, and in some comments, it does not intentionally depart from or add  to the material published in the listed references.", "authors": "Rosen, S.", "words_pool": ["add", "articl", "atla", "author", "briefli", "brooker", "build", "comment", "compil", "comput", "consider", "cover", "depart", "describ", "detail", "develop", "devot", "expand", "expositori", "featur", "ferranti", "intent", "interest", "join", "lightli", "list", "major", "materi", "morri", "number", "origin", "paper", "past", "point", "present", "present", "program", "publish", "pure", "purpos", "recent", "refer", "rohl", "small", "space", "system", "topic", "treat", "year", "rosen"], "word_count": {"add": 1, "articl": 1, "atla": 1, "author": 1, "briefli": 1, "brooker": 1, "build": 1, "comment": 1, "compil": 1, "comput": 1, "consider": 1, "cover": 1, "depart": 1, "describ": 1, "detail": 1, "develop": 1, "devot": 1, "expand": 1, "expositori": 1, "featur": 1, "ferranti": 1, "intent": 1, "interest": 1, "join": 1, "lightli": 1, "list": 1, "major": 1, "materi": 1, "morri": 1, "number": 1, "origin": 1, "paper": 3, "past": 1, "point": 1, "present": 2, "program": 1, "publish": 2, "pure": 1, "purpos": 1, "recent": 1, "refer": 1, "rohl": 1, "small": 1, "space": 1, "system": 2, "topic": 1, "treat": 1, "year": 1, "rosen": 1}}, "1047": {"id": "1047", "title": "Generation of Test Matrices by Similarity Transformations", "abstract": "A method for obtaining test matrices with a prescribed distribution of characteristic roots  is given.  The process consists of using particularly simple similarity transformations to generate full  matrices from canonical forms.  The matrices generated also have known characteristic vectors, inverses  and determinants.", "authors": "Ortega, J. M.", "words_pool": ["canon", "characterist", "consist", "determin", "distribut", "form", "full", "gener", "gener", "gener", "invers", "known", "matric", "method", "obtain", "prescrib", "process", "root", "similar", "simpl", "test", "transform", "vector", "ortega"], "word_count": {"canon": 1, "characterist": 2, "consist": 1, "determin": 1, "distribut": 1, "form": 1, "full": 1, "gener": 2, "invers": 1, "known": 1, "matric": 3, "method": 1, "obtain": 1, "prescrib": 1, "process": 1, "root": 1, "similar": 1, "simpl": 1, "test": 1, "transform": 1, "vector": 1, "ortega": 1}}, "1048": {"id": "1048", "title": "Approximate Solution of Axially Symmetric Problems", "abstract": "A variety of physical problems in such diverse fields as electrostatic  field theory, heat  and ideal fluid flow, and stress concentration theory reduce, under the assumption of axial symmetry,  to the study of an elliptic partial differential equation.  Dirichlet-type problems associated with this  equation are studied on regions whose boundaries include a nondegenerate portion of the x-axis and exceedingly  accurate numerical methods are given for approximating solutions.", "authors": "Greenspan, D.", "words_pool": ["accur", "approxim", "approxim", "assumpt", "axial", "axial", "axi", "boundari", "concentr", "differenti", "dirichlet", "divers", "electrostat", "ellipt", "equat", "exceedingli", "field", "field", "flow", "fluid", "heat", "ideal", "includ", "method", "nondegener", "numer", "partial", "physic", "portion", "problem", "reduc", "region", "solut", "solut", "stress", "studi", "studi", "symmetr", "symmetri", "theori", "type", "varieti", "greenspan"], "word_count": {"accur": 1, "approxim": 1, "assumpt": 1, "axial": 1, "axi": 1, "boundari": 1, "concentr": 1, "differenti": 1, "dirichlet": 1, "divers": 1, "electrostat": 1, "ellipt": 1, "equat": 2, "exceedingli": 1, "field": 2, "flow": 1, "fluid": 1, "heat": 1, "ideal": 1, "includ": 1, "method": 1, "nondegener": 1, "numer": 1, "partial": 1, "physic": 1, "portion": 1, "problem": 2, "reduc": 1, "region": 1, "solut": 1, "stress": 1, "studi": 2, "symmetr": 1, "symmetri": 1, "theori": 2, "type": 1, "varieti": 1, "greenspan": 1}}, "1049": {"id": "1049", "title": "Numerical Solution of Nonlinear Two-Point Boundary Problems by Finite Difference Methods", "abstract": "Solution of nonlinear two-point boundary-value problems is often an extremely difficult task.   Quite apart from questions of reality and uniqueness, there is no established numerical technique for  this problem.  At present, shooting techniques are the easiest method of attacking these problems.  When  these fail, the more difficult method of finite differences can often be used to obtain a solution.   This paper gives examples and discusses the finite difference method for non-linear two-point boundary-value  problems.", "authors": "Holt, J. F.", "words_pool": ["attack", "boundari", "differ", "differ", "difficult", "discuss", "easiest", "establish", "exampl", "extrem", "fail", "finit", "linear", "method", "method", "non", "nonlinear", "numer", "obtain", "paper", "point", "present", "problem", "problem", "question", "realiti", "shoot", "solut", "task", "techniqu", "techniqu", "uniqu", "holt"], "word_count": {"attack": 1, "boundari": 2, "differ": 2, "difficult": 2, "discuss": 1, "easiest": 1, "establish": 1, "exampl": 1, "extrem": 1, "fail": 1, "finit": 2, "linear": 1, "method": 3, "non": 1, "nonlinear": 1, "numer": 1, "obtain": 1, "paper": 1, "point": 2, "present": 1, "problem": 4, "question": 1, "realiti": 1, "shoot": 1, "solut": 2, "task": 1, "techniqu": 2, "uniqu": 1, "holt": 1}}, "1050": {"id": "1050", "title": "A Parts Breakdown Technique Using List Structures", "abstract": "List structured parts breakdown is proposed and discussed.  Implementation facts are presented  on operating program using these techniques.", "authors": "Brian, W. J.", "words_pool": ["breakdown", "discuss", "fact", "implement", "list", "oper", "part", "present", "program", "propos", "structur", "structur", "techniqu", "techniqu", "brian"], "word_count": {"breakdown": 1, "discuss": 1, "fact": 1, "implement": 1, "list": 1, "oper": 1, "part": 1, "present": 1, "program": 1, "propos": 1, "structur": 1, "techniqu": 1, "brian": 1}}, "1051": {"id": "1051", "title": "Multiword List Items", "abstract": "The list concept as originally proposed by Newell, Simon and Shaw specified single computer  words as elements of a list.  This report describes the use of two or more consecutive words as one element.   Such use results in a considerable saving in both the space required to hold a given amount of data,  and in the execution time required to perform a given process on the data.  Following a brief description  of standard list structures with single-word items, the multiword items are introduced.  Then variable-length  items are described, along with the corresponding space-utilization problems.  Finally, several examples  are given to illustrate the use of multiword lists. This paper attempts to draw together various recent  papers which have applied some of these concepts in different ways, and indicate how they relate to the  more general problems.", "authors": "Comfort, W. T.", "words_pool": ["amount", "appli", "attempt", "comput", "concept", "concept", "consecut", "consider", "data", "describ", "descript", "draw", "element", "element", "exampl", "execut", "final", "gener", "hold", "illustr", "introduc", "item", "length", "list", "list", "multiword", "newel", "origin", "paper", "paper", "perform", "problem", "process", "propos", "recent", "relat", "report", "requir", "result", "save", "shaw", "simon", "singl", "space", "standard", "structur", "time", "util", "variabl", "way", "word", "word", "comfort"], "word_count": {"amount": 1, "appli": 1, "attempt": 1, "comput": 1, "concept": 2, "consecut": 1, "consider": 1, "data": 2, "describ": 1, "descript": 1, "draw": 1, "element": 2, "exampl": 1, "execut": 1, "final": 1, "gener": 1, "hold": 1, "illustr": 1, "introduc": 1, "item": 3, "length": 1, "list": 4, "multiword": 2, "newel": 1, "origin": 1, "paper": 2, "perform": 1, "problem": 2, "process": 1, "propos": 1, "recent": 1, "relat": 1, "report": 1, "requir": 2, "result": 1, "save": 1, "shaw": 1, "simon": 1, "singl": 2, "space": 2, "standard": 1, "structur": 1, "time": 1, "util": 1, "variabl": 1, "way": 1, "word": 3, "comfort": 1}}, "1052": {"id": "1052", "title": "Reducing Truncation Errors by Programming", "abstract": "In accumulating a sum such as in a numerical integration with a large number of intervals,  the sum itself becomes much larger than the individual addends.  This may produce a less accurate sum  as the number of intervals is increased.  Separate variables can be established as accumulators to hold  partial sums within various distinct intervals.  Thus, the extensive successive truncations are eliminated.", "authors": "Wolfe, J. M.", "words_pool": ["accumul", "accumul", "accur", "addend", "distinct", "elimin", "error", "establish", "extens", "hold", "increas", "individu", "integr", "interv", "larg", "larger", "number", "numer", "partial", "produc", "program", "reduc", "separ", "success", "sum", "sum", "truncat", "truncat", "variabl", "wolf"], "word_count": {"accumul": 2, "accur": 1, "addend": 1, "distinct": 1, "elimin": 1, "error": 1, "establish": 1, "extens": 1, "hold": 1, "increas": 1, "individu": 1, "integr": 1, "interv": 3, "larg": 1, "larger": 1, "number": 2, "numer": 1, "partial": 1, "produc": 1, "program": 1, "reduc": 1, "separ": 1, "success": 1, "sum": 4, "truncat": 1, "variabl": 1, "wolf": 1}}, "1053": {"id": "1053", "title": "Design and Implementation of a General-Purpose Input Routine", "abstract": "A general-purpose input routine is discussed and advocated for FORTRAN.  The philosophy of  such programs is examined and exemplified.", "authors": "Hassitt, A.", "words_pool": ["advoc", "design", "discuss", "examin", "exemplifi", "fortran", "gener", "implement", "input", "philosophi", "program", "purpos", "routin", "hassitt"], "word_count": {"advoc": 1, "design": 1, "discuss": 1, "examin": 1, "exemplifi": 1, "fortran": 1, "gener": 1, "implement": 1, "input": 1, "philosophi": 1, "program": 1, "purpos": 1, "routin": 1, "hassitt": 1}}, "1054": {"id": "1054", "title": "Gauss-Seidel (Algorithm 220 )", "authors": "Batson, A. P.", "words_pool": ["algorithm", "gauss", "seidel", "batson"], "word_count": {"algorithm": 1, "gauss": 1, "seidel": 1, "batson": 1}}, "1055": {"id": "1055", "title": "q-Bessel Functions In(t) (Algorithm 214)", "authors": "Simoes Pereira, J. M. S.", "words_pool": ["algorithm", "bessel", "function", "simo", "pereira"], "word_count": {"algorithm": 1, "bessel": 1, "function": 1, "simo": 1, "pereira": 1}}, "1056": {"id": "1056", "title": "Shellsort (Algorithm 201)", "authors": "Batty, M. A.", "words_pool": ["algorithm", "shellsort", "batti"], "word_count": {"algorithm": 1, "shellsort": 1, "batti": 1}}, "1057": {"id": "1057", "title": "Critical Path Scheduling (Algorithm 40)", "authors": "Hoffman, I. A.", "words_pool": ["algorithm", "critic", "path", "schedul", "hoffman"], "word_count": {"algorithm": 1, "critic": 1, "path": 1, "schedul": 1, "hoffman": 1}}, "1058": {"id": "1058", "title": "Simpson's Rule for Multiple Integration (Algorithm 233)", "authors": "Olynyk, F.", "words_pool": ["algorithm", "integr", "multipl", "rule", "simpson", "olynyk"], "word_count": {"algorithm": 1, "integr": 1, "multipl": 1, "rule": 1, "simpson": 1, "olynyk": 1}}, "1059": {"id": "1059", "title": "Heapsort (Algorithm 232)", "authors": "Williams, J. W. J.", "words_pool": ["algorithm", "heapsort", "william"], "word_count": {"algorithm": 1, "heapsort": 1, "william": 1}}, "1060": {"id": "1060", "title": "Matrix Inversion (Algorithm 231)", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "invers", "matrix", "boothroyd"], "word_count": {"algorithm": 1, "invers": 1, "matrix": 1, "boothroyd": 1}}, "1061": {"id": "1061", "title": "Matrix Permutation (Algorithm 230)", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "matrix", "permut", "boothroyd"], "word_count": {"algorithm": 1, "matrix": 1, "permut": 1, "boothroyd": 1}}, "1062": {"id": "1062", "title": "Symbol Manipulation in FORTRAN-SASP I Subroutines", "abstract": "A set of subroutines for use in FORTRAN are described whose purpose is to synthesize output  strings from (i) input strings which have been analyzed by the SHADOW general syntactic analysis subroutine  reported earlier, and/or (ii) packed BCD strings formed in any way.  Function-type subroutines are included  for intermediate manipulations, which are performed on the strings which are stored in an abbreviated  internal representation.  The automatic way in which an internal representation for each newly created  substring is stored sequentially in a block of common storage, and the manner in which a storage block  is dynamically allocated for that purpose, are discussed.", "authors": "Bailey, M. J. Barnett, M. P. Burleson, P. B.", "words_pool": ["abbrevi", "alloc", "analysi", "analyz", "automat", "bcd", "block", "common", "creat", "discuss", "dynam", "earlier", "form", "fortran", "function", "gener", "ii", "includ", "input", "intermedi", "intern", "manipul", "manipul", "manner", "newli", "output", "pack", "perform", "purpos", "report", "represent", "sasp", "sequenti", "set", "shadow", "storag", "store", "string", "subroutin", "subroutin", "substr", "symbol", "syntact", "synthes", "type", "bailey", "barnett", "burleson"], "word_count": {"abbrevi": 1, "alloc": 1, "analysi": 1, "analyz": 1, "automat": 1, "bcd": 1, "block": 2, "common": 1, "creat": 1, "discuss": 1, "dynam": 1, "earlier": 1, "form": 1, "fortran": 1, "function": 1, "gener": 1, "ii": 1, "includ": 1, "input": 1, "intermedi": 1, "intern": 2, "manipul": 1, "manner": 1, "newli": 1, "output": 1, "pack": 1, "perform": 1, "purpos": 2, "report": 1, "represent": 2, "sasp": 1, "sequenti": 1, "set": 1, "shadow": 1, "storag": 2, "store": 2, "string": 4, "subroutin": 3, "substr": 1, "symbol": 1, "syntact": 1, "synthes": 1, "type": 1, "bailey": 1, "barnett": 1, "burleson": 1}}, "1063": {"id": "1063", "title": "One-Inch Perforated Paper Tape for Information Interchange (Proposed American Standard)", "words_pool": ["american", "inch", "inform", "interchang", "paper", "perfor", "propos", "standard", "tape"], "word_count": {"american": 1, "inch": 1, "inform": 1, "interchang": 1, "paper": 1, "perfor": 1, "propos": 1, "standard": 1, "tape": 1}}, "1064": {"id": "1064", "title": "Perforated Tape Code for Information Interchange (Proposed American Standard)", "words_pool": ["american", "code", "inform", "interchang", "perfor", "propos", "standard", "tape"], "word_count": {"american": 1, "code": 1, "inform": 1, "interchang": 1, "perfor": 1, "propos": 1, "standard": 1, "tape": 1}}, "1065": {"id": "1065", "title": "Bit Sequencing of the American Standard Code for Information Interchange (ASCII) in Serial-by-Bit  Data Transmission (Proposed American Standard)", "words_pool": ["american", "ascii", "bit", "code", "data", "inform", "interchang", "propos", "sequenc", "serial", "standard", "transmiss"], "word_count": {"american": 2, "ascii": 1, "bit": 2, "code": 1, "data": 1, "inform": 1, "interchang": 1, "propos": 1, "sequenc": 1, "serial": 1, "standard": 2, "transmiss": 1}}, "1066": {"id": "1066", "title": "Growing Applications of Linear Programming", "abstract": "Use of linear programming models has grown so extensively in recent years that the whole concept  for organizing a computer code has undergone a radical change.  It no longer is adequate merely to reduce  a mathematical algorithm (i.e. the simplex method) to a computer code.  An advanced code must cope with  such a variety of situations that the respective computer subprograms must be organized into an integrated  system.  Emphasis in this paper is devoted to the underlying principles upon which future linear programming  systems must be based.  These viewpoints are influenced by the new demands that applications within the  petroleum industry are placing on such systems.  Some of the components of such a system are: translation  of problem statement in terms of basic data to linear programming matrix coefficients, data transmission  for direct computer entry, data file at the computer center, data processing and editing prior to solving  the simplex algorithm, an efficient and reliable code for solving the above-mentioned algorithm, and  flexible means for summarizing the results.", "authors": "Aronofsky, J. S.", "words_pool": ["adequ", "advanc", "algorithm", "applic", "base", "basic", "center", "chang", "code", "coeffici", "compon", "comput", "concept", "cope", "data", "demand", "devot", "direct", "edit", "effici", "emphasi", "entri", "extens", "flexibl", "futur", "grow", "grown", "industri", "influenc", "integr", "linear", "longer", "mathemat", "matrix", "mean", "mention", "mere", "method", "model", "organ", "organ", "paper", "petroleum", "place", "principl", "prior", "problem", "process", "program", "radic", "recent", "reduc", "reliabl", "respect", "result", "simplex", "situat", "solv", "statement", "subprogram", "summar", "system", "system", "term", "translat", "transmiss", "undergon", "underli", "varieti", "viewpoint", "year", "aronofski"], "word_count": {"adequ": 1, "advanc": 1, "algorithm": 3, "applic": 1, "base": 1, "basic": 1, "center": 1, "chang": 1, "code": 4, "coeffici": 1, "compon": 1, "comput": 5, "concept": 1, "cope": 1, "data": 4, "demand": 1, "devot": 1, "direct": 1, "edit": 1, "effici": 1, "emphasi": 1, "entri": 1, "extens": 1, "flexibl": 1, "futur": 1, "grow": 1, "grown": 1, "industri": 1, "influenc": 1, "integr": 1, "linear": 3, "longer": 1, "mathemat": 1, "matrix": 1, "mean": 1, "mention": 1, "mere": 1, "method": 1, "model": 1, "organ": 2, "paper": 1, "petroleum": 1, "place": 1, "principl": 1, "prior": 1, "problem": 1, "process": 1, "program": 3, "radic": 1, "recent": 1, "reduc": 1, "reliabl": 1, "respect": 1, "result": 1, "simplex": 2, "situat": 1, "solv": 2, "statement": 1, "subprogram": 1, "summar": 1, "system": 4, "term": 1, "translat": 1, "transmiss": 1, "undergon": 1, "underli": 1, "varieti": 1, "viewpoint": 1, "year": 1, "aronofski": 1}}, "1067": {"id": "1067", "title": "Picture Generation With a Standard Line Printer", "abstract": "A method is described for producing gray-toned pictures on a line printer by utilizing the  different degrees of blackness of standard print characters.  Gray scales with 17, 32 and 64 levels have  been devised.  Scanned images of blood cells are used to display the technique.", "authors": "Perry, B. Mendelsohn, M. L.", "words_pool": ["black", "blood", "cell", "charact", "degre", "devis", "display", "gener", "gray", "imag", "level", "line", "method", "pictur", "pictur", "print", "printer", "produc", "scale", "scan", "standard", "techniqu", "tone", "util", "perri", "mendelsohn"], "word_count": {"black": 1, "blood": 1, "cell": 1, "charact": 1, "degre": 1, "devis": 1, "display": 1, "gener": 1, "gray": 2, "imag": 1, "level": 1, "line": 1, "method": 1, "pictur": 1, "print": 1, "printer": 1, "produc": 1, "scale": 1, "scan": 1, "standard": 1, "techniqu": 1, "tone": 1, "util": 1, "perri": 1, "mendelsohn": 1}}, "1068": {"id": "1068", "title": "A FORTRAN II Load-Time-Saver", "authors": "Ackermann, A. F.", "words_pool": ["fortran", "ii", "load", "saver", "time", "ackermann"], "word_count": {"fortran": 1, "ii": 1, "load": 1, "saver": 1, "time": 1, "ackermann": 1}}, "1069": {"id": "1069", "title": "A Method for Comparing the Internal Operating Speeds of Computers", "authors": "Raichelson, E. Collins, G.", "words_pool": ["compar", "comput", "intern", "method", "oper", "speed", "raichelson", "collin"], "word_count": {"compar": 1, "comput": 1, "intern": 1, "method": 1, "oper": 1, "speed": 1, "raichelson": 1, "collin": 1}}, "1070": {"id": "1070", "title": "Expand, A System for Input Card Replication", "authors": "Warrington, J. A. Norris, J. H.", "words_pool": ["card", "expand", "input", "replic", "system", "warrington", "norri"], "word_count": {"card": 1, "expand": 1, "input": 1, "replic": 1, "system": 1, "warrington": 1, "norri": 1}}, "1071": {"id": "1071", "title": "Computer-Usage Accounting for Generalized Time-Sharing Systems", "abstract": "The current development of general time-sharing systems requires a revision of accounting procedures  for computer usage. Since time-sharing system users operate concurrently, it is necessary to be more  precise as to the amount of computer time and storage space that a user actually utilizes.  The various  cost factors which should be considered for computer usage accounting in generalized time-sharing systems  are discussed.", "authors": "Rosenberg, A. M.", "words_pool": ["account", "actual", "amount", "comput", "concurr", "consid", "cost", "develop", "discuss", "factor", "gener", "gener", "oper", "precis", "procedur", "requir", "revis", "share", "space", "storag", "system", "system", "time", "usag", "user", "user", "util", "rosenberg"], "word_count": {"account": 2, "actual": 1, "amount": 1, "comput": 3, "concurr": 1, "consid": 1, "cost": 1, "develop": 1, "discuss": 1, "factor": 1, "gener": 2, "oper": 1, "precis": 1, "procedur": 1, "requir": 1, "revis": 1, "share": 3, "space": 1, "storag": 1, "system": 3, "time": 4, "usag": 2, "user": 2, "util": 1, "rosenberg": 1}}, "1072": {"id": "1072", "title": "An Improved Equivalence Algorithm", "abstract": "An algorithm for assigning storage on the basis of EQUIVALENCE, DIMENSION and COMMON declarations  is presented.  The algorithm is based on a tree structure, and has reduced computation time by 40 percent  over a previously published algorithm by identifying all equivalence classes with one scan of the EQUIVALENCE  declarations.  The method is applicable in any problem in which it is necessary to identify equivalence  classes, given the element pairs defining the equivalence relation.", "authors": "Galler, B. A. Fisher, M. J.", "words_pool": ["algorithm", "applic", "assign", "base", "basi", "class", "common", "comput", "declar", "defin", "dimens", "element", "equival", "identifi", "identifi", "improv", "method", "pair", "percent", "present", "previous", "problem", "publish", "reduc", "relat", "scan", "storag", "structur", "time", "tree", "galler", "fisher"], "word_count": {"algorithm": 3, "applic": 1, "assign": 1, "base": 1, "basi": 1, "class": 2, "common": 1, "comput": 1, "declar": 2, "defin": 1, "dimens": 1, "element": 1, "equival": 5, "identifi": 2, "improv": 1, "method": 1, "pair": 1, "percent": 1, "present": 1, "previous": 1, "problem": 1, "publish": 1, "reduc": 1, "relat": 1, "scan": 1, "storag": 1, "structur": 1, "time": 1, "tree": 1, "galler": 1, "fisher": 1}}, "1073": {"id": "1073", "title": "A Fast Procedure for Generating Exponential Random Variables", "abstract": "A very fast method for generating exponential random variables in a digital computer is outlined.", "authors": "MacLaren, M. D. Marsaglia, G. Bray, T. A.", "words_pool": ["comput", "digit", "exponenti", "fast", "gener", "method", "outlin", "procedur", "random", "variabl", "maclaren", "marsaglia", "bray"], "word_count": {"comput": 1, "digit": 1, "exponenti": 1, "fast": 1, "gener": 1, "method": 1, "outlin": 1, "procedur": 1, "random": 1, "variabl": 1, "maclaren": 1, "marsaglia": 1, "bray": 1}}, "1074": {"id": "1074", "title": "Shanks (Algorithm 215)", "authors": "Schumaker, L.", "words_pool": ["algorithm", "shank", "schumak"], "word_count": {"algorithm": 1, "shank": 1, "schumak": 1}}, "1075": {"id": "1075", "title": "Shuttlesort (Algorithm 175)", "authors": "Juelich, O. C.", "words_pool": ["algorithm", "shuttlesort", "juelich"], "word_count": {"algorithm": 1, "shuttlesort": 1, "juelich": 1}}, "1076": {"id": "1076", "title": "Multiple Integration (Algorithm 146)", "authors": "Wirth, N.", "words_pool": ["algorithm", "integr", "multipl", "wirth"], "word_count": {"algorithm": 1, "integr": 1, "multipl": 1, "wirth": 1}}, "1077": {"id": "1077", "title": "Chebyshev Curve Fit (Algorithm 91)", "authors": "Naur, P.", "words_pool": ["algorithm", "chebyshev", "curv", "fit", "naur"], "word_count": {"algorithm": 1, "chebyshev": 1, "curv": 1, "fit": 1, "naur": 1}}, "1078": {"id": "1078", "title": "Elementary Functions by Continued Fractions (Algorithm 229)", "authors": "Morelock, J. C.", "words_pool": ["algorithm", "continu", "elementari", "fraction", "function", "morelock"], "word_count": {"algorithm": 1, "continu": 1, "elementari": 1, "fraction": 1, "function": 1, "morelock": 1}}, "1079": {"id": "1079", "title": "Q-Bessel Functions (Algorithm 228)", "authors": "Simoes Pereira, J. M. S.", "words_pool": ["algorithm", "bessel", "function", "simo", "pereira"], "word_count": {"algorithm": 1, "bessel": 1, "function": 1, "simo": 1, "pereira": 1}}, "1080": {"id": "1080", "title": "Chebyshev Polynomial Coefficients (Algorithm 227)", "authors": "Cyvin, S. J.", "words_pool": ["algorithm", "chebyshev", "coeffici", "polynomi", "cyvin"], "word_count": {"algorithm": 1, "chebyshev": 1, "coeffici": 1, "polynomi": 1, "cyvin": 1}}, "1081": {"id": "1081", "title": "Normal Distribution Function (Algorithm 226)", "authors": "Cyvin, S. J.", "words_pool": ["algorithm", "distribut", "function", "normal", "cyvin"], "word_count": {"algorithm": 1, "distribut": 1, "function": 1, "normal": 1, "cyvin": 1}}, "1082": {"id": "1082", "title": "Gamma Function with Controlled Accuracy (Algorithm 225)", "authors": "Cyvin, S. J. Cyvin, B. N.", "words_pool": ["accuraci", "algorithm", "control", "function", "gamma", "cyvin", "cyvin"], "word_count": {"accuraci": 1, "algorithm": 1, "control": 1, "function": 1, "gamma": 1, "cyvin": 1}}, "1083": {"id": "1083", "title": "An Experiment in a User-Oriented Computer System", "abstract": "A version of a software-hardware system for the purpose of facilitating the programming and  analysis of well-formulated problems is described.  A modified Flexowriter is used to generate computer-acceptable  input when equations or computable requests are typed in much the same manner as they would appear in  conventional mathematical texts.  The typing and language rules are quite flexible and unrestrictive.   While the compiler part is efficient, the system as a whole has much broader aspects as a tool for the  study of problem solving and self-teaching systems.", "authors": "Klerer, M. May, J.", "words_pool": ["accept", "analysi", "aspect", "broader", "compil", "comput", "comput", "convent", "effici", "equat", "experi", "facilit", "flexibl", "flexowrit", "formul", "gener", "hardwar", "input", "languag", "manner", "mathemat", "modifi", "orient", "part", "problem", "problem", "program", "purpos", "request", "rule", "softwar", "solv", "studi", "system", "system", "teach", "text", "tool", "type", "type", "unrestrict", "user", "version", "klerer"], "word_count": {"accept": 1, "analysi": 1, "aspect": 1, "broader": 1, "compil": 1, "comput": 2, "convent": 1, "effici": 1, "equat": 1, "experi": 1, "facilit": 1, "flexibl": 1, "flexowrit": 1, "formul": 1, "gener": 1, "hardwar": 1, "input": 1, "languag": 1, "manner": 1, "mathemat": 1, "modifi": 1, "orient": 1, "part": 1, "problem": 2, "program": 1, "purpos": 1, "request": 1, "rule": 1, "softwar": 1, "solv": 1, "studi": 1, "system": 3, "teach": 1, "text": 1, "tool": 1, "type": 2, "unrestrict": 1, "user": 1, "version": 1, "klerer": 1}}, "1084": {"id": "1084", "title": "On Declaring Arbitrarily Coded Alphabets", "abstract": "The inability of existing programming languages to handle character strings from more than  one or two alphabets is mentioned and a scheme for declaring additional alphabets is proposed.  The scheme  provides for: many-to-one encodings, right or left justification, collating sequences different from  numeric sequence, variations in character size (number of bits.) from alphabet to alphabet, and arbitrary  source-language character representation.", "authors": "Shaw, C. J.", "words_pool": ["addit", "alphabet", "alphabet", "arbitrarili", "arbitrari", "bit", "charact", "code", "collat", "declar", "encod", "exist", "handl", "inabl", "justif", "languag", "languag", "left", "mention", "number", "numer", "program", "propos", "represent", "scheme", "sequenc", "sequenc", "size", "sourc", "string", "variat", "shaw"], "word_count": {"addit": 1, "alphabet": 4, "arbitrarili": 1, "arbitrari": 1, "bit": 1, "charact": 3, "code": 1, "collat": 1, "declar": 1, "encod": 1, "exist": 1, "handl": 1, "inabl": 1, "justif": 1, "languag": 2, "left": 1, "mention": 1, "number": 1, "numer": 1, "program": 1, "propos": 1, "represent": 1, "scheme": 2, "sequenc": 2, "size": 1, "sourc": 1, "string": 1, "variat": 1, "shaw": 1}}, "1085": {"id": "1085", "title": "Specification for General-Purpose Paper Cards for Information Processing (Proposed American Standard)", "words_pool": ["american", "card", "gener", "inform", "paper", "process", "propos", "purpos", "specif", "standard"], "word_count": {"american": 1, "card": 1, "gener": 1, "inform": 1, "paper": 1, "process": 1, "propos": 1, "purpos": 1, "specif": 1, "standard": 1}}, "1086": {"id": "1086", "title": "A Proposal for Input-Output Conventions in ALGOL 60-A Report of the Subcommittee on ALGOL of  the ACM Programming Language Committee", "words_pool": ["acm", "algol", "committe", "convent", "input", "languag", "output", "program", "propos", "report", "subcommitte"], "word_count": {"acm": 1, "algol": 2, "committe": 1, "convent": 1, "input": 1, "languag": 1, "output": 1, "program": 1, "propos": 1, "report": 1, "subcommitte": 1}}, "1087": {"id": "1087", "title": "Problems in Automatic Abstracting", "abstract": "A variety of problems concerning the design and operation of an automatic abstracting system  are discussed.  The purpose is to a general view of several major problem areas.  No attempt is made  to discuss details or to indicate preferences among alternative solutions.", "authors": "Edmundson, H. P.", "words_pool": ["abstract", "altern", "area", "attempt", "automat", "concern", "design", "detail", "discuss", "discuss", "gener", "made", "major", "oper", "prefer", "problem", "problem", "purpos", "solut", "system", "varieti", "view", "edmundson"], "word_count": {"abstract": 1, "altern": 1, "area": 1, "attempt": 1, "automat": 1, "concern": 1, "design": 1, "detail": 1, "discuss": 2, "gener": 1, "made": 1, "major": 1, "oper": 1, "prefer": 1, "problem": 2, "purpos": 1, "solut": 1, "system": 1, "varieti": 1, "view": 1, "edmundson": 1}}, "1088": {"id": "1088", "title": "Menu Planning by Computer", "abstract": "A computer code has been developed which plans menus by finding minimum cost combinations of  menu items such that the daily dietary, gastronomic and production requirements can be satisfied for  a sequence of days.  A fast, special integer programming algorithm is described which approximates the  theoretical solution to the problem.  If necessary, any menu can be changed on-line and then post-optimized.   Up to 30 percent saving on food cost is possible.  A FORTRAN program for the IBM 1410 is available on  request.  A considerable amount of data processing must precede the implementation of the system.", "authors": "Balistfy, J. L.", "words_pool": ["algorithm", "amount", "approxim", "chang", "code", "combin", "comput", "consider", "cost", "daili", "data", "day", "develop", "dietari", "fast", "find", "food", "fortran", "gastronom", "ibm", "implement", "integ", "item", "line", "menu", "menu", "minimum", "optim", "percent", "plan", "plan", "post", "preced", "problem", "process", "product", "program", "program", "request", "requir", "satisfi", "save", "sequenc", "solut", "special", "system", "theoret", "balistfi"], "word_count": {"algorithm": 1, "amount": 1, "approxim": 1, "chang": 1, "code": 1, "combin": 1, "comput": 1, "consider": 1, "cost": 2, "daili": 1, "data": 1, "day": 1, "develop": 1, "dietari": 1, "fast": 1, "find": 1, "food": 1, "fortran": 1, "gastronom": 1, "ibm": 1, "implement": 1, "integ": 1, "item": 1, "line": 1, "menu": 3, "minimum": 1, "optim": 1, "percent": 1, "plan": 1, "post": 1, "preced": 1, "problem": 1, "process": 1, "product": 1, "program": 2, "request": 1, "requir": 1, "satisfi": 1, "save": 1, "sequenc": 1, "solut": 1, "special": 1, "system": 1, "theoret": 1, "balistfi": 1}}, "1089": {"id": "1089", "title": "Designing a Computer Center", "authors": "Denison, A. Popov, G.", "words_pool": ["center", "comput", "design", "denison", "popov"], "word_count": {"center": 1, "comput": 1, "design": 1, "denison": 1, "popov": 1}}, "1090": {"id": "1090", "title": "Incomplete Beta Function Ratios (Algorithm 222)", "authors": "Gautschi, W.", "words_pool": ["algorithm", "beta", "function", "incomplet", "ratio", "gautschi"], "word_count": {"algorithm": 1, "beta": 1, "function": 1, "incomplet": 1, "ratio": 1, "gautschi": 1}}, "1091": {"id": "1091", "title": "Hypergeometric and Confluent Hypergeometric (Algorithm 191 & 192)", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "confluent", "hypergeometr", "thacher", "jr"], "word_count": {"algorithm": 1, "confluent": 1, "hypergeometr": 2, "thacher": 1, "jr": 1}}, "1092": {"id": "1092", "title": "Nonrecursive Adaptive Integration (Algorithm 182)", "authors": "Butler, H. S.", "words_pool": ["adapt", "algorithm", "integr", "nonrecurs", "butler"], "word_count": {"adapt": 1, "algorithm": 1, "integr": 1, "nonrecurs": 1, "butler": 1}}, "1093": {"id": "1093", "title": "Evaluation of Determinant (Algorithm 224)", "authors": "Rotenberg, L. J.", "words_pool": ["algorithm", "determin", "evalu", "rotenberg"], "word_count": {"algorithm": 1, "determin": 1, "evalu": 1, "rotenberg": 1}}, "1094": {"id": "1094", "title": "Prime Twins (Algorithm 223)", "authors": "Shimrat, M.", "words_pool": ["algorithm", "prime", "twin", "shimrat"], "word_count": {"algorithm": 1, "prime": 1, "twin": 1, "shimrat": 1}}, "1095": {"id": "1095", "title": "Decimal Tables of Binary Coded Tables", "authors": "Griebrok, M.", "words_pool": ["binari", "code", "decim", "tabl", "griebrok"], "word_count": {"binari": 1, "code": 1, "decim": 1, "tabl": 2, "griebrok": 1}}, "1096": {"id": "1096", "title": "On Avoiding Matrix Reversals Between 7090 FORTRAN II and 7090 FORTRAN IV", "authors": "Stevens, D. Benson, B.", "words_pool": ["avoid", "fortran", "ii", "iv", "matrix", "revers", "steven", "benson"], "word_count": {"avoid": 1, "fortran": 2, "ii": 1, "iv": 1, "matrix": 1, "revers": 1, "steven": 1, "benson": 1}}, "1097": {"id": "1097", "title": "An Algorithm for Converting Integers from Base A to Base B", "abstract": "A little known, simple algorithm for integer conversion between number systems is presented  and proved.", "authors": "Gladwin, H. T.", "words_pool": ["algorithm", "base", "convers", "convert", "integ", "integ", "known", "number", "present", "prove", "simpl", "system", "gladwin"], "word_count": {"algorithm": 1, "base": 2, "convers": 1, "convert": 1, "integ": 1, "known": 1, "number": 1, "present": 1, "prove": 1, "simpl": 1, "system": 1, "gladwin": 1}}, "1098": {"id": "1098", "title": "A Comparison of List-Processing Computer Languages (Including a Detailed Comparison of COMIT,  IPL-V, LISP 1.5, and SLIP)", "abstract": "A detailed comparison is presented of COMIT, IPL-V, LISP 1.5 and SLIP - four well-known computer  programming languages which, among them, exhibit all the principal characteristics of existing list-processing  languages.  Important common features of list-processing languages are reviewed: forms of data structures  which are manipulated, necessity for dynamic allocation of storage, use of pushdown stores, and use of  recursive operations.  Principal differences between the four languages under consideration are detailed:  representations of data, both by the programmer and within the machine; methods for storage allocation;  programming formalisms and special processes available, including arithmetic facilities; and usability  in terms of availability, documentation, learning aids and debugging facilities.  A rough comparison  shows that all the languages discussed have approximately the same speed.  Finally, the authors give  some heuristics to aid in the selection of one of these languages for use in particular problem applications,  concluding that no one of the languages considered is distinctly superior in all possible list-processing  applications.", "authors": "Bobrow, D. G. Raphael, B.", "words_pool": ["aid", "aid", "alloc", "applic", "approxim", "arithmet", "author", "avail", "characterist", "comit", "common", "comparison", "comput", "conclud", "consider", "consid", "data", "debug", "detail", "differ", "discuss", "distinctli", "document", "dynam", "exhibit", "exist", "facil", "featur", "final", "formal", "form", "give", "heurist", "import", "includ", "ipl", "known", "languag", "learn", "lisp", "list", "machin", "manipul", "method", "necess", "oper", "present", "princip", "problem", "process", "process", "programm", "program", "pushdown", "recurs", "represent", "review", "rough", "select", "show", "slip", "special", "speed", "storag", "store", "structur", "superior", "term", "usabl", "bobrow", "raphael"], "word_count": {"aid": 2, "alloc": 2, "applic": 2, "approxim": 1, "arithmet": 1, "author": 1, "avail": 1, "characterist": 1, "comit": 1, "common": 1, "comparison": 2, "comput": 1, "conclud": 1, "consider": 1, "consid": 1, "data": 2, "debug": 1, "detail": 2, "differ": 1, "discuss": 1, "distinctli": 1, "document": 1, "dynam": 1, "exhibit": 1, "exist": 1, "facil": 2, "featur": 1, "final": 1, "formal": 1, "form": 1, "give": 1, "heurist": 1, "import": 1, "includ": 1, "ipl": 1, "known": 1, "languag": 7, "learn": 1, "lisp": 1, "list": 3, "machin": 1, "manipul": 1, "method": 1, "necess": 1, "oper": 1, "present": 1, "princip": 2, "problem": 1, "process": 4, "programm": 1, "program": 2, "pushdown": 1, "recurs": 1, "represent": 1, "review": 1, "rough": 1, "select": 1, "show": 1, "slip": 1, "special": 1, "speed": 1, "storag": 2, "store": 1, "structur": 1, "superior": 1, "term": 1, "usabl": 1, "bobrow": 1, "raphael": 1}}, "1099": {"id": "1099", "title": "Professional Computer Work for the Blind", "abstract": "Developments in computer technology have opened new professional opportunities for the intelligent  blind.  Since there are few if any occupations in which the blind can participate without serious disadvantage,  the opportunities offered them to gain entrance into various occupations through computer use including  that of programmer, is important for future rehabilitation planning. Also of immediate interest is the  fact that the blind may be especially suited for programming work.  Because of intense training in and  constant experience with locating objects in the unseen environment and also because of superbly trained  memory, the blind brings to the work of programming skills which the sighted has had little need to acquire.   These qualifications should result in fewer debugging problems and make the blind a valuable addition  to any systems group.  Before the blind could become a serious professional, a number of aids and techniques  had to be developed that can mediate between machines and programmer.  This paper describes the techniques  and aids which were designed by the staff of the Medical Computing Center of the University of Cincinnati  College of Medicine.", "authors": "Sterling, T. D. Lichstein, M.  Scarpino, F. Stuebing, D.", "words_pool": ["acquir", "addit", "aid", "blind", "bring", "center", "cincinnati", "colleg", "comput", "comput", "constant", "debug", "describ", "design", "develop", "develop", "disadvantag", "entranc", "environ", "especi", "experi", "fact", "fewer", "futur", "gain", "group", "import", "includ", "intellig", "intens", "interest", "locat", "machin", "make", "mediat", "medic", "medicin", "memori", "need", "number", "object", "occup", "offer", "open", "opportun", "paper", "particip", "plan", "problem", "profession", "programm", "program", "qualif", "rehabilit", "result", "sight", "skill", "staff", "suit", "superbl", "system", "techniqu", "technolog", "train", "train", "univers", "unseen", "valuabl", "work", "sterl", "lichstein", "scarpino", "stueb"], "word_count": {"acquir": 1, "addit": 1, "aid": 2, "blind": 6, "bring": 1, "center": 1, "cincinnati": 1, "colleg": 1, "comput": 3, "constant": 1, "debug": 1, "describ": 1, "design": 1, "develop": 2, "disadvantag": 1, "entranc": 1, "environ": 1, "especi": 1, "experi": 1, "fact": 1, "fewer": 1, "futur": 1, "gain": 1, "group": 1, "import": 1, "includ": 1, "intellig": 1, "intens": 1, "interest": 1, "locat": 1, "machin": 1, "make": 1, "mediat": 1, "medic": 1, "medicin": 1, "memori": 1, "need": 1, "number": 1, "object": 1, "occup": 2, "offer": 1, "open": 1, "opportun": 2, "paper": 1, "particip": 1, "plan": 1, "problem": 1, "profession": 2, "programm": 2, "program": 2, "qualif": 1, "rehabilit": 1, "result": 1, "sight": 1, "skill": 1, "staff": 1, "suit": 1, "superbl": 1, "system": 1, "techniqu": 2, "technolog": 1, "train": 2, "univers": 1, "unseen": 1, "valuabl": 1, "work": 2, "sterl": 1, "lichstein": 1, "scarpino": 1, "stueb": 1}}, "1100": {"id": "1100", "title": "Status of Computer Sciences Curricula in Colleges and Universities", "authors": "Atchison, W. F. Hamblen, J. W.", "words_pool": ["colleg", "comput", "curricula", "scienc", "statu", "univers", "atchison", "hamblen"], "word_count": {"colleg": 1, "comput": 1, "curricula": 1, "scienc": 1, "statu": 1, "univers": 1, "atchison": 1, "hamblen": 1}}, "1101": {"id": "1101", "title": "The Place of Logical Design and Switching Theory In The Computer Curriculum", "authors": "Muller, D. E.", "words_pool": ["comput", "curriculum", "design", "logic", "place", "switch", "theori", "muller"], "word_count": {"comput": 1, "curriculum": 1, "design": 1, "logic": 1, "place": 1, "switch": 1, "theori": 1, "muller": 1}}, "1102": {"id": "1102", "title": "Mechanical Languages: A Course Specification", "authors": "Gorn, S.", "words_pool": ["cours", "languag", "mechan", "specif", "gorn"], "word_count": {"cours": 1, "languag": 1, "mechan": 1, "specif": 1, "gorn": 1}}, "1103": {"id": "1103", "title": "Logic for the Computer Sciences", "authors": "Korfhage, R. R.", "words_pool": ["comput", "logic", "scienc", "korfhag"], "word_count": {"comput": 1, "logic": 1, "scienc": 1, "korfhag": 1}}, "1104": {"id": "1104", "title": "An Undergraduate Curriculum in Numerical Analysis", "authors": "Forsythe, G. E.", "words_pool": ["analysi", "curriculum", "numer", "undergradu", "forsyth"], "word_count": {"analysi": 1, "curriculum": 1, "numer": 1, "undergradu": 1, "forsyth": 1}}, "1105": {"id": "1105", "title": "On Introducing Digital Computing", "authors": "Arden, B. W.", "words_pool": ["comput", "digit", "introduc", "arden"], "word_count": {"comput": 1, "digit": 1, "introduc": 1, "arden": 1}}, "1106": {"id": "1106", "title": "Programming of Digital Computers", "authors": "Perlis, A. J.", "words_pool": ["comput", "digit", "program", "perli"], "word_count": {"comput": 1, "digit": 1, "program": 1, "perli": 1}}, "1107": {"id": "1107", "title": "Computers and Education", "authors": "Keenan, T. A.", "words_pool": ["comput", "educ", "keenan"], "word_count": {"comput": 1, "educ": 1, "keenan": 1}}, "1108": {"id": "1108", "title": "Digital Data Processor for Tracking the Partially Illuminated Moon*", "abstract": "A study of lunar tracking techniques and fabrication of a breadboard to assess the feasibility  of the best technique selected was conducted to define a tracking system for observation of the sight line  to the center of a partially illuminated moon.  The data processing portion of the system is presented  in detail and then described in general are the operation of the tracker head assembly for data readout,  the operation of the entire system and the effect data processing considerations have on the design of  the tracker system.  The system basically consists of an optical sensor, digital computer and tracker  drive mechanism.  The three system units, connected in cascade, comprise the control loop.  For this  application, an optical telescope with a radial mechanical scanning mechanism was used that read out  lunar sight line measurement information.  This information is sequentially read into a special purpose  digital computer that extracts the measurements and computes the error signals that drive the tracker  to the appropriate attitude.", "authors": "Wilcox, H. J.", "words_pool": ["applic", "assembl", "assess", "attitud", "basic", "breadboard", "cascad", "center", "compris", "comput", "comput", "conduct", "connect", "consider", "consist", "control", "data", "defin", "design", "detail", "digit", "drive", "effect", "entir", "error", "extract", "fabric", "feasibl", "gener", "head", "illumin", "inform", "line", "loop", "lunar", "measur", "measur", "mechan", "mechan", "moon", "observ", "oper", "optic", "partial", "portion", "present", "process", "processor", "purpos", "radial", "read", "readout", "scan", "select", "sensor", "sequenti", "sight", "signal", "special", "studi", "system", "techniqu", "techniqu", "telescop", "tracker", "track", "unit", "wilcox"], "word_count": {"applic": 1, "assembl": 1, "assess": 1, "attitud": 1, "basic": 1, "breadboard": 1, "cascad": 1, "center": 1, "compris": 1, "comput": 3, "conduct": 1, "connect": 1, "consider": 1, "consist": 1, "control": 1, "data": 3, "defin": 1, "design": 1, "detail": 1, "digit": 2, "drive": 2, "effect": 1, "entir": 1, "error": 1, "extract": 1, "fabric": 1, "feasibl": 1, "gener": 1, "head": 1, "illumin": 1, "inform": 2, "line": 2, "loop": 1, "lunar": 2, "measur": 2, "mechan": 3, "moon": 1, "observ": 1, "oper": 2, "optic": 2, "partial": 1, "portion": 1, "present": 1, "process": 2, "processor": 1, "purpos": 1, "radial": 1, "read": 2, "readout": 1, "scan": 1, "select": 1, "sensor": 1, "sequenti": 1, "sight": 2, "signal": 1, "special": 1, "studi": 1, "system": 6, "techniqu": 2, "telescop": 1, "tracker": 4, "track": 2, "unit": 1, "wilcox": 1}}, "1109": {"id": "1109", "title": "Conversion of a Power to a Series of Chebyshev Polynomials*", "abstract": "Even slowly convergent power series can be rearranged as series in Chebyshev polynomials if  appropriate sequence transformations are used in evaluating the coefficients.  The method is illustrated  by computing the coefficients for the expansion of the logarithm and dilogarithm.", "authors": "Thacher Jr., H. C.", "words_pool": ["chebyshev", "coeffici", "comput", "converg", "convers", "dilogarithm", "evalu", "expans", "illustr", "logarithm", "method", "polynomi", "power", "rearrang", "sequenc", "seri", "slowli", "transform", "thacher", "jr"], "word_count": {"chebyshev": 1, "coeffici": 2, "comput": 1, "converg": 1, "convers": 1, "dilogarithm": 1, "evalu": 1, "expans": 1, "illustr": 1, "logarithm": 1, "method": 1, "polynomi": 1, "power": 1, "rearrang": 1, "sequenc": 1, "seri": 2, "slowli": 1, "transform": 1, "thacher": 1, "jr": 1}}, "1110": {"id": "1110", "title": "A Fourier Series Method for the Numerical Solution of a Class of Parabolic Partial Differential  Equations*", "abstract": "A Fourier series method is described which, when applied to a certain class of parabolic partial  differential equations, reduces the problem to a system of ordinary differential equations.  An application  is given for which the method shows a considerable advantage over conventional finite difference methods.", "authors": "Forrington, C. V. D.", "words_pool": ["advantag", "applic", "appli", "class", "consider", "convent", "differ", "differenti", "equat", "finit", "fourier", "method", "method", "numer", "ordinari", "parabol", "partial", "problem", "reduc", "seri", "show", "solut", "system", "forrington"], "word_count": {"advantag": 1, "applic": 1, "appli": 1, "class": 1, "consider": 1, "convent": 1, "differ": 1, "differenti": 2, "equat": 2, "finit": 1, "fourier": 1, "method": 3, "numer": 1, "ordinari": 1, "parabol": 1, "partial": 1, "problem": 1, "reduc": 1, "seri": 1, "show": 1, "solut": 1, "system": 1, "forrington": 1}}, "1111": {"id": "1111", "title": "A Class of Iterative Techniques For the Factorization of Polynomials*", "abstract": "A method of iteration is developed in terms of a function of somewhat arbitrary character.   Sufficient conditions are given for convergence of the process, yielding factors of arbitrary degree  for polynomials in one variable.  Both Lin's method and Newton's method occur as special cases.", "authors": "Luther, H. A.", "words_pool": ["arbitrari", "case", "charact", "class", "condit", "converg", "degre", "develop", "factor", "factor", "function", "iter", "iter", "lin", "method", "newton", "occur", "polynomi", "process", "special", "suffici", "techniqu", "term", "variabl", "yield", "luther"], "word_count": {"arbitrari": 2, "case": 1, "charact": 1, "class": 1, "condit": 1, "converg": 1, "degre": 1, "develop": 1, "factor": 1, "function": 1, "iter": 1, "lin": 1, "method": 3, "newton": 1, "occur": 1, "polynomi": 1, "process": 1, "special": 1, "suffici": 1, "techniqu": 1, "term": 1, "variabl": 1, "yield": 1, "luther": 1}}, "1112": {"id": "1112", "title": "A Technique for Computer Detection and Correction of Spelling Errors*", "abstract": "The method described assumes that a word which cannot be found in a dictionary has at most  one error, which might be a wrong, missing or extra letter or a single transposition.  The unidentified  input word is compared to the dictionary again, testing each time to see if the words match-assuming  one of these errors occurred.  During a test run on garbled text, correct identifications were made for  over 95 percent of these error types.", "authors": "Damerau, F. J.", "words_pool": ["assum", "assum", "compar", "comput", "correct", "correct", "detect", "dictionari", "error", "error", "extra", "found", "garbl", "identif", "input", "letter", "made", "match", "method", "miss", "occur", "percent", "run", "singl", "spell", "techniqu", "test", "test", "text", "time", "transposit", "type", "unidentifi", "word", "word", "wrong", "damerau"], "word_count": {"assum": 2, "compar": 1, "comput": 1, "correct": 1, "detect": 1, "dictionari": 2, "error": 3, "extra": 1, "found": 1, "garbl": 1, "identif": 1, "input": 1, "letter": 1, "made": 1, "match": 1, "method": 1, "miss": 1, "occur": 1, "percent": 1, "run": 1, "singl": 1, "spell": 1, "techniqu": 1, "test": 2, "text": 1, "time": 1, "transposit": 1, "type": 1, "unidentifi": 1, "word": 3, "wrong": 1, "damerau": 1}}, "1113": {"id": "1113", "title": "Computer-Made Perspective Movies as a Scientific and Communication Tool*", "abstract": "It is easy to program the basic transformation required for a perspective drawing.  This fact  plus the advent of high speed microfilm printers such as the General Dynamics Electronics S-C 4020 makes  possible perspective movies as the direct output from a computer.  The programming of such a movie is  briefly described for studying the angular motions of a satellite containing an attitude control system.   In the movie, a domino-shaped box represents the satellite and a sphere with circles of latitude and  longitude represents the earth.  The cost was approximately three to eight minutes of IBM 7090 time per  one minute of movie.", "authors": "Zajac, E. E.", "words_pool": ["advent", "angular", "approxim", "attitud", "basic", "box", "briefli", "circl", "commun", "comput", "control", "cost", "direct", "domino", "draw", "dynam", "earth", "easi", "electron", "fact", "gener", "high", "ibm", "latitud", "longitud", "made", "make", "microfilm", "minut", "minut", "motion", "movi", "movi", "output", "perspect", "printer", "program", "program", "repres", "requir", "satellit", "scientif", "shape", "speed", "sphere", "studi", "system", "time", "tool", "transform", "zajac"], "word_count": {"advent": 1, "angular": 1, "approxim": 1, "attitud": 1, "basic": 1, "box": 1, "briefli": 1, "circl": 1, "commun": 1, "comput": 1, "control": 1, "cost": 1, "direct": 1, "domino": 1, "draw": 1, "dynam": 1, "earth": 1, "easi": 1, "electron": 1, "fact": 1, "gener": 1, "high": 1, "ibm": 1, "latitud": 1, "longitud": 1, "made": 1, "make": 1, "microfilm": 1, "minut": 2, "motion": 1, "movi": 4, "output": 1, "perspect": 2, "printer": 1, "program": 2, "repres": 2, "requir": 1, "satellit": 2, "scientif": 1, "shape": 1, "speed": 1, "sphere": 1, "studi": 1, "system": 1, "time": 1, "tool": 1, "transform": 1, "zajac": 1}}, "1114": {"id": "1114", "title": "Generating a Canonical Prefix Encoding*", "abstract": "Computer programs for generating a minimum-redundancy exhaustive prefix encoding are described.   One program generates a Huffman frequency tree, another determines the structure functions of an encoding,  and a third program assigns codes.", "authors": "Schwartz, E. S. Kallick, B.", "words_pool": ["assign", "canon", "code", "comput", "determin", "encod", "exhaust", "frequenc", "function", "gener", "gener", "huffman", "minimum", "prefix", "program", "program", "redund", "structur", "tree", "schwartz", "kallick"], "word_count": {"assign": 1, "canon": 1, "code": 1, "comput": 1, "determin": 1, "encod": 2, "exhaust": 1, "frequenc": 1, "function": 1, "gener": 2, "huffman": 1, "minimum": 1, "prefix": 1, "program": 3, "redund": 1, "structur": 1, "tree": 1, "schwartz": 1, "kallick": 1}}, "1115": {"id": "1115", "title": "Randomized Binary Searching With Tree Structure", "abstract": "A more efficient method of using tree structures is proposed, which utilizers both plus and  minus branches in the search path.  Very significant gains result when the search key includes alphabetic  characters.", "authors": "Clampett Jr., H. A.", "words_pool": ["alphabet", "binari", "branch", "charact", "effici", "gain", "includ", "key", "method", "minu", "path", "propos", "random", "result", "search", "search", "signific", "structur", "structur", "tree", "util", "clampett", "jr"], "word_count": {"alphabet": 1, "binari": 1, "branch": 1, "charact": 1, "effici": 1, "gain": 1, "includ": 1, "key": 1, "method": 1, "minu": 1, "path": 1, "propos": 1, "random": 1, "result": 1, "search": 2, "signific": 1, "structur": 1, "tree": 1, "util": 1, "clampett": 1, "jr": 1}}, "1116": {"id": "1116", "title": "Tests on a Computer Method for Constructing School Timetables*", "abstract": "A previously proposed computer method for constructing timetables, based on an iteration involving  Boolean matrices, is described.  In limited tests the method has successfully produced timetables on  every trial.  References are given which relate the timetable problem to theorems on matrices of zeros  and ones, and to theorems on bipartite graphs.  Some problems of applying the method to constructing  timetables in real situations are noted.", "authors": "Csima, J. Gotlieb, C. C.", "words_pool": ["appli", "base", "bipartit", "boolean", "comput", "construct", "graph", "involv", "iter", "limit", "matric", "method", "note", "previous", "problem", "problem", "produc", "propos", "real", "refer", "relat", "school", "situat", "success", "test", "theorem", "timet", "timet", "trial", "zero", "csima", "gotlieb"], "word_count": {"appli": 1, "base": 1, "bipartit": 1, "boolean": 1, "comput": 1, "construct": 2, "graph": 1, "involv": 1, "iter": 1, "limit": 1, "matric": 2, "method": 3, "note": 1, "previous": 1, "problem": 2, "produc": 1, "propos": 1, "real": 1, "refer": 1, "relat": 1, "school": 1, "situat": 1, "success": 1, "test": 1, "theorem": 2, "timet": 4, "trial": 1, "zero": 1, "csima": 1, "gotlieb": 1}}, "1117": {"id": "1117", "title": "Polyphase Sorting With Overlapped Rewind*", "abstract": "A variation of the polyphase merge technique of sorting is described which permits one tape  at a time to be rewound while the merge is continued on the remaining tapes.  The result is the overlapping  of a major portion of the rewind time.  The technique should be considered whenever a sort is written  to operate on five or more tapes that cannot be read backwards.  The savings of the overlap method appear  to increase as the number of available tapes is increased.", "authors": "McAlester, R. L.", "words_pool": ["backward", "consid", "continu", "increas", "increas", "major", "merg", "method", "number", "oper", "overlap", "overlap", "overlap", "permit", "polyphas", "portion", "read", "remain", "result", "rewind", "rewound", "save", "sort", "sort", "tape", "tape", "techniqu", "time", "variat", "written", "mcalest"], "word_count": {"backward": 1, "consid": 1, "continu": 1, "increas": 2, "major": 1, "merg": 2, "method": 1, "number": 1, "oper": 1, "overlap": 2, "permit": 1, "polyphas": 1, "portion": 1, "read": 1, "remain": 1, "result": 1, "rewind": 1, "rewound": 1, "save": 1, "sort": 2, "tape": 4, "techniqu": 2, "time": 2, "variat": 1, "written": 1, "mcalest": 1}}, "1118": {"id": "1118", "title": "FORTRAN Subroutines for Time Series Data Reduction*", "authors": "MacGowan, R. A.", "words_pool": ["data", "fortran", "reduct", "seri", "subroutin", "time", "macgowan"], "word_count": {"data": 1, "fortran": 1, "reduct": 1, "seri": 1, "subroutin": 1, "time": 1, "macgowan": 1}}, "1119": {"id": "1119", "title": "An Open Letter to X3.4.3 (FORTRAN Standards -- American Association)", "words_pool": ["american", "associ", "fortran", "letter", "open", "standard", "x3"], "word_count": {"american": 1, "associ": 1, "fortran": 1, "letter": 1, "open": 1, "standard": 1, "x3": 1}}, "1120": {"id": "1120", "title": "\"ALCOR Group Representations of ALGOL Symbols,\" Comm. ACM 6 (1963), 597-599. (Corrigenda)", "words_pool": ["acm", "alcor", "algol", "comm", "corrigenda", "group", "represent", "symbol"], "word_count": {"acm": 1, "alcor": 1, "algol": 1, "comm": 1, "corrigenda": 1, "group": 1, "represent": 1, "symbol": 1}}, "1121": {"id": "1121", "title": "Comments on \"A Continued Operation Notation\"*", "abstract": "This note is intended to clarify and correct several points in a recent paper describing some  notations for symbol manipulation by M.P. Barnett [Comm. ACM 6(August, 1963)].", "authors": "Barnett, M. P. Gerard, J. M. Sambles, A. W.", "words_pool": ["acm", "august", "barnett", "clarifi", "comm", "comment", "continu", "correct", "describ", "intend", "manipul", "notat", "notat", "note", "oper", "paper", "point", "recent", "symbol", "barnett", "gerard", "sambl"], "word_count": {"acm": 1, "august": 1, "barnett": 1, "clarifi": 1, "comm": 1, "comment": 1, "continu": 1, "correct": 1, "describ": 1, "intend": 1, "manipul": 1, "notat": 1, "note": 1, "oper": 1, "paper": 1, "point": 1, "recent": 1, "symbol": 1, "gerard": 1, "sambl": 1}}, "1122": {"id": "1122", "title": "A Note on Some Compiling Algorithms", "abstract": "Two compiling generators for arithmetic expressions are discussed: one presently in use in  an experimental compiler, and an improvement suggested by K. Speierman of Burroughs.", "authors": "Anderson, J. P.", "words_pool": ["algorithm", "arithmet", "burrough", "compil", "compil", "discuss", "experiment", "express", "gener", "improv", "note", "present", "speierman", "suggest", "anderson"], "word_count": {"algorithm": 1, "arithmet": 1, "burrough": 1, "compil": 2, "discuss": 1, "experiment": 1, "express": 1, "gener": 1, "improv": 1, "note": 1, "present": 1, "speierman": 1, "suggest": 1, "anderson": 1}}, "1123": {"id": "1123", "title": "Gauss (Algorithm 209)", "authors": "Gladfelter, G. W.", "words_pool": ["algorithm", "gauss", "gladfelt"], "word_count": {"algorithm": 1, "gauss": 1, "gladfelt": 1}}, "1124": {"id": "1124", "title": "Matrix Division (Algorithm 197)", "authors": "Wells, M.", "words_pool": ["algorithm", "divis", "matrix", "well"], "word_count": {"algorithm": 1, "divis": 1, "matrix": 1, "well": 1}}, "1125": {"id": "1125", "title": "Syminv2 (Algorithm 150)", "authors": "Naur, P.", "words_pool": ["algorithm", "syminv2", "naur"], "word_count": {"algorithm": 1, "syminv2": 1, "naur": 1}}, "1126": {"id": "1126", "title": "ERF (Algorithm 123)", "authors": "Barton, S. P. Wagner, J. F.", "words_pool": ["algorithm", "erf", "barton", "wagner"], "word_count": {"algorithm": 1, "erf": 1, "barton": 1, "wagner": 1}}, "1127": {"id": "1127", "title": "Tridiagonal Matrix (Algorithm 122)", "authors": "Naur, P.", "words_pool": ["algorithm", "matrix", "tridiagon", "naur"], "word_count": {"algorithm": 1, "matrix": 1, "tridiagon": 1, "naur": 1}}, "1128": {"id": "1128", "title": "Evaluation of Determinant (Algorithm 41)", "authors": "Rotenberg, L. J.", "words_pool": ["algorithm", "determin", "evalu", "rotenberg"], "word_count": {"algorithm": 1, "determin": 1, "evalu": 1, "rotenberg": 1}}, "1129": {"id": "1129", "title": "Incomplete Beta Function Ratios (Algorithm 222)", "authors": "Gautschi, W.", "words_pool": ["algorithm", "beta", "function", "incomplet", "ratio", "gautschi"], "word_count": {"algorithm": 1, "beta": 1, "function": 1, "incomplet": 1, "ratio": 1, "gautschi": 1}}, "1130": {"id": "1130", "title": "Gamma Function (Althm 221)", "authors": "Gautschi, W.", "words_pool": ["althm", "function", "gamma", "gautschi"], "word_count": {"althm": 1, "function": 1, "gamma": 1, "gautschi": 1}}, "1131": {"id": "1131", "title": "On Context and Ambiguity in Parsing*", "authors": "Ross, D. T.", "words_pool": ["ambigu", "context", "pars", "ross"], "word_count": {"ambigu": 1, "context": 1, "pars": 1, "ross": 1}}, "1132": {"id": "1132", "title": "An Extension to ALGOL for Manipulating Formulae*", "authors": "Perlis, A. J. Iturriaga, R.", "words_pool": ["algol", "extens", "formula", "manipul", "perli", "iturriaga"], "word_count": {"algol": 1, "extens": 1, "formula": 1, "manipul": 1, "perli": 1, "iturriaga": 1}}, "1133": {"id": "1133", "title": "A Programming Package for Some General Modes of Arithmetic*", "authors": "Brooker, R. A.", "words_pool": ["arithmet", "gener", "mode", "packag", "program", "brooker"], "word_count": {"arithmet": 1, "gener": 1, "mode": 1, "packag": 1, "program": 1, "brooker": 1}}, "1134": {"id": "1134", "title": "Some Effects of the 6600 Computer on Language Structures*", "abstract": "The problem of compiling efficient 6600 codes prompted the development of an intermediate language  reflecting the structure of the machine, that is more easily manipulated in improving object program  efficiency.  The subject of this paper is the intermediate language and methods of manipulating it.   Compilations of a series of arithmetic statements are discussed.  It is assumed that all functions and  exponentials have been removed from these statements, and replaced by simple variables.  For purposes  of simplicity the treatment of subscripts is ignored.  A simplified 6600 structure is presented to illustrate the compiling method.  Several assumptions are made for purposes of simplification, although there are  cases in which the assumptions are violated in the actual machine.", "authors": "Allard, R. W. Wolf, K. A. Zemlin, R. A.", "words_pool": ["actual", "arithmet", "assum", "assumpt", "case", "code", "compil", "compil", "comput", "develop", "discuss", "easili", "effect", "effici", "effici", "exponenti", "function", "illustr", "improv", "intermedi", "languag", "machin", "made", "manipul", "manipul", "method", "method", "object", "paper", "present", "problem", "program", "prompt", "purpos", "reflect", "remov", "replac", "seri", "simpl", "simplic", "simplif", "simplifi", "statement", "structur", "structur", "subject", "subscript", "treatment", "variabl", "violat", "allard", "wolf", "zemlin"], "word_count": {"actual": 1, "arithmet": 1, "assum": 1, "assumpt": 2, "case": 1, "code": 1, "compil": 3, "comput": 1, "develop": 1, "discuss": 1, "easili": 1, "effect": 1, "effici": 2, "exponenti": 1, "function": 1, "illustr": 1, "improv": 1, "intermedi": 2, "languag": 2, "machin": 2, "made": 1, "manipul": 2, "method": 2, "object": 1, "paper": 1, "present": 1, "problem": 1, "program": 1, "prompt": 1, "purpos": 2, "reflect": 1, "remov": 1, "replac": 1, "seri": 1, "simpl": 1, "simplic": 1, "simplif": 1, "simplifi": 1, "statement": 2, "structur": 2, "subject": 1, "subscript": 1, "treatment": 1, "variabl": 1, "violat": 1, "allard": 1, "wolf": 1, "zemlin": 1}}, "1135": {"id": "1135", "title": "A General Business-Oriented Language Based on Decision Expressions*", "abstract": "The structure of a digital compute programming language which covers a wide class of business  and file processing applications is presented.  Such a structure, based on identifying and incorporating  into a compiler the aspects common to all processes of such class, permits writing extremely compact  programs, even for comparatively complex applications, in terms of tables of control expressions which  express only information characteristic of the particular application.  Furthermore,local changes of  a process (e.g. changes affecting only one of the output files involved) can be effected by local modifications  in the program (e.g. modification of only one entry of the tables).  This structure also allows for inexpensive  preparation of loading-speed compilers which translate the source programs into efficient machine codes.   The approach adopted here departs from conventional mechanical language design philosophies.  It stresses  the structural analysis of the class of processes to be represented in the languages, as opposed to emphasizing  formal (i.e., contents-independent) syntactical definitions.  It relies exclusively on nonprocedural  representation of process as sets (tables) of relations between data and results (there are no control  statements such as GO TO, etc.), instead of using procedure descriptions (which are one-to-one translations  of flowcharts).  Here an invariant pattern of procedure is identified as characteristic of the class  of all batch file processes.  This new philosophy has the potential to overcome well-known deficiencies  of other business-oriented languages and fully meets the requirements set by CODASYL for such languages,  including machine-independence.", "authors": "Lombardi, L. A.", "words_pool": ["adopt", "affect", "analysi", "applic", "applic", "approach", "aspect", "base", "batch", "busi", "characterist", "class", "codasyl", "code", "common", "compact", "compar", "compil", "compil", "complex", "comput", "content", "control", "convent", "cover", "data", "decis", "defici", "definit", "depart", "descript", "design", "digit", "effect", "effici", "emphas", "entri", "exclus", "express", "express", "extrem", "flowchart", "formal", "fulli", "gener", "identifi", "identifi", "includ", "incorpor", "independ", "independ", "inexpens", "inform", "invari", "involv", "known", "languag", "languag", "load", "local", "machin", "mechan", "meet", "modif", "modif", "nonprocedur", "oppos", "orient", "output", "overcom", "pattern", "permit", "philosophi", "philosophi", "potenti", "prepar", "present", "procedur", "process", "process", "process", "program", "program", "program", "relat", "reli", "represent", "repres", "requir", "result", "set", "set", "sourc", "speed", "statement", "stress", "structur", "structur", "syntact", "tabl", "term", "translat", "translat", "wide", "write", "lombardi"], "word_count": {"adopt": 1, "affect": 1, "analysi": 1, "applic": 3, "approach": 1, "aspect": 1, "base": 1, "batch": 1, "busi": 2, "characterist": 2, "class": 4, "codasyl": 1, "code": 1, "common": 1, "compact": 1, "compar": 1, "compil": 2, "complex": 1, "comput": 1, "content": 1, "control": 2, "convent": 1, "cover": 1, "data": 1, "decis": 1, "defici": 1, "definit": 1, "depart": 1, "descript": 1, "design": 1, "digit": 1, "effect": 1, "effici": 1, "emphas": 1, "entri": 1, "exclus": 1, "express": 2, "extrem": 1, "flowchart": 1, "formal": 1, "fulli": 1, "gener": 1, "identifi": 2, "includ": 1, "incorpor": 1, "independ": 2, "inexpens": 1, "inform": 1, "invari": 1, "involv": 1, "known": 1, "languag": 5, "load": 1, "local": 2, "machin": 2, "mechan": 1, "meet": 1, "modif": 2, "nonprocedur": 1, "oppos": 1, "orient": 1, "output": 1, "overcom": 1, "pattern": 1, "permit": 1, "philosophi": 2, "potenti": 1, "prepar": 1, "present": 1, "procedur": 2, "process": 6, "program": 4, "relat": 1, "reli": 1, "represent": 1, "repres": 1, "requir": 1, "result": 1, "set": 2, "sourc": 1, "speed": 1, "statement": 1, "stress": 1, "structur": 4, "syntact": 1, "tabl": 3, "term": 1, "translat": 2, "wide": 1, "write": 1, "lombardi": 1}}, "1136": {"id": "1136", "title": "Beginnings of a Theory of Information Handling*", "authors": "Steel Jr., T. B.", "words_pool": ["begin", "handl", "inform", "theori", "steel", "jr"], "word_count": {"begin": 1, "handl": 1, "inform": 1, "theori": 1, "steel": 1, "jr": 1}}, "1137": {"id": "1137", "title": "A Format Language*", "authors": "Perlis, A. J.", "words_pool": ["format", "languag", "perli"], "word_count": {"format": 1, "languag": 1, "perli": 1}}, "1138": {"id": "1138", "title": "Formalism in Programming Languages*", "authors": "Iverson, K. E.", "words_pool": ["formal", "languag", "program", "iverson"], "word_count": {"formal": 1, "languag": 1, "program": 1, "iverson": 1}}, "1139": {"id": "1139", "title": "FORTRAN IV as a Syntax Language*", "authors": "Leavenworth, B. M.", "words_pool": ["fortran", "iv", "languag", "syntax", "leavenworth"], "word_count": {"fortran": 1, "iv": 1, "languag": 1, "syntax": 1, "leavenworth": 1}}, "1140": {"id": "1140", "title": "\"Structural Connections\" in Formal Language*", "authors": "Irons, E. T.", "words_pool": ["connect", "formal", "languag", "structur", "iron"], "word_count": {"connect": 1, "formal": 1, "languag": 1, "structur": 1, "iron": 1}}, "1141": {"id": "1141", "title": "Bounded Context Syntactic Analysis", "authors": "Floyd, R. W.", "words_pool": ["analysi", "bound", "context", "syntact", "floyd"], "word_count": {"analysi": 1, "bound": 1, "context": 1, "syntact": 1, "floyd": 1}}, "1142": {"id": "1142", "title": "An Extension of ALGOL-Like Languages", "authors": "Rose, G. F.", "words_pool": ["algol", "extens", "languag", "rose"], "word_count": {"algol": 1, "extens": 1, "languag": 1, "rose": 1}}, "1143": {"id": "1143", "title": "Analysis of Decay-Type Data*", "abstract": "A comparative study has been made of a variety of numerical techniques for fitting experimental  data of the decay type by forms involving the sums of exponentials.  Statistical errors of the fitted  parameters are also calculated.  These methods have been applied to artificially-generated sets of data  as well as to the results of experiments with radioactive tracers on both human and animal subjects.   Results show that the values of the fitted parameters are very sensitive to variations in the fitting  procedure.  Therefore great care very sensitive to variations in the fitting procedure.  Therefore great  care must be exercised in identifying such values with physical constants.  Although the values of functions  derived from these fitted parameters which can definitely be associated with physical entities are generally  more stable under variations in the fitting techniques, error bounds can be so large that no great confidence  can be placed even in them.  It would therefore appear best to select a uniform technique both for running  the experiments and for analyzing the data, and then to consider as significant only relative results  between one subject and the next.", "authors": "Worsley, B. H.", "words_pool": ["analysi", "analyz", "anim", "appli", "artifici", "bound", "calcul", "care", "compar", "confid", "consid", "constant", "data", "decay", "definit", "deriv", "entiti", "error", "error", "exercis", "experiment", "experi", "exponenti", "fit", "fit", "form", "function", "gener", "gener", "great", "human", "identifi", "involv", "larg", "made", "method", "numer", "paramet", "physic", "procedur", "radioact", "rel", "result", "run", "select", "sensit", "set", "show", "signific", "stabl", "statist", "studi", "subject", "subject", "sum", "techniqu", "techniqu", "tracer", "type", "uniform", "valu", "variat", "varieti", "worsley"], "word_count": {"analysi": 1, "analyz": 1, "anim": 1, "appli": 1, "artifici": 1, "bound": 1, "calcul": 1, "care": 2, "compar": 1, "confid": 1, "consid": 1, "constant": 1, "data": 3, "decay": 1, "definit": 1, "deriv": 1, "entiti": 1, "error": 2, "exercis": 1, "experiment": 1, "experi": 2, "exponenti": 1, "fit": 7, "form": 1, "function": 1, "gener": 2, "great": 3, "human": 1, "identifi": 1, "involv": 1, "larg": 1, "made": 1, "method": 1, "numer": 1, "paramet": 3, "physic": 2, "procedur": 2, "radioact": 1, "rel": 1, "result": 3, "run": 1, "select": 1, "sensit": 2, "set": 1, "show": 1, "signific": 1, "stabl": 1, "statist": 1, "studi": 1, "subject": 2, "sum": 1, "techniqu": 3, "tracer": 1, "type": 1, "uniform": 1, "valu": 3, "variat": 3, "varieti": 1, "worsley": 1}}, "1144": {"id": "1144", "title": "Digital Computer Determination of Alpha Source Activity", "abstract": "A technique is described for determining the activity and homogeneity of an alpha source.   It is believed that the technique, using a digital computer, has many uses and applications in the field  of nuclear physics. The technique involves computer manipulation of the digital image of the nuclear  source.  Experimental details are given.", "authors": "Robbins, D. Taylor, W. E.", "words_pool": ["activ", "alpha", "applic", "believ", "comput", "detail", "determin", "determin", "digit", "experiment", "field", "homogen", "imag", "involv", "manipul", "nuclear", "physic", "sourc", "techniqu", "robbin", "taylor"], "word_count": {"activ": 1, "alpha": 1, "applic": 1, "believ": 1, "comput": 2, "detail": 1, "determin": 1, "digit": 2, "experiment": 1, "field": 1, "homogen": 1, "imag": 1, "involv": 1, "manipul": 1, "nuclear": 2, "physic": 1, "sourc": 2, "techniqu": 3, "robbin": 1, "taylor": 1}}, "1145": {"id": "1145", "title": "GIT-A Heuristic Program for Testing Pairs of Directed Line Graphs for Isomorphism*", "abstract": "Given a pair of directed line graphs, the problem of ascertaining whether or not they are isomorphic  is one for which no efficient algorithmic solution is known.  Since a straightforward enumerative algorithm  might require 40 years of running time on a very high speed computer in order to compare two 15-node  graphs, a more sophisticated approach seems called for.  The situation is similar to that prevailing  in areas such as game-playing and theorem-proving, where practical algorithms are unknown (for the interesting  cases), but where various practical though only partially successful techniques are available.  Git-Graph  Isomorphism Tester-incorporates a variety of processes that attempt to narrow down the search for an  isomorphism, or to demonstrate that none exists.  No one scheme is relied upon exclusively for a solution,  and the program is designed to avoid excessive computation along fruitless lines.  GIT has been written  in the COMIT language and successfully tested on the IBM 7090.", "authors": "Unger, S. H.", "words_pool": ["algorithm", "algorithm", "algorithm", "approach", "area", "ascertain", "attempt", "avoid", "call", "case", "comit", "compar", "comput", "comput", "demonstr", "design", "direct", "effici", "enum", "excess", "exclus", "exist", "fruitless", "game", "git", "graph", "graph", "heurist", "high", "ibm", "incorpor", "interest", "isomorph", "isomorph", "known", "languag", "line", "line", "narrow", "node", "order", "pair", "pair", "partial", "play", "practic", "prevail", "problem", "process", "program", "prove", "reli", "requir", "run", "scheme", "search", "similar", "situat", "solut", "sophist", "speed", "straightforward", "success", "success", "techniqu", "test", "tester", "test", "theorem", "time", "unknown", "varieti", "written", "year", "unger"], "word_count": {"algorithm": 3, "approach": 1, "area": 1, "ascertain": 1, "attempt": 1, "avoid": 1, "call": 1, "case": 1, "comit": 1, "compar": 1, "comput": 2, "demonstr": 1, "design": 1, "direct": 1, "effici": 1, "enum": 1, "excess": 1, "exclus": 1, "exist": 1, "fruitless": 1, "game": 1, "git": 2, "graph": 3, "heurist": 1, "high": 1, "ibm": 1, "incorpor": 1, "interest": 1, "isomorph": 3, "known": 1, "languag": 1, "line": 2, "narrow": 1, "node": 1, "order": 1, "pair": 1, "partial": 1, "play": 1, "practic": 2, "prevail": 1, "problem": 1, "process": 1, "program": 1, "prove": 1, "reli": 1, "requir": 1, "run": 1, "scheme": 1, "search": 1, "similar": 1, "situat": 1, "solut": 2, "sophist": 1, "speed": 1, "straightforward": 1, "success": 2, "techniqu": 1, "test": 1, "tester": 1, "theorem": 1, "time": 1, "unknown": 1, "varieti": 1, "written": 1, "year": 1, "unger": 1}}, "1146": {"id": "1146", "title": "An Efficient Composite Formula for Multidimensional Quadrature", "abstract": "A (2s+1)-point second-degree quadrature formula for integration over an s-dimensional hyper-rectangle  is presented.  All but one of the points lie on the surface with weights of opposite sign attached to  points on opposite faces.  When a large volume is subdivided into congruent rectangular subdivisions,  only one point is required in each interior subdivision to achieve second-degree accuracy.", "authors": "Thacher Jr., H. C.", "words_pool": ["2s", "accuraci", "achiev", "attach", "composit", "congruent", "degre", "dimension", "effici", "face", "formula", "hyper", "integr", "interior", "larg", "lie", "multidimension", "opposit", "point", "point", "present", "quadratur", "rectangl", "rectangular", "requir", "sign", "subdivid", "subdivis", "subdivis", "surfac", "volum", "weight", "thacher", "jr"], "word_count": {"2s": 1, "accuraci": 1, "achiev": 1, "attach": 1, "composit": 1, "congruent": 1, "degre": 2, "dimension": 1, "effici": 1, "face": 1, "formula": 1, "hyper": 1, "integr": 1, "interior": 1, "larg": 1, "lie": 1, "multidimension": 1, "opposit": 2, "point": 4, "present": 1, "quadratur": 1, "rectangl": 1, "rectangular": 1, "requir": 1, "sign": 1, "subdivid": 1, "subdivis": 2, "surfac": 1, "volum": 1, "weight": 1, "thacher": 1, "jr": 1}}, "1147": {"id": "1147", "title": "On the Numerical Solution of Boundary Value Problems for Linear Ordinary Differential Equations*", "abstract": "A numerical method is presented for the solution of boundary value problems involving linear  ordinary differential equations.  The method described is noniterative and makes use of any one-step  numerical integration scheme to reduce the problem from one of boundary values to one of initial values.   Comments are made concerning some numerical results of applying the method to a specific problem.  In  addition an extension of the algorithm described to more general problems is discussed.", "authors": "Day, J. T. Collins II, G. W.", "words_pool": ["addit", "algorithm", "appli", "boundari", "comment", "concern", "differenti", "discuss", "equat", "extens", "gener", "initi", "integr", "involv", "linear", "made", "make", "method", "nonit", "numer", "ordinari", "present", "problem", "problem", "reduc", "result", "scheme", "solut", "specif", "step", "valu", "day", "collin", "ii"], "word_count": {"addit": 1, "algorithm": 1, "appli": 1, "boundari": 2, "comment": 1, "concern": 1, "differenti": 1, "discuss": 1, "equat": 1, "extens": 1, "gener": 1, "initi": 1, "integr": 1, "involv": 1, "linear": 1, "made": 1, "make": 1, "method": 3, "nonit": 1, "numer": 3, "ordinari": 1, "present": 1, "problem": 4, "reduc": 1, "result": 1, "scheme": 1, "solut": 1, "specif": 1, "step": 1, "valu": 2, "day": 1, "collin": 1, "ii": 1}}, "1148": {"id": "1148", "title": "An Example in \"Significant-Digit\" Arithmetic*", "abstract": "Different methods of handling the summing process for the geometric series are shown to give  results indicating widely differing significances when carried out in a machine incorporating \"significant-digit\"  arithmetic.", "authors": "Miller, R. H.", "words_pool": ["arithmet", "carri", "differ", "digit", "geometr", "give", "handl", "incorpor", "indic", "machin", "method", "process", "result", "seri", "shown", "signific", "signific", "sum", "wide", "miller"], "word_count": {"arithmet": 1, "carri": 1, "differ": 1, "digit": 1, "geometr": 1, "give": 1, "handl": 1, "incorpor": 1, "indic": 1, "machin": 1, "method": 1, "process": 1, "result": 1, "seri": 1, "shown": 1, "signific": 2, "sum": 1, "wide": 1, "miller": 1}}, "1149": {"id": "1149", "title": "GARGOYLE , A Language for Compiler Writing*", "authors": "Garwick, J. V.", "words_pool": ["compil", "gargoyl", "languag", "write", "garwick"], "word_count": {"compil": 1, "gargoyl": 1, "languag": 1, "write": 1, "garwick": 1}}, "1150": {"id": "1150", "title": "A Fortran Post-Mortem Procedure", "authors": "Kahan, W. Leppik, J. J.", "words_pool": ["fortran", "mortem", "post", "procedur", "kahan", "leppik"], "word_count": {"fortran": 1, "mortem": 1, "post": 1, "procedur": 1, "kahan": 1, "leppik": 1}}, "1151": {"id": "1151", "title": "A Note on Multiplying Boolean Matrices II", "authors": "Comstock, D. R.", "words_pool": ["boolean", "ii", "matric", "multipli", "note", "comstock"], "word_count": {"boolean": 1, "ii": 1, "matric": 1, "multipli": 1, "note": 1, "comstock": 1}}, "1152": {"id": "1152", "title": "Floating-Point Arithmetic with 84-Bit Numbers", "abstract": "A classic and straightforward technique is presented which is not limited to the size or type  of number representation used or multiple precision arithmetic.", "authors": "Gregory, R. T. Raney, J. L.", "words_pool": ["arithmet", "bit", "classic", "float", "limit", "multipl", "number", "number", "point", "precis", "present", "represent", "size", "straightforward", "techniqu", "type", "gregori", "raney"], "word_count": {"arithmet": 1, "bit": 1, "classic": 1, "float": 1, "limit": 1, "multipl": 1, "number": 1, "point": 1, "precis": 1, "present": 1, "represent": 1, "size": 1, "straightforward": 1, "techniqu": 1, "type": 1, "gregori": 1, "raney": 1}}, "1153": {"id": "1153", "title": "A Fast Procedure for Generating Normal Random Variables*", "abstract": "A technique for generating normally distributed random numbers is described.  It is faster  than those currently in general use and is readily applicable to both binary and decimal computers.", "authors": "Marsaglia, G. MacLaren, M. D. Bray, T. A.", "words_pool": ["applic", "binari", "comput", "decim", "distribut", "fast", "faster", "gener", "gener", "normal", "number", "procedur", "random", "readili", "techniqu", "variabl", "marsaglia", "maclaren", "bray"], "word_count": {"applic": 1, "binari": 1, "comput": 1, "decim": 1, "distribut": 1, "fast": 1, "faster": 1, "gener": 2, "normal": 1, "number": 1, "procedur": 1, "random": 1, "readili": 1, "techniqu": 1, "variabl": 1, "marsaglia": 1, "maclaren": 1, "bray": 1}}, "1154": {"id": "1154", "title": "Multi-Tape and Infinite-State Automata -- A Survey", "abstract": "A survey of machines which are more powerful than finite automata and less powerful than general  Turing machines is presented.  It is felt that the machines in this category are as closely related to  digital computers as either the finite automata or the unrestricted Turing machines.  Intermediate machines  can be created by adjoining on infinite-state memory to a finite-state machine and then performing any  or all of the following: (1) restrict the manner in which the unbounded portion of the memory can be  accessed, (2) bound the number of steps allowed for a computation by some increasing recursive function  of the length of the input, (3) restrict the total amount of memory available in the same manner.  Examples  from all three classes and their properties are discussed.", "authors": "Fischer, P. C.", "words_pool": ["access", "adjoin", "allow", "amount", "automata", "bound", "categori", "class", "close", "comput", "comput", "creat", "digit", "discuss", "exampl", "felt", "finit", "function", "gener", "increas", "infinit", "input", "intermedi", "length", "machin", "machin", "manner", "memori", "multi", "number", "perform", "portion", "power", "present", "properti", "recurs", "relat", "restrict", "state", "step", "survey", "tape", "total", "ture", "unbound", "unrestrict", "fischer"], "word_count": {"access": 1, "adjoin": 1, "allow": 1, "amount": 1, "automata": 2, "bound": 1, "categori": 1, "class": 1, "close": 1, "comput": 2, "creat": 1, "digit": 1, "discuss": 1, "exampl": 1, "felt": 1, "finit": 3, "function": 1, "gener": 1, "increas": 1, "infinit": 1, "input": 1, "intermedi": 1, "length": 1, "machin": 6, "manner": 2, "memori": 3, "multi": 1, "number": 1, "perform": 1, "portion": 1, "power": 2, "present": 1, "properti": 1, "recurs": 1, "relat": 1, "restrict": 2, "state": 2, "step": 1, "survey": 1, "tape": 1, "total": 1, "ture": 2, "unbound": 1, "unrestrict": 1, "fischer": 1}}, "1155": {"id": "1155", "title": "Experiments with a Deductive Question-Answering Program", "abstract": "As an investigation in artificial intelligence, computer experiments on deductive question-answering  were run with a LISP program called DEDUCOM, an acronym for DEDUctive COMmunicator. When given 68 facts,  DEDUCOM answered 10 questions answerable from the facts.  A fact tells DEDUCOM either some specific information  or a method of answering a general kind of question.  Some conclusions drawn in the article are: (1)  DEDUCOM can answer a wide variety of questions.  (2) A human can increase the deductive power of DEDUCOM  by telling it more facts.  (3) DEDUCOM can write very simple programs (it is hoped that this ability  is the forerunner of an ability to self-program, which is a way to learn).  (4)DEDUCOM's search procedure  at present has two bad defects: some questions answerable from the given facts cannot be answered and  some other answerable questions can be answered only if the relevant facts are given in the \"right\" order.   (6) At present, DEDUCOM's method of making logical deductions in predicate calculus has two bad defects:  some facts have to be changed to logically equivalent ones before being given to DEDUCOM, and some redundant  facts have to be given to DEDUCOM.", "authors": "Slagle, J. R.", "words_pool": ["abil", "acronym", "answer", "answer", "answer", "answer", "articl", "artifici", "bad", "calculu", "call", "chang", "commun", "comput", "conclus", "deducom", "deduct", "deduct", "defect", "drawn", "equival", "experi", "fact", "fact", "forerunn", "gener", "hope", "human", "increas", "inform", "intellig", "investig", "kind", "learn", "lisp", "logic", "logic", "make", "method", "order", "power", "predic", "present", "procedur", "program", "program", "question", "question", "redund", "relev", "run", "search", "simpl", "specif", "tell", "tell", "varieti", "wide", "write", "slagl"], "word_count": {"abil": 2, "acronym": 1, "answer": 9, "articl": 1, "artifici": 1, "bad": 2, "calculu": 1, "call": 1, "chang": 1, "commun": 1, "comput": 1, "conclus": 1, "deducom": 10, "deduct": 4, "defect": 2, "drawn": 1, "equival": 1, "experi": 1, "fact": 8, "forerunn": 1, "gener": 1, "hope": 1, "human": 1, "increas": 1, "inform": 1, "intellig": 1, "investig": 1, "kind": 1, "learn": 1, "lisp": 1, "logic": 2, "make": 1, "method": 2, "order": 1, "power": 1, "predic": 1, "present": 2, "procedur": 1, "program": 3, "question": 6, "redund": 1, "relev": 1, "run": 1, "search": 1, "simpl": 1, "specif": 1, "tell": 2, "varieti": 1, "wide": 1, "write": 1, "slagl": 1}}, "1156": {"id": "1156", "title": "Hankel Function (Algorithm 124 [S17])", "authors": "Reilly, G. A.", "words_pool": ["algorithm", "function", "hankel", "s17", "reilli"], "word_count": {"algorithm": 1, "function": 1, "hankel": 1, "s17": 1, "reilli": 1}}, "1157": {"id": "1157", "title": "Procedure for the Normal Distribution Functions (Algorithm 272 [S15])", "authors": "MacLaren, M. D.", "words_pool": ["algorithm", "distribut", "function", "normal", "procedur", "s15", "maclaren"], "word_count": {"algorithm": 1, "distribut": 1, "function": 1, "normal": 1, "procedur": 1, "s15": 1, "maclaren": 1}}, "1158": {"id": "1158", "title": "Program Structures for Parallel Processing", "abstract": "Constructs for organizing and explicating parallel program segments are discussed as extensions  to ALGOL 60.  The constructs serve as meta-commands and are motivated by equipment having multiprocessing  capability.", "authors": "Anderson, J. P.", "words_pool": ["algol", "capabl", "command", "construct", "discuss", "equip", "explic", "extens", "meta", "motiv", "multiprocess", "organ", "parallel", "process", "program", "segment", "serv", "structur", "anderson"], "word_count": {"algol": 1, "capabl": 1, "command": 1, "construct": 2, "discuss": 1, "equip": 1, "explic": 1, "extens": 1, "meta": 1, "motiv": 1, "multiprocess": 1, "organ": 1, "parallel": 1, "process": 1, "program": 1, "segment": 1, "serv": 1, "structur": 1, "anderson": 1}}, "1159": {"id": "1159", "title": "Machine Independence: Its Technology and Economics", "abstract": "A survey is offered of techniques for transferring programs, and especially compilers, from  one computer to another.  Of the methods examined, the \"bootstrap\" technique is singled out for detailed  discussion, with emphasis on its economics. The considerations that determine the applicability of bootstrapping  in any specific case are discussed, and an attempt is made to assign appropriate qualitative weights  to them.  Finally, reasons are given for believing that the machine-independence problem is being substantially  diminished by current trends in computer design, and that it is this process of convergence in hardware  design rather than any foreseeable software developments that will lead to its satisfactory resolution.", "authors": "Halpern, M. I.", "words_pool": ["applic", "assign", "attempt", "believ", "bootstrap", "bootstrap", "case", "compil", "comput", "consider", "converg", "design", "detail", "determin", "develop", "diminish", "discuss", "discuss", "econom", "emphasi", "especi", "examin", "final", "forese", "hardwar", "independ", "lead", "machin", "made", "method", "offer", "problem", "process", "program", "qualit", "reason", "resolut", "satisfactori", "singl", "softwar", "specif", "substanti", "survey", "techniqu", "techniqu", "technolog", "transfer", "trend", "weight", "halpern"], "word_count": {"applic": 1, "assign": 1, "attempt": 1, "believ": 1, "bootstrap": 2, "case": 1, "compil": 1, "comput": 2, "consider": 1, "converg": 1, "design": 2, "detail": 1, "determin": 1, "develop": 1, "diminish": 1, "discuss": 2, "econom": 1, "emphasi": 1, "especi": 1, "examin": 1, "final": 1, "forese": 1, "hardwar": 1, "independ": 1, "lead": 1, "machin": 1, "made": 1, "method": 1, "offer": 1, "problem": 1, "process": 1, "program": 1, "qualit": 1, "reason": 1, "resolut": 1, "satisfactori": 1, "singl": 1, "softwar": 1, "specif": 1, "substanti": 1, "survey": 1, "techniqu": 2, "technolog": 1, "transfer": 1, "trend": 1, "weight": 1, "halpern": 1}}, "1160": {"id": "1160", "title": "CAT: A 7090-3600 Computer-Aided Translation", "abstract": "A semi-automatic translation system has been implemented which converts 7090 FAP language programs  into 3600 assembly language.  The input to the system is a FAP program deck which has been specially  prepared for translation by the user.  The output consists of the translated COMPASS language program  together with a comprehensive diagnostic listing which the user must analyze in order to verify any questionable  areas of the translation.  The translation processor consists of three distinct phases: an assembly of  the FAP program, a comprehensive analysis of the assembled code with particular regard to the actions  of instructions upon other instructions and upon data, and finally the output pass which generates the  COMPASS program in the form of macro instructions.", "authors": "Wilson, D. M.  Moss, D. J.", "words_pool": ["action", "aid", "analysi", "analyz", "area", "assembl", "assembl", "automat", "cat", "code", "compass", "comprehens", "comput", "consist", "convert", "data", "deck", "diagnost", "distinct", "fap", "final", "form", "gener", "implement", "input", "instruct", "languag", "list", "macro", "order", "output", "pass", "phase", "prepar", "processor", "program", "program", "question", "regard", "semi", "special", "system", "translat", "translat", "user", "verifi", "wilson", "moss"], "word_count": {"action": 1, "aid": 1, "analysi": 1, "analyz": 1, "area": 1, "assembl": 3, "automat": 1, "cat": 1, "code": 1, "compass": 2, "comprehens": 2, "comput": 1, "consist": 2, "convert": 1, "data": 1, "deck": 1, "diagnost": 1, "distinct": 1, "fap": 3, "final": 1, "form": 1, "gener": 1, "implement": 1, "input": 1, "instruct": 3, "languag": 3, "list": 1, "macro": 1, "order": 1, "output": 2, "pass": 1, "phase": 1, "prepar": 1, "processor": 1, "program": 5, "question": 1, "regard": 1, "semi": 1, "special": 1, "system": 2, "translat": 5, "user": 2, "verifi": 1, "wilson": 1, "moss": 1}}, "1161": {"id": "1161", "title": "1401 Compatibility Feature on the IBM System/360 Model 30", "abstract": "The \"second generation\" of stored-program computers, of which IBM 1400 series was a part, brought  EDP into the mass market for the first time on a large scale.  As this era unfolded, rapid changes in  technology led to rapid obsolescence of data processing equipment.  Program written for a particular  system required tedious conversion as incompatible new machines came into use.  The IBM System/360 has  been designed with the conversion problem specifically in mind.  One of the conversion aids available  on the Model 30 is the 1401 compatibility feature.  This feature, in conjunction with other aids, permits  a smooth and inexpensive transition to optimum use of the new system.", "authors": "McCormack, M. A. Schansman, T. T. Womack, K. K.", "words_pool": ["aid", "brought", "came", "compat", "comput", "conjunct", "convers", "data", "design", "edp", "equip", "era", "featur", "gener", "ibm", "incompat", "inexpens", "larg", "led", "machin", "market", "mass", "mind", "model", "obsolesc", "optimum", "part", "permit", "problem", "process", "program", "rapid", "requir", "scale", "seri", "smooth", "specif", "store", "system", "technolog", "tediou", "time", "transit", "unfold", "written", "mccormack", "schansman", "womack"], "word_count": {"aid": 2, "brought": 1, "came": 1, "compat": 1, "comput": 1, "conjunct": 1, "convers": 3, "data": 1, "design": 1, "edp": 1, "equip": 1, "era": 1, "featur": 2, "gener": 1, "ibm": 2, "incompat": 1, "inexpens": 1, "larg": 1, "led": 1, "machin": 1, "market": 1, "mass": 1, "mind": 1, "model": 1, "obsolesc": 1, "optimum": 1, "part": 1, "permit": 1, "problem": 1, "process": 1, "program": 2, "rapid": 2, "requir": 1, "scale": 1, "seri": 1, "smooth": 1, "specif": 1, "store": 1, "system": 3, "technolog": 1, "tediou": 1, "time": 1, "transit": 1, "unfold": 1, "written": 1, "mccormack": 1, "schansman": 1, "womack": 1}}, "1162": {"id": "1162", "title": "An Assembly Language for Reprogramming", "abstract": "Complete reprogramming of compiler language programs is seldom necessary.  It is assembly language  programs which present the greatest difficulty.  Assembly languages generally provide a one-for-one translation  from a symbolic to a numeric version of a program, that is, from assembly language to machine language.   The meta-language presented here can be used to specify the mapping of any language which conforms to  a canonical list form into an arbitrary stream of bits.  This bit stream may be treated as a machine  language program, a character stream, or whatever else the user might desire.  Thus, this meta-language  can be used to map from one assembly language into another or from the assembly language for one machine  into the machine language of another.", "authors": "Graham, M. L. Ingerman, P. Z.", "words_pool": ["arbitrari", "assembl", "bit", "bit", "canon", "charact", "compil", "complet", "conform", "desir", "difficulti", "form", "gener", "greatest", "languag", "languag", "list", "machin", "map", "map", "meta", "numer", "present", "present", "program", "program", "provid", "reprogram", "seldom", "stream", "symbol", "translat", "treat", "user", "version", "graham", "ingerman"], "word_count": {"arbitrari": 1, "assembl": 5, "bit": 2, "canon": 1, "charact": 1, "compil": 1, "complet": 1, "conform": 1, "desir": 1, "difficulti": 1, "form": 1, "gener": 1, "greatest": 1, "languag": 12, "list": 1, "machin": 4, "map": 2, "meta": 2, "numer": 1, "present": 2, "program": 4, "provid": 1, "reprogram": 1, "seldom": 1, "stream": 3, "symbol": 1, "translat": 1, "treat": 1, "user": 1, "version": 1, "graham": 1, "ingerman": 1}}, "1163": {"id": "1163", "title": "Philco/IBM Translation at Problem-Oriented, Symbolic and Binary Levels", "abstract": "A translation system has been developed to eliminate most of the effort formerly required to  reprogram Philco 2000 series codes for IBM 7094 operation.  Experience with this system is limited but  highly successful encouraging application of the techniques to other source and object languages.", "authors": "Olsen, T. M.", "words_pool": ["applic", "binari", "code", "develop", "effort", "elimin", "encourag", "experi", "highli", "ibm", "languag", "level", "limit", "object", "oper", "orient", "philco", "problem", "reprogram", "requir", "seri", "sourc", "success", "symbol", "system", "techniqu", "translat", "olsen"], "word_count": {"applic": 1, "binari": 1, "code": 1, "develop": 1, "effort": 1, "elimin": 1, "encourag": 1, "experi": 1, "highli": 1, "ibm": 1, "languag": 1, "level": 1, "limit": 1, "object": 1, "oper": 1, "orient": 1, "philco": 1, "problem": 1, "reprogram": 1, "requir": 1, "seri": 1, "sourc": 1, "success": 1, "symbol": 1, "system": 2, "techniqu": 1, "translat": 1, "olsen": 1}}, "1164": {"id": "1164", "title": "Emulation of Large Systems", "abstract": "The conversion problem and a new technique called emulation are discussed.  The technique of  emulation is developed and includes sections on both the Central Processing Unit (CPU) and the Input/Output  unit (I/O).  This general treatment is followed by three sections that describe in greater detail the  implementation of compatibility features using the emulation techniques for the IBM 7074, 7080 and 7090  systems on IBM System/360.", "authors": "Tucker, S. G.", "words_pool": ["call", "central", "compat", "convers", "cpu", "describ", "detail", "develop", "discuss", "emul", "featur", "gener", "greater", "ibm", "implement", "includ", "input", "larg", "output", "problem", "process", "section", "system", "system", "techniqu", "techniqu", "treatment", "unit", "tucker"], "word_count": {"call": 1, "central": 1, "compat": 1, "convers": 1, "cpu": 1, "describ": 1, "detail": 1, "develop": 1, "discuss": 1, "emul": 3, "featur": 1, "gener": 1, "greater": 1, "ibm": 2, "implement": 1, "includ": 1, "input": 1, "larg": 1, "output": 1, "problem": 1, "process": 1, "section": 2, "system": 2, "techniqu": 3, "treatment": 1, "unit": 2, "tucker": 1}}, "1165": {"id": "1165", "title": "The Spectra 70/45 Emulator for the RCA 301", "abstract": "The RCA 301 Emulator System is supplied with the Spectra 70/45 as a reprogramming aid.  It  allows an RCA 301 object program to be run on the Spectra 70/45 without necessitating changes in the  RCA 301 object code.  Execution rates are considerably better than traditional simulation.  The Emulator  provides an increase in throughput capacity for the 301 user on the Spectra 70/45.  The Emulator makes  use of both hardware micro-program routines and software routines to accomplish its function.", "authors": "Benjamin, R. I.", "words_pool": ["accomplish", "aid", "capac", "code", "consider", "emul", "execut", "function", "hardwar", "increas", "make", "micro", "necessit", "object", "program", "rate", "rca", "reprogram", "routin", "run", "simul", "softwar", "spectra", "suppli", "system", "throughput", "tradit", "user", "benjamin"], "word_count": {"accomplish": 1, "aid": 1, "capac": 1, "code": 1, "consider": 1, "emul": 3, "execut": 1, "function": 1, "hardwar": 1, "increas": 1, "make": 1, "micro": 1, "necessit": 1, "object": 2, "program": 2, "rate": 1, "rca": 3, "reprogram": 1, "routin": 2, "run": 1, "simul": 1, "softwar": 1, "spectra": 3, "suppli": 1, "system": 1, "throughput": 1, "tradit": 1, "user": 1, "benjamin": 1}}, "1166": {"id": "1166", "title": "A Use of Macros in Translation of Symbolic Assembly Language of One Computer to Another", "abstract": "A set of macro-operations has been prepared to assist in translating IBM 7090 symbolic assembly  language programs to IBM 7040 machine language programs.  This set, inserted at the beginning of the  7090 symbolic deck, treats incompatible instruction mnemonics as macro-instructions to produce equivalent  7040 instruction sets.  Incompatible instructions are categorized into basic operational classes which  can be expressed by a single basic skeleton.  Several levels of macro calls are required to supply arguments  to the basic skeleton for each particular instruction.  Modification at execution time of the address  or tag of an incompatible instruction requires incorporation of an address-tag equivalent.  I/O is handled  by generating calls to I/O simulation subroutines.", "authors": "Dellert Jr., G. T.", "words_pool": ["address", "argument", "assembl", "assist", "basic", "begin", "call", "categor", "class", "comput", "deck", "equival", "execut", "express", "gener", "handl", "ibm", "incompat", "incorpor", "insert", "instruct", "instruct", "languag", "level", "machin", "macro", "macro", "mnemon", "modif", "oper", "oper", "prepar", "produc", "program", "requir", "requir", "set", "set", "simul", "singl", "skeleton", "subroutin", "suppli", "symbol", "tag", "time", "translat", "translat", "treat", "dellert", "jr"], "word_count": {"address": 2, "argument": 1, "assembl": 1, "assist": 1, "basic": 3, "begin": 1, "call": 2, "categor": 1, "class": 1, "comput": 1, "deck": 1, "equival": 2, "execut": 1, "express": 1, "gener": 1, "handl": 1, "ibm": 2, "incompat": 3, "incorpor": 1, "insert": 1, "instruct": 6, "languag": 2, "level": 1, "machin": 1, "macro": 3, "mnemon": 1, "modif": 1, "oper": 2, "prepar": 1, "produc": 1, "program": 2, "requir": 2, "set": 3, "simul": 1, "singl": 1, "skeleton": 2, "subroutin": 1, "suppli": 1, "symbol": 2, "tag": 2, "time": 1, "translat": 1, "treat": 1, "dellert": 1, "jr": 1}}, "1167": {"id": "1167", "title": "On the Translation of Machine Language Programs", "abstract": "Automatic translation of machine language programs is becoming a highly desirable goal with  the advent of new large-scale computers.  The pitfalls that make it difficult to achieve completely automatic  translations are analyzed, and it is shown that these are primarily of a semantic nature.  A semi-automatic  procedure for resolving semantic problems is suggested.", "authors": "Gaines, R. S.", "words_pool": ["achiev", "advent", "analyz", "automat", "complet", "comput", "desir", "difficult", "goal", "highli", "languag", "larg", "machin", "make", "natur", "pitfal", "primarili", "problem", "procedur", "program", "resolv", "scale", "semant", "semi", "shown", "suggest", "translat", "translat", "gain"], "word_count": {"achiev": 1, "advent": 1, "analyz": 1, "automat": 3, "complet": 1, "comput": 1, "desir": 1, "difficult": 1, "goal": 1, "highli": 1, "languag": 1, "larg": 1, "machin": 1, "make": 1, "natur": 1, "pitfal": 1, "primarili": 1, "problem": 1, "procedur": 1, "program": 1, "resolv": 1, "scale": 1, "semant": 2, "semi": 1, "shown": 1, "suggest": 1, "translat": 2, "gain": 1}}, "1168": {"id": "1168", "title": "Across Machine Lines in COBOL", "abstract": "The production of a large, file-maintenance-and-retrieval program system written in COBOL is  described.  The COBOL language was used specifically to enable the system to operate on three IBM computers.", "authors": "Fredericks, D. S. Warburtin, C. R.", "words_pool": ["cobol", "comput", "enabl", "ibm", "languag", "larg", "line", "machin", "mainten", "oper", "product", "program", "retriev", "specif", "system", "written", "frederick", "warburtin"], "word_count": {"cobol": 2, "comput": 1, "enabl": 1, "ibm": 1, "languag": 1, "larg": 1, "line": 1, "machin": 1, "mainten": 1, "oper": 1, "product": 1, "program": 1, "retriev": 1, "specif": 1, "system": 2, "written": 1, "frederick": 1, "warburtin": 1}}, "1169": {"id": "1169", "title": "hen the exchange corresponding to the least negative increment of  {Delta F} is performed.  The process is iterated and stopped when the set of the increments is a positive  or empty set, which, it is proved, corresponds to a minimum.  The procedure is similar to the Downhill  Method for finding the minimum of a real function F(P), and can be applied to other placement problems.   Experimental results are presented with backboards formed by many elements and different initial placements.", "abstract": "A partially exhaustive algorithm is presented for solving the following problem arising from  automatic layout of a computer.  Given an ordered set E1, E2,..., EN of N computer components, for each  permutation of the elements E1, E2.., EN, there is attached a value of an integer function F.  The algorithm  finds a local minimum of F by evaluating the set {Delta F} of the increments corresponding to a certain  set of exchanges of two elements", "authors": "Pomentale, T.", "words_pool": ["algorithm", "appli", "aris", "attach", "automat", "backboard", "compon", "comput", "correspond", "delta", "downhil", "e1", "e2", "element", "empti", "en", "evalu", "exchang", "exchang", "exhaust", "experiment", "find", "find", "form", "function", "hen", "increment", "increment", "initi", "integ", "iter", "layout", "local", "method", "minimum", "neg", "order", "partial", "perform", "permut", "placement", "placement", "posit", "present", "problem", "problem", "procedur", "process", "prove", "real", "result", "set", "similar", "solv", "stop", "pomental"], "word_count": {"algorithm": 2, "appli": 1, "aris": 1, "attach": 1, "automat": 1, "backboard": 1, "compon": 1, "comput": 2, "correspond": 1, "delta": 1, "downhil": 1, "e1": 2, "e2": 2, "element": 2, "empti": 1, "en": 2, "evalu": 1, "exchang": 1, "exhaust": 1, "experiment": 1, "find": 1, "form": 1, "function": 1, "hen": 1, "increment": 1, "initi": 1, "integ": 1, "iter": 1, "layout": 1, "local": 1, "method": 1, "minimum": 1, "neg": 1, "order": 1, "partial": 1, "perform": 1, "permut": 1, "placement": 2, "posit": 1, "present": 1, "problem": 1, "procedur": 1, "process": 1, "prove": 1, "real": 1, "result": 1, "set": 3, "similar": 1, "solv": 1, "stop": 1, "pomental": 1}}, "1170": {"id": "1170", "title": "Analyzing English Syntax with a Pattern-Learning Parser", "abstract": "A dependency analysis system based on pattern recognition and learning logic was developed  to infer word classes and rules of syntactic combination from experience with text which had been analyzed.   The characteristics used to form word classes are the depth in the dependency tree of each word, the  direction of its governor and the same features for each of its immediate neighbors. Syntactic rules  of combination show the relation of a word to its governor in the depth pattern of the sentence.  The  system was tested on 400 elementary basic English sentences including 300 used earlier by Knowlton in  a different learning parser of all 400 sentences.  After experience with 300 sentences it was able to  generalize with 77 percent accuracy to the next 100.  In accumulative learning trials after the first  200 sentences it averaged a probability of .9 for accurately parsing each new sentence it encountered.   It was concluded that the system is adequate for learning to parse the bulk of basic English but that  further development is required before conclusions about its application to ordinary English can be stored.   The system is operational and available on the ARPA/SDC time-shared computing system.", "authors": "McConlogue, K. Simmons, R. F.", "words_pool": ["abl", "accumul", "accuraci", "accur", "adequ", "analysi", "analyz", "analyz", "applic", "arpa", "averag", "base", "basic", "bulk", "characterist", "class", "combin", "comput", "conclud", "conclus", "depend", "depth", "develop", "develop", "direct", "earlier", "elementari", "encount", "english", "experi", "featur", "form", "gener", "governor", "includ", "infer", "knowlton", "learn", "logic", "neighbor", "oper", "ordinari", "pars", "parser", "pars", "pattern", "percent", "probabl", "recognit", "relat", "requir", "rule", "sdc", "sentenc", "sentenc", "share", "show", "store", "syntact", "syntax", "system", "test", "text", "time", "tree", "trial", "word", "mcconlogu", "simmon"], "word_count": {"abl": 1, "accumul": 1, "accuraci": 1, "accur": 1, "adequ": 1, "analysi": 1, "analyz": 1, "applic": 1, "arpa": 1, "averag": 1, "base": 1, "basic": 2, "bulk": 1, "characterist": 1, "class": 2, "combin": 2, "comput": 1, "conclud": 1, "conclus": 1, "depend": 2, "depth": 2, "develop": 2, "direct": 1, "earlier": 1, "elementari": 1, "encount": 1, "english": 3, "experi": 2, "featur": 1, "form": 1, "gener": 1, "governor": 2, "includ": 1, "infer": 1, "knowlton": 1, "learn": 4, "logic": 1, "neighbor": 1, "oper": 1, "ordinari": 1, "pars": 2, "parser": 1, "pattern": 2, "percent": 1, "probabl": 1, "recognit": 1, "relat": 1, "requir": 1, "rule": 2, "sdc": 1, "sentenc": 6, "share": 1, "show": 1, "store": 1, "syntact": 2, "syntax": 1, "system": 5, "test": 1, "text": 1, "time": 1, "tree": 1, "trial": 1, "word": 4, "mcconlogu": 1, "simmon": 1}}, "1171": {"id": "1171", "title": "A Comparison of the Primal-Simplex and Primal-Dual Algorithms for Linear Programming", "abstract": "A statistical comparison of the primal-dual and the more commonly used primal-simplex algorithm  for solving linear programming problems has been made under the assumption of starting with a full artificial  basis.  Under these conditions the primal-dual method shows a statistically significant superiority on  randomly generated problems.  It has also been found, via a regression analysis, that the relevant parameters  in determining the difference in the number of iterations between the algorithms is not only the number  of constraints and the number of variables but also the ratio of the latter to the former.", "authors": "Mueller, R. K. Cooper, L.", "words_pool": ["algorithm", "algorithm", "analysi", "artifici", "assumpt", "basi", "commonli", "comparison", "condit", "constraint", "determin", "differ", "dual", "found", "full", "gener", "iter", "linear", "made", "method", "number", "paramet", "primal", "problem", "program", "randomli", "ratio", "regress", "relev", "show", "signific", "simplex", "solv", "start", "statist", "statist", "superior", "variabl", "mueller", "cooper"], "word_count": {"algorithm": 2, "analysi": 1, "artifici": 1, "assumpt": 1, "basi": 1, "commonli": 1, "comparison": 1, "condit": 1, "constraint": 1, "determin": 1, "differ": 1, "dual": 2, "found": 1, "full": 1, "gener": 1, "iter": 1, "linear": 1, "made": 1, "method": 1, "number": 3, "paramet": 1, "primal": 3, "problem": 2, "program": 1, "randomli": 1, "ratio": 1, "regress": 1, "relev": 1, "show": 1, "signific": 1, "simplex": 1, "solv": 1, "start": 1, "statist": 2, "superior": 1, "variabl": 1, "mueller": 1, "cooper": 1}}, "1172": {"id": "1172", "title": "Conversion of Limited-Entry Decision Tables to Computer Programs", "abstract": "Decision tables are useful for describing a set of complex decision rules based on given sets  of conditions.  Algorithms that can efficiently convert the tables into computer programs will extend  the usefulness of decision tables to computer users.  Two such algorithms, based on work done by M. S.  Montalbano, are described and extended here to handle dashes and ELSE-decision rules.  The first algorithm  minimizes the computer storage space required for the resultant program, the second minimizes computer  running time. During the conversion process, both pinpoint any contradictions or redundancies among the  rules in a table.", "authors": "Pollack, S. L.", "words_pool": ["algorithm", "algorithm", "base", "complex", "comput", "condit", "contradict", "convers", "convert", "dash", "decis", "describ", "effici", "entri", "extend", "extend", "handl", "limit", "minim", "montalbano", "pinpoint", "process", "program", "program", "redund", "requir", "result", "rule", "run", "set", "set", "space", "storag", "tabl", "tabl", "time", "use", "user", "work", "pollack"], "word_count": {"algorithm": 3, "base": 2, "complex": 1, "comput": 4, "condit": 1, "contradict": 1, "convers": 1, "convert": 1, "dash": 1, "decis": 4, "describ": 1, "effici": 1, "entri": 1, "extend": 2, "handl": 1, "limit": 1, "minim": 2, "montalbano": 1, "pinpoint": 1, "process": 1, "program": 2, "redund": 1, "requir": 1, "result": 1, "rule": 3, "run": 1, "set": 2, "space": 1, "storag": 1, "tabl": 4, "time": 1, "use": 1, "user": 1, "work": 1, "pollack": 1}}, "1173": {"id": "1173", "title": "The Performance of a System for Automatic Segmentation of Programs Within an ALGOL Compiler (GIER  ALGOL)", "abstract": "The GIER ALGOL compiler makes use of an automatic system for handling the transfers of program  segments from the drum store to the core store at program execution time.  The logic of this system is  described. The performance of the system is discussed, primarily on the basis of execution times related  to two specific programs.  This discussion concludes with an assessment of the potential gains of various  ways of improving the system.", "authors": "Naur, P.", "words_pool": ["algol", "assess", "automat", "basi", "compil", "conclud", "core", "discuss", "discuss", "drum", "execut", "gain", "gier", "handl", "improv", "logic", "make", "perform", "potenti", "primarili", "program", "program", "relat", "segment", "segment", "specif", "store", "system", "time", "time", "transfer", "way", "naur"], "word_count": {"algol": 1, "assess": 1, "automat": 1, "basi": 1, "compil": 1, "conclud": 1, "core": 1, "discuss": 2, "drum": 1, "execut": 2, "gain": 1, "gier": 1, "handl": 1, "improv": 1, "logic": 1, "make": 1, "perform": 1, "potenti": 1, "primarili": 1, "program": 3, "relat": 1, "segment": 1, "specif": 1, "store": 2, "system": 4, "time": 2, "transfer": 1, "way": 1, "naur": 1}}, "1174": {"id": "1174", "title": "Inverse Permutation (Algorithm 250 [G6])", "authors": "Medlock, C. W.", "words_pool": ["algorithm", "g6", "invers", "permut", "medlock"], "word_count": {"algorithm": 1, "g6": 1, "invers": 1, "permut": 1, "medlock": 1}}, "1175": {"id": "1175", "title": "Quickersort (Algorithm 271 [M1])", "authors": "Scowen, R. S.", "words_pool": ["algorithm", "m1", "quickersort", "scowen"], "word_count": {"algorithm": 1, "m1": 1, "quickersort": 1, "scowen": 1}}, "1176": {"id": "1176", "title": "Finding Eigenvectors by Gaussian Elimination (Algorithm 270 [F2])", "authors": "Newhouse, A.", "words_pool": ["algorithm", "eigenvector", "elimin", "f2", "find", "gaussian", "newhous"], "word_count": {"algorithm": 1, "eigenvector": 1, "elimin": 1, "f2": 1, "find": 1, "gaussian": 1, "newhous": 1}}, "1177": {"id": "1177", "title": "Determinant Evaluation (Algorithm 269 [F3])", "authors": "Pfann, J.", "words_pool": ["algorithm", "determin", "evalu", "f3", "pfann"], "word_count": {"algorithm": 1, "determin": 1, "evalu": 1, "f3": 1, "pfann": 1}}, "1178": {"id": "1178", "title": "ALGOL 60 Reference Language Editor (Algorithm 268 [R2])", "authors": "McKeeman, W. M.", "words_pool": ["algol", "algorithm", "editor", "languag", "r2", "refer", "mckeeman"], "word_count": {"algol": 1, "algorithm": 1, "editor": 1, "languag": 1, "r2": 1, "refer": 1, "mckeeman": 1}}, "1179": {"id": "1179", "title": "PUFFT-The Purdue University Fast FORTRAN Translator", "abstract": "A core resident, compile-and-go system designed for the IBM 7090/7094 computer is described.   In little more than half of the 32k word core memory PUFFT provides a monitor for job sequencing, a  translator for the full FORTRAN IV language, the FORTRAN subroutine library, an input--output system  for use at compile time and at execute time, and a rather elaborate diagnostic message writing routine.   Batches of small- and medium-sized FORTRAN IV source language programs are processed at very high speeds.   Language compatibility has been maintained so that programs may be debugged in the PUFFT system and  then recompiled and run in the IBJOB-IBFTC system supplied by the manufacturer.", "authors": "Rosen, S. Spurgeon, A. Donnelly, J. K.", "words_pool": ["32k", "batch", "compat", "compil", "comput", "core", "debug", "design", "diagnost", "elabor", "execut", "fast", "fortran", "full", "half", "high", "ibftc", "ibjob", "ibm", "input", "iv", "job", "languag", "librari", "maintain", "manufactur", "medium", "memori", "messag", "monitor", "output", "process", "program", "pufft", "purdu", "recompil", "resid", "routin", "run", "sequenc", "size", "small", "sourc", "speed", "subroutin", "suppli", "system", "time", "translat", "univers", "word", "write", "rosen", "spurgeon", "donnelli"], "word_count": {"32k": 1, "batch": 1, "compat": 1, "compil": 2, "comput": 1, "core": 2, "debug": 1, "design": 1, "diagnost": 1, "elabor": 1, "execut": 1, "fast": 1, "fortran": 3, "full": 1, "half": 1, "high": 1, "ibftc": 1, "ibjob": 1, "ibm": 1, "input": 1, "iv": 2, "job": 1, "languag": 3, "librari": 1, "maintain": 1, "manufactur": 1, "medium": 1, "memori": 1, "messag": 1, "monitor": 1, "output": 1, "process": 1, "program": 2, "pufft": 2, "purdu": 1, "recompil": 1, "resid": 1, "routin": 1, "run": 1, "sequenc": 1, "size": 1, "small": 1, "sourc": 1, "speed": 1, "subroutin": 1, "suppli": 1, "system": 4, "time": 2, "translat": 1, "univers": 1, "word": 1, "write": 1, "rosen": 1, "spurgeon": 1, "donnelli": 1}}, "1180": {"id": "1180", "title": "AXLE: An Axiomatic Language for String Transformations", "abstract": "AXLE is a language designed for data manipulation.  Data arranged in a linear form in a workspace  is transformed according to a table of axioms, called imperatives.  A transformation consists of a matching  procedure, which decides where an imperative is applicable, and a replacement procedure that modifies  that part of the workspace.  Imperatives are applied in accordance with definitions of symbolic terms,  presented systematically in an assertion table.  The process of definition includes the special case  of recursive assertions.  Several complete programs of imperatives are given to show a few applications of the language.", "authors": "Cohen, I. Wegstein, J. H.", "words_pool": ["accord", "accord", "applic", "applic", "appli", "arrang", "assert", "assert", "axiomat", "axiom", "axl", "call", "case", "complet", "consist", "data", "decid", "definit", "definit", "design", "form", "imper", "imper", "includ", "languag", "linear", "manipul", "match", "modifi", "part", "present", "procedur", "process", "program", "recurs", "replac", "show", "special", "string", "symbol", "systemat", "tabl", "term", "transform", "transform", "transform", "workspac", "cohen", "wegstein"], "word_count": {"accord": 2, "applic": 2, "appli": 1, "arrang": 1, "assert": 2, "axiomat": 1, "axiom": 1, "axl": 1, "call": 1, "case": 1, "complet": 1, "consist": 1, "data": 2, "decid": 1, "definit": 2, "design": 1, "form": 1, "imper": 4, "includ": 1, "languag": 2, "linear": 1, "manipul": 1, "match": 1, "modifi": 1, "part": 1, "present": 1, "procedur": 2, "process": 1, "program": 1, "recurs": 1, "replac": 1, "show": 1, "special": 1, "string": 1, "symbol": 1, "systemat": 1, "tabl": 2, "term": 1, "transform": 2, "workspac": 2, "cohen": 1, "wegstein": 1}}, "1181": {"id": "1181", "title": "A Simple Data Transmission System Using the Office Telephone", "abstract": "A method has evolved for transmitting data of a type originating in many laboratory situation  direct to a central computer.  The method requires almost no specialized equipment and uses any ordinary  telephone on a \"callup\" basis.  Present applications include cardiac-output calculations, radio-activity  tracer studies and neurophysiology time-sequence studies of nerve impulses.", "authors": "Neilsen, I. R.", "words_pool": ["activ", "applic", "basi", "calcul", "callup", "cardiac", "central", "comput", "data", "direct", "equip", "evolv", "impuls", "includ", "laboratori", "method", "nerv", "neurophysiolog", "offic", "ordinari", "origin", "output", "present", "radio", "requir", "sequenc", "simpl", "situat", "special", "studi", "system", "telephon", "time", "tracer", "transmiss", "transmit", "type", "neilsen"], "word_count": {"activ": 1, "applic": 1, "basi": 1, "calcul": 1, "callup": 1, "cardiac": 1, "central": 1, "comput": 1, "data": 1, "direct": 1, "equip": 1, "evolv": 1, "impuls": 1, "includ": 1, "laboratori": 1, "method": 2, "nerv": 1, "neurophysiolog": 1, "offic": 1, "ordinari": 1, "origin": 1, "output": 1, "present": 1, "radio": 1, "requir": 1, "sequenc": 1, "simpl": 1, "situat": 1, "special": 1, "studi": 2, "system": 1, "telephon": 1, "time": 1, "tracer": 1, "transmiss": 1, "transmit": 1, "type": 1, "neilsen": 1}}, "1182": {"id": "1182", "title": "Contextual Correlates of Synonymy", "abstract": "Experimental corroboration was obtained for the hypothesis that the proportion of words common  to the contexts of word A and to the contexts of word B is a function of the degree to which A and B  are similar in meaning.  The shapes of the functions, however, indicate that similarity of context is  reliable as criterion only for detecting pairs of words that are very similar in meaning.", "authors": "Rubenstein, H. Goodenough, J. B.", "words_pool": ["common", "context", "context", "contextu", "correl", "corrobor", "criterion", "degre", "detect", "experiment", "function", "function", "hypothesi", "mean", "obtain", "pair", "proport", "reliabl", "shape", "similar", "similar", "synonymi", "word", "word", "rubenstein", "goodenough"], "word_count": {"common": 1, "context": 3, "contextu": 1, "correl": 1, "corrobor": 1, "criterion": 1, "degre": 1, "detect": 1, "experiment": 1, "function": 2, "hypothesi": 1, "mean": 2, "obtain": 1, "pair": 1, "proport": 1, "reliabl": 1, "shape": 1, "similar": 3, "synonymi": 1, "word": 4, "rubenstein": 1, "goodenough": 1}}, "1183": {"id": "1183", "title": "A Note on the Use of a Digital Computer for Doing Tedious Algebra and Programming", "abstract": "A special purpose compiler was written with FORTRAN II language and made possible the writing  of very long programs by the computer.  The procedure is based on a straight-forward use of FORMAT statements  for generating machine-written programs.", "authors": "Veronis, G.", "words_pool": ["algebra", "base", "compil", "comput", "digit", "format", "fortran", "forward", "gener", "ii", "languag", "long", "machin", "made", "note", "procedur", "program", "program", "purpos", "special", "statement", "straight", "tediou", "write", "written", "veroni"], "word_count": {"algebra": 1, "base": 1, "compil": 1, "comput": 1, "digit": 1, "format": 1, "fortran": 1, "forward": 1, "gener": 1, "ii": 1, "languag": 1, "long": 1, "machin": 1, "made": 1, "note": 1, "procedur": 1, "program": 2, "purpos": 1, "special": 1, "statement": 1, "straight": 1, "tediou": 1, "write": 1, "written": 2, "veroni": 1}}, "1184": {"id": "1184", "title": "A Fast Storage Allocator", "abstract": "A fast storage bookkeeping method is described which is particularly appropriate for list-structure  operations and other situations involving many sizes of blocks that are fixed in size and location.    This scheme, used in the LLLLLL or L6 (Bell Telephone Laboratories Low-Level List Language), makes available  blocks of computer registers in several different sizes: the smaller blocks are obtained by successively  splitting larger ones in half, and the larger blocks are reconstituted if and when their parts are simultaneously  free.", "authors": "Knowlton, K", "words_pool": ["alloc", "bell", "block", "bookkeep", "comput", "fast", "fix", "free", "half", "involv", "l6", "laboratori", "languag", "larger", "level", "list", "llllll", "locat", "low", "make", "method", "obtain", "oper", "part", "reconstitut", "regist", "scheme", "simultan", "situat", "size", "size", "smaller", "split", "storag", "structur", "success", "telephon", "knowlton"], "word_count": {"alloc": 1, "bell": 1, "block": 4, "bookkeep": 1, "comput": 1, "fast": 1, "fix": 1, "free": 1, "half": 1, "involv": 1, "l6": 1, "laboratori": 1, "languag": 1, "larger": 2, "level": 1, "list": 2, "llllll": 1, "locat": 1, "low": 1, "make": 1, "method": 1, "obtain": 1, "oper": 1, "part": 1, "reconstitut": 1, "regist": 1, "scheme": 1, "simultan": 1, "situat": 1, "size": 3, "smaller": 1, "split": 1, "storag": 1, "structur": 1, "success": 1, "telephon": 1, "knowlton": 1}}, "1185": {"id": "1185", "title": "A program to Solve the Pentomino Problem by the Recursive Use of Macros", "abstract": "A coding technique is described in which certain macro-instructions are given lists as arguments  and are thereby used recursively.  The discussion covers primarily an example in which the technique  is used to solve the pentomino problem-the problem of fitting 12 pentominos without overlapping into  a plane area formed of 60 elemental squares.", "authors": "Fletcher, J. G.", "words_pool": ["area", "argument", "code", "cover", "discuss", "element", "fit", "form", "instruct", "list", "macro", "macro", "overlap", "pentomino", "pentomino", "plane", "primarili", "problem", "program", "recurs", "recurs", "solv", "squar", "techniqu", "fletcher"], "word_count": {"area": 1, "argument": 1, "code": 1, "cover": 1, "discuss": 1, "element": 1, "fit": 1, "form": 1, "instruct": 1, "list": 1, "macro": 1, "overlap": 1, "pentomino": 2, "plane": 1, "primarili": 1, "problem": 2, "program": 1, "recurs": 1, "solv": 1, "squar": 1, "techniqu": 2, "fletcher": 1}}, "1186": {"id": "1186", "title": "Recursive Solution of a Class Of Combinatorial Problems: An Example", "abstract": "Combinatorial problems requiring the selection of n elements from a set of m elements may be  solved by a recursion process analogous to that for computing binomial coefficients.  Several specific  problems are analyzed, the general technique is exposed, and an ALGOL program is developed for one of  the problems.", "authors": "Lynch,W. C.", "words_pool": ["algol", "analog", "analyz", "binomi", "class", "coeffici", "combinatori", "comput", "develop", "element", "expos", "gener", "problem", "process", "program", "recurs", "recurs", "requir", "select", "set", "solut", "solv", "specif", "techniqu", "lynch"], "word_count": {"algol": 1, "analog": 1, "analyz": 1, "binomi": 1, "class": 1, "coeffici": 1, "combinatori": 1, "comput": 1, "develop": 1, "element": 2, "expos": 1, "gener": 1, "problem": 3, "process": 1, "program": 1, "recurs": 1, "requir": 1, "select": 1, "set": 1, "solut": 1, "solv": 1, "specif": 1, "techniqu": 1, "lynch": 1}}, "1187": {"id": "1187", "title": "Note on an ASCII-Octal Code Table (Standards)", "authors": "Crosby, W. S.", "words_pool": ["ascii", "code", "note", "octal", "standard", "tabl", "crosbi"], "word_count": {"ascii": 1, "code": 1, "note": 1, "octal": 1, "standard": 1, "tabl": 1, "crosbi": 1}}, "1188": {"id": "1188", "title": "An ALGOL-like Computer Design Language", "abstract": "The idea of constructing a computer design language by making use of an ALGOL-like programming  language is presented.  A computer designer can benefit from using a design language at a higher level  just as a computer user can benefit from a higher level programming language.  The purposes and requirements  of the design language are enumerated.  To achieve most of the purposes a translator is required to translate  a design of computer logic into a set of Boolean equations.  The design language is presented in terms  of vocabulary, statements, sequences and microprogram.  Included are examples of identifiers, expressions  with both unary and binary operators, declaration statements, transfer statements, terminal statements,  exchange statements, if statements, do statements, go to statements, several sequences and a microprogram.", "authors": "Chu, Y.", "words_pool": ["achiev", "algol", "benefit", "binari", "boolean", "comput", "construct", "declar", "design", "design", "enumer", "equat", "exampl", "exchang", "express", "higher", "idea", "identifi", "includ", "languag", "level", "logic", "make", "microprogram", "oper", "present", "program", "purpos", "requir", "requir", "sequenc", "set", "statement", "termin", "term", "transfer", "translat", "translat", "unari", "user", "vocabulari", "chu"], "word_count": {"achiev": 1, "algol": 1, "benefit": 2, "binari": 1, "boolean": 1, "comput": 4, "construct": 1, "declar": 1, "design": 6, "enumer": 1, "equat": 1, "exampl": 1, "exchang": 1, "express": 1, "higher": 2, "idea": 1, "identifi": 1, "includ": 1, "languag": 6, "level": 2, "logic": 1, "make": 1, "microprogram": 2, "oper": 1, "present": 2, "program": 2, "purpos": 2, "requir": 2, "sequenc": 2, "set": 1, "statement": 8, "termin": 1, "term": 1, "transfer": 1, "translat": 2, "unari": 1, "user": 1, "vocabulari": 1, "chu": 1}}, "1189": {"id": "1189", "title": "Random Normal Deviate (Algorithm 267 [G5])", "authors": "Pike, M. C.", "words_pool": ["algorithm", "deviat", "g5", "normal", "random", "pike"], "word_count": {"algorithm": 1, "deviat": 1, "g5": 1, "normal": 1, "random": 1, "pike": 1}}, "1190": {"id": "1190", "title": "Pseudo-Random Numbers (Algorithm 266 [G5])", "authors": "Pike, M. C. Hill, I. D.", "words_pool": ["algorithm", "g5", "number", "pseudo", "random", "pike", "hill"], "word_count": {"algorithm": 1, "g5": 1, "number": 1, "pseudo": 1, "random": 1, "pike": 1, "hill": 1}}, "1191": {"id": "1191", "title": "Find Precedence Functions (Algorithm 265 [L2])", "authors": "Wirth, N.", "words_pool": ["algorithm", "find", "function", "l2", "preced", "wirth"], "word_count": {"algorithm": 1, "find": 1, "function": 1, "l2": 1, "preced": 1, "wirth": 1}}, "1192": {"id": "1192", "title": "Interpolation in a Table (Algorithm 264 [E1])", "authors": "Stafford, J.", "words_pool": ["algorithm", "e1", "interpol", "tabl", "stafford"], "word_count": {"algorithm": 1, "e1": 1, "interpol": 1, "tabl": 1, "stafford": 1}}, "1193": {"id": "1193", "title": "Gomory 1 (Algorithm 263 [H])", "authors": "Langmaack, H.", "words_pool": ["algorithm", "gomori", "langmaack"], "word_count": {"algorithm": 1, "gomori": 1, "langmaack": 1}}, "1194": {"id": "1194", "title": "Establishment of the ACM Repository and Principles of the IR System Applied to its Operation", "abstract": "The history of the establishment of the ACM Repository at the Moore School, University of Pennsylvania,  is reviewed briefly.  Two principles are presented as paramount in the provision of information services:  (1) easy accessibility to the information files by users unfamiliar with file organization, and (2) value  of service exceeding user costs.  These principles serve as guides in mechanizing the ACM Repository.   The main features of the information system are direct user access via on-line teletypewriter console,  direct user access to all details of the system organization, unrestricted and expandable search vocabulary,  user access through many facets of document indexing, and stochastic search through linked index terms  and other file relationships.  The first contribution to the ACM Repository consisted of 315 documents,  relating primarily to early research on compilers.  These documents have been cataloged and indexed and  the catalog is scheduled to appear in Computing Reviews.  The indexing system is described in detail.   The Main Catalog is used to describe the documents, and inverted lists are provided by the Repository  system for retrieval by concept coordination.", "authors": "Rubinoff, M. White Jr., J. F.", "words_pool": ["access", "access", "acm", "appli", "briefli", "catalog", "catalog", "compil", "comput", "concept", "consist", "consol", "contribut", "coordin", "cost", "describ", "detail", "detail", "direct", "document", "document", "earli", "easi", "establish", "exceed", "expand", "facet", "featur", "guid", "histori", "index", "index", "index", "inform", "invert", "ir", "line", "link", "list", "main", "mechan", "moor", "oper", "organ", "paramount", "pennsylvania", "present", "primarili", "principl", "provid", "provis", "relat", "relationship", "repositori", "research", "retriev", "review", "review", "schedul", "school", "search", "serv", "servic", "servic", "stochast", "system", "teletypewrit", "term", "unfamiliar", "univers", "unrestrict", "user", "user", "vocabulari", "rubinoff", "white", "jr"], "word_count": {"access": 4, "acm": 3, "appli": 1, "briefli": 1, "catalog": 3, "compil": 1, "comput": 1, "concept": 1, "consist": 1, "consol": 1, "contribut": 1, "coordin": 1, "cost": 1, "describ": 1, "detail": 2, "direct": 2, "document": 4, "earli": 1, "easi": 1, "establish": 1, "exceed": 1, "expand": 1, "facet": 1, "featur": 1, "guid": 1, "histori": 1, "index": 4, "inform": 3, "invert": 1, "ir": 1, "line": 1, "link": 1, "list": 1, "main": 2, "mechan": 1, "moor": 1, "oper": 1, "organ": 2, "paramount": 1, "pennsylvania": 1, "present": 1, "primarili": 1, "principl": 2, "provid": 1, "provis": 1, "relat": 1, "relationship": 1, "repositori": 4, "research": 1, "retriev": 1, "review": 2, "schedul": 1, "school": 1, "search": 2, "serv": 1, "servic": 2, "stochast": 1, "system": 4, "teletypewrit": 1, "term": 1, "unfamiliar": 1, "univers": 1, "unrestrict": 1, "user": 5, "vocabulari": 1, "rubinoff": 1, "white": 1, "jr": 1}}, "1195": {"id": "1195", "title": "UPLIFTS-University of Pittsburgh Linear File Tandem System", "abstract": "A series of computer programs has been developed and is now operational for processing the  National Aeronautics and Space Administration linear file system on an IBM 1401-7090 combined data processing  system.  The program are note-worthy in that they create fixed length logical records and fixed length  blocks from variable length source data, and format the output for optimization of processing on the  IBM 7090 system.  The programs are completely self-checking and test for both validity and accuracy of  the input materials as provided by the National Aeronautics and Space Administration.", "authors": "Canter, J. D. Donaghey, C. E.", "words_pool": ["accuraci", "administr", "aeronaut", "block", "check", "combin", "complet", "comput", "creat", "data", "develop", "fix", "format", "ibm", "input", "length", "linear", "logic", "materi", "nation", "note", "oper", "optim", "output", "pittsburgh", "process", "program", "program", "provid", "record", "seri", "sourc", "space", "system", "tandem", "test", "univers", "uplift", "valid", "variabl", "worthi", "canter", "donaghey"], "word_count": {"accuraci": 1, "administr": 2, "aeronaut": 2, "block": 1, "check": 1, "combin": 1, "complet": 1, "comput": 1, "creat": 1, "data": 2, "develop": 1, "fix": 2, "format": 1, "ibm": 2, "input": 1, "length": 3, "linear": 1, "logic": 1, "materi": 1, "nation": 2, "note": 1, "oper": 1, "optim": 1, "output": 1, "pittsburgh": 1, "process": 3, "program": 3, "provid": 1, "record": 1, "seri": 1, "sourc": 1, "space": 2, "system": 3, "tandem": 1, "test": 1, "univers": 1, "uplift": 1, "valid": 1, "variabl": 1, "worthi": 1, "canter": 1, "donaghey": 1}}, "1196": {"id": "1196", "title": "Applications of Differential Equations in General Problem Solving", "abstract": "A large class of problems leading to digital computer processing can be formulated in terms  of the numerical solution of systems of ordinary differential equations.  Powerful methods are in existence  for the solution of such systems.  A good general purpose routine for the solution of such systems furnishes  a powerful tool for processing many problems.  This is true from the point of view of ease of programming,  ease of debugging, and minimization of computer time.  A number of examples are discussed in detail.", "authors": "Klopfenstein, R. W.", "words_pool": ["applic", "class", "comput", "debug", "detail", "differenti", "digit", "discuss", "eas", "equat", "exampl", "exist", "formul", "furnish", "gener", "good", "larg", "lead", "method", "minim", "number", "numer", "ordinari", "point", "power", "problem", "problem", "process", "program", "purpos", "routin", "solut", "solv", "system", "term", "time", "tool", "true", "view", "klopfenstein"], "word_count": {"applic": 1, "class": 1, "comput": 2, "debug": 1, "detail": 1, "differenti": 1, "digit": 1, "discuss": 1, "eas": 2, "equat": 1, "exampl": 1, "exist": 1, "formul": 1, "furnish": 1, "gener": 1, "good": 1, "larg": 1, "lead": 1, "method": 1, "minim": 1, "number": 1, "numer": 1, "ordinari": 1, "point": 1, "power": 2, "problem": 2, "process": 2, "program": 1, "purpos": 1, "routin": 1, "solut": 3, "solv": 1, "system": 3, "term": 1, "time": 1, "tool": 1, "true": 1, "view": 1, "klopfenstein": 1}}, "1197": {"id": "1197", "title": "Finding Zeros of a Polynomial by the Q-D Algorithm", "abstract": "A method which finds simultaneously all the zeros of a polynomial, developed by H. Rutishauser,  has been tested on a number of polynomials with real coefficients.  This slowly converging method (the  Quotient-Difference (Q-D) algorithm) provides starting values for a Newton or a Bairstow algorithm for  more rapid convergence.  Necessary and sufficient conditions for the existence of the Q-D scheme are  not completely known; however, failure may occur when zeros have equal, or nearly equal magnitudes.   Success was achieved, in most of the cases tried, with the failures usually traceable to the equal magnitude  difficulty.  In some cases, computer roundoff may result in errors which spoil the scheme.  Even if the  Q-D algorithm does not give all the zeros, it will usually find a majority of them.", "authors": "Henrich, P. Watkins, B. O.", "words_pool": ["achiev", "algorithm", "bairstow", "case", "coeffici", "complet", "comput", "condit", "converg", "converg", "develop", "differ", "difficulti", "equal", "error", "exist", "failur", "failur", "find", "find", "find", "give", "known", "magnitud", "magnitud", "major", "method", "nearli", "newton", "number", "occur", "polynomi", "polynomi", "quotient", "rapid", "real", "result", "roundoff", "rutishaus", "scheme", "simultan", "slowli", "spoil", "start", "success", "suffici", "test", "traceabl", "tri", "valu", "zero", "henrich", "watkin"], "word_count": {"achiev": 1, "algorithm": 3, "bairstow": 1, "case": 2, "coeffici": 1, "complet": 1, "comput": 1, "condit": 1, "converg": 2, "develop": 1, "differ": 1, "difficulti": 1, "equal": 3, "error": 1, "exist": 1, "failur": 2, "find": 2, "give": 1, "known": 1, "magnitud": 2, "major": 1, "method": 2, "nearli": 1, "newton": 1, "number": 1, "occur": 1, "polynomi": 2, "quotient": 1, "rapid": 1, "real": 1, "result": 1, "roundoff": 1, "rutishaus": 1, "scheme": 2, "simultan": 1, "slowli": 1, "spoil": 1, "start": 1, "success": 1, "suffici": 1, "test": 1, "traceabl": 1, "tri": 1, "valu": 1, "zero": 3, "henrich": 1, "watkin": 1}}, "1198": {"id": "1198", "title": "Solution of a Problem in Concurrent Programming Control", "abstract": "A number of mainly independent sequential-cyclic processes with restricted means of communication  with each other can be made in such a way that at any moment one and only one of them is engaged in the  \"critical section\" of its cycle.", "authors": "Dijkstra, E. W.", "words_pool": ["commun", "concurr", "control", "critic", "cycl", "cyclic", "engag", "independ", "made", "mainli", "mean", "moment", "number", "problem", "process", "program", "restrict", "section", "sequenti", "solut", "dijkstra"], "word_count": {"commun": 1, "concurr": 1, "control": 1, "critic": 1, "cycl": 1, "cyclic": 1, "engag": 1, "independ": 1, "made": 1, "mainli": 1, "mean": 1, "moment": 1, "number": 1, "problem": 1, "process": 1, "program": 1, "restrict": 1, "section": 1, "sequenti": 1, "solut": 1, "dijkstra": 1}}, "1199": {"id": "1199", "title": "A Computer Center Simulation Project", "abstract": "Today's computation centers are based on rapidly changing technologies of hardware and software  systems.  It is difficult, therefore, to base decisions on experience; in most instances, the benefits  of comparable experience for a given problem situation are not available.  In this paper, a mathematical  model of the Lockheed Central Computer Center is formulated that describes the operation of a computation  center in terms of information nets, decision processes, and control functions.  Experiments performed  with this model, the results of the experiments, and the application of the results are discussed.", "authors": "Hutchinson, G. K.", "words_pool": ["applic", "base", "base", "benefit", "center", "center", "central", "chang", "compar", "comput", "comput", "control", "decis", "decis", "describ", "difficult", "discuss", "experi", "experi", "formul", "function", "hardwar", "inform", "instanc", "lockhe", "mathemat", "model", "net", "oper", "paper", "perform", "problem", "process", "project", "rapidli", "result", "simul", "situat", "softwar", "system", "technolog", "term", "today", "hutchinson"], "word_count": {"applic": 1, "base": 2, "benefit": 1, "center": 3, "central": 1, "chang": 1, "compar": 1, "comput": 3, "control": 1, "decis": 2, "describ": 1, "difficult": 1, "discuss": 1, "experi": 4, "formul": 1, "function": 1, "hardwar": 1, "inform": 1, "instanc": 1, "lockhe": 1, "mathemat": 1, "model": 2, "net": 1, "oper": 1, "paper": 1, "perform": 1, "problem": 1, "process": 1, "project": 1, "rapidli": 1, "result": 2, "simul": 1, "situat": 1, "softwar": 1, "system": 1, "technolog": 1, "term": 1, "today": 1, "hutchinson": 1}}, "1200": {"id": "1200", "title": "On Reversible Subroutines and Computers that Run Backwards", "abstract": "A computer design is describe which permits subroutines to be executed backward as well as  forward, either with their instructions unchanged or replaced with conjugate instructions.  It is shown  that using this concept a number of new subroutine types can be developed with rather unusual properties.   Since these properties are analogous to certain matrix operations, a parallel nomenclature is suggested  for their classification.", "authors": "Reily, E. D. Federighi, F. D.", "words_pool": ["analog", "backward", "backward", "classif", "comput", "comput", "concept", "conjug", "describ", "design", "develop", "execut", "forward", "instruct", "matrix", "nomenclatur", "number", "oper", "parallel", "permit", "properti", "replac", "revers", "run", "shown", "subroutin", "subroutin", "suggest", "type", "unchang", "unusu", "reili", "federighi"], "word_count": {"analog": 1, "backward": 1, "classif": 1, "comput": 1, "concept": 1, "conjug": 1, "describ": 1, "design": 1, "develop": 1, "execut": 1, "forward": 1, "instruct": 2, "matrix": 1, "nomenclatur": 1, "number": 1, "oper": 1, "parallel": 1, "permit": 1, "properti": 2, "replac": 1, "revers": 1, "run": 1, "shown": 1, "subroutin": 2, "suggest": 1, "type": 1, "unchang": 1, "unusu": 1, "reili": 1, "federighi": 1}}, "1201": {"id": "1201", "title": "Generation of Permutations in Lexico-Graphical Order (Algorithm 202 [G6])", "authors": "Elliott, R. W.", "words_pool": ["algorithm", "g6", "gener", "graphic", "lexico", "order", "permut", "elliott"], "word_count": {"algorithm": 1, "g6": 1, "gener": 1, "graphic": 1, "lexico": 1, "order": 1, "permut": 1, "elliott": 1}}, "1202": {"id": "1202", "title": "Normal Random (Algorithm 200 [G5])", "authors": "Pike, M. C.", "words_pool": ["algorithm", "g5", "normal", "random", "pike"], "word_count": {"algorithm": 1, "g5": 1, "normal": 1, "random": 1, "pike": 1}}, "1203": {"id": "1203", "title": "Normdey (Algorithm 121 [G5])", "authors": "Pike, M. C.", "words_pool": ["algorithm", "g5", "normdey", "pike"], "word_count": {"algorithm": 1, "g5": 1, "normdey": 1, "pike": 1}}, "1204": {"id": "1204", "title": "Character Structure and Character Parity Sense for Serial-by-Bit Data Communication in the American  Standard Code for Information Interchange (Proposed American Standard)", "words_pool": ["american", "bit", "charact", "code", "commun", "data", "inform", "interchang", "pariti", "propos", "sens", "serial", "standard", "structur"], "word_count": {"american": 2, "bit": 1, "charact": 2, "code": 1, "commun": 1, "data": 1, "inform": 1, "interchang": 1, "pariti": 1, "propos": 1, "sens": 1, "serial": 1, "standard": 2, "structur": 1}}, "1205": {"id": "1205", "title": "An Undergraduate Program in Computer Science-Preliminary Recommendations", "authors": "A Report from the ACM Curriculum Committee on Computer Science", "words_pool": ["comput", "preliminari", "program", "recommend", "scienc", "undergradu", "report", "acm", "curriculum", "committe", "comput", "scienc"], "word_count": {"comput": 1, "preliminari": 1, "program": 1, "recommend": 1, "scienc": 1, "undergradu": 1, "report": 1, "acm": 1, "curriculum": 1, "committe": 1}}, "1206": {"id": "1206", "title": "The Self-Judgment Method of Curve Fitting", "abstract": "A computer-oriented method for processing and communicating numerical data is described.  The  Instrument Reliability Factors (IRF), which exactly define the limits of reliability of each measured  item of information, are used to compute the Maximum Permitted Error (MPE) associated with each values  of each ordinate.  The Self-Judgment Principle (SJP) is used to discard wrong information and to compute  mean values of the parameters and their MPE's in terms of the IRF.  Data compatibility tests with any  number of different equations can be made quickly.  Otherwise intractable problems are easily solved,  and the design of many experiments is greatly simplified.  The computational and mathematical techniques  used to reduce bias in the SJP are discussed.  Inadequacies in the statistical and graphical methods  of curve fitting are noted.", "authors": "DeMaine, P. A. D.", "words_pool": ["bia", "commun", "compat", "comput", "comput", "comput", "curv", "data", "defin", "design", "discard", "discuss", "easili", "equat", "error", "exactli", "experi", "factor", "fit", "graphic", "greatli", "inadequaci", "inform", "instrument", "intract", "irf", "item", "judgment", "limit", "made", "mathemat", "maximum", "mean", "measur", "method", "method", "mpe", "note", "number", "numer", "ordin", "orient", "paramet", "permit", "principl", "problem", "process", "quickli", "reduc", "reliabl", "simplifi", "sjp", "solv", "statist", "techniqu", "term", "test", "valu", "wrong", "demain"], "word_count": {"bia": 1, "commun": 1, "compat": 1, "comput": 4, "curv": 1, "data": 2, "defin": 1, "design": 1, "discard": 1, "discuss": 1, "easili": 1, "equat": 1, "error": 1, "exactli": 1, "experi": 1, "factor": 1, "fit": 1, "graphic": 1, "greatli": 1, "inadequaci": 1, "inform": 2, "instrument": 1, "intract": 1, "irf": 2, "item": 1, "judgment": 1, "limit": 1, "made": 1, "mathemat": 1, "maximum": 1, "mean": 1, "measur": 1, "method": 2, "mpe": 2, "note": 1, "number": 1, "numer": 1, "ordin": 1, "orient": 1, "paramet": 1, "permit": 1, "principl": 1, "problem": 1, "process": 1, "quickli": 1, "reduc": 1, "reliabl": 2, "simplifi": 1, "sjp": 2, "solv": 1, "statist": 1, "techniqu": 1, "term": 1, "test": 1, "valu": 2, "wrong": 1, "demain": 1}}, "1207": {"id": "1207", "title": "Remarks on Simulation of Boolean Functions", "authors": "Dodd, G. G.", "words_pool": ["boolean", "function", "remark", "simul", "dodd"], "word_count": {"boolean": 1, "function": 1, "remark": 1, "simul": 1, "dodd": 1}}, "1208": {"id": "1208", "title": "Simulation of Computer Logic by Fortran Arithmetic", "authors": "Weingarten, F. W.", "words_pool": ["arithmet", "comput", "fortran", "logic", "simul", "weingarten"], "word_count": {"arithmet": 1, "comput": 1, "fortran": 1, "logic": 1, "simul": 1, "weingarten": 1}}, "1209": {"id": "1209", "title": "Negative and Zero Subscripts in Fortran II Programming for the IBM 1620", "authors": "Garber, M. S.", "words_pool": ["fortran", "ibm", "ii", "neg", "program", "subscript", "garber"], "word_count": {"fortran": 1, "ibm": 1, "ii": 1, "neg": 1, "program": 1, "subscript": 1, "garber": 1}}, "1210": {"id": "1210", "title": "File-Handling Within FORTRAN", "abstract": "This note describes some FORTRAN subroutines to facilitate handling of tape files.  They allow  symbolic naming of information files, without violating the casual scientific programmer's idea of simplicity.   Some comments on two years use of these subroutines are given.", "authors": "Harrison, M. C.", "words_pool": ["allow", "casual", "comment", "describ", "facilit", "fortran", "handl", "idea", "inform", "name", "note", "programm", "scientif", "simplic", "subroutin", "symbol", "tape", "violat", "year", "harrison"], "word_count": {"allow": 1, "casual": 1, "comment": 1, "describ": 1, "facilit": 1, "fortran": 1, "handl": 1, "idea": 1, "inform": 1, "name": 1, "note": 1, "programm": 1, "scientif": 1, "simplic": 1, "subroutin": 2, "symbol": 1, "tape": 1, "violat": 1, "year": 1, "harrison": 1}}, "1211": {"id": "1211", "title": "A Note on Storage of Strings", "abstract": "A method for storing strings is described which uses blocks of indefinite size, and is therefore  completely dynamic.  Its relation to similar schemes is discussed.", "authors": "Berztiss, A. T.", "words_pool": ["block", "complet", "discuss", "dynam", "indefinit", "method", "note", "relat", "scheme", "similar", "size", "storag", "store", "string", "berztiss"], "word_count": {"block": 1, "complet": 1, "discuss": 1, "dynam": 1, "indefinit": 1, "method": 1, "note": 1, "relat": 1, "scheme": 1, "similar": 1, "size": 1, "storag": 1, "store": 1, "string": 1, "berztiss": 1}}, "1212": {"id": "1212", "title": "Non-linear Extrapolation and Two-Point Boundary Value Problems", "abstract": "It is suggested that the convergence properties of the usual Picard successive approximation  scheme may be improved through use of non-linrar extrapolation techniques.  A numerical example is provided.", "authors": "Bellman, R. Kagiada, H. Kalba, R.", "words_pool": ["approxim", "boundari", "converg", "extrapol", "improv", "linear", "linrar", "non", "numer", "picard", "point", "problem", "properti", "provid", "scheme", "success", "suggest", "techniqu", "usual", "bellman", "kagiada", "kalba"], "word_count": {"approxim": 1, "boundari": 1, "converg": 1, "extrapol": 1, "improv": 1, "linear": 1, "linrar": 1, "non": 1, "numer": 1, "picard": 1, "point": 1, "problem": 1, "properti": 1, "provid": 1, "scheme": 1, "success": 1, "suggest": 1, "techniqu": 1, "usual": 1, "bellman": 1, "kagiada": 1, "kalba": 1}}, "1213": {"id": "1213", "title": "Dynamic Format Specifications", "abstract": "The use and implementation of two new FORTRAN format conversions are discussed.  These format  types give the FORTRAN programmer control of input/output specifications at execution time.", "authors": "Ranelletti, J. E.", "words_pool": ["control", "convers", "discuss", "dynam", "execut", "format", "fortran", "give", "implement", "input", "output", "programm", "specif", "time", "type", "ranelletti"], "word_count": {"control": 1, "convers": 1, "discuss": 1, "dynam": 1, "execut": 1, "format": 2, "fortran": 2, "give": 1, "implement": 1, "input": 1, "output": 1, "programm": 1, "specif": 1, "time": 1, "type": 1, "ranelletti": 1}}, "1214": {"id": "1214", "title": "Some Experiments in Algebraic Manipulation by Computer", "abstract": "A set of subroutines to allow algebraic manipulations on the IBM 7094 computer has been written  a List Processor, SLIP.  A series of four problems of increasing difficulty were solved using these routines.", "authors": "Lapidus, A. Goldstein, M.", "words_pool": ["algebra", "allow", "comput", "difficulti", "experi", "ibm", "increas", "list", "manipul", "manipul", "problem", "processor", "routin", "seri", "set", "slip", "solv", "subroutin", "written", "lapidu", "goldstein"], "word_count": {"algebra": 1, "allow": 1, "comput": 1, "difficulti": 1, "experi": 1, "ibm": 1, "increas": 1, "list": 1, "manipul": 1, "problem": 1, "processor": 1, "routin": 1, "seri": 1, "set": 1, "slip": 1, "solv": 1, "subroutin": 1, "written": 1, "lapidu": 1, "goldstein": 1}}, "1215": {"id": "1215", "title": "Some Techniques Used in the ALCOR ILLINOIS 7090", "abstract": "An ALGOL compiler has been written by the ALCOR group for the IBM 7090.  Some little known  but significant techniques in compiler writing, together with organizational details of this compiler,  are described.  Timing estimates and an indication of compiler requirements are also given.", "authors": "Gries, D. Paul, M. Wiehle, H. R.", "words_pool": ["alcor", "algol", "compil", "detail", "estim", "group", "ibm", "illinoi", "indic", "known", "organiz", "requir", "signific", "techniqu", "time", "write", "written", "gri", "paul", "wiehl"], "word_count": {"alcor": 1, "algol": 1, "compil": 4, "detail": 1, "estim": 1, "group": 1, "ibm": 1, "illinoi": 1, "indic": 1, "known": 1, "organiz": 1, "requir": 1, "signific": 1, "techniqu": 1, "time": 1, "write": 1, "written": 1, "gri": 1, "paul": 1, "wiehl": 1}}, "1216": {"id": "1216", "title": "Symbolic Derivatives Without List Processing, Subroutines, or Recursion", "abstract": "A routine has been developed which computes and prints out the symbolic derivative of an absolutely  continuous elementary function of one or several variables.  No use is made of list-processing languages.   The chain rule is applied and the result is edited to produce results as elegant and efficient as those  obtained by hand computation.  A subset may be imbeded in a formula translator to introduce a differentiation  operator into an \"algebraic\" programming language.", "authors": "Smith, P. J.", "words_pool": ["absolut", "algebra", "appli", "chain", "comput", "comput", "continu", "deriv", "deriv", "develop", "differenti", "edit", "effici", "eleg", "elementari", "formula", "function", "hand", "imbed", "introduc", "languag", "languag", "list", "made", "obtain", "oper", "print", "process", "produc", "program", "recurs", "result", "result", "routin", "rule", "subroutin", "subset", "symbol", "translat", "variabl", "smith"], "word_count": {"absolut": 1, "algebra": 1, "appli": 1, "chain": 1, "comput": 2, "continu": 1, "deriv": 1, "develop": 1, "differenti": 1, "edit": 1, "effici": 1, "eleg": 1, "elementari": 1, "formula": 1, "function": 1, "hand": 1, "imbed": 1, "introduc": 1, "languag": 2, "list": 1, "made": 1, "obtain": 1, "oper": 1, "print": 1, "process": 1, "produc": 1, "program": 1, "recurs": 1, "result": 2, "routin": 1, "rule": 1, "subroutin": 1, "subset": 1, "symbol": 1, "translat": 1, "variabl": 1, "smith": 1}}, "1217": {"id": "1217", "title": "Map of Partitions into Integers (Algorithm 264 [A1])", "authors": "McKay, J. K. S.", "words_pool": ["a1", "algorithm", "integ", "map", "partit", "mckay"], "word_count": {"a1": 1, "algorithm": 1, "integ": 1, "map": 1, "partit": 1, "mckay": 1}}, "1218": {"id": "1218", "title": "Partition Generator (Algorithm 263 [A1])", "authors": "McKay, J. K. S.", "words_pool": ["a1", "algorithm", "gener", "partit", "mckay"], "word_count": {"a1": 1, "algorithm": 1, "gener": 1, "partit": 1, "mckay": 1}}, "1219": {"id": "1219", "title": "Number of Restricted Partitions of N (Algorithm 262 [A1])", "authors": "McKay,J. K. S.", "words_pool": ["a1", "algorithm", "number", "partit", "restrict", "mckay"], "word_count": {"a1": 1, "algorithm": 1, "number": 1, "partit": 1, "restrict": 1, "mckay": 1}}, "1220": {"id": "1220", "title": "9-J Symbols (Algorithm 261 [Z])", "authors": "Gunn, J. H.", "words_pool": ["algorithm", "symbol", "gunn"], "word_count": {"algorithm": 1, "symbol": 1, "gunn": 1}}, "1221": {"id": "1221", "title": "6-J Symbols (Algorithm 260 [Z])", "authors": "Gunn, J. H.", "words_pool": ["algorithm", "symbol", "gunn"], "word_count": {"algorithm": 1, "symbol": 1, "gunn": 1}}, "1222": {"id": "1222", "title": "Legendre Functions for Arguments Larger Than One (Algorithm 259 [S16])", "authors": "Gautschi, W.", "words_pool": ["algorithm", "argument", "function", "larger", "legendr", "s16", "gautschi"], "word_count": {"algorithm": 1, "argument": 1, "function": 1, "larger": 1, "legendr": 1, "s16": 1, "gautschi": 1}}, "1223": {"id": "1223", "title": "High Speed Compilation of Efficient Object Code", "abstract": "A three-pass compiler with the following properties is briefly described:  The last two passes  scan an intermediate language produced by the preceding pass in essentially the reverse of the order  in which it was generated, so that the first pass is the only one which hasto read the bulky problem-oriented  input.  The double scan, one in either direction, performed by the first two passes, allows the compiler  to remove locally constant expressions and recursively calculable expressions from loops and to do the  important part of common subexpression recognition.  Optimization such as the effective use of index  registers, although as important, is not discussed since the object code which would be most efficient  is highly machine dependent.  The discussion is in terms of a FORTRAN-like language, although the technique  is applicable to most algebraic languages.", "authors": "Gear, C. W.", "words_pool": ["algebra", "applic", "briefli", "bulki", "calcul", "code", "common", "compil", "compil", "constant", "depend", "direct", "discuss", "discuss", "doubl", "effect", "effici", "essenti", "express", "fortran", "gener", "hasto", "high", "highli", "import", "index", "input", "intermedi", "languag", "languag", "local", "loop", "machin", "object", "optim", "order", "orient", "part", "pass", "pass", "perform", "preced", "problem", "produc", "properti", "read", "recognit", "recurs", "regist", "remov", "revers", "scan", "speed", "subexpress", "techniqu", "term", "gear"], "word_count": {"algebra": 1, "applic": 1, "briefli": 1, "bulki": 1, "calcul": 1, "code": 1, "common": 1, "compil": 2, "constant": 1, "depend": 1, "direct": 1, "discuss": 2, "doubl": 1, "effect": 1, "effici": 1, "essenti": 1, "express": 2, "fortran": 1, "gener": 1, "hasto": 1, "high": 1, "highli": 1, "import": 2, "index": 1, "input": 1, "intermedi": 1, "languag": 3, "local": 1, "loop": 1, "machin": 1, "object": 1, "optim": 1, "order": 1, "orient": 1, "part": 1, "pass": 5, "perform": 1, "preced": 1, "problem": 1, "produc": 1, "properti": 1, "read": 1, "recognit": 1, "recurs": 1, "regist": 1, "remov": 1, "revers": 1, "scan": 2, "speed": 1, "subexpress": 1, "techniqu": 1, "term": 1, "gear": 1}}, "1224": {"id": "1224", "title": "Determining a Computing Center Environment", "abstract": "An investigation is described in which several generally unavailable parameters descriptive  of a computing center environment are obtained.  The actual data collection and reduction is described,  and the results of one month of this collection are tabulated and summarized.", "authors": "Rosin, R. F.", "words_pool": ["actual", "center", "collect", "comput", "data", "descript", "determin", "environ", "gener", "investig", "month", "obtain", "paramet", "reduct", "result", "summar", "tabul", "unavail", "rosin"], "word_count": {"actual": 1, "center": 1, "collect": 2, "comput": 1, "data": 1, "descript": 1, "determin": 1, "environ": 1, "gener": 1, "investig": 1, "month": 1, "obtain": 1, "paramet": 1, "reduct": 1, "result": 1, "summar": 1, "tabul": 1, "unavail": 1, "rosin": 1}}, "1225": {"id": "1225", "title": "The Predictive Analyzer and a Path Elimination Technique", "abstract": "Some of the characteristic features of a predictive analyzer, a system of syntactic analysis  now operational at Harvard on and IBM 7094, are delineated.  The advantages and disadvantages of the  system are discussed in comparison to those of an immediate constituent analyzer, developed at the RAND  Corporation with Robinson's English grammar.  In addition, a new technique is described for repetitive  path elimination for a predictive analyzer, which can now claim efficiency both in processing time and  core storage requirement.", "authors": "Kuno, S.", "words_pool": ["addit", "advantag", "analysi", "analyz", "characterist", "claim", "comparison", "constitu", "core", "corpor", "delin", "develop", "disadvantag", "discuss", "effici", "elimin", "english", "featur", "grammar", "harvard", "ibm", "oper", "path", "predict", "process", "rand", "repetit", "requir", "robinson", "storag", "syntact", "system", "techniqu", "time", "kuno"], "word_count": {"addit": 1, "advantag": 1, "analysi": 1, "analyz": 3, "characterist": 1, "claim": 1, "comparison": 1, "constitu": 1, "core": 1, "corpor": 1, "delin": 1, "develop": 1, "disadvantag": 1, "discuss": 1, "effici": 1, "elimin": 1, "english": 1, "featur": 1, "grammar": 1, "harvard": 1, "ibm": 1, "oper": 1, "path": 1, "predict": 2, "process": 1, "rand": 1, "repetit": 1, "requir": 1, "robinson": 1, "storag": 1, "syntact": 1, "system": 2, "techniqu": 1, "time": 1, "kuno": 1}}, "1226": {"id": "1226", "title": "The Organization of Structured Files", "abstract": "A data file is an integral part of a data processing system.  In many systems, the selection  of an organization for the data within the file can be critical to the system's operating efficiency.   This paper provides the systems designer with an information source which describes ten techniques that  may be employed for organizing structured data.  The characteristics of the organizations described are  application independent, thus providing the designer with a reference which allows him to limit the number  of file organizations he must consider for his system.", "authors": "Dzubak, B. J. Warburton, C. R.", "words_pool": ["applic", "characterist", "consid", "critic", "data", "describ", "design", "effici", "employ", "independ", "inform", "integr", "limit", "number", "oper", "organ", "organ", "organ", "paper", "part", "process", "provid", "refer", "select", "sourc", "structur", "system", "system", "techniqu", "ten", "dzubak", "warburton"], "word_count": {"applic": 1, "characterist": 1, "consid": 1, "critic": 1, "data": 4, "describ": 1, "design": 2, "effici": 1, "employ": 1, "independ": 1, "inform": 1, "integr": 1, "limit": 1, "number": 1, "oper": 1, "organ": 4, "paper": 1, "part": 1, "process": 1, "provid": 1, "refer": 1, "select": 1, "sourc": 1, "structur": 1, "system": 5, "techniqu": 1, "ten": 1, "dzubak": 1, "warburton": 1}}, "1227": {"id": "1227", "title": "Transport (Algorithm 258 [H])", "authors": "Bayer, G.", "words_pool": ["algorithm", "transport", "bayer"], "word_count": {"algorithm": 1, "transport": 1, "bayer": 1}}, "1228": {"id": "1228", "title": "Treesort 3 (Algorithm 245 [M1])", "authors": "Abrams, P. S.", "words_pool": ["algorithm", "m1", "treesort", "abram"], "word_count": {"algorithm": 1, "m1": 1, "treesort": 1, "abram": 1}}, "1229": {"id": "1229", "title": "Random Permutation (Algorithm 235 [G6])", "authors": "Pike, M. C.", "words_pool": ["algorithm", "g6", "permut", "random", "pike"], "word_count": {"algorithm": 1, "g6": 1, "permut": 1, "random": 1, "pike": 1}}, "1230": {"id": "1230", "title": "Method for Hyphenating at the End of a Printed Line", "abstract": "A description of a method of hyphenation is presented as a result of application of several  general rules.  The character sets considered by the routine and the method are briefly outlined.", "authors": "Rich, R. P. Stone, A. G.", "words_pool": ["applic", "briefli", "charact", "consid", "descript", "end", "gener", "hyphen", "hyphen", "line", "method", "outlin", "present", "print", "result", "routin", "rule", "set", "rich", "stone"], "word_count": {"applic": 1, "briefli": 1, "charact": 1, "consid": 1, "descript": 1, "end": 1, "gener": 1, "hyphen": 1, "line": 1, "method": 2, "outlin": 1, "present": 1, "print": 1, "result": 1, "routin": 1, "rule": 1, "set": 1, "rich": 1, "stone": 1}}, "1231": {"id": "1231", "title": "Peephole Optimization", "abstract": "Redundant instructions may be discarded during the final stage of compilation by using a simple  optimizing technique called peephole optimization. The method is described and examplesare given.", "authors": "McKeeman, W. M.", "words_pool": ["call", "compil", "discard", "examplesar", "final", "instruct", "method", "optim", "optim", "peephol", "redund", "simpl", "stage", "techniqu", "mckeeman"], "word_count": {"call": 1, "compil": 1, "discard": 1, "examplesar": 1, "final": 1, "instruct": 1, "method": 1, "optim": 2, "peephol": 1, "redund": 1, "simpl": 1, "stage": 1, "techniqu": 1, "mckeeman": 1}}, "1232": {"id": "1232", "title": "Representation of the Standard ECMA 7-Bit Code in Punched Cards (ECMA Standard)", "words_pool": ["bit", "card", "code", "ecma", "punch", "represent", "standard"], "word_count": {"bit": 1, "card": 1, "code": 1, "ecma": 2, "punch": 1, "represent": 1, "standard": 2}}, "1233": {"id": "1233", "title": "Conventions for the Use of Symbols in the Preparation of Flowcharts for Information Processing  Systems (A Standard Working Paper)", "abstract": "This paper is intended as an outline of the various conventions which are being considered  for the use of flowcharts for information processing systems.  The conventions are applied to the use  of the symbols appearing in the proposed American Standard Flowchart Symbols and not with the symbols  per se.", "words_pool": ["american", "appear", "appli", "consid", "convent", "flowchart", "flowchart", "inform", "intend", "outlin", "paper", "prepar", "process", "propos", "se", "standard", "symbol", "system", "work"], "word_count": {"american": 1, "appear": 1, "appli": 1, "consid": 1, "convent": 2, "flowchart": 2, "inform": 1, "intend": 1, "outlin": 1, "paper": 1, "prepar": 1, "process": 1, "propos": 1, "se": 1, "standard": 1, "symbol": 3, "system": 1, "work": 1}}, "1234": {"id": "1234", "title": "The Structure of Yet Another ALGOL Compiler", "abstract": "A high-speed \"top down\" method of syntax analysis which completely eliminates \"back-up\" of  the source string has been implemented in a convenient macro-language.  A technique of  simulation at  compile time of the use of a conventional run-time stack enables the generation of code for expressions  which minimizes stores, fetches and stack-pointer motion at run time, while properly trating recursion  and side effects of procedures.  Block structure and recursion are handled without need for interpretive  methods at run times.  The \"context problem\" in the transmission to recursive procedures of parameters  \"called by name\" is solved in a manner which permits the handling of the common cases of simple expressions  and array identifiers with particular efficiency.", "authors": "Kanner, H. Kosinski, P. Robinson, C. L.", "words_pool": ["algol", "analysi", "array", "back", "block", "call", "case", "code", "common", "compil", "compil", "complet", "context", "conveni", "convent", "effect", "effici", "elimin", "enabl", "express", "fetch", "gener", "handl", "handl", "high", "identifi", "implement", "interpret", "languag", "macro", "manner", "method", "method", "minim", "motion", "need", "paramet", "permit", "pointer", "problem", "procedur", "properli", "recurs", "recurs", "run", "side", "simpl", "simul", "solv", "sourc", "speed", "stack", "store", "string", "structur", "syntax", "techniqu", "time", "time", "top", "transmiss", "trate", "kanner", "kosinski", "robinson"], "word_count": {"algol": 1, "analysi": 1, "array": 1, "back": 1, "block": 1, "call": 1, "case": 1, "code": 1, "common": 1, "compil": 1, "complet": 1, "context": 1, "conveni": 1, "convent": 1, "effect": 1, "effici": 1, "elimin": 1, "enabl": 1, "express": 2, "fetch": 1, "gener": 1, "handl": 2, "high": 1, "identifi": 1, "implement": 1, "interpret": 1, "languag": 1, "macro": 1, "manner": 1, "method": 2, "minim": 1, "motion": 1, "need": 1, "paramet": 1, "permit": 1, "pointer": 1, "problem": 1, "procedur": 2, "properli": 1, "recurs": 3, "run": 3, "side": 1, "simpl": 1, "simul": 1, "solv": 1, "sourc": 1, "speed": 1, "stack": 2, "store": 1, "string": 1, "structur": 1, "syntax": 1, "techniqu": 1, "time": 4, "top": 1, "transmiss": 1, "trate": 1, "kanner": 1, "kosinski": 1, "robinson": 1}}, "1235": {"id": "1235", "title": "A Stochastic Approach to the Grammatical Coding of English", "abstract": "A computer program is described which will assign each word in an English text to its form  class or part of speech.  The program operates at relatively high speed in only a limited storage space.   About half of the word-events in a corpus are identified through the use of a small dictionary of function  words and frequently occurring lexical words.  Some suffix tests and logical-decision rules are employed  to code additional words.  Finally, the remaining words are assigned to one class or another on the basis  of the most probable form classes to occur within the already identified contexts.  The conditional probabilities  used as a basis for this coding were empirically derived from a separate hand-coded corpus.On preliminary  trials, the accuracy of the coder was 91% to 93%, with obvious ways of improving the algorithm being  suggested by an analysis of the results.", "authors": "Stolz, W. S. Tannenbaum, H. Carstensen, F. V.", "words_pool": ["accuraci", "addit", "algorithm", "analysi", "approach", "assign", "assign", "basi", "class", "class", "code", "code", "coder", "code", "comput", "condit", "context", "corpu", "decis", "deriv", "dictionari", "empir", "employ", "english", "event", "final", "form", "frequent", "function", "grammat", "half", "hand", "high", "identifi", "improv", "lexic", "limit", "logic", "obviou", "occur", "occur", "oper", "part", "preliminari", "probabl", "probabl", "program", "remain", "result", "rule", "separ", "small", "space", "speech", "speed", "stochast", "storag", "suffix", "suggest", "test", "text", "trial", "way", "word", "word", "stolz", "tannenbaum", "carstensen"], "word_count": {"accuraci": 1, "addit": 1, "algorithm": 1, "analysi": 1, "approach": 1, "assign": 2, "basi": 2, "class": 3, "code": 3, "coder": 1, "comput": 1, "condit": 1, "context": 1, "corpu": 2, "decis": 1, "deriv": 1, "dictionari": 1, "empir": 1, "employ": 1, "english": 1, "event": 1, "final": 1, "form": 2, "frequent": 1, "function": 1, "grammat": 1, "half": 1, "hand": 1, "high": 1, "identifi": 2, "improv": 1, "lexic": 1, "limit": 1, "logic": 1, "obviou": 1, "occur": 2, "oper": 1, "part": 1, "preliminari": 1, "probabl": 2, "program": 2, "remain": 1, "result": 1, "rule": 1, "separ": 1, "small": 1, "space": 1, "speech": 1, "speed": 1, "stochast": 1, "storag": 1, "suffix": 1, "suggest": 1, "test": 1, "text": 1, "trial": 1, "way": 1, "word": 6, "stolz": 1, "tannenbaum": 1, "carstensen": 1}}, "1236": {"id": "1236", "title": "The SMART Automatic Document Retrieval System-An Illustration", "abstract": "A fully automatic document retrieval system operating on the IBM 7094 is described.  The system  is characterized by the fact that several hundred different methods are available to analyze documents  and search requests.  This feature is used in the retrieval process by leaving the exact sequence of  operations initially unspecified, and adapting the search strategy to the needs of individual users.   The system is used not only to simulate an actual operating environment, but also to test the effectiveness  of the various available processing methods.  Results obtained so far seem to indicate that some combination  of analysis procedures can in general be relied upon to retrieve the wanted information.  A typical search  request is used as an example in the present report to illustrate systems operations and evaluation procedures.", "authors": "Salton, G. Lesk, M. E.", "words_pool": ["actual", "adapt", "analysi", "analyz", "automat", "character", "combin", "document", "document", "effect", "environ", "evalu", "exact", "fact", "featur", "fulli", "gener", "hundr", "ibm", "illustr", "illustr", "individu", "inform", "initi", "leav", "method", "need", "obtain", "oper", "oper", "present", "procedur", "process", "process", "reli", "report", "request", "request", "result", "retriev", "retriev", "search", "sequenc", "simul", "smart", "strategi", "system", "system", "test", "typic", "unspecifi", "user", "want", "salton", "lesk"], "word_count": {"actual": 1, "adapt": 1, "analysi": 1, "analyz": 1, "automat": 1, "character": 1, "combin": 1, "document": 2, "effect": 1, "environ": 1, "evalu": 1, "exact": 1, "fact": 1, "featur": 1, "fulli": 1, "gener": 1, "hundr": 1, "ibm": 1, "illustr": 1, "individu": 1, "inform": 1, "initi": 1, "leav": 1, "method": 2, "need": 1, "obtain": 1, "oper": 4, "present": 1, "procedur": 2, "process": 2, "reli": 1, "report": 1, "request": 2, "result": 1, "retriev": 3, "search": 3, "sequenc": 1, "simul": 1, "smart": 1, "strategi": 1, "system": 4, "test": 1, "typic": 1, "unspecifi": 1, "user": 1, "want": 1, "salton": 1, "lesk": 1}}, "1237": {"id": "1237", "title": "Conversion of Decision Tables To Computer Programs", "abstract": "Several translation procedures for the conversion of decision tables to programs are presented  and then evaluated in terms of storage requirements, execution time and compile time.  The procedures  are valuable as hand-coding guides or as algorithms for a compiler.  Both limited-entry and extended-entry  tables are analyzed.  In addition to table analysis, the nature of table-oriented programming languages  and features is discussed.  It is presumed that the reader is familiar with the nature of decision tables  and conventional definitions.", "authors": "Press, L. I.", "words_pool": ["addit", "algorithm", "analysi", "analyz", "code", "compil", "compil", "comput", "convent", "convers", "decis", "definit", "discuss", "entri", "evalu", "execut", "extend", "familiar", "featur", "guid", "hand", "languag", "limit", "natur", "orient", "present", "presum", "procedur", "program", "program", "reader", "requir", "storag", "tabl", "tabl", "term", "time", "translat", "valuabl", "press"], "word_count": {"addit": 1, "algorithm": 1, "analysi": 1, "analyz": 1, "code": 1, "compil": 2, "comput": 1, "convent": 1, "convers": 1, "decis": 2, "definit": 1, "discuss": 1, "entri": 2, "evalu": 1, "execut": 1, "extend": 1, "familiar": 1, "featur": 1, "guid": 1, "hand": 1, "languag": 1, "limit": 1, "natur": 2, "orient": 1, "present": 1, "presum": 1, "procedur": 2, "program": 2, "reader": 1, "requir": 1, "storag": 1, "tabl": 5, "term": 1, "time": 2, "translat": 1, "valuabl": 1, "press": 1}}, "1238": {"id": "1238", "title": "A Technique for Integrated Reports from a Multi-run System", "abstract": "The requirements of a requisition accounting system for the San Francisco Overseas Supply Agency  (OSA) included exception reporting to OSA itself.  The simultaneous satisfaction of the reporting requirement  and the accounting requirements posed definite problems in system design, particularly the handling of  the reporting function.  A practical and satisfactory solution was developed by expanding the basic system  with two tailored service runs for report production.  These two runs permitted a final system that was  easier to debug, easy to maintain, efficient in production and responsive to the changing requirements of OSA.", "authors": "Budea, N. Kamena, J. G. Kamena, R. M.", "words_pool": ["account", "agenc", "basic", "chang", "debug", "definit", "design", "develop", "easier", "easi", "effici", "except", "expand", "final", "francisco", "function", "handl", "includ", "integr", "maintain", "multi", "osa", "oversea", "permit", "pose", "practic", "problem", "product", "report", "report", "report", "requir", "requir", "requisit", "respons", "run", "run", "san", "satisfact", "satisfactori", "servic", "simultan", "solut", "suppli", "system", "tailor", "techniqu", "budea", "kamena", "kamena"], "word_count": {"account": 2, "agenc": 1, "basic": 1, "chang": 1, "debug": 1, "definit": 1, "design": 1, "develop": 1, "easier": 1, "easi": 1, "effici": 1, "except": 1, "expand": 1, "final": 1, "francisco": 1, "function": 1, "handl": 1, "includ": 1, "integr": 1, "maintain": 1, "multi": 1, "osa": 3, "oversea": 1, "permit": 1, "pose": 1, "practic": 1, "problem": 1, "product": 2, "report": 4, "requir": 4, "requisit": 1, "respons": 1, "run": 2, "san": 1, "satisfact": 1, "satisfactori": 1, "servic": 1, "simultan": 1, "solut": 1, "suppli": 1, "system": 4, "tailor": 1, "techniqu": 1, "budea": 1, "kamena": 1}}, "1239": {"id": "1239", "title": "Graycode (Algorithm 246 [Z])", "authors": "Allen, W. D.", "words_pool": ["algorithm", "graycod", "allen"], "word_count": {"algorithm": 1, "graycod": 1, "allen": 1}}, "1240": {"id": "1240", "title": "Transport (Algorithm 258 [H])", "authors": "Bayer, G.", "words_pool": ["algorithm", "transport", "bayer"], "word_count": {"algorithm": 1, "transport": 1, "bayer": 1}}, "1241": {"id": "1241", "title": "Havie Integrator (Algorithm 257 [D1])", "authors": "Kubik, R. N.", "words_pool": ["algorithm", "d1", "havi", "integr", "kubik"], "word_count": {"algorithm": 1, "d1": 1, "havi": 1, "integr": 1, "kubik": 1}}, "1242": {"id": "1242", "title": "Modified Graeffe Method (Algorithm 256 [C2])", "authors": "Grau, A. A.", "words_pool": ["algorithm", "c2", "graeff", "method", "modifi", "grau"], "word_count": {"algorithm": 1, "c2": 1, "graeff": 1, "method": 1, "modifi": 1, "grau": 1}}, "1243": {"id": "1243", "title": "Testing the Understanding of the Difference Between Call by Name and Call by Value in ALGOL 60", "authors": "Weil, R. L.", "words_pool": ["algol", "call", "differ", "test", "understand", "weil"], "word_count": {"algol": 1, "call": 2, "differ": 1, "test": 1, "understand": 1, "weil": 1}}, "1244": {"id": "1244", "title": "Bit Manipulation in Fortran Language", "authors": "Tobey, G. D.", "words_pool": ["bit", "fortran", "languag", "manipul", "tobey"], "word_count": {"bit": 1, "fortran": 1, "languag": 1, "manipul": 1, "tobey": 1}}, "1245": {"id": "1245", "title": "A Fortran n-Ary Counter", "authors": "Kent, W.", "words_pool": ["ari", "counter", "fortran", "kent"], "word_count": {"ari": 1, "counter": 1, "fortran": 1, "kent": 1}}, "1246": {"id": "1246", "title": "Deeply Nested Iterations", "authors": "Korphage, R. R.", "words_pool": ["deepli", "iter", "nest", "korphag"], "word_count": {"deepli": 1, "iter": 1, "nest": 1, "korphag": 1}}, "1247": {"id": "1247", "title": "An Operating Environment for Dynamic-Recursive Computer Programming Systems", "abstract": "Presented in this paper is a brief nontechnical introduction to OEDIPUS, a computer programming  system which can serve as an operating environment for dynamic and/or recursive programs and programming  systems.  The available services include dynamic allocation of storage for contiguous blocks of arbitrary  size, input and output for a hierarchy of data types, a public pushdown list for automatic recursive  programming, a rudimentary compiler for subroutine communication and bookkeeping, and debugging aids.", "authors": "Brown, W. S.", "words_pool": ["aid", "alloc", "arbitrari", "automat", "block", "bookkeep", "commun", "compil", "comput", "contigu", "data", "debug", "dynam", "environ", "hierarchi", "includ", "input", "introduct", "list", "nontechn", "oedipu", "oper", "output", "paper", "present", "program", "program", "public", "pushdown", "recurs", "rudimentari", "serv", "servic", "size", "storag", "subroutin", "system", "system", "type", "brown"], "word_count": {"aid": 1, "alloc": 1, "arbitrari": 1, "automat": 1, "block": 1, "bookkeep": 1, "commun": 1, "compil": 1, "comput": 1, "contigu": 1, "data": 1, "debug": 1, "dynam": 2, "environ": 1, "hierarchi": 1, "includ": 1, "input": 1, "introduct": 1, "list": 1, "nontechn": 1, "oedipu": 1, "oper": 1, "output": 1, "paper": 1, "present": 1, "program": 4, "public": 1, "pushdown": 1, "recurs": 2, "rudimentari": 1, "serv": 1, "servic": 1, "size": 1, "storag": 1, "subroutin": 1, "system": 2, "type": 1, "brown": 1}}, "1248": {"id": "1248", "title": "On the Automatic Simplification of Computer Programs", "abstract": "Presented in this paper is the problem of writing a program which would examine any other program  and perform such simplifications on it as can be detected from the argument-program's form alone, without  having any knowledge of what it is supposed to do.", "authors": "Nievergelt, J.", "words_pool": ["argument", "automat", "comput", "detect", "examin", "form", "knowledg", "paper", "perform", "present", "problem", "program", "program", "simplif", "simplif", "suppos", "write", "nievergelt"], "word_count": {"argument": 1, "automat": 1, "comput": 1, "detect": 1, "examin": 1, "form": 1, "knowledg": 1, "paper": 1, "perform": 1, "present": 1, "problem": 1, "program": 3, "simplif": 1, "suppos": 1, "write": 1, "nievergelt": 1}}, "1249": {"id": "1249", "title": "Recorded Magnetic Tape for Information Interchange (200 CPI, NRZI) (On the Revised Proposed  American Standard)", "words_pool": ["american", "cpi", "inform", "interchang", "magnet", "nrzi", "propos", "record", "revis", "standard", "tape"], "word_count": {"american": 1, "cpi": 1, "inform": 1, "interchang": 1, "magnet": 1, "nrzi": 1, "propos": 1, "record": 1, "revis": 1, "standard": 1, "tape": 1}}, "1250": {"id": "1250", "title": "Graphic Symbols for Problem Definition and Analysis-A Standards Working Paper", "words_pool": ["analysi", "definit", "graphic", "paper", "problem", "standard", "symbol", "work"], "word_count": {"analysi": 1, "definit": 1, "graphic": 1, "paper": 1, "problem": 1, "standard": 1, "symbol": 1, "work": 1}}, "1251": {"id": "1251", "title": "American Standard and IFIP/ICC Vocabularies compared", "abstract": "The \"Proposed American Standard Vocabulary of Information Processing\" and the \"IFIP/ICC Vocabulary  of Terms Used in Information Processing\" are analyzed and compared.", "authors": "Traub, J. F.", "words_pool": ["american", "analyz", "compar", "icc", "ifip", "inform", "process", "propos", "standard", "term", "vocabulari", "vocabulari", "traub"], "word_count": {"american": 1, "analyz": 1, "compar": 1, "icc": 1, "ifip": 1, "inform": 2, "process": 2, "propos": 1, "standard": 1, "term": 1, "vocabulari": 2, "traub": 1}}, "1252": {"id": "1252", "title": "Symbolic Notations for Statistical Tables and an Approach Towards Automatic System Design", "abstract": "The preparation of statistical tables is an important function of the data processing systems  of some organizations, and a symbolic notation for the description of tables has been shown to be a useful  aid to documentation.  Such a notation also provides the first step towards making automatic a tedious  and time-consuming part of system design and programming in many computer applications.  One notation  is described and suggestions are made for the implementation of the larger goal.", "authors": "Smith, B. W.", "words_pool": ["aid", "applic", "approach", "automat", "comput", "consum", "data", "descript", "design", "document", "function", "goal", "implement", "import", "larger", "made", "make", "notat", "notat", "organ", "part", "prepar", "process", "program", "shown", "statist", "step", "suggest", "symbol", "system", "system", "tabl", "tediou", "time", "smith"], "word_count": {"aid": 1, "applic": 1, "approach": 1, "automat": 1, "comput": 1, "consum": 1, "data": 1, "descript": 1, "design": 1, "document": 1, "function": 1, "goal": 1, "implement": 1, "import": 1, "larger": 1, "made": 1, "make": 1, "notat": 3, "organ": 1, "part": 1, "prepar": 1, "process": 1, "program": 1, "shown": 1, "statist": 1, "step": 1, "suggest": 1, "symbol": 1, "system": 2, "tabl": 2, "tediou": 1, "time": 1, "smith": 1}}, "1253": {"id": "1253", "title": "QUIKSCRIPT-A SIMSCRIPT- Like Language for the G-20", "abstract": "QUIKSCRIPT is a simulation language based on SIMSCRIPT and programmed entirely in an algebraic  language, 20-GATE.  The QUIKSCRIPT language, its internal implementation, and major differences between  QUIKSCRIPT and SIMSCRIPT are presented.  This paper is not a programming guide to the language, but rather  an attempt to present its flavor.  A brief description of SIMSCRIPT is included, as is a sufficient description  of 20-GATE to render this material understandable to the reader familiar with algebraic languages.", "authors": "Tonge, F. M. Keller, P. Newell, A.", "words_pool": ["algebra", "attempt", "base", "descript", "differ", "entir", "familiar", "flavor", "gate", "guid", "implement", "includ", "intern", "languag", "languag", "major", "materi", "paper", "present", "present", "program", "program", "quikscript", "reader", "render", "simscript", "simul", "suffici", "understand", "tong", "keller", "newel"], "word_count": {"algebra": 2, "attempt": 1, "base": 1, "descript": 2, "differ": 1, "entir": 1, "familiar": 1, "flavor": 1, "gate": 2, "guid": 1, "implement": 1, "includ": 1, "intern": 1, "languag": 5, "major": 1, "materi": 1, "paper": 1, "present": 2, "program": 2, "quikscript": 3, "reader": 1, "render": 1, "simscript": 3, "simul": 1, "suffici": 1, "understand": 1, "tong": 1, "keller": 1, "newel": 1}}, "1254": {"id": "1254", "title": "The Iteration Element", "abstract": "A recent addition to the MAD language has made the iteration structure of the MAD THROUGH statement  (corresponding to the ALGOL for statement and the FORTRAN DO statement) available within expressions.", "authors": "Galler, B. A. Fischer, M. J.", "words_pool": ["addit", "algol", "element", "express", "fortran", "iter", "languag", "mad", "made", "recent", "statement", "structur", "galler", "fischer"], "word_count": {"addit": 1, "algol": 1, "element": 1, "express": 1, "fortran": 1, "iter": 1, "languag": 1, "mad": 2, "made": 1, "recent": 1, "statement": 3, "structur": 1, "galler": 1, "fischer": 1}}, "1255": {"id": "1255", "title": "A Method of Data List Processing With Application to EEG Analysis", "abstract": "A set of subroutines is discussed, which is designed to aid in the programming of computations  on indexed lists of numbers using machine language or a symbolic assembly system.  The most commonly  performed list operations are outlined, and logically arranged into five groups.  As an example, the  computation of power spectral density from the autocovariance function is discussed for a class of EEG  signals.", "authors": "Philpott, C. M. Lago, G. V.", "words_pool": ["aid", "analysi", "applic", "arrang", "assembl", "autocovari", "class", "commonli", "comput", "comput", "data", "densiti", "design", "discuss", "eeg", "function", "group", "index", "languag", "list", "list", "logic", "machin", "method", "number", "oper", "outlin", "perform", "power", "process", "program", "set", "signal", "spectral", "subroutin", "symbol", "system", "philpott", "lago"], "word_count": {"aid": 1, "analysi": 1, "applic": 1, "arrang": 1, "assembl": 1, "autocovari": 1, "class": 1, "commonli": 1, "comput": 2, "data": 1, "densiti": 1, "design": 1, "discuss": 2, "eeg": 1, "function": 1, "group": 1, "index": 1, "languag": 1, "list": 2, "logic": 1, "machin": 1, "method": 1, "number": 1, "oper": 1, "outlin": 1, "perform": 1, "power": 1, "process": 1, "program": 1, "set": 1, "signal": 1, "spectral": 1, "subroutin": 1, "symbol": 1, "system": 1, "philpott": 1, "lago": 1}}, "1256": {"id": "1256", "title": "Dynamic Variable Formatting", "authors": "King, D. R.", "words_pool": ["dynam", "format", "variabl", "king"], "word_count": {"dynam": 1, "format": 1, "variabl": 1, "king": 1}}, "1257": {"id": "1257", "title": "DEBUG-An Extension to Current On-Line Debugging Techniques", "abstract": "A method of on-linr assembly-language debugging which greatly simplifies several of the bookkeeping  tasks characteristically associated with that process has been developed and implemented in a program  for the UNIVAC M-460 computer at Air Force Cambridge Research Laboratories.  With this program, an online  user may insert or delete (in symbolic assembly language) any number of lines at any point of his previously  assembled program in core, with the remainder of the program being relocated appropriately.", "authors": "Evans, T. G. Darley, D. L.", "words_pool": ["air", "appropri", "assembl", "assembl", "bookkeep", "cambridg", "characterist", "comput", "core", "debug", "debug", "delet", "develop", "extens", "forc", "greatli", "implement", "insert", "laboratori", "languag", "line", "line", "linr", "method", "number", "onlin", "point", "previous", "process", "program", "reloc", "remaind", "research", "simplifi", "symbol", "task", "techniqu", "univac", "user", "evan", "darley"], "word_count": {"air": 1, "appropri": 1, "assembl": 3, "bookkeep": 1, "cambridg": 1, "characterist": 1, "comput": 1, "core": 1, "debug": 1, "delet": 1, "develop": 1, "extens": 1, "forc": 1, "greatli": 1, "implement": 1, "insert": 1, "laboratori": 1, "languag": 2, "line": 1, "linr": 1, "method": 1, "number": 1, "onlin": 1, "point": 1, "previous": 1, "process": 1, "program": 4, "reloc": 1, "remaind": 1, "research": 1, "simplifi": 1, "symbol": 1, "task": 1, "techniqu": 1, "univac": 1, "user": 1, "evan": 1, "darley": 1}}, "1258": {"id": "1258", "title": "An Extended Arithmetic Package", "abstract": "In many fields, for example algebraic number theory, arithmetic must be carried out to a degree  of precision which exceeds the normal hardware capacity of most machines.  In such cases, an extended  arithmetic package provides a comprehensive and easy-to-use way of performing such arithmetic.  Such  a package was coded for the IBM 7090.  In discussing the general problems associated with the design  of an extended arithmetic package, specific reference is made to this program.", "authors": "Blum, B. I.", "words_pool": ["algebra", "arithmet", "capac", "carri", "case", "code", "comprehens", "degre", "design", "discuss", "easi", "exce", "extend", "field", "gener", "hardwar", "ibm", "machin", "made", "normal", "number", "packag", "perform", "precis", "problem", "program", "refer", "specif", "theori", "blum"], "word_count": {"algebra": 1, "arithmet": 4, "capac": 1, "carri": 1, "case": 1, "code": 1, "comprehens": 1, "degre": 1, "design": 1, "discuss": 1, "easi": 1, "exce": 1, "extend": 2, "field": 1, "gener": 1, "hardwar": 1, "ibm": 1, "machin": 1, "made": 1, "normal": 1, "number": 1, "packag": 3, "perform": 1, "precis": 1, "problem": 1, "program": 1, "refer": 1, "specif": 1, "theori": 1, "blum": 1}}, "1259": {"id": "1259", "title": "Applications of Binary Numbers In Computer Routines", "abstract": "A binary number can be thought of as an alternate form of expression for either a set of letters  or a decimal number.  There are then three equivalent expressions, easily translatable to one another,  each having different characteristics.  Four examples are given in which the form of an expression is  changed to an equivalent expression to save space or gain power.", "authors": "Weldon, R. J. Baker, R. L.", "words_pool": ["altern", "applic", "binari", "chang", "characterist", "comput", "decim", "easili", "equival", "exampl", "express", "express", "form", "gain", "letter", "number", "number", "power", "routin", "save", "set", "space", "thought", "translat", "weldon", "baker"], "word_count": {"altern": 1, "applic": 1, "binari": 1, "chang": 1, "characterist": 1, "comput": 1, "decim": 1, "easili": 1, "equival": 2, "exampl": 1, "express": 4, "form": 2, "gain": 1, "letter": 1, "number": 2, "power": 1, "routin": 1, "save": 1, "set": 1, "space": 1, "thought": 1, "translat": 1, "weldon": 1, "baker": 1}}, "1260": {"id": "1260", "title": "Least-Squares Analysis of Resonance Spectra on Small Computers", "abstract": "The problem of analyzing data from a Mossbauer effect experiment is discussed.  By using the  cut step procedure for convergence and by imposing physical constraints on the functional form of the  calculation it is possible to make the analysis on a small computer.  The analysis has been carried out  on an IBM 1410 computer with a 40,000 BCD core memory.", "authors": "Marshall, S. W. Nelson, J. A. Wilenzick, R. M.", "words_pool": ["analysi", "analyz", "bcd", "calcul", "carri", "comput", "comput", "constraint", "converg", "core", "cut", "data", "discuss", "effect", "experi", "form", "function", "ibm", "impos", "make", "memori", "mossbauer", "physic", "problem", "procedur", "reson", "small", "spectra", "squar", "step", "marshal", "nelson", "wilenzick"], "word_count": {"analysi": 2, "analyz": 1, "bcd": 1, "calcul": 1, "carri": 1, "comput": 2, "constraint": 1, "converg": 1, "core": 1, "cut": 1, "data": 1, "discuss": 1, "effect": 1, "experi": 1, "form": 1, "function": 1, "ibm": 1, "impos": 1, "make": 1, "memori": 1, "mossbauer": 1, "physic": 1, "problem": 1, "procedur": 1, "reson": 1, "small": 1, "spectra": 1, "squar": 1, "step": 1, "marshal": 1, "nelson": 1, "wilenzick": 1}}, "1261": {"id": "1261", "title": "Modeling and Simulation of Digital Networks", "abstract": "The simulation of digital networks on a digital computer provides the engineer with an effective  means of analyzing time-quantized logical behavior.  The digital network is modeled as a set of time-dependent  or time-independent Boolean transformations; each transformation describing the input-output relationship  of a model element comprising the network mode.  The simplicity of utilizing the FORTRAN IV Programming  System as a digital Network Simulator is discussed an illustrated.  This simplicity is derived from a  common modeling technique applicable to combinational and sequential digital networks and a systematic  programming approach.", "authors": "Larsen, R. P. Mano, M. M.", "words_pool": ["analyz", "applic", "approach", "behavior", "boolean", "combin", "common", "compris", "comput", "depend", "deriv", "describ", "digit", "discuss", "effect", "element", "engin", "fortran", "illustr", "independ", "input", "iv", "logic", "mean", "mode", "model", "model", "model", "network", "network", "output", "program", "quantiz", "relationship", "sequenti", "set", "simplic", "simul", "simul", "system", "systemat", "techniqu", "time", "transform", "transform", "util", "larsen", "mano"], "word_count": {"analyz": 1, "applic": 1, "approach": 1, "behavior": 1, "boolean": 1, "combin": 1, "common": 1, "compris": 1, "comput": 1, "depend": 1, "deriv": 1, "describ": 1, "digit": 5, "discuss": 1, "effect": 1, "element": 1, "engin": 1, "fortran": 1, "illustr": 1, "independ": 1, "input": 1, "iv": 1, "logic": 1, "mean": 1, "mode": 1, "model": 3, "network": 5, "output": 1, "program": 2, "quantiz": 1, "relationship": 1, "sequenti": 1, "set": 1, "simplic": 2, "simul": 2, "system": 1, "systemat": 1, "techniqu": 1, "time": 3, "transform": 2, "util": 1, "larsen": 1, "mano": 1}}, "1262": {"id": "1262", "title": "Procedure-Oriented Language Statements to Facilitate Parallel Processing", "abstract": "Two statements are suggested which allow a programmer writing in a procedure-oriented language  to indicate sections of program which are to be executed in parallel.  The statements are DO TOGETHER  and HOLD.  These serve partly as brackets in establishing a range of parallel operation and partly to  define each parallel path within this range.  DO TOGETHERs may be nested.  The statements should be particularly  effective for use with computing devices capable of attaining some degree of compute-compute overlap.", "authors": "Opler, A.", "words_pool": ["allow", "attain", "bracket", "capabl", "comput", "comput", "defin", "degre", "devic", "effect", "establish", "execut", "facilit", "hold", "languag", "nest", "oper", "orient", "overlap", "parallel", "partli", "path", "procedur", "process", "program", "programm", "rang", "section", "serv", "statement", "suggest", "togeth", "write", "opler"], "word_count": {"allow": 1, "attain": 1, "bracket": 1, "capabl": 1, "comput": 3, "defin": 1, "degre": 1, "devic": 1, "effect": 1, "establish": 1, "execut": 1, "facilit": 1, "hold": 1, "languag": 1, "nest": 1, "oper": 1, "orient": 1, "overlap": 1, "parallel": 3, "partli": 2, "path": 1, "procedur": 1, "process": 1, "program": 1, "programm": 1, "rang": 2, "section": 1, "serv": 1, "statement": 3, "suggest": 1, "togeth": 1, "write": 1, "opler": 1}}, "1263": {"id": "1263", "title": "Metalanguage and Syntax Specification", "abstract": "Two metalanguages are described, one sufficient for the table specification of the ALGOL syntax,  the other with additional metaoperators adequate and used for the formal table description of Basic FORTRAN.", "authors": "Burkhardt, W. H.", "words_pool": ["addit", "adequ", "algol", "basic", "descript", "formal", "fortran", "metalanguag", "metalanguag", "metaoper", "specif", "suffici", "syntax", "tabl", "burkhardt"], "word_count": {"addit": 1, "adequ": 1, "algol": 1, "basic": 1, "descript": 1, "formal": 1, "fortran": 1, "metalanguag": 1, "metaoper": 1, "specif": 1, "suffici": 1, "syntax": 1, "tabl": 2, "burkhardt": 1}}, "1264": {"id": "1264", "title": "BLNSYS-A 1401 Operating System with Braille Capabilities", "abstract": "BLNSYS is an operating system designed for a 4K 1401 with common optional features and two  attached tape drives.  Printed output of this system or of executing programs may be in either English  or braille.  Even though this system was written for a small machine with minimal peripheral equipment,  jobs may be batched, so that card handling and lost processing time is at a minimum.  This system will  perform any or all of the following users specified functions: assemble SPS source decks, post list,  produce condensed or uncondensed object decks, execute user's program, list card input to a program,  list punched output, provide a storage dump, execute a program submitted for execution as an uncondensed  object deck under debugging trace control, card-to-braille conversion, brailled listings of 7040 IBSYS  batch output, and update or duplicate the system tape itself.  Input-ouput subroutines are also included  in the system.", "authors": "Landwehr, J. B. McLaughlin, C. Mueller, H. Lichstein, M. Pollack, S. V.", "words_pool": ["4k", "assembl", "attach", "batch", "batch", "blnsi", "braill", "braill", "capabl", "card", "common", "condens", "control", "convers", "debug", "deck", "deck", "design", "drive", "dump", "duplic", "english", "equip", "execut", "execut", "execut", "featur", "function", "handl", "ibsi", "includ", "input", "job", "list", "list", "lost", "machin", "minim", "minimum", "object", "oper", "option", "ouput", "output", "perform", "peripher", "post", "print", "process", "produc", "program", "program", "provid", "punch", "small", "sourc", "sp", "storag", "submit", "subroutin", "system", "tape", "time", "trace", "uncondens", "updat", "user", "user", "written", "landwehr", "mclaughlin", "mueller", "lichstein", "pollack"], "word_count": {"4k": 1, "assembl": 1, "attach": 1, "batch": 2, "blnsi": 1, "braill": 3, "capabl": 1, "card": 3, "common": 1, "condens": 1, "control": 1, "convers": 1, "debug": 1, "deck": 3, "design": 1, "drive": 1, "dump": 1, "duplic": 1, "english": 1, "equip": 1, "execut": 4, "featur": 1, "function": 1, "handl": 1, "ibsi": 1, "includ": 1, "input": 2, "job": 1, "list": 4, "lost": 1, "machin": 1, "minim": 1, "minimum": 1, "object": 2, "oper": 1, "option": 1, "ouput": 1, "output": 3, "perform": 1, "peripher": 1, "post": 1, "print": 1, "process": 1, "produc": 1, "program": 4, "provid": 1, "punch": 1, "small": 1, "sourc": 1, "sp": 1, "storag": 1, "submit": 1, "subroutin": 1, "system": 6, "tape": 2, "time": 1, "trace": 1, "uncondens": 2, "updat": 1, "user": 2, "written": 1, "landwehr": 1, "mclaughlin": 1, "mueller": 1, "lichstein": 1, "pollack": 1}}, "1265": {"id": "1265", "title": "On the Relative Efficiencies of Context-Free Grammar Recognizers", "abstract": "A number of diverse recognition procedures that have been proposed for parsing sentences with  respect to a context-free grammar are described in this paper by means of a common device.  Each procedure  is defined by giving an algorithm for obtaining a nondeterministic Turing Machine recognizer that is  equivalent to a given context-free grammar.  The formalization of the Turing Machine has been chosen  to make possible particularly simple description of the parsing procedures considered.  An attempt has  been made to compare recognition efficiencies for the procedures defined.  For a few simple grammars  and sentences a formal comparison has been made.  Empirical comparison of the recognition of more realistic  programming languages such as LISP and ALGOL has been made by means of a program which simulates the  Turing Machine on the Univac M-460 computer.  Several algorithms for producing grammars equivalent to  a given context-free grammar have been considered, and the increase in recognition efficiency they afford  has been empirically investigated.", "authors": "Griffiths, T. V. Petrick, S. R.", "words_pool": ["afford", "algol", "algorithm", "algorithm", "attempt", "chosen", "common", "compar", "comparison", "comput", "consid", "context", "defin", "descript", "devic", "divers", "effici", "effici", "empir", "empir", "equival", "formal", "formal", "free", "give", "grammar", "grammar", "increas", "investig", "languag", "lisp", "machin", "made", "make", "mean", "nondeterminist", "number", "obtain", "paper", "pars", "procedur", "procedur", "produc", "program", "program", "propos", "realist", "recognit", "recogn", "recogn", "rel", "respect", "sentenc", "simpl", "simul", "ture", "univac", "griffith", "petrick"], "word_count": {"afford": 1, "algol": 1, "algorithm": 2, "attempt": 1, "chosen": 1, "common": 1, "compar": 1, "comparison": 2, "comput": 1, "consid": 2, "context": 3, "defin": 2, "descript": 1, "devic": 1, "divers": 1, "effici": 2, "empir": 2, "equival": 2, "formal": 2, "free": 3, "give": 1, "grammar": 5, "increas": 1, "investig": 1, "languag": 1, "lisp": 1, "machin": 3, "made": 3, "make": 1, "mean": 2, "nondeterminist": 1, "number": 1, "obtain": 1, "paper": 1, "pars": 2, "procedur": 4, "produc": 1, "program": 2, "propos": 1, "realist": 1, "recognit": 4, "recogn": 1, "rel": 1, "respect": 1, "sentenc": 2, "simpl": 2, "simul": 1, "ture": 3, "univac": 1, "griffith": 1, "petrick": 1}}, "1266": {"id": "1266", "title": "Considerations Relating to Purpose of FORTRAN Standardization (Appendixes to ASA FORTRAN Standard)", "words_pool": ["appendix", "asa", "consider", "fortran", "purpos", "relat", "standard", "standard"], "word_count": {"appendix": 1, "asa": 1, "consider": 1, "fortran": 2, "purpos": 1, "relat": 1, "standard": 2}}, "1267": {"id": "1267", "title": "Performance of Systems Used for Data Transmission Transfer Rate of Information Bits -An ASA Tutorial  Standard", "abstract": "Information thruput as a characteristic of systems performance is discussed.  This discussion  includes the pertinent aspects of information transfer, of determination of transfer rate of information  bits (TRIB), of residual errors, and of standard measurement conditions.  The paper also presents an  orderly arrangement of characteristics and parameters that affect information thruput, and some examples  on procedures for determining a thruput rate in terms of TRIB.  It concludes that a performance characteristic  involving information rate can best be expressed as the TRIB in conjunction with the Residual Error Rate.", "words_pool": ["affect", "arrang", "asa", "aspect", "bit", "characterist", "characterist", "conclud", "condit", "conjunct", "data", "determin", "determin", "discuss", "discuss", "error", "error", "exampl", "express", "includ", "inform", "involv", "measur", "orderli", "paper", "paramet", "perform", "pertin", "present", "procedur", "rate", "residu", "standard", "system", "term", "thruput", "transfer", "transmiss", "trib", "tutori"], "word_count": {"affect": 1, "arrang": 1, "asa": 1, "aspect": 1, "bit": 1, "characterist": 3, "conclud": 1, "condit": 1, "conjunct": 1, "data": 1, "determin": 2, "discuss": 2, "error": 2, "exampl": 1, "express": 1, "includ": 1, "inform": 5, "involv": 1, "measur": 1, "orderli": 1, "paper": 1, "paramet": 1, "perform": 2, "pertin": 1, "present": 1, "procedur": 1, "rate": 4, "residu": 2, "standard": 1, "system": 1, "term": 1, "thruput": 3, "transfer": 2, "transmiss": 1, "trib": 3, "tutori": 1}}, "1268": {"id": "1268", "title": "Logarithm of a Complex Number (Algorithm 243 [B3])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "b3", "complex", "logarithm", "number", "boothroyd"], "word_count": {"algorithm": 1, "b3": 1, "complex": 1, "logarithm": 1, "number": 1, "boothroyd": 1}}, "1269": {"id": "1269", "title": "Computation of Fourier Coefficients (Algorithm [C6])", "authors": "Teijelo, L.", "words_pool": ["algorithm", "c6", "coeffici", "comput", "fourier", "teijelo"], "word_count": {"algorithm": 1, "c6": 1, "coeffici": 1, "comput": 1, "fourier": 1, "teijelo": 1}}, "1270": {"id": "1270", "title": "On ALGOL Education: Automatic Grading Programs", "abstract": "Two ALGOL grader programs are presented for the computer evaluation of student ALGOL programs.  One is for a beginner's program; it furnishes random data and checks answers. The other provides a searching  test of the reliability and efficiency of an integration procedure.  There is a statement of the essential  properties of a computer system, in order that grader programs can be effectively used.", "authors": "Forsythe, G. E. Wirth, N.", "words_pool": ["algol", "answer", "automat", "beginn", "check", "comput", "data", "educ", "effect", "effici", "essenti", "evalu", "furnish", "grader", "grade", "integr", "order", "present", "procedur", "program", "program", "properti", "random", "reliabl", "search", "statement", "student", "system", "test", "forsyth", "wirth"], "word_count": {"algol": 2, "answer": 1, "automat": 1, "beginn": 1, "check": 1, "comput": 2, "data": 1, "educ": 1, "effect": 1, "effici": 1, "essenti": 1, "evalu": 1, "furnish": 1, "grader": 2, "grade": 1, "integr": 1, "order": 1, "present": 1, "procedur": 1, "program": 4, "properti": 1, "random": 1, "reliabl": 1, "search": 1, "statement": 1, "student": 1, "system": 1, "test": 1, "forsyth": 1, "wirth": 1}}, "1271": {"id": "1271", "title": "Secondary Key Retrieval Using an IBM 7090-1301 System", "abstract": "The secondary key retrieval method involves the preparation of secondary storage lists from  primary data records. Search requests are satisfied by logical operations on appropriate lists, producing  a complete set of addresses of primary records relevant to the request.  Experimental results are presented  and a comparative analysis is given.", "authors": "Davis, D. R. Lin, A. D.", "words_pool": ["address", "analysi", "compar", "complet", "data", "experiment", "ibm", "involv", "key", "list", "logic", "method", "oper", "prepar", "present", "primari", "produc", "record", "relev", "request", "request", "result", "retriev", "satisfi", "search", "secondari", "set", "storag", "system", "davi", "lin"], "word_count": {"address": 1, "analysi": 1, "compar": 1, "complet": 1, "data": 1, "experiment": 1, "ibm": 1, "involv": 1, "key": 1, "list": 2, "logic": 1, "method": 1, "oper": 1, "prepar": 1, "present": 1, "primari": 2, "produc": 1, "record": 2, "relev": 1, "request": 2, "result": 1, "retriev": 1, "satisfi": 1, "search": 1, "secondari": 2, "set": 1, "storag": 1, "system": 1, "davi": 1, "lin": 1}}, "1272": {"id": "1272", "title": "Expanding the Editing Function In Language Data Processing", "abstract": "In automatic abstracting, citation indexing, mechanical translation and other such procedures,  editing is required whenever the automatic method leaves something to be desired.  This paper discusses  the economy of editing as a function of the amount of condensation of text in language processing operations,  and then contends that editing can be regarded as an opportunity rather than as an unwelcome necessity.   \"Heavy editing,\" which goes beyond mere correction and improvement of computer output, is exemplified  by the use of a concordance in preparing a survey article or lecture.  Other opportunities for heavy  editing are described, chief among them being interpretation and expansion of computer output in such  processes as factor analysis.  Applications are described, such processes as factor analysis.  Applications  are described, such as the quick, unbiased evaluation of a large volume of incoming mail or telegrams,  yielding summary reports not possible for either humans or computers to produce alone.", "authors": "Doule, L. B.", "words_pool": ["abstract", "amount", "analysi", "applic", "articl", "automat", "chief", "citat", "comput", "comput", "concord", "condens", "contend", "correct", "data", "desir", "discuss", "economi", "edit", "evalu", "exemplifi", "expand", "expans", "factor", "function", "goe", "heavi", "human", "improv", "incom", "index", "interpret", "languag", "larg", "leav", "lectur", "mail", "mechan", "mere", "method", "necess", "oper", "opportun", "opportun", "output", "paper", "prepar", "procedur", "process", "process", "produc", "quick", "regard", "report", "requir", "summari", "survey", "telegram", "text", "translat", "unbias", "unwelcom", "volum", "yield", "doul"], "word_count": {"abstract": 1, "amount": 1, "analysi": 2, "applic": 2, "articl": 1, "automat": 2, "chief": 1, "citat": 1, "comput": 3, "concord": 1, "condens": 1, "contend": 1, "correct": 1, "data": 1, "desir": 1, "discuss": 1, "economi": 1, "edit": 5, "evalu": 1, "exemplifi": 1, "expand": 1, "expans": 1, "factor": 2, "function": 1, "goe": 1, "heavi": 2, "human": 1, "improv": 1, "incom": 1, "index": 1, "interpret": 1, "languag": 1, "larg": 1, "leav": 1, "lectur": 1, "mail": 1, "mechan": 1, "mere": 1, "method": 1, "necess": 1, "oper": 1, "opportun": 2, "output": 2, "paper": 1, "prepar": 1, "procedur": 1, "process": 3, "produc": 1, "quick": 1, "regard": 1, "report": 1, "requir": 1, "summari": 1, "survey": 1, "telegram": 1, "text": 1, "translat": 1, "unbias": 1, "unwelcom": 1, "volum": 1, "yield": 1, "doul": 1}}, "1273": {"id": "1273", "title": "Remark on Romberg Quadrature", "abstract": "A modified form of Romberg quadrature is described, which is less sensitive to the accumulation  of rounding errors than the customary one.", "authors": "Krasun, A. M. Prager, W.", "words_pool": ["accumul", "customari", "error", "form", "modifi", "quadratur", "remark", "romberg", "round", "sensit", "krasun", "prager"], "word_count": {"accumul": 1, "customari": 1, "error": 1, "form": 1, "modifi": 1, "quadratur": 1, "remark": 1, "romberg": 1, "round": 1, "sensit": 1, "krasun": 1, "prager": 1}}, "1274": {"id": "1274", "title": "On the Numerical Solution of an N-Point Boundary Value Problem for Linear Ordinary Differential  Equations", "abstract": "A method for the numerical solution of then-point boundary value problem for homogeneous linear  ordinary differential equations is developed.  The method requires two Runge-Kutta integrations over  the interval under consideration and the solution of a linear system of equations with n-1 unknowns.", "authors": "Day, J. T.", "words_pool": ["boundari", "consider", "develop", "differenti", "equat", "homogen", "integr", "interv", "kutta", "linear", "method", "numer", "ordinari", "point", "problem", "requir", "rung", "solut", "system", "unknown", "day"], "word_count": {"boundari": 1, "consider": 1, "develop": 1, "differenti": 1, "equat": 2, "homogen": 1, "integr": 1, "interv": 1, "kutta": 1, "linear": 2, "method": 2, "numer": 1, "ordinari": 1, "point": 1, "problem": 1, "requir": 1, "rung": 1, "solut": 2, "system": 1, "unknown": 1, "day": 1}}, "1275": {"id": "1275", "title": "Code Structures for Protection and Manipulation of Variable Length Items (Corrigendum)", "authors": "Ramamoorthy, C. V.", "words_pool": ["code", "corrigendum", "item", "length", "manipul", "protect", "structur", "variabl", "ramamoorthi"], "word_count": {"code": 1, "corrigendum": 1, "item": 1, "length": 1, "manipul": 1, "protect": 1, "structur": 1, "variabl": 1, "ramamoorthi": 1}}, "1276": {"id": "1276", "title": "Still Another Use for FORTRAN II Chaining", "words_pool": ["chain", "fortran", "ii"], "word_count": {"chain": 1, "fortran": 1, "ii": 1}}, "1277": {"id": "1277", "title": "The Use of Cobol Subroutines in Fortran Main Programs", "authors": "Tajiri, K.", "words_pool": ["cobol", "fortran", "main", "program", "subroutin", "tajiri"], "word_count": {"cobol": 1, "fortran": 1, "main": 1, "program": 1, "subroutin": 1, "tajiri": 1}}, "1278": {"id": "1278", "title": "Wengert's Numerical Method for Partial Derivatives, Orbit Determination and Quasilinearization", "abstract": "In a recent article in the Communications of the ACM, R. Wengert suggested a technique for  machine evaluation of the partial derivatives of a function given in analytical form.  In solving non-linear  boundary-value problems using quasilinearization many partial derivatives must be formed analytically  and then evaluated numerically.  Wengert's method appears very attractive from the programming viewpoint  equations which might not otherwise be undertaken.", "authors": "Bellman, R. E. Kagiwada, H. Kalaba, R. E.", "words_pool": ["acm", "analyt", "analyt", "appear", "articl", "attract", "boundari", "commun", "deriv", "determin", "equat", "evalu", "evalu", "form", "form", "function", "linear", "machin", "method", "non", "numer", "numer", "orbit", "partial", "problem", "program", "quasilinear", "recent", "solv", "suggest", "techniqu", "undertaken", "viewpoint", "wengert", "bellman", "kagiwada", "kalaba"], "word_count": {"acm": 1, "analyt": 2, "appear": 1, "articl": 1, "attract": 1, "boundari": 1, "commun": 1, "deriv": 2, "determin": 1, "equat": 1, "evalu": 2, "form": 2, "function": 1, "linear": 1, "machin": 1, "method": 1, "non": 1, "numer": 1, "orbit": 1, "partial": 2, "problem": 1, "program": 1, "quasilinear": 1, "recent": 1, "solv": 1, "suggest": 1, "techniqu": 1, "undertaken": 1, "viewpoint": 1, "wengert": 2, "bellman": 1, "kagiwada": 1, "kalaba": 1}}, "1279": {"id": "1279", "title": "Use of a Conditional Base Number System for Encoding Sequences of Correlated Characters", "abstract": "A procedure is described for the relatively efficient encoding of sequences of characters which  have predecessor-successor selection rules.  The procedure is shown to assign a unique integer to each  sequence and to generate a reasonably compact set of values.", "authors": "Brown, R. M.", "words_pool": ["assign", "base", "charact", "compact", "condit", "correl", "effici", "encod", "gener", "integ", "number", "predecessor", "procedur", "reason", "rule", "select", "sequenc", "sequenc", "set", "shown", "successor", "system", "uniqu", "valu", "brown"], "word_count": {"assign": 1, "base": 1, "charact": 1, "compact": 1, "condit": 1, "correl": 1, "effici": 1, "encod": 1, "gener": 1, "integ": 1, "number": 1, "predecessor": 1, "procedur": 2, "reason": 1, "rule": 1, "select": 1, "sequenc": 2, "set": 1, "shown": 1, "successor": 1, "system": 1, "uniqu": 1, "valu": 1, "brown": 1}}, "1280": {"id": "1280", "title": "Numerical Integration of a Differential-Difference Equation with a Decreasing Time-Lag", "abstract": "Systems in which variable time-lags are present are of common occurrence in biology.  Variable  flow rates are a common cause of these variable lags.  At present no extensive body of knowledge exists  concerning the effects which these variable lags can cause.  Shown here is a method of reducing some  differential-difference equations to ordinary differential equations which can then be studied numerically  with ease.  Subsequent study will deal with situations in which multiple-lags and lags dependent on the  solution itself are present.", "authors": "Bellman, R. E. Buell, J. D. Kalaba, R. E.", "words_pool": ["biolog", "bodi", "common", "concern", "deal", "decreas", "depend", "differ", "differenti", "eas", "effect", "equat", "equat", "exist", "extens", "flow", "integr", "knowledg", "lag", "lag", "method", "multipl", "numer", "numer", "occurr", "ordinari", "present", "rate", "reduc", "shown", "situat", "solut", "studi", "studi", "subsequ", "system", "time", "variabl", "bellman", "buell", "kalaba"], "word_count": {"biolog": 1, "bodi": 1, "common": 2, "concern": 1, "deal": 1, "decreas": 1, "depend": 1, "differ": 1, "differenti": 2, "eas": 1, "effect": 1, "equat": 2, "exist": 1, "extens": 1, "flow": 1, "integr": 1, "knowledg": 1, "lag": 5, "method": 1, "multipl": 1, "numer": 1, "occurr": 1, "ordinari": 1, "present": 3, "rate": 1, "reduc": 1, "shown": 1, "situat": 1, "solut": 1, "studi": 2, "subsequ": 1, "system": 1, "time": 1, "variabl": 4, "bellman": 1, "buell": 1, "kalaba": 1}}, "1281": {"id": "1281", "title": "Data Input by Question and Answer", "abstract": "A data input scheme for a time-sharing computer is described in this paper.  Instead of using format statements to determine the input, the computer asks the user for the required values one at a  time.  The computer converses with the user during the input process, checks for errors, provides standard  data, and allows editing of values input.", "authors": "Pyle, I. C.", "words_pool": ["answer", "ask", "check", "comput", "convers", "data", "determin", "edit", "error", "format", "input", "paper", "process", "question", "requir", "scheme", "share", "standard", "statement", "time", "user", "valu", "pyle"], "word_count": {"answer": 1, "ask": 1, "check": 1, "comput": 3, "convers": 1, "data": 2, "determin": 1, "edit": 1, "error": 1, "format": 1, "input": 4, "paper": 1, "process": 1, "question": 1, "requir": 1, "scheme": 1, "share": 1, "standard": 1, "statement": 1, "time": 2, "user": 2, "valu": 2, "pyle": 1}}, "1282": {"id": "1282", "title": "The Use of FORTRAN in Subroutines with COBOL Main Programs", "abstract": "By using the proper COBOL coding techniques and accounting for differences in storage allocation  and library routines between the two languages, it is possible to write FORTRAN IV subroutines that may  be called from COBOL main programs.  Such a technique enables the programmer to take advantage of the  most useful properties of each language while minimizing their respective disadvantages.", "authors": "Shavell, Z. A.", "words_pool": ["account", "advantag", "alloc", "call", "cobol", "code", "differ", "disadvantag", "enabl", "fortran", "iv", "languag", "languag", "librari", "main", "minim", "programm", "program", "proper", "properti", "respect", "routin", "storag", "subroutin", "take", "techniqu", "techniqu", "write", "shavel"], "word_count": {"account": 1, "advantag": 1, "alloc": 1, "call": 1, "cobol": 2, "code": 1, "differ": 1, "disadvantag": 1, "enabl": 1, "fortran": 1, "iv": 1, "languag": 2, "librari": 1, "main": 1, "minim": 1, "programm": 1, "program": 1, "proper": 1, "properti": 1, "respect": 1, "routin": 1, "storag": 1, "subroutin": 1, "take": 1, "techniqu": 2, "write": 1, "shavel": 1}}, "1283": {"id": "1283", "title": "Matrix Inversion (Algorithm 231 [F1])", "authors": "Ferring, M.", "words_pool": ["algorithm", "f1", "invers", "matrix", "fer"], "word_count": {"algorithm": 1, "f1": 1, "invers": 1, "matrix": 1, "fer": 1}}, "1284": {"id": "1284", "title": "Bessel Function for a Set of Integer Orders", "authors": "Stafford, J.", "words_pool": ["bessel", "function", "integ", "order", "set", "stafford"], "word_count": {"bessel": 1, "function": 1, "integ": 1, "order": 1, "set": 1, "stafford": 1}}, "1285": {"id": "1285", "title": "Eigenvalues and Eigenvectors of a Real Symmetric Matrix by the QR Method (Algorithm 254 [F2])", "authors": "Businger, P. A.", "words_pool": ["algorithm", "eigenvalu", "eigenvector", "f2", "matrix", "method", "qr", "real", "symmetr", "busing"], "word_count": {"algorithm": 1, "eigenvalu": 1, "eigenvector": 1, "f2": 1, "matrix": 1, "method": 1, "qr": 1, "real": 1, "symmetr": 1, "busing": 1}}, "1286": {"id": "1286", "title": "Eigenvalues of a Real Symmetric Matrix by the QR Method (Algorithm 253 [F2])", "authors": "Businger, P. A.", "words_pool": ["algorithm", "eigenvalu", "f2", "matrix", "method", "qr", "real", "symmetr", "busing"], "word_count": {"algorithm": 1, "eigenvalu": 1, "f2": 1, "matrix": 1, "method": 1, "qr": 1, "real": 1, "symmetr": 1, "busing": 1}}, "1287": {"id": "1287", "title": "Vector Coupling or Clebsch-Gordan Coefficients (Algorithm 252 [Z])", "authors": "Gunn, J. H.", "words_pool": ["algorithm", "clebsch", "coeffici", "coupl", "gordan", "vector", "gunn"], "word_count": {"algorithm": 1, "clebsch": 1, "coeffici": 1, "coupl": 1, "gordan": 1, "vector": 1, "gunn": 1}}, "1288": {"id": "1288", "title": "CLP-The Cornell List Processor", "abstract": "Presented in this paper are the highlights of CLP, a teaching language which has been employed  at Cornell University and was constructed to serve as a means of introducing simulation and other list-processing  concepts.  The various advantages of CLP are discussed and examples are given.", "authors": "Conway, R. W. Delfausse, J. J. Maxwell, W. L. Walker, W. E.", "words_pool": ["advantag", "clp", "concept", "construct", "cornel", "discuss", "employ", "exampl", "highlight", "introduc", "languag", "list", "mean", "paper", "present", "process", "processor", "serv", "simul", "teach", "univers", "conway", "delfauss", "maxwel", "walker"], "word_count": {"advantag": 1, "clp": 2, "concept": 1, "construct": 1, "cornel": 1, "discuss": 1, "employ": 1, "exampl": 1, "highlight": 1, "introduc": 1, "languag": 1, "list": 1, "mean": 1, "paper": 1, "present": 1, "process": 1, "processor": 1, "serv": 1, "simul": 1, "teach": 1, "univers": 1, "conway": 1, "delfauss": 1, "maxwel": 1, "walker": 1}}, "1289": {"id": "1289", "title": "Proposed Revised American Standard Code for Information Interchange", "words_pool": ["american", "code", "inform", "interchang", "propos", "revis", "standard"], "word_count": {"american": 1, "code": 1, "inform": 1, "interchang": 1, "propos": 1, "revis": 1, "standard": 1}}, "1290": {"id": "1290", "title": "Transparent-Mode Control Procedures for Data Communication, Using the American Standard Code  for Information Interchange -A Tutorial", "abstract": "This paper gives the considerations of Task Group X3.3.4 in the area of transparent-mode data  communication control philosophy.  The appearance of this paper was forecast (underthe name of \"second-level  control\") in the earlier tutorial paper, \"Control Procedures for Data Communications,\" Task Group document  X3.3.4.44, dated May 1964.  The present paper elaborates upon solutions to the problems of transparency  to the basic ASCII communication control characters as outlined in the previous paper mentioned above.   Moreover, it goes on to cover the additional control problems of handling material such as off line encrypted  data or non-ASCII codes by means of systems providing complete character transparency.  It does not cover  concepts of transparency in which the normal character structure or modulation rate of a system may be  abandoned.  In conjunction with the earlier tutorial paper, this paper is expected to lead to a proposal  for stand ardizationof data communication control procedures using the American Stand ard Code for Information  Interchange.", "words_pool": ["abandon", "addit", "american", "appear", "ard", "ardizationof", "area", "ascii", "basic", "charact", "charact", "code", "code", "commun", "commun", "complet", "concept", "conjunct", "consider", "control", "cover", "data", "date", "document", "earlier", "elabor", "encrypt", "expect", "forecast", "goe", "group", "handl", "inform", "interchang", "lead", "level", "line", "materi", "mean", "mention", "mode", "modul", "non", "normal", "outlin", "paper", "philosophi", "present", "previou", "problem", "procedur", "propos", "provid", "rate", "solut", "stand", "standard", "structur", "system", "system", "task", "transpar", "transpar", "tutori", "underth", "x3"], "word_count": {"abandon": 1, "addit": 1, "american": 1, "appear": 1, "ard": 1, "ardizationof": 1, "area": 1, "ascii": 2, "basic": 1, "charact": 3, "code": 2, "commun": 4, "complet": 1, "concept": 1, "conjunct": 1, "consider": 1, "control": 6, "cover": 2, "data": 4, "date": 1, "document": 1, "earlier": 2, "elabor": 1, "encrypt": 1, "expect": 1, "forecast": 1, "goe": 1, "group": 2, "handl": 1, "inform": 1, "interchang": 1, "lead": 1, "level": 1, "line": 1, "materi": 1, "mean": 1, "mention": 1, "mode": 1, "modul": 1, "non": 1, "normal": 1, "outlin": 1, "paper": 7, "philosophi": 1, "present": 1, "previou": 1, "problem": 2, "procedur": 2, "propos": 1, "provid": 1, "rate": 1, "solut": 1, "stand": 2, "standard": 1, "structur": 1, "system": 2, "task": 2, "transpar": 4, "tutori": 2, "underth": 1, "x3": 2}}, "1291": {"id": "1291", "title": "Tabular Input of Data", "authors": "George, R.", "words_pool": ["data", "input", "tabular", "georg"], "word_count": {"data": 1, "input": 1, "tabular": 1, "georg": 1}}, "1292": {"id": "1292", "title": "On a Divide-and-Correct Method For Variable Precision Division", "abstract": "Described in this paper is a divide-and-correct method for variable precision division in digital  computers.  Unlike the earlier methods of Stein and Pope, the present method uses a suitably rounded  form of the normalized divisor for getting an estimate of the quotient characters.  This results in a  correction of at most plus or minus one to the estimate, to obtain the exact quotient character.  It  is believed that this method will be widely applicable for division operations in variable word-length  character-oriented machines.", "authors": "Krishnamurthy, E. V.", "words_pool": ["applic", "believ", "charact", "charact", "comput", "correct", "correct", "digit", "divid", "divis", "divisor", "earlier", "estim", "exact", "form", "get", "length", "machin", "method", "method", "minu", "normal", "obtain", "oper", "orient", "paper", "pope", "precis", "present", "quotient", "result", "round", "stein", "suitabl", "unlik", "variabl", "wide", "word", "krishnamurthi"], "word_count": {"applic": 1, "believ": 1, "charact": 3, "comput": 1, "correct": 2, "digit": 1, "divid": 1, "divis": 2, "divisor": 1, "earlier": 1, "estim": 2, "exact": 1, "form": 1, "get": 1, "length": 1, "machin": 1, "method": 4, "minu": 1, "normal": 1, "obtain": 1, "oper": 1, "orient": 1, "paper": 1, "pope": 1, "precis": 1, "present": 1, "quotient": 2, "result": 1, "round": 1, "stein": 1, "suitabl": 1, "unlik": 1, "variabl": 2, "wide": 1, "word": 1, "krishnamurthi": 1}}, "1293": {"id": "1293", "title": "Method is Randomness", "abstract": "Certain nonrandom properties of a commonly used random number generator are described and analyzed.", "authors": "Greenberger, M.", "words_pool": ["analyz", "commonli", "gener", "method", "nonrandom", "number", "properti", "random", "random", "greenberg"], "word_count": {"analyz": 1, "commonli": 1, "gener": 1, "method": 1, "nonrandom": 1, "number": 1, "properti": 1, "random": 1, "greenberg": 1}}, "1294": {"id": "1294", "title": "Note on Triple-Precision Floating-Point Arithmetic with 132-Bit Numbers", "abstract": "In a recent paper, Gregory and Raney described a technique for double-precision floating-point  arithmetic.  A similar technique can be developed for triple-precision floating-point arithmetic and  it is  the purpose of this note to describe this technique.  Only the multiplication and the division  algorithms are described, since the addition-subtraction algorithm can be obtained by a trivial modification  of the algorithm in Gregory's and Raney's paper.", "authors": "Ikebe, Y.", "words_pool": ["addit", "algorithm", "algorithm", "arithmet", "bit", "describ", "develop", "divis", "doubl", "float", "gregori", "modif", "multipl", "note", "number", "obtain", "paper", "point", "precis", "purpos", "raney", "recent", "similar", "subtract", "techniqu", "tripl", "trivial", "ikeb"], "word_count": {"addit": 1, "algorithm": 3, "arithmet": 2, "bit": 1, "describ": 1, "develop": 1, "divis": 1, "doubl": 1, "float": 2, "gregori": 2, "modif": 1, "multipl": 1, "note": 1, "number": 1, "obtain": 1, "paper": 2, "point": 2, "precis": 2, "purpos": 1, "raney": 2, "recent": 1, "similar": 1, "subtract": 1, "techniqu": 3, "tripl": 1, "trivial": 1, "ikeb": 1}}, "1295": {"id": "1295", "title": "PERT Time Calculations Without Topological Ordering", "abstract": "A simplified technique is presented for PERT Time calculations without topological ordering.   Each event is assigned a unique memory location.  An activity is represented by a link.  A link is defined  as a memory location containing the address of another memory location.  The time information for an  activity is carried with its link.  For a typical net, the majority of activities can be described by  one 36-bit cell each.  The remainder use two 36-bit cells each.  The links are unidirectional; forward  during the T(E) calculation (expected completion time for an activity);backward during the T(L) calculation  (time latest allowable for completion of an activity).  The calculations progress through the net topologically  even though the net is not represented topologically in core.", "authors": "Lass, S. E.", "words_pool": ["activ", "activ", "address", "allow", "assign", "backward", "bit", "calcul", "calcul", "carri", "cell", "cell", "complet", "core", "defin", "event", "expect", "forward", "inform", "latest", "link", "link", "locat", "major", "memori", "net", "order", "pert", "present", "progress", "remaind", "repres", "simplifi", "techniqu", "time", "topolog", "topolog", "typic", "unidirect", "uniqu", "lass"], "word_count": {"activ": 5, "address": 1, "allow": 1, "assign": 1, "backward": 1, "bit": 2, "calcul": 4, "carri": 1, "cell": 2, "complet": 2, "core": 1, "defin": 1, "event": 1, "expect": 1, "forward": 1, "inform": 1, "latest": 1, "link": 4, "locat": 3, "major": 1, "memori": 3, "net": 3, "order": 1, "pert": 1, "present": 1, "progress": 1, "remaind": 1, "repres": 2, "simplifi": 1, "techniqu": 1, "time": 4, "topolog": 3, "typic": 1, "unidirect": 1, "uniqu": 1, "lass": 1}}, "1296": {"id": "1296", "title": "Ative (Algorithm 205 [E4])", "authors": "Wasscher, E. J.", "words_pool": ["algorithm", "ativ", "e4", "wasscher"], "word_count": {"algorithm": 1, "ativ": 1, "e4": 1, "wasscher": 1}}, "1297": {"id": "1297", "title": "Steep1 (Algorithm 203 [E4])", "authors": "Varah, J. M.", "words_pool": ["algorithm", "e4", "steep1", "varah"], "word_count": {"algorithm": 1, "e4": 1, "steep1": 1, "varah": 1}}, "1298": {"id": "1298", "title": "Adaptive Numerical Integration by Simpson's Rule (Algorithm 145 [D1])", "authors": "Pike, M. C.", "words_pool": ["adapt", "algorithm", "d1", "integr", "numer", "rule", "simpson", "pike"], "word_count": {"adapt": 1, "algorithm": 1, "d1": 1, "integr": 1, "numer": 1, "rule": 1, "simpson": 1, "pike": 1}}, "1299": {"id": "1299", "title": "Solutions of the Diophantine Equation (Algorithm 139 [A1])", "authors": "Bowlden, H. J.", "words_pool": ["a1", "algorithm", "diophantin", "equat", "solut", "bowlden"], "word_count": {"a1": 1, "algorithm": 1, "diophantin": 1, "equat": 1, "solut": 1, "bowlden": 1}}, "1300": {"id": "1300", "title": "Function Minimization (Algorithm 251[E4])", "authors": "Wells, M.", "words_pool": ["algorithm", "e4", "function", "minim", "well"], "word_count": {"algorithm": 1, "e4": 1, "function": 1, "minim": 1, "well": 1}}, "1301": {"id": "1301", "title": "On ALGOL I/O Conventions", "authors": "Zaremba, W. A.", "words_pool": ["algol", "convent", "zaremba"], "word_count": {"algol": 1, "convent": 1, "zaremba": 1}}, "1302": {"id": "1302", "title": "Parallel Signaling Speeds for Data Transmission (Proposed American Stand ard)", "words_pool": ["american", "ard", "data", "parallel", "propos", "signal", "speed", "stand", "transmiss"], "word_count": {"american": 1, "ard": 1, "data": 1, "parallel": 1, "propos": 1, "signal": 1, "speed": 1, "stand": 1, "transmiss": 1}}, "1303": {"id": "1303", "title": "A Correspondence Between ALGOL 60 and Church's Lambda-Notation: Part II*", "authors": "Landin, P. J.", "words_pool": ["algol", "church", "correspond", "ii", "lambda", "notat", "part", "landin"], "word_count": {"algol": 1, "church": 1, "correspond": 1, "ii": 1, "lambda": 1, "notat": 1, "part": 1, "landin": 1}}, "1304": {"id": "1304", "title": "A Rapid Turnaround Multi-Programming System", "abstract": "In this paper, basic features, system characteristics and the control algorithm for a multi-programming  system with rapid turnaround time are described.", "authors": "Irons, E. T.", "words_pool": ["algorithm", "basic", "characterist", "control", "featur", "multi", "paper", "program", "rapid", "system", "time", "turnaround", "iron"], "word_count": {"algorithm": 1, "basic": 1, "characterist": 1, "control": 1, "featur": 1, "multi": 1, "paper": 1, "program": 1, "rapid": 1, "system": 2, "time": 1, "turnaround": 1, "iron": 1}}, "1305": {"id": "1305", "title": "The Internal Structure of the FORTRAN CEP Translator", "abstract": "The FORTRAN CEP translator converts a source program written in the FORTRAN CEP language into  an object program written in the language of the CEP computer.  In this paper, after an outline of the  CEP computer, the internal structure of the translator is described.  Emphasis is on the compilation  of expressions, of input/output lists, and of subscripted variables.", "authors": "Mancino, O. G. Cecchi, M. M.", "words_pool": ["cep", "compil", "comput", "convert", "emphasi", "express", "fortran", "input", "intern", "languag", "list", "object", "outlin", "output", "paper", "program", "sourc", "structur", "subscript", "translat", "variabl", "written", "mancino", "cecchi"], "word_count": {"cep": 4, "compil": 1, "comput": 2, "convert": 1, "emphasi": 1, "express": 1, "fortran": 2, "input": 1, "intern": 1, "languag": 2, "list": 1, "object": 1, "outlin": 1, "output": 1, "paper": 1, "program": 2, "sourc": 1, "structur": 1, "subscript": 1, "translat": 2, "variabl": 1, "written": 2, "mancino": 1, "cecchi": 1}}, "1306": {"id": "1306", "title": "A Class of Unambiguous Computer Languages", "abstract": "Discussed in this paper is the concept of a fully nested computer language which may be one  means of designing computer languages which would be completely free of ambiguities.  Several suggestions  are also given here for the redefinition of ALGOL as a fully nested language.", "authors": "Johnston, J. B.", "words_pool": ["algol", "ambigu", "class", "complet", "comput", "concept", "design", "discuss", "free", "fulli", "languag", "languag", "mean", "nest", "paper", "redefinit", "suggest", "unambigu", "johnston"], "word_count": {"algol": 1, "ambigu": 1, "class": 1, "complet": 1, "comput": 2, "concept": 1, "design": 1, "discuss": 1, "free": 1, "fulli": 2, "languag": 3, "mean": 1, "nest": 2, "paper": 1, "redefinit": 1, "suggest": 1, "unambigu": 1, "johnston": 1}}, "1307": {"id": "1307", "title": "A Lightpen-Controlled Program For On-Line Data Analysis", "abstract": "This paper describes a technique designed to ease the use of a data processing system by a  person, in particular, a scientist, who is intimately and primarily concerned with interpreting the significance  of data handled by the system.  Since such a person is often unable to spend the time necessary to master  a programming language, it is essential that he be aided in composing commands to the computer.  In the  system described, the user is not required to learn or remember the vocabulary of the language because  the vocabulary is displayed before him on\"menus\" by means of a computer-drive scope.  He selects the  various vocabulary elements required by pointing with the light pen.  By use of a small unordered set  of rewriting rules applied as a result of light pen selections, the user generates only syntactically correct commands to the system.  He does not have to learn or remember the grammar.  The program restricts  the user severely in the particular language he can use, but the method for communicating with the program  makes these restrictions seem quite natural and unconstraining.  The program has been used successfully  for over ten months.", "authors": "Goodenough, J. B.", "words_pool": ["aid", "analysi", "appli", "command", "commun", "compos", "comput", "concern", "control", "correct", "data", "describ", "design", "display", "drive", "eas", "element", "essenti", "gener", "grammar", "handl", "interpret", "intim", "languag", "learn", "light", "lightpen", "line", "make", "master", "mean", "menu", "method", "month", "natur", "paper", "pen", "person", "point", "primarili", "process", "program", "program", "rememb", "requir", "restrict", "restrict", "result", "rewrit", "rule", "scientist", "scope", "select", "select", "set", "sever", "signific", "small", "spend", "success", "syntact", "system", "techniqu", "ten", "time", "unabl", "unconstrain", "unord", "user", "vocabulari", "goodenough"], "word_count": {"aid": 1, "analysi": 1, "appli": 1, "command": 2, "commun": 1, "compos": 1, "comput": 2, "concern": 1, "control": 1, "correct": 1, "data": 2, "describ": 1, "design": 1, "display": 1, "drive": 1, "eas": 1, "element": 1, "essenti": 1, "gener": 1, "grammar": 1, "handl": 1, "interpret": 1, "intim": 1, "languag": 3, "learn": 2, "light": 2, "lightpen": 1, "line": 1, "make": 1, "master": 1, "mean": 1, "menu": 1, "method": 1, "month": 1, "natur": 1, "paper": 1, "pen": 2, "person": 2, "point": 1, "primarili": 1, "process": 1, "program": 4, "rememb": 2, "requir": 2, "restrict": 2, "result": 1, "rewrit": 1, "rule": 1, "scientist": 1, "scope": 1, "select": 2, "set": 1, "sever": 1, "signific": 1, "small": 1, "spend": 1, "success": 1, "syntact": 1, "system": 4, "techniqu": 1, "ten": 1, "time": 1, "unabl": 1, "unconstrain": 1, "unord": 1, "user": 3, "vocabulari": 3, "goodenough": 1}}, "1308": {"id": "1308", "title": "A Mathematical Model for Mechanical part Description", "abstract": "The flexibility of a mathematical model takes advantage of the common information requirements  of computer-aided engineering drawing, numerical control tape generation, and physical characteristic  computation.  By judicious control of man-machine communication requirements, improved results over conventional  engineering design processes are possible.  An English-like input language, tailored for use by draftsmen  and designers, will describe the part and specify the output desired.  One approach to the mathematical  model consists of a group of surface-defining quadric equations, which are created by a system of modular  subprogram.  Other subprograms will convert the mathematical model into instructions for driving automatic  drafting machines and numerical controlled machine tools.  Physical part characteristics, such as center  of gravity, can be computed by subprograms and used in dynamic analysis work.  The proposed overall system  is presented and experiments and demonstrations are discussed.", "authors": "Luh, J. Y. S. Krolak, R. J.", "words_pool": ["advantag", "aid", "analysi", "approach", "automat", "center", "characterist", "characterist", "common", "commun", "comput", "comput", "comput", "consist", "control", "control", "convent", "convert", "creat", "defin", "demonstr", "describ", "descript", "design", "design", "desir", "discuss", "draft", "draftsmen", "draw", "drive", "dynam", "engin", "english", "equat", "experi", "flexibl", "gener", "graviti", "group", "improv", "inform", "input", "instruct", "judici", "languag", "machin", "machin", "man", "mathemat", "mechan", "model", "modular", "numer", "output", "part", "physic", "present", "process", "propos", "quadric", "requir", "result", "subprogram", "subprogram", "surfac", "system", "tailor", "take", "tape", "tool", "work", "luh", "krolak"], "word_count": {"advantag": 1, "aid": 1, "analysi": 1, "approach": 1, "automat": 1, "center": 1, "characterist": 2, "common": 1, "commun": 1, "comput": 3, "consist": 1, "control": 3, "convent": 1, "convert": 1, "creat": 1, "defin": 1, "demonstr": 1, "describ": 1, "descript": 1, "design": 2, "desir": 1, "discuss": 1, "draft": 1, "draftsmen": 1, "draw": 1, "drive": 1, "dynam": 1, "engin": 2, "english": 1, "equat": 1, "experi": 1, "flexibl": 1, "gener": 1, "graviti": 1, "group": 1, "improv": 1, "inform": 1, "input": 1, "instruct": 1, "judici": 1, "languag": 1, "machin": 3, "man": 1, "mathemat": 3, "mechan": 1, "model": 3, "modular": 1, "numer": 2, "output": 1, "part": 2, "physic": 2, "present": 1, "process": 1, "propos": 1, "quadric": 1, "requir": 2, "result": 1, "subprogram": 3, "surfac": 1, "system": 2, "tailor": 1, "take": 1, "tape": 1, "tool": 1, "work": 1, "luh": 1, "krolak": 1}}, "1309": {"id": "1309", "title": "A Computer User-Oriented System", "abstract": "A computer language system has been developed which makes possible fast preparation of management  reports, regardless of computational complexity or format variety.  Costs are sufficiently low so that  individually tailored reports can be prepared for every manager.  The system requires initial preparation  of large data banks containing data in elementary form.  Use of two special languages, EXTRACT and MATRAN,  permits selective extraction of any data subset, efficient processing through any computational sequence,  and flexible presentation of results in either tabular or graphical form.  Matrix algebra is used as  a fundamental vehicle for accomplishing both manipulation and computation.", "authors": "Montillon, G. D.", "words_pool": ["accomplish", "algebra", "bank", "complex", "comput", "comput", "comput", "cost", "data", "develop", "effici", "elementari", "extract", "extract", "fast", "flexibl", "form", "format", "fundament", "graphic", "individu", "initi", "languag", "languag", "larg", "low", "make", "manag", "manag", "manipul", "matran", "matrix", "orient", "permit", "prepar", "prepar", "present", "process", "regardless", "report", "requir", "result", "select", "sequenc", "special", "subset", "suffici", "system", "tabular", "tailor", "user", "varieti", "vehicl", "montillon"], "word_count": {"accomplish": 1, "algebra": 1, "bank": 1, "complex": 1, "comput": 4, "cost": 1, "data": 3, "develop": 1, "effici": 1, "elementari": 1, "extract": 2, "fast": 1, "flexibl": 1, "form": 2, "format": 1, "fundament": 1, "graphic": 1, "individu": 1, "initi": 1, "languag": 2, "larg": 1, "low": 1, "make": 1, "manag": 2, "manipul": 1, "matran": 1, "matrix": 1, "orient": 1, "permit": 1, "prepar": 3, "present": 1, "process": 1, "regardless": 1, "report": 2, "requir": 1, "result": 1, "select": 1, "sequenc": 1, "special": 1, "subset": 1, "suffici": 1, "system": 2, "tabular": 1, "tailor": 1, "user": 1, "varieti": 1, "vehicl": 1, "montillon": 1}}, "1310": {"id": "1310", "title": "A Rapid Braille Transliteration Technique for Certain IBM Machines", "authors": "Weiler, W. J. Klema, V. C.", "words_pool": ["braill", "ibm", "machin", "rapid", "techniqu", "transliter", "weiler", "klema"], "word_count": {"braill": 1, "ibm": 1, "machin": 1, "rapid": 1, "techniqu": 1, "transliter": 1, "weiler": 1, "klema": 1}}, "1311": {"id": "1311", "title": "Efficient Autocorrelation", "authors": "Schmid, L. P.", "words_pool": ["autocorrel", "effici", "schmid"], "word_count": {"autocorrel": 1, "effici": 1, "schmid": 1}}, "1312": {"id": "1312", "title": "Recursion and Iteration", "authors": "Rice, H. G.", "words_pool": ["iter", "recurs", "rice"], "word_count": {"iter": 1, "recurs": 1, "rice": 1}}, "1313": {"id": "1313", "title": "Construction of Nonlinear Programming Test Problems", "authors": "Rosen, J. B. Suzuki, S.", "words_pool": ["construct", "nonlinear", "problem", "program", "test", "rosen", "suzuki"], "word_count": {"construct": 1, "nonlinear": 1, "problem": 1, "program": 1, "test": 1, "rosen": 1, "suzuki": 1}}, "1314": {"id": "1314", "title": "The Organization of Symbol Tables", "abstract": "An efficient symbol table organization is an important feature in the design of any compiler.   During the construction of the Virginia ALGOL 60 compiler for the Burroughs B205, the primary consideration  in the symbol table design was that the recognition of identifiers and reserved words should be as rapid  as possible.  The general features of the technique are described.", "authors": "Batson, A.", "words_pool": ["algol", "b205", "burrough", "compil", "consider", "construct", "design", "effici", "featur", "featur", "gener", "identifi", "import", "organ", "primari", "rapid", "recognit", "reserv", "symbol", "tabl", "tabl", "techniqu", "virginia", "word", "batson"], "word_count": {"algol": 1, "b205": 1, "burrough": 1, "compil": 2, "consider": 1, "construct": 1, "design": 2, "effici": 1, "featur": 2, "gener": 1, "identifi": 1, "import": 1, "organ": 1, "primari": 1, "rapid": 1, "recognit": 1, "reserv": 1, "symbol": 2, "tabl": 2, "techniqu": 1, "virginia": 1, "word": 1, "batson": 1}}, "1315": {"id": "1315", "title": "Automation of the Radioisotope Accountability System", "abstract": "The Radioisotope Service of the Veterans Administration Hospital, Omaha, Nebraska, used a manual  system of radioisotope accountability for three years.  The procedure which was satisfactory but time-consuming  was converted from manual to a fully automated computer system in January, 1963.  The program for purchased  radioisotopes is written in FORMAT FORTRAN for the IBM 1620 Computer.  A second program for maintaining  accountability for reactor-created radioisotopes is written  in the FORCOM programming language.  A minimum  amount of bookkeeping is required by the reactor operating staff.  The United States Atomic Energy Commission  regulations specify that records be kept.  This system provides detailed records for each container of  radioactive material purchased and/or created in the Triga reactor indicating the amounts received, used,  and/or transferred to the health physicist for disposal.  Consolidated records contain total amounts  received, used, and/or disposed of for any specified period of time.  Purchased radioisotopes are reported  in millicuries; reactor-created radioisotopes in microcuries.", "authors": "Lahners, E. L.", "words_pool": ["account", "administr", "amount", "amount", "atom", "autom", "autom", "bookkeep", "commiss", "comput", "consolid", "consum", "contain", "convert", "creat", "detail", "dispos", "dispos", "energi", "forcom", "format", "fortran", "fulli", "health", "hospit", "ibm", "indic", "januari", "languag", "maintain", "materi", "microcuri", "millicuri", "minimum", "nebraska", "omaha", "oper", "period", "physicist", "procedur", "program", "program", "purchas", "radioact", "radioisotop", "radioisotop", "reactor", "receiv", "record", "regul", "report", "requir", "satisfactori", "servic", "staff", "state", "system", "time", "total", "transfer", "triga", "unit", "veteran", "written", "year", "lahner"], "word_count": {"account": 2, "administr": 1, "amount": 3, "atom": 1, "autom": 1, "bookkeep": 1, "commiss": 1, "comput": 2, "consolid": 1, "consum": 1, "contain": 1, "convert": 1, "creat": 3, "detail": 1, "dispos": 2, "energi": 1, "forcom": 1, "format": 1, "fortran": 1, "fulli": 1, "health": 1, "hospit": 1, "ibm": 1, "indic": 1, "januari": 1, "languag": 1, "maintain": 1, "materi": 1, "microcuri": 1, "millicuri": 1, "minimum": 1, "nebraska": 1, "omaha": 1, "oper": 1, "period": 1, "physicist": 1, "procedur": 1, "program": 3, "purchas": 3, "radioact": 1, "radioisotop": 6, "reactor": 4, "receiv": 2, "record": 3, "regul": 1, "report": 1, "requir": 1, "satisfactori": 1, "servic": 1, "staff": 1, "state": 1, "system": 3, "time": 2, "total": 1, "transfer": 1, "triga": 1, "unit": 1, "veteran": 1, "written": 2, "year": 1, "lahner": 1}}, "1316": {"id": "1316", "title": "Bessel Functions of the First Kind (Algorithm 236 [S17])", "authors": "Gautschi, W.", "words_pool": ["algorithm", "bessel", "function", "kind", "s17", "gautschi"], "word_count": {"algorithm": 1, "bessel": 1, "function": 1, "kind": 1, "s17": 1, "gautschi": 1}}, "1317": {"id": "1317", "title": "Poisson-Charlier Polynomials (Algorithm 234 [S23])", "authors": ".", "words_pool": ["algorithm", "charlier", "poisson", "polynomi", "s23"], "word_count": {"algorithm": 1, "charlier": 1, "poisson": 1, "polynomi": 1, "s23": 1}}, "1318": {"id": "1318", "title": "Arccossin (Algorithm 206 [B1])", "authors": "Bowlden, H. J.", "words_pool": ["algorithm", "arccossin", "b1", "bowlden"], "word_count": {"algorithm": 1, "arccossin": 1, "b1": 1, "bowlden": 1}}, "1319": {"id": "1319", "title": "Crout with Equilibration and Iteration (Algorithm 135 [F4])", "authors": "Meissner, L. P.", "words_pool": ["algorithm", "crout", "equilibr", "f4", "iter", "meissner"], "word_count": {"algorithm": 1, "crout": 1, "equilibr": 1, "f4": 1, "iter": 1, "meissner": 1}}, "1320": {"id": "1320", "title": "Inverse Permutation (Algorithm 250 [G6])", "authors": "Boonstra, B. H.", "words_pool": ["algorithm", "g6", "invers", "permut", "boonstra"], "word_count": {"algorithm": 1, "g6": 1, "invers": 1, "permut": 1, "boonstra": 1}}, "1321": {"id": "1321", "title": "Outreal N (Algorithm [I5])", "authors": "Wirth, N. E.", "words_pool": ["algorithm", "i5", "outreal", "wirth"], "word_count": {"algorithm": 1, "i5": 1, "outreal": 1, "wirth": 1}}, "1322": {"id": "1322", "title": "Netflow (Algorithm 248 [H])", "authors": "Briggs, W. A.", "words_pool": ["algorithm", "netflow", "brigg"], "word_count": {"algorithm": 1, "netflow": 1, "brigg": 1}}, "1323": {"id": "1323", "title": "A Correspondence Between ALGOL 60 and Church's Lambda-Notation: Part I*", "abstract": "This paper describes how some of the semantics of ALGOL 60 can be formalized by establishing  a correspondence between expressions of ALGOL 60 and expressions in a modified form of Church's L-notation.   First a model for computer languages and compute behavior is described, based on the notions of functional  application and functional abstraction, but also having analogues for imperative language features.   Then this model is used as an \"abstract object language\" into which ALGOL 60 is mapped.  Many of ALGOL  60's features emerge as particular arrangements of a small number of structural rules, suggesting new  classifications and generalizations.  The correspondence is first described informally, mainly by illustrations.   The second part of the paper gives a formal description, i.e. an \"abstract compiler\" into the \"abstract  objct language.\"  This is itself presented in a \"purely functional\" notation, that is one using only  application and abstraction.", "authors": "Landin, P. J.", "words_pool": ["abstract", "abstract", "algol", "analogu", "applic", "arrang", "base", "behavior", "church", "classif", "compil", "comput", "comput", "correspond", "describ", "descript", "emerg", "establish", "express", "featur", "form", "formal", "formal", "function", "gener", "illustr", "imper", "inform", "lambda", "languag", "languag", "mainli", "map", "model", "modifi", "notat", "notion", "number", "objct", "object", "paper", "part", "present", "pure", "rule", "semant", "small", "structur", "suggest", "landin"], "word_count": {"abstract": 5, "algol": 4, "analogu": 1, "applic": 2, "arrang": 1, "base": 1, "behavior": 1, "church": 1, "classif": 1, "compil": 1, "comput": 2, "correspond": 2, "describ": 1, "descript": 1, "emerg": 1, "establish": 1, "express": 2, "featur": 2, "form": 1, "formal": 2, "function": 3, "gener": 1, "illustr": 1, "imper": 1, "inform": 1, "lambda": 1, "languag": 4, "mainli": 1, "map": 1, "model": 2, "modifi": 1, "notat": 2, "notion": 1, "number": 1, "objct": 1, "object": 1, "paper": 2, "part": 1, "present": 1, "pure": 1, "rule": 1, "semant": 1, "small": 1, "structur": 1, "suggest": 1, "landin": 1}}, "1324": {"id": "1324", "title": "Answering English questions by Computer: A Survey", "abstract": "Fifteen experimental English language question-answering systems which are programmed and operating  are described and reviewed.  The systems range from a conversation machine to programs which make sentences  about pictures and systems which translate from English into logical calculi.  Systems are classified  as list-structured data-based, graphic data-based, text-based and inferential.  Principles and methods  of operations are detailed and discussed.  It is concluded that the data-base question-answer has passed  from initial research into the early developmental phase.  The most difficult and important research  questions for the advancement of general-purpose language processors are seen to be concerned with measuring,  dealing with ambiguities, translating into formal languages and searching large tree structures.", "authors": "Simmons, R. F.", "words_pool": ["advanc", "ambigu", "answer", "answer", "base", "base", "calculi", "classifi", "comput", "concern", "conclud", "convers", "data", "deal", "detail", "development", "difficult", "discuss", "earli", "english", "experiment", "fifteen", "formal", "gener", "graphic", "import", "inferenti", "initi", "languag", "languag", "larg", "list", "logic", "machin", "make", "measur", "method", "oper", "oper", "pass", "phase", "pictur", "principl", "processor", "program", "program", "purpos", "question", "question", "rang", "research", "review", "search", "seen", "sentenc", "structur", "structur", "survey", "system", "text", "translat", "translat", "tree", "simmon"], "word_count": {"advanc": 1, "ambigu": 1, "answer": 2, "base": 4, "calculi": 1, "classifi": 1, "comput": 1, "concern": 1, "conclud": 1, "convers": 1, "data": 3, "deal": 1, "detail": 1, "development": 1, "difficult": 1, "discuss": 1, "earli": 1, "english": 2, "experiment": 1, "fifteen": 1, "formal": 1, "gener": 1, "graphic": 1, "import": 1, "inferenti": 1, "initi": 1, "languag": 3, "larg": 1, "list": 1, "logic": 1, "machin": 1, "make": 1, "measur": 1, "method": 1, "oper": 2, "pass": 1, "phase": 1, "pictur": 1, "principl": 1, "processor": 1, "program": 2, "purpos": 1, "question": 3, "rang": 1, "research": 2, "review": 1, "search": 1, "seen": 1, "sentenc": 1, "structur": 2, "survey": 1, "system": 4, "text": 1, "translat": 2, "tree": 1, "simmon": 1}}, "1325": {"id": "1325", "title": "Remote, On-Line, Real-time Computer Diagnosis of the Clinical Electrocardiogram", "abstract": "Presented in this paper is a brief report on the hardware, software, system configuration and  function of a system for the remote, online, real-time digital computer diagnosis of clinical electrocardiograms.   It seems likely that efforts of this sort will lead to a satisfactory solution to the problem of the  automatic diagnosis of electrocardiograms.  Current attempts by the authors to extend the diagnostic  capabilities of the present system are particularly concerned with increasing the fidelity of the adaptive  matched filters, the development of three dimensional pattern analysis, the analysis of parallel electrocardiographer-computer  diagnostic interaction, and a study of the possibility of introducing major, tree-like branching decisions  early in the diagnostic process.", "authors": "Whipple, G. H. Dickson, J. F. Horibe, H. Stark, L.", "words_pool": ["adapt", "analysi", "attempt", "author", "automat", "branch", "capabl", "clinic", "comput", "concern", "configur", "decis", "develop", "diagnosi", "diagnost", "digit", "dimension", "earli", "effort", "electrocardiogram", "electrocardiogram", "electrocardiograph", "extend", "fidel", "filter", "function", "hardwar", "increas", "interact", "introduc", "lead", "like", "line", "major", "match", "onlin", "paper", "parallel", "pattern", "possibl", "present", "present", "problem", "process", "real", "remot", "report", "satisfactori", "softwar", "solut", "sort", "studi", "system", "time", "tree", "whippl", "dickson", "horib", "stark"], "word_count": {"adapt": 1, "analysi": 2, "attempt": 1, "author": 1, "automat": 1, "branch": 1, "capabl": 1, "clinic": 1, "comput": 2, "concern": 1, "configur": 1, "decis": 1, "develop": 1, "diagnosi": 2, "diagnost": 3, "digit": 1, "dimension": 1, "earli": 1, "effort": 1, "electrocardiogram": 2, "electrocardiograph": 1, "extend": 1, "fidel": 1, "filter": 1, "function": 1, "hardwar": 1, "increas": 1, "interact": 1, "introduc": 1, "lead": 1, "like": 1, "line": 1, "major": 1, "match": 1, "onlin": 1, "paper": 1, "parallel": 1, "pattern": 1, "possibl": 1, "present": 2, "problem": 1, "process": 1, "real": 1, "remot": 1, "report": 1, "satisfactori": 1, "softwar": 1, "solut": 1, "sort": 1, "studi": 1, "system": 3, "time": 1, "tree": 1, "whippl": 1, "dickson": 1, "horib": 1, "stark": 1}}, "1326": {"id": "1326", "title": "Boundary Networks", "abstract": "A feasible computer procedure is described for determining the total or partial inclusion of  arbitrarily given points and lines with respect to a set of general polygonal domains which partition  a plane bounded region.  A scheme for the computer representation of the boundaries of the domains and  an algorithm, based on this  scheme, for evaluating the inclusion relations are specified in detail.   The method employs several levels of selection criteria for the purpose of reducing the number of accesses  to auxiliary storage devices and the amount of boundary data for which processing is required.", "authors": "Loomis, R. G.", "words_pool": ["access", "algorithm", "amount", "arbitrarili", "auxiliari", "base", "boundari", "boundari", "bound", "comput", "criteria", "data", "detail", "determin", "devic", "domain", "employ", "evalu", "feasibl", "gener", "inclus", "level", "line", "method", "network", "number", "partial", "partit", "plane", "point", "polygon", "procedur", "process", "purpos", "reduc", "region", "relat", "represent", "requir", "respect", "scheme", "select", "set", "storag", "total", "loomi"], "word_count": {"access": 1, "algorithm": 1, "amount": 1, "arbitrarili": 1, "auxiliari": 1, "base": 1, "boundari": 2, "bound": 1, "comput": 2, "criteria": 1, "data": 1, "detail": 1, "determin": 1, "devic": 1, "domain": 2, "employ": 1, "evalu": 1, "feasibl": 1, "gener": 1, "inclus": 2, "level": 1, "line": 1, "method": 1, "network": 1, "number": 1, "partial": 1, "partit": 1, "plane": 1, "point": 1, "polygon": 1, "procedur": 1, "process": 1, "purpos": 1, "reduc": 1, "region": 1, "relat": 1, "represent": 1, "requir": 1, "respect": 1, "scheme": 2, "select": 1, "set": 1, "storag": 1, "total": 1, "loomi": 1}}, "1327": {"id": "1327", "title": "Use of Decision Tables in Computer Programming", "abstract": "A decision table is a tabular form for displaying decision logic.  Decision tables have many  inherent advantages.  The technique to be illustrated puts these advantages to use in that it enables  one to program directly from a decision table.  The technique is based on the creation of a binary image  of a limited entry decision table in computer memory.  A binary image of a given set of input conditions  can also be created.  This data image is used to scan the decision table image to arrive at the proper  course of action.  There are several advantages gained from the programming point view: (1) amount of  computer memory used is drastically reduced, (2) programming is simplified, and (3) documentation is  brief and clear.", "authors": "Kirk, H. W.", "words_pool": ["action", "advantag", "amount", "arriv", "base", "binari", "clear", "comput", "condit", "cours", "creat", "creation", "data", "decis", "directli", "display", "document", "drastic", "enabl", "entri", "form", "gain", "illustr", "imag", "inher", "input", "limit", "logic", "memori", "point", "program", "program", "proper", "put", "reduc", "scan", "set", "simplifi", "tabl", "tabl", "tabular", "techniqu", "view", "kirk"], "word_count": {"action": 1, "advantag": 3, "amount": 1, "arriv": 1, "base": 1, "binari": 2, "clear": 1, "comput": 2, "condit": 1, "cours": 1, "creat": 1, "creation": 1, "data": 1, "decis": 6, "directli": 1, "display": 1, "document": 1, "drastic": 1, "enabl": 1, "entri": 1, "form": 1, "gain": 1, "illustr": 1, "imag": 4, "inher": 1, "input": 1, "limit": 1, "logic": 1, "memori": 2, "point": 1, "program": 3, "proper": 1, "put": 1, "reduc": 1, "scan": 1, "set": 1, "simplifi": 1, "tabl": 5, "tabular": 1, "techniqu": 2, "view": 1, "kirk": 1}}, "1328": {"id": "1328", "title": "Further Remarks on Reducing Truncation Errors", "authors": "Kahan, W.", "words_pool": ["error", "reduc", "remark", "truncat", "kahan"], "word_count": {"error": 1, "reduc": 1, "remark": 1, "truncat": 1, "kahan": 1}}, "1329": {"id": "1329", "title": "Simulation of Boolean Functions in a Decimal computer", "authors": "Mano, M. M.", "words_pool": ["boolean", "comput", "decim", "function", "simul", "mano"], "word_count": {"boolean": 1, "comput": 1, "decim": 1, "function": 1, "simul": 1, "mano": 1}}, "1330": {"id": "1330", "title": "Automated Plotting Flow-Charts on a Small Computer", "authors": "Anderson, H. E.", "words_pool": ["autom", "chart", "comput", "flow", "plot", "small", "anderson"], "word_count": {"autom": 1, "chart": 1, "comput": 1, "flow": 1, "plot": 1, "small": 1, "anderson": 1}}, "1331": {"id": "1331", "title": "Code Structures for Protection and Manipulation of Variable-Length Items", "abstract": "When items are made up of a variable number of characters, each containing the same number  of bits, certain control information (partition symbols) is inserted to mark their separations.  Since  errors in identification of these control characters can lead to serious trouble, methods of protecting  these symbols are indicated.  A 6-bit code assignment of alphanumeric characters for fixed word-length  computers is given and its suitability for error detection and variable-length item manipulation is shown.   Also indicated is its flexibility during certain arithmetic operations.", "authors": "Ramamoorthy, C. V.", "words_pool": ["alphanumer", "arithmet", "assign", "bit", "bit", "charact", "code", "comput", "control", "detect", "error", "error", "fix", "flexibl", "identif", "inform", "insert", "item", "item", "lead", "length", "made", "manipul", "mark", "method", "number", "oper", "partit", "protect", "protect", "separ", "shown", "structur", "suitabl", "symbol", "troubl", "variabl", "word", "ramamoorthi"], "word_count": {"alphanumer": 1, "arithmet": 1, "assign": 1, "bit": 2, "charact": 3, "code": 1, "comput": 1, "control": 2, "detect": 1, "error": 2, "fix": 1, "flexibl": 1, "identif": 1, "inform": 1, "insert": 1, "item": 2, "lead": 1, "length": 2, "made": 1, "manipul": 1, "mark": 1, "method": 1, "number": 2, "oper": 1, "partit": 1, "protect": 1, "separ": 1, "shown": 1, "structur": 1, "suitabl": 1, "symbol": 2, "troubl": 1, "variabl": 2, "word": 1, "ramamoorthi": 1}}, "1332": {"id": "1332", "title": "Subroutine Assembly", "abstract": "A description is given of an assembly system, which requires only one pass and does not maintain  a table of information about the subroutine library.", "authors": "Samet, P. A.", "words_pool": ["assembl", "descript", "inform", "librari", "maintain", "pass", "requir", "subroutin", "system", "tabl", "samet"], "word_count": {"assembl": 1, "descript": 1, "inform": 1, "librari": 1, "maintain": 1, "pass": 1, "requir": 1, "subroutin": 1, "system": 1, "tabl": 1, "samet": 1}}, "1333": {"id": "1333", "title": "Reducing Truncation Errors Using Cascading Accumulators", "abstract": "When accumulating a large number of quantities as in numerical integration, the sum itself  may become much larger than the individual addends.  This results in truncation error.  Much of this  error can be eliminated using cascading accumulators as noted in a recent article by Wolfe.  A simpler  and slightly more flexible algorithm is presented which deals also with the case of negative addends.", "authors": "Ross, D. R.", "words_pool": ["accumul", "accumul", "addend", "algorithm", "articl", "cascad", "case", "deal", "elimin", "error", "error", "flexibl", "individu", "integr", "larg", "larger", "neg", "note", "number", "numer", "present", "quantiti", "recent", "reduc", "result", "simpler", "slightli", "sum", "truncat", "wolf", "ross"], "word_count": {"accumul": 2, "addend": 2, "algorithm": 1, "articl": 1, "cascad": 1, "case": 1, "deal": 1, "elimin": 1, "error": 2, "flexibl": 1, "individu": 1, "integr": 1, "larg": 1, "larger": 1, "neg": 1, "note": 1, "number": 1, "numer": 1, "present": 1, "quantiti": 1, "recent": 1, "reduc": 1, "result": 1, "simpler": 1, "slightli": 1, "sum": 1, "truncat": 1, "wolf": 1, "ross": 1}}, "1334": {"id": "1334", "title": "Mechanization of Tedious Algebra: The Newcomb Operators of Planetary Theory", "abstract": "A computer program has been written to generate tables of formulas for the Newcomb operators  of planetary theory.  The Newcomb operators are expressed as polynomials in two variables, one of which  stands for a simple differential operator, and the other for an arbitrary integer.  The polynomials are  generated by a recurrence scheme.  The program is coded in FORTRAN, using simple array manipulation techniques  to perform the algebraic operations.  Formulas for over 100 Newcomb operators have been produced by the  program and typeset photographically on an S-560 Photon system.", "authors": "Gerard, J. M. Izsak, I. G. Barnett, M. P.", "words_pool": ["algebra", "algebra", "arbitrari", "array", "code", "comput", "differenti", "express", "formula", "fortran", "gener", "gener", "integ", "manipul", "mechan", "newcomb", "oper", "oper", "oper", "perform", "photograph", "photon", "planetari", "polynomi", "produc", "program", "recurr", "scheme", "simpl", "stand", "system", "tabl", "techniqu", "tediou", "theori", "typeset", "variabl", "written", "gerard", "izsak", "barnett"], "word_count": {"algebra": 1, "arbitrari": 1, "array": 1, "code": 1, "comput": 1, "differenti": 1, "express": 1, "formula": 2, "fortran": 1, "gener": 2, "integ": 1, "manipul": 1, "mechan": 1, "newcomb": 3, "oper": 5, "perform": 1, "photograph": 1, "photon": 1, "planetari": 1, "polynomi": 2, "produc": 1, "program": 3, "recurr": 1, "scheme": 1, "simpl": 2, "stand": 1, "system": 1, "tabl": 1, "techniqu": 1, "tediou": 1, "theori": 1, "typeset": 1, "variabl": 1, "written": 1, "gerard": 1, "izsak": 1, "barnett": 1}}, "1335": {"id": "1335", "title": "Character Set for Optical Character Recognition (Proposed American Stand ard)", "words_pool": ["american", "ard", "charact", "optic", "propos", "recognit", "set", "stand"], "word_count": {"american": 1, "ard": 1, "charact": 2, "optic": 1, "propos": 1, "recognit": 1, "set": 1, "stand": 1}}, "1336": {"id": "1336", "title": "NPL: Highlights of A New Programming Language", "authors": "Radin, G. Rogoway, H. P.", "words_pool": ["highlight", "languag", "npl", "program", "radin", "rogoway"], "word_count": {"highlight": 1, "languag": 1, "npl": 1, "program": 1, "radin": 1, "rogoway": 1}}, "1337": {"id": "1337", "title": "EULER: A Generalization of ALGOL, and its Formal Definition", "authors": "Wirth, N. Weber, H.", "words_pool": ["algol", "definit", "euler", "formal", "gener", "wirth", "weber"], "word_count": {"algol": 1, "definit": 1, "euler": 1, "formal": 1, "gener": 1, "wirth": 1, "weber": 1}}, "1338": {"id": "1338", "title": "Additional Comments on a Problem in Concurrent Progamming Control", "authors": "Knuth, D. E.", "words_pool": ["addit", "comment", "concurr", "control", "problem", "progam", "knuth"], "word_count": {"addit": 1, "comment": 1, "concurr": 1, "control": 1, "problem": 1, "progam": 1, "knuth": 1}}, "1339": {"id": "1339", "title": "A Contribution to the Development of ALGOL", "authors": "Wirth, N. Hoare, C. A. R.", "words_pool": ["algol", "contribut", "develop", "wirth", "hoar"], "word_count": {"algol": 1, "contribut": 1, "develop": 1, "wirth": 1, "hoar": 1}}, "1340": {"id": "1340", "title": "Multiplexing of Slow Peripherals", "abstract": "The philosophy of a monitor which allows slow output devices to be multiplexed is presented.", "authors": "Abraham, C. Lance, G. N. Pearcey, T.", "words_pool": ["devic", "monitor", "multiplex", "multiplex", "output", "peripher", "philosophi", "present", "slow", "abraham", "lanc", "pearcey"], "word_count": {"devic": 1, "monitor": 1, "multiplex": 1, "output": 1, "peripher": 1, "philosophi": 1, "present": 1, "slow": 1, "abraham": 1, "lanc": 1, "pearcey": 1}}, "1341": {"id": "1341", "title": "Levels of Computer Systems", "abstract": "In building current computer systems, we tend to break them down into \"levels\" of control,  command and communication; in using the system, we break our problems down correspondingly.  The continued  use of such a structure raises questions about its effects on the usefulness of future systems, particularly  with regard to such trends as time sharing, parallel programming, and, eventually, systems which learn.   In this essay some of these questions are posed, and the general attitude we must take in pursuing the  problem further is discussed.", "authors": "Bryant, P.", "words_pool": ["attitud", "break", "build", "command", "commun", "comput", "continu", "control", "correspondingli", "discuss", "effect", "essay", "eventu", "futur", "gener", "learn", "level", "parallel", "pose", "problem", "problem", "program", "pursu", "question", "rais", "regard", "share", "structur", "system", "system", "take", "tend", "time", "trend", "use", "bryant"], "word_count": {"attitud": 1, "break": 2, "build": 1, "command": 1, "commun": 1, "comput": 1, "continu": 1, "control": 1, "correspondingli": 1, "discuss": 1, "effect": 1, "essay": 1, "eventu": 1, "futur": 1, "gener": 1, "learn": 1, "level": 1, "parallel": 1, "pose": 1, "problem": 2, "program": 1, "pursu": 1, "question": 2, "rais": 1, "regard": 1, "share": 1, "structur": 1, "system": 4, "take": 1, "tend": 1, "time": 1, "trend": 1, "use": 1, "bryant": 1}}, "1342": {"id": "1342", "title": "Transportation Problem (Algorithms 293 [H])", "authors": "Bayer, G.", "words_pool": ["algorithm", "problem", "transport", "bayer"], "word_count": {"algorithm": 1, "problem": 1, "transport": 1, "bayer": 1}}, "1343": {"id": "1343", "title": "Havie Integrator (Algorithm 257 [D1])", "authors": "Farkas, I.", "words_pool": ["algorithm", "d1", "havi", "integr", "farka"], "word_count": {"algorithm": 1, "d1": 1, "havi": 1, "integr": 1, "farka": 1}}, "1344": {"id": "1344", "title": "Statistical Computations Based Upon Algebraically Specified Models", "abstract": "Based upon a machine-readable statistical model and related symbolic specifications, an efficient  method of performing calculations for statistical models of a balanced complete nature is presented.   Fixes, mixed, and random analysis of variance models are considered.  A procedure for obtaining variance  components and calculated F statistics for the model terms is included.", "authors": "Schlater, J. E. Hemerle, W. J.", "words_pool": ["algebra", "analysi", "balanc", "base", "calcul", "calcul", "complet", "compon", "comput", "consid", "effici", "fix", "includ", "machin", "method", "mix", "model", "model", "natur", "obtain", "perform", "present", "procedur", "random", "readabl", "relat", "specif", "statist", "statist", "symbol", "term", "varianc", "schlater", "hemerl"], "word_count": {"algebra": 1, "analysi": 1, "balanc": 1, "base": 1, "calcul": 2, "complet": 1, "compon": 1, "comput": 1, "consid": 1, "effici": 1, "fix": 1, "includ": 1, "machin": 1, "method": 1, "mix": 1, "model": 4, "natur": 1, "obtain": 1, "perform": 1, "present": 1, "procedur": 1, "random": 1, "readabl": 1, "relat": 1, "specif": 1, "statist": 3, "symbol": 1, "term": 1, "varianc": 2, "schlater": 1, "hemerl": 1}}, "1345": {"id": "1345", "title": "Tensor Calculations on the Computer", "abstract": "A FORMAC program has been written which is capable of calculating various quantities of interest  in tensor calculus.  Using this code, Christoffel symbols have been calculated for 12 basic orthogonal  coordinate systems.", "authors": "Waltons, J. J.", "words_pool": ["basic", "calcul", "calcul", "calcul", "calculu", "capabl", "christoffel", "code", "comput", "coordin", "formac", "interest", "orthogon", "program", "quantiti", "symbol", "system", "tensor", "written", "walton"], "word_count": {"basic": 1, "calcul": 2, "calculu": 1, "capabl": 1, "christoffel": 1, "code": 1, "comput": 1, "coordin": 1, "formac": 1, "interest": 1, "orthogon": 1, "program": 1, "quantiti": 1, "symbol": 1, "system": 1, "tensor": 1, "written": 1, "walton": 1}}, "1346": {"id": "1346", "title": "On the Application of the Process of Equalization of Maxima to Obtain Rational Approximation  to Certain Modified Bessel Functions", "abstract": "The second Remes algorithm as originally established for polynomials, may converge or not when  the approximating functions are rational.  However, the few results known in this domain show how efficient  the algorithm can be to obtain approximations with a small error, much more than in the polynomial case,  in which the best approximation can be very nearly approached directly by a series development.  The  aim of this paper is to investigate the limitations of the applicability of certain extensions of the  algorithm to the case where the approximations are rational as well as to present some numerical results.", "authors": "Gargantini, L.", "words_pool": ["aim", "algorithm", "applic", "applic", "approach", "approxim", "approxim", "approxim", "bessel", "case", "converg", "develop", "directli", "domain", "effici", "equal", "error", "establish", "extens", "function", "investig", "known", "limit", "maxima", "modifi", "nearli", "numer", "obtain", "origin", "paper", "polynomi", "polynomi", "present", "process", "ration", "reme", "result", "seri", "show", "small", "gargantini"], "word_count": {"aim": 1, "algorithm": 3, "applic": 1, "approach": 1, "approxim": 4, "bessel": 1, "case": 2, "converg": 1, "develop": 1, "directli": 1, "domain": 1, "effici": 1, "equal": 1, "error": 1, "establish": 1, "extens": 1, "function": 1, "investig": 1, "known": 1, "limit": 1, "maxima": 1, "modifi": 1, "nearli": 1, "numer": 1, "obtain": 1, "origin": 1, "paper": 1, "polynomi": 2, "present": 1, "process": 1, "ration": 2, "reme": 1, "result": 2, "seri": 1, "show": 1, "small": 1, "gargantini": 1}}, "1347": {"id": "1347", "title": "General Time-Varying Systems Error Sensitivities Program", "abstract": "The evaluation, by the propagation of variance technique, of the sensitivity of time-varying  systems to initial condition and parameter errors, involves the determination of several system-dependent  partial derivative matrices.  This requirement has led to separate programs for each system under investigation.   A new program, through utilization of the Wengert differentiation technique, automatically determines  the required matrices from specific system equations supplied in subroutine form at execution time, eliminating  the need for individualized programs, and presaging the further development of extremely general computer  programs.", "authors": "Wilkins, R. D.", "words_pool": ["comput", "condit", "depend", "deriv", "determin", "determin", "develop", "differenti", "elimin", "equat", "error", "error", "evalu", "execut", "extrem", "form", "gener", "individu", "initi", "investig", "involv", "led", "matric", "need", "paramet", "partial", "presag", "program", "program", "propag", "requir", "requir", "sensit", "sensit", "separ", "specif", "subroutin", "suppli", "system", "system", "techniqu", "time", "util", "varianc", "vari", "wengert", "wilkin"], "word_count": {"comput": 1, "condit": 1, "depend": 1, "deriv": 1, "determin": 2, "develop": 1, "differenti": 1, "elimin": 1, "equat": 1, "error": 1, "evalu": 1, "execut": 1, "extrem": 1, "form": 1, "gener": 1, "individu": 1, "initi": 1, "investig": 1, "involv": 1, "led": 1, "matric": 2, "need": 1, "paramet": 1, "partial": 1, "presag": 1, "program": 4, "propag": 1, "requir": 2, "sensit": 1, "separ": 1, "specif": 1, "subroutin": 1, "suppli": 1, "system": 4, "techniqu": 2, "time": 2, "util": 1, "varianc": 1, "vari": 1, "wengert": 1, "wilkin": 1}}, "1348": {"id": "1348", "title": "FLOWTRACE, A Computer Program for Flowcharting Programs", "abstract": "The FLOWTRACE system produces flowcharts of programs written in \"almost any\" programming language.   One most describe the syntax of the control statements in his language; for this purpose a metalanguage  is available.  The resultant object deck is used to flowchart any programs in the language described.   Several examples of FAP and SNOBOL flowcharts are given.  However, it is not necessary to confine one's  scope to existing languages.  One may define his own language in any \"well-structured\" manner.  This  feature is particularly useful when it is desirable to chart only comments within a program.  Such an  approach permits the documentation of descriptive remarks and avoids the inclusion of coding details.", "authors": "Sherman, P. M.", "words_pool": ["approach", "avoid", "chart", "code", "comment", "comput", "confin", "control", "deck", "defin", "describ", "descript", "desir", "detail", "document", "exampl", "exist", "fap", "featur", "flowchart", "flowchart", "flowchart", "flowtrac", "inclus", "languag", "languag", "manner", "metalanguag", "object", "permit", "produc", "program", "program", "program", "purpos", "remark", "result", "scope", "snobol", "statement", "structur", "syntax", "system", "written", "sherman"], "word_count": {"approach": 1, "avoid": 1, "chart": 1, "code": 1, "comment": 1, "comput": 1, "confin": 1, "control": 1, "deck": 1, "defin": 1, "describ": 1, "descript": 1, "desir": 1, "detail": 1, "document": 1, "exampl": 1, "exist": 1, "fap": 1, "featur": 1, "flowchart": 3, "flowtrac": 1, "inclus": 1, "languag": 5, "manner": 1, "metalanguag": 1, "object": 1, "permit": 1, "produc": 1, "program": 4, "purpos": 1, "remark": 1, "result": 1, "scope": 1, "snobol": 1, "statement": 1, "structur": 1, "syntax": 1, "system": 1, "written": 1, "sherman": 1}}, "1349": {"id": "1349", "title": "Computing Capabilities at Western European Universities", "abstract": "This report on the author's trip to universities in Western Europe in the summer of 1966 gives  brief descriptions of computing activities at each institution visited.  Present equipment capabilities  vary from moderate to large scale; however, many institutions plan to acquire complex time-shared systems  in the near future.  In the author's opinion, the state of the art lags behind that on this continent.   This lag is attributed to four principal factors: (a) the handicapping organization of academic procedures;  (b) the university-government financial relationship; (c) the subordinated organization of the computing  facility; (d) the paucity of professional interchange of knowledge.  The effects of these constraints  are explicated.", "authors": "Finerman, A.", "words_pool": ["academ", "acquir", "activ", "art", "attribut", "author", "capabl", "complex", "comput", "constraint", "contin", "descript", "effect", "equip", "europ", "european", "explic", "facil", "factor", "financi", "futur", "govern", "handicap", "institut", "institut", "interchang", "knowledg", "lag", "lag", "larg", "moder", "opinion", "organ", "pauciti", "plan", "present", "princip", "procedur", "profession", "relationship", "report", "scale", "share", "state", "subordin", "summer", "system", "time", "trip", "univers", "univers", "vari", "visit", "western", "finerman"], "word_count": {"academ": 1, "acquir": 1, "activ": 1, "art": 1, "attribut": 1, "author": 2, "capabl": 1, "complex": 1, "comput": 2, "constraint": 1, "contin": 1, "descript": 1, "effect": 1, "equip": 1, "europ": 1, "european": 1, "explic": 1, "facil": 1, "factor": 1, "financi": 1, "futur": 1, "govern": 1, "handicap": 1, "institut": 2, "interchang": 1, "knowledg": 1, "lag": 2, "larg": 1, "moder": 1, "opinion": 1, "organ": 2, "pauciti": 1, "plan": 1, "present": 1, "princip": 1, "procedur": 1, "profession": 1, "relationship": 1, "report": 1, "scale": 1, "share": 1, "state": 1, "subordin": 1, "summer": 1, "system": 1, "time": 1, "trip": 1, "univers": 2, "vari": 1, "visit": 1, "western": 1, "finerman": 1}}, "1350": {"id": "1350", "title": "The Augmented Predictive Analyzer for Context-Free Languages-Its Relative Efficiency", "abstract": "It has been proven by Greibach that for a given context-free grammar G, a standard-form grammar  Gs can be constructed, which generates the same languages as is generated by G and whose rules are all  of the form Z --> cY(1) ... Y(m), (m >= O) where Z and Y(i) are intermediate symbols and c a terminal  symbol.  Since the predictive analyzer at Harvard uses a standard-form grammar, it can accept the language  of any context-free Grammar G, given an equivalent standard-form grammar Gs.  The structural descriptions  SD(Gs,X) assigned to a given sentence X by the predictive analyzer, however, are usually different from  the structural descriptions SD(G,X) assigned to the same sentence by the original context-free grammar  G from which Gs is derived.  In Section 1, an algorithm, originally due to Abbott is described standard-form  grammar each of whose rules is in standard form, supplemented by additional information describing its  derivation from the original context-free grammar.  A technique for performing the SD(Gs,X) to SD(G,X)  transformation effectively is also described.  In section 2, the augmented predictive analyzer as a parsing  algorithm for arbitrary context-free languages is compared with two other parsing algorithms: a selective  top-to-bottom algorithm similar to Irons' \"error correcting parse algorithm\" and an immediate constituent  analyzer which is an extension of Sakai-Cocke's algorithm for normal grammars.  The comparison is based  upon several criteria of efficiency, covering core-storage requirements, complexities of the programs  and processing time.", "authors": "Kuno,S.", "words_pool": ["abbott", "accept", "addit", "algorithm", "algorithm", "analyz", "arbitrari", "assign", "augment", "base", "bottom", "cock", "compar", "comparison", "complex", "constitu", "construct", "context", "core", "correct", "cover", "criteria", "cy", "deriv", "deriv", "describ", "descript", "due", "effect", "effici", "equival", "error", "extens", "form", "free", "gener", "gener", "grammar", "grammar", "greibach", "gs", "harvard", "inform", "intermedi", "iron", "languag", "languag", "normal", "origin", "origin", "pars", "pars", "perform", "predict", "process", "program", "proven", "rel", "requir", "rule", "sakai", "sd", "section", "select", "sentenc", "similar", "standard", "storag", "structur", "supplement", "symbol", "symbol", "techniqu", "termin", "time", "top", "transform", "kuno"], "word_count": {"abbott": 1, "accept": 1, "addit": 1, "algorithm": 6, "analyz": 4, "arbitrari": 1, "assign": 2, "augment": 1, "base": 1, "bottom": 1, "cock": 1, "compar": 1, "comparison": 1, "complex": 1, "constitu": 1, "construct": 1, "context": 5, "core": 1, "correct": 1, "cover": 1, "criteria": 1, "cy": 1, "deriv": 2, "describ": 1, "descript": 2, "due": 1, "effect": 1, "effici": 1, "equival": 1, "error": 1, "extens": 1, "form": 6, "free": 5, "gener": 2, "grammar": 9, "greibach": 1, "gs": 5, "harvard": 1, "inform": 1, "intermedi": 1, "iron": 1, "languag": 3, "normal": 1, "origin": 3, "pars": 3, "perform": 1, "predict": 3, "process": 1, "program": 1, "proven": 1, "rel": 1, "requir": 1, "rule": 2, "sakai": 1, "sd": 4, "section": 2, "select": 1, "sentenc": 2, "similar": 1, "standard": 5, "storag": 1, "structur": 2, "supplement": 1, "symbol": 2, "techniqu": 1, "termin": 1, "time": 1, "top": 1, "transform": 1, "kuno": 1}}, "1351": {"id": "1351", "title": "Automatic Error Bounds on Real Zeros of Rational Functions", "abstract": "A procedure for implementing an interval arithmetic version of the Newton-Raphson method is  proposed.  The procedure require only a starting interval over which the zeros of a given rational function  are to be located.  The method automatically provides bounds  for roundoff error.", "authors": "Dargel, R. H. Loscalzo, F. R. Witt, T. H.", "words_pool": ["arithmet", "automat", "bound", "error", "function", "function", "implement", "interv", "locat", "method", "newton", "procedur", "propos", "raphson", "ration", "real", "requir", "roundoff", "start", "version", "zero", "dargel", "loscalzo", "witt"], "word_count": {"arithmet": 1, "automat": 1, "bound": 1, "error": 1, "function": 1, "implement": 1, "interv": 2, "locat": 1, "method": 2, "newton": 1, "procedur": 2, "propos": 1, "raphson": 1, "ration": 1, "real": 1, "requir": 1, "roundoff": 1, "start": 1, "version": 1, "zero": 1, "dargel": 1, "loscalzo": 1, "witt": 1}}, "1352": {"id": "1352", "title": "Automatic Integration of a Function with a Parameter", "abstract": "Two efficient methods for automatic numerical integration are Romberg integration and adaptive  Simpson integration.  For integrands of the form f(x)g(x,a) where a is a parameter, it is shown that  Romberg's method is more efficient.  A FORTRAN program shows how to achieve this greater efficiency.", "authors": "Rabinowitz, P.", "words_pool": ["achiev", "adapt", "automat", "effici", "effici", "form", "fortran", "function", "greater", "integrand", "integr", "method", "method", "numer", "paramet", "program", "romberg", "shown", "show", "simpson", "rabinowitz"], "word_count": {"achiev": 1, "adapt": 1, "automat": 1, "effici": 3, "form": 1, "fortran": 1, "function": 1, "greater": 1, "integrand": 1, "integr": 3, "method": 2, "numer": 1, "paramet": 1, "program": 1, "romberg": 2, "shown": 1, "show": 1, "simpson": 1, "rabinowitz": 1}}, "1353": {"id": "1353", "title": "Techniques for Automatic Tolerance Control in Linear Programming", "abstract": "In this technical note, the numerical steps for the simplex method of linear programming are  reviewed and the tolerances needed in the numerical procedure are defined.  Objective criteria are given  for accomplishing the numerical steps of the method and the calculation of necessary tolerances.", "authors": "Clasen, R. J.", "words_pool": ["accomplish", "automat", "calcul", "control", "criteria", "defin", "linear", "method", "need", "note", "numer", "object", "procedur", "program", "review", "simplex", "step", "technic", "techniqu", "toler", "toler", "clasen"], "word_count": {"accomplish": 1, "automat": 1, "calcul": 1, "control": 1, "criteria": 1, "defin": 1, "linear": 1, "method": 2, "need": 1, "note": 1, "numer": 3, "object": 1, "procedur": 1, "program": 1, "review": 1, "simplex": 1, "step": 2, "technic": 1, "techniqu": 1, "toler": 2, "clasen": 1}}, "1354": {"id": "1354", "title": "Conversion of Decision Tables to Computer Programs by Rule Mark Techniques", "abstract": "The rule mask technique is one method of converting limited entry decision tables to computer  programs.  Recent discussion suggest that in many circumstances it is to be preferred to the technique  of constructing networks or trees.  A drawback of the technique as hitherto presented is its liability  to produce object programs of longer run time than necessary.  In this paper a modification of the technique  is discussed which takes into account both rule frequencies and the relative times for evaluating conditions.   This can materially improve object program run time.", "authors": "King, P. J. H.", "words_pool": ["account", "circumst", "comput", "condit", "construct", "convers", "convert", "decis", "discuss", "discuss", "drawback", "entri", "evalu", "frequenc", "hitherto", "improv", "liabil", "limit", "longer", "mark", "mask", "materi", "method", "modif", "network", "object", "paper", "prefer", "present", "produc", "program", "program", "recent", "rel", "rule", "run", "suggest", "tabl", "take", "techniqu", "techniqu", "time", "time", "tree", "king"], "word_count": {"account": 1, "circumst": 1, "comput": 1, "condit": 1, "construct": 1, "convers": 1, "convert": 1, "decis": 1, "discuss": 2, "drawback": 1, "entri": 1, "evalu": 1, "frequenc": 1, "hitherto": 1, "improv": 1, "liabil": 1, "limit": 1, "longer": 1, "mark": 1, "mask": 1, "materi": 1, "method": 1, "modif": 1, "network": 1, "object": 2, "paper": 1, "prefer": 1, "present": 1, "produc": 1, "program": 3, "recent": 1, "rel": 1, "rule": 2, "run": 2, "suggest": 1, "tabl": 1, "take": 1, "techniqu": 4, "time": 3, "tree": 1, "king": 1}}, "1355": {"id": "1355", "title": "Regular Coulomb Wave Functions (Algorithm 292 )", "authors": "Gautschi, W.", "words_pool": ["algorithm", "coulomb", "function", "regular", "wave", "gautschi"], "word_count": {"algorithm": 1, "coulomb": 1, "function": 1, "regular": 1, "wave": 1, "gautschi": 1}}, "1356": {"id": "1356", "title": "Havie Integrator (Algorithm 257 [D1])", "authors": "Hillstrom, K.", "words_pool": ["algorithm", "d1", "havi", "integr", "hillstrom"], "word_count": {"algorithm": 1, "d1": 1, "havi": 1, "integr": 1, "hillstrom": 1}}, "1357": {"id": "1357", "title": "Examination Scheduling (Algorithm 286 [H])", "authors": "Williams, R.", "words_pool": ["algorithm", "examin", "schedul", "william"], "word_count": {"algorithm": 1, "examin": 1, "schedul": 1, "william": 1}}, "1358": {"id": "1358", "title": "Syntax Macros and Extended Translation", "abstract": "A translation approach is described which allows one to extended the syntax and semantics of  a given high-level base language by the use of a new formalism called a syntax-macro.  Syntax-macros  define string transformations based on syntactic elements of the base language.  Two types of macros  are discussed, and examples are given of their use.  The conditional generation of macros based on options  and alternatives recognized by the scan are also described.", "authors": "Leavenworth, B. M.", "words_pool": ["altern", "approach", "base", "base", "call", "condit", "defin", "discuss", "element", "exampl", "extend", "formal", "gener", "high", "languag", "level", "macro", "macro", "option", "recogn", "scan", "semant", "string", "syntact", "syntax", "transform", "translat", "type", "leavenworth"], "word_count": {"altern": 1, "approach": 1, "base": 4, "call": 1, "condit": 1, "defin": 1, "discuss": 1, "element": 1, "exampl": 1, "extend": 1, "formal": 1, "gener": 1, "high": 1, "languag": 2, "level": 1, "macro": 4, "option": 1, "recogn": 1, "scan": 1, "semant": 1, "string": 1, "syntact": 1, "syntax": 3, "transform": 1, "translat": 1, "type": 1, "leavenworth": 1}}, "1359": {"id": "1359", "title": "Data Filtering Applied to Information Storage and Retrieval Applications", "abstract": "Manipulation of data strings is the most complex processing function in information storage  and retrieval applications.  Data string manipulation is discussed within the context of an interpretive  processing environment controlled by the use of procedural directives.  The sequence of procedural directives  is derived from a job assumed to be expressed in a user-oriented source language.  Each data string with  the structured data environment (data bank) is explicitly or implicitly related to a format declaration residing in a format library.  The processing mechanics associated with data string manipulation is developed  in accordance with a generalized data filtering concept.  This results in the implementation of a two-part  data filter module that satisfies internal processing functions by filtering data strings through format  declarations associated with its input and output ports.", "authors": "Larsen, R. P.", "words_pool": ["accord", "applic", "appli", "assum", "bank", "complex", "concept", "context", "control", "data", "declar", "declar", "deriv", "develop", "direct", "discuss", "environ", "explicitli", "express", "filter", "filter", "format", "function", "function", "gener", "implement", "implicitli", "inform", "input", "intern", "interpret", "job", "languag", "librari", "manipul", "mechan", "modul", "orient", "output", "part", "port", "procedur", "process", "relat", "resid", "result", "retriev", "satisfi", "sequenc", "sourc", "storag", "string", "string", "structur", "user", "larsen"], "word_count": {"accord": 1, "applic": 1, "appli": 1, "assum": 1, "bank": 1, "complex": 1, "concept": 1, "context": 1, "control": 1, "data": 9, "declar": 2, "deriv": 1, "develop": 1, "direct": 2, "discuss": 1, "environ": 2, "explicitli": 1, "express": 1, "filter": 3, "format": 3, "function": 2, "gener": 1, "implement": 1, "implicitli": 1, "inform": 1, "input": 1, "intern": 1, "interpret": 1, "job": 1, "languag": 1, "librari": 1, "manipul": 3, "mechan": 1, "modul": 1, "orient": 1, "output": 1, "part": 1, "port": 1, "procedur": 2, "process": 4, "relat": 1, "resid": 1, "result": 1, "retriev": 1, "satisfi": 1, "sequenc": 1, "sourc": 1, "storag": 1, "string": 5, "structur": 1, "user": 1, "larsen": 1}}, "1360": {"id": "1360", "title": "Description of Systems Used for Data Transmission* (An ASA Tutorial)", "words_pool": ["asa", "data", "descript", "system", "transmiss", "tutori"], "word_count": {"asa": 1, "data": 1, "descript": 1, "system": 1, "transmiss": 1, "tutori": 1}}, "1361": {"id": "1361", "title": "Rectangular Holes in Twelve-Row Punched Cards* (Proposed American Standard)", "words_pool": ["american", "card", "hole", "propos", "punch", "rectangular", "row", "standard", "twelv"], "word_count": {"american": 1, "card": 1, "hole": 1, "propos": 1, "punch": 1, "rectangular": 1, "row": 1, "standard": 1, "twelv": 1}}, "1362": {"id": "1362", "title": "Code Extension in ASCII* (An ASA Tutorial)", "abstract": "The American Standard Code for Information Interchange (ASCII) contains a number of control  characters associated with the principle of code extension, that is, with the representation of information  which cannot be directly represented by means of the characters in the Code.  The manner of use of these  characters has not previously been completely described.  This paper presents a set of mutually consistent  philosophies regarding code extension applications, and suggests a corollary set of doctrines for the  application of the code extension characters.  Distinctions are drawn between code extension and such  other concepts as \"graphic substitution\" or \"syntactic representation\" which are often used to meet similar  requirements.  Also covered are certain topics which are not truly concerned with code extension but  which are often linked with it in discussion on code applications.  The material in this paper is equally  applicable in principle to the (proposed) ISO international 7-bit code for information interchange.", "words_pool": ["american", "applic", "applic", "applic", "asa", "ascii", "bit", "charact", "code", "complet", "concept", "concern", "consist", "control", "corollari", "cover", "directli", "discuss", "distinct", "doctrin", "drawn", "equal", "extens", "graphic", "inform", "interchang", "intern", "iso", "link", "manner", "materi", "mean", "meet", "mutual", "number", "paper", "philosophi", "present", "previous", "principl", "propos", "regard", "represent", "repres", "requir", "set", "similar", "standard", "substitut", "suggest", "syntact", "topic", "truli", "tutori"], "word_count": {"american": 1, "applic": 4, "asa": 1, "ascii": 1, "bit": 1, "charact": 4, "code": 9, "complet": 1, "concept": 1, "concern": 1, "consist": 1, "control": 1, "corollari": 1, "cover": 1, "directli": 1, "discuss": 1, "distinct": 1, "doctrin": 1, "drawn": 1, "equal": 1, "extens": 5, "graphic": 1, "inform": 3, "interchang": 2, "intern": 1, "iso": 1, "link": 1, "manner": 1, "materi": 1, "mean": 1, "meet": 1, "mutual": 1, "number": 1, "paper": 2, "philosophi": 1, "present": 1, "previous": 1, "principl": 2, "propos": 1, "regard": 1, "represent": 2, "repres": 1, "requir": 1, "set": 2, "similar": 1, "standard": 1, "substitut": 1, "suggest": 1, "syntact": 1, "topic": 1, "truli": 1, "tutori": 1}}, "1363": {"id": "1363", "title": "A General Method of Systematic Interval Computation for Numerical Integration of Initial Value  Problems", "abstract": "A procedure is given for continuously computing and monitoring the step size to be used by  a self-starting, p-th order numerical integration method to solve an initial value problem.  The procedure  uses an estimate of the truncation error to calculate the step size.", "authors": "Martin, W. C. Paulson, K. C. Sashkin, L.", "words_pool": ["calcul", "comput", "comput", "continu", "error", "estim", "gener", "initi", "integr", "interv", "method", "monitor", "numer", "order", "problem", "problem", "procedur", "size", "solv", "start", "step", "systemat", "th", "truncat", "martin", "paulson", "sashkin"], "word_count": {"calcul": 1, "comput": 1, "continu": 1, "error": 1, "estim": 1, "gener": 1, "initi": 1, "integr": 1, "interv": 1, "method": 1, "monitor": 1, "numer": 1, "order": 1, "problem": 1, "procedur": 2, "size": 2, "solv": 1, "start": 1, "step": 2, "systemat": 1, "th": 1, "truncat": 1, "martin": 1, "paulson": 1, "sashkin": 1}}, "1364": {"id": "1364", "title": "Mathematical Experimentation in Time-Lag Modulation", "abstract": "Equations of the form du/dt = g(u(t),u(h(t))) arise in a number of scientific contexts.  The  authors point out some interesting properties of the solution u'(t) = -u(t-1-k*sin(wt))+sin(at).  These  properties were obtained by means of numerical solution.", "authors": "Bellman, R. Buell, J. Kalaba, R.", "words_pool": ["aris", "author", "context", "dt", "du", "equat", "experiment", "form", "interest", "lag", "mathemat", "mean", "modul", "number", "numer", "obtain", "point", "properti", "scientif", "sin", "solut", "time", "wt", "bellman", "buell", "kalaba"], "word_count": {"aris": 1, "author": 1, "context": 1, "dt": 1, "du": 1, "equat": 1, "experiment": 1, "form": 1, "interest": 1, "lag": 1, "mathemat": 1, "mean": 1, "modul": 1, "number": 1, "numer": 1, "obtain": 1, "point": 1, "properti": 2, "scientif": 1, "sin": 2, "solut": 2, "time": 1, "wt": 1, "bellman": 1, "buell": 1, "kalaba": 1}}, "1365": {"id": "1365", "title": "Eliminating Monotonous Mathematics with FORMAC", "abstract": "The FORMAC (FORmula MAnipulation Compiler) programming system provides a powerful tool for  performing mathematical analysis.  It is an extension of FORTRAN IV which permits the use of the computer  to perform the tedious algebraic computations that arise in many different fields.  Among the areas in  which it has been successfully used are: differentiation of complicated expressions, expansion of truncated  power series, solution of simultaneous equations with literal coefficients, nonlinear maximum likelihood  estimation, tensor analysis, and generation of the coefficients of equations in Keplerian motion.  These  types of analysis-which arose in the solution of specific practical problems in physics, engineering,  astronomy, statistics and astronautics-are discussed in the paper.  In addition to its usage for specific  problem solutions, FORMAC can also be used to automate the analysis phase in certain production programming.   Several such applications are presented.", "authors": "Tobey, R. G.", "words_pool": ["addit", "algebra", "analysi", "applic", "area", "aris", "aros", "astronaut", "astronomi", "autom", "coeffici", "compil", "complic", "comput", "comput", "differenti", "discuss", "elimin", "engin", "equat", "estim", "expans", "express", "extens", "field", "formac", "formula", "fortran", "gener", "iv", "keplerian", "likelihood", "liter", "manipul", "mathemat", "mathemat", "maximum", "monoton", "motion", "nonlinear", "paper", "perform", "perform", "permit", "phase", "physic", "power", "power", "practic", "present", "problem", "problem", "product", "program", "seri", "simultan", "solut", "solut", "specif", "statist", "success", "system", "tediou", "tensor", "tool", "truncat", "type", "usag", "tobey"], "word_count": {"addit": 1, "algebra": 1, "analysi": 4, "applic": 1, "area": 1, "aris": 1, "aros": 1, "astronaut": 1, "astronomi": 1, "autom": 1, "coeffici": 2, "compil": 1, "complic": 1, "comput": 2, "differenti": 1, "discuss": 1, "elimin": 1, "engin": 1, "equat": 2, "estim": 1, "expans": 1, "express": 1, "extens": 1, "field": 1, "formac": 2, "formula": 1, "fortran": 1, "gener": 1, "iv": 1, "keplerian": 1, "likelihood": 1, "liter": 1, "manipul": 1, "mathemat": 1, "maximum": 1, "monoton": 1, "motion": 1, "nonlinear": 1, "paper": 1, "perform": 2, "permit": 1, "phase": 1, "physic": 1, "power": 2, "practic": 1, "present": 1, "problem": 2, "product": 1, "program": 2, "seri": 1, "simultan": 1, "solut": 3, "specif": 2, "statist": 1, "success": 1, "system": 1, "tediou": 1, "tensor": 1, "tool": 1, "truncat": 1, "type": 1, "usag": 1, "tobey": 1}}, "1366": {"id": "1366", "title": "Computer Simulation-Discussion of the Technique and Comparison of Languages", "abstract": "The purpose of this paper is to present a comparison of some computer simulation languages  and of some of the involved in comparing software packages for digital computers are discussed in Part  I.  The issue is obvious: users of digital computers must choose from available languages or write their  own.  Substantial costs can occur, particularly in training, implementation and computer time if an inappropriate  language is chosen.More and more computer simulation languages are being developed: comparisons and  evaluations of existing languages are useful for designers and implementers as well as users.  The second  part is devoted to computer simulation and simulation languages.  The computational characteristics of  simulation are discussed with  special attention being paid to a distinction between continuous and discrete  change models.  Part III presents a detailed comparison of six simulation languages and packages: SIMSCRIPT,  CLP, CSL, GASP, CPSS and SOL.  The characteristics of each are summarized in a series of tables.  The  implications of this analysis for designers of languages, for users, and for implementers are developed.   The conclusion of the paper is that the packages now available for computer simulation offer features  which none of the more general-purpose packages do and that analysis of strengths and weaknesses of each  suggests ways in which both current and future simulation languages and packages can be improved.", "authors": "Teichroew, D. Lubin, J. F.", "words_pool": ["analysi", "attent", "chang", "characterist", "choos", "chosen", "clp", "compar", "comparison", "comparison", "comput", "comput", "comput", "conclus", "continu", "cost", "cpss", "csl", "design", "detail", "develop", "devot", "digit", "discret", "discuss", "discuss", "distinct", "evalu", "exist", "featur", "futur", "gasp", "gener", "iii", "implement", "implement", "implic", "improv", "inappropri", "involv", "issu", "languag", "languag", "model", "obviou", "occur", "offer", "packag", "paid", "paper", "part", "present", "present", "purpos", "seri", "simscript", "simul", "softwar", "sol", "special", "strength", "substanti", "suggest", "summar", "tabl", "techniqu", "time", "train", "user", "way", "weak", "write", "teichroew", "lubin"], "word_count": {"analysi": 2, "attent": 1, "chang": 1, "characterist": 2, "choos": 1, "chosen": 1, "clp": 1, "compar": 1, "comparison": 3, "comput": 8, "conclus": 1, "continu": 1, "cost": 1, "cpss": 1, "csl": 1, "design": 2, "detail": 1, "develop": 2, "devot": 1, "digit": 2, "discret": 1, "discuss": 2, "distinct": 1, "evalu": 1, "exist": 1, "featur": 1, "futur": 1, "gasp": 1, "gener": 1, "iii": 1, "implement": 3, "implic": 1, "improv": 1, "inappropri": 1, "involv": 1, "issu": 1, "languag": 9, "model": 1, "obviou": 1, "occur": 1, "offer": 1, "packag": 5, "paid": 1, "paper": 2, "part": 3, "present": 2, "purpos": 2, "seri": 1, "simscript": 1, "simul": 8, "softwar": 1, "sol": 1, "special": 1, "strength": 1, "substanti": 1, "suggest": 1, "summar": 1, "tabl": 1, "techniqu": 1, "time": 1, "train": 1, "user": 3, "way": 1, "weak": 1, "write": 1, "teichroew": 1, "lubin": 1}}, "1367": {"id": "1367", "title": "Character Structure and Character Parity Sense for Parallel-by-Bit Data Communication in ASCII*  (Proposed American Standard)", "words_pool": ["american", "ascii", "bit", "charact", "commun", "data", "parallel", "pariti", "propos", "sens", "standard", "structur"], "word_count": {"american": 1, "ascii": 1, "bit": 1, "charact": 2, "commun": 1, "data": 1, "parallel": 1, "pariti": 1, "propos": 1, "sens": 1, "standard": 1, "structur": 1}}, "1368": {"id": "1368", "title": "Systematic Generation of Hamiltonian Circuits", "abstract": "For a combinatorial matrix which may specify both directed and nondirected arcs, the paper  describes a computer program which generates systematically and exhaustively all the Hamiltonian circuits.  Specific application is made to the \"traveling salesman\" problem.", "authors": "Roberts, S. M.", "words_pool": ["applic", "arc", "circuit", "combinatori", "comput", "describ", "direct", "exhaust", "gener", "gener", "hamiltonian", "made", "matrix", "nondirect", "paper", "problem", "program", "salesman", "specif", "systemat", "systemat", "travel", "robert"], "word_count": {"applic": 1, "arc": 1, "circuit": 1, "combinatori": 1, "comput": 1, "describ": 1, "direct": 1, "exhaust": 1, "gener": 1, "hamiltonian": 1, "made": 1, "matrix": 1, "nondirect": 1, "paper": 1, "problem": 1, "program": 1, "salesman": 1, "specif": 1, "systemat": 1, "travel": 1, "robert": 1}}, "1369": {"id": "1369", "title": "Half Rotations in N-Dimensional Euclidean Space", "abstract": "An iterative procedure is described for determining half rotations in n-dimensional Euclidean  space. The method is a variant of the cyclic Jacobi procedure and utilizers elementary plane rotations  to obtain the half rotation matrix.  Numerical examples are given.", "authors": "McCamon, R. B.", "words_pool": ["cyclic", "determin", "dimension", "elementari", "euclidean", "exampl", "half", "iter", "jacobi", "matrix", "method", "numer", "obtain", "plane", "procedur", "rotat", "rotat", "space", "util", "variant", "mccamon"], "word_count": {"cyclic": 1, "determin": 1, "dimension": 1, "elementari": 1, "euclidean": 1, "exampl": 1, "half": 2, "iter": 1, "jacobi": 1, "matrix": 1, "method": 1, "numer": 1, "obtain": 1, "plane": 1, "procedur": 2, "rotat": 3, "space": 1, "util": 1, "variant": 1, "mccamon": 1}}, "1370": {"id": "1370", "title": "Linear Equations, Exact Solutions (Algorithm 290 [F4])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "equat", "exact", "f4", "linear", "solut", "boothroyd"], "word_count": {"algorithm": 1, "equat": 1, "exact": 1, "f4": 1, "linear": 1, "solut": 1, "boothroyd": 1}}, "1371": {"id": "1371", "title": "Logarithm of Gamma Function (Algorithm 291 [S14])", "authors": "Pike, M. C. Hill, I. D.", "words_pool": ["algorithm", "function", "gamma", "logarithm", "s14", "pike", "hill"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "logarithm": 1, "s14": 1, "pike": 1, "hill": 1}}, "1372": {"id": "1372", "title": "Direct Search (Algorithm 178 [E4])", "authors": "Bell, M. Pike, M. C.", "words_pool": ["algorithm", "direct", "e4", "search", "bell", "pike"], "word_count": {"algorithm": 1, "direct": 1, "e4": 1, "search": 1, "bell": 1, "pike": 1}}, "1373": {"id": "1373", "title": "Gamma Function; Gamma Function for Range 1 to 2; Reciprocal Gamma Function to Real Argument;  Gamma Function; Logarithm of Gamma Function (Algorithms 34[S14]; 54[S14]; 80[S14]; 221[S14]; 291[S14])", "authors": "Pike, M. C. Hill, I. D.", "words_pool": ["algorithm", "argument", "function", "gamma", "logarithm", "rang", "real", "reciproc", "s14", "pike", "hill"], "word_count": {"algorithm": 1, "argument": 1, "function": 5, "gamma": 5, "logarithm": 1, "rang": 1, "real": 1, "reciproc": 1, "s14": 5, "pike": 1, "hill": 1}}, "1374": {"id": "1374", "title": "Evaluation of Determinant; Determinant Evaluation (Algorithms 41[F3]; 269[F3])", "authors": "Bergson, A.", "words_pool": ["algorithm", "determin", "evalu", "f3", "bergson"], "word_count": {"algorithm": 1, "determin": 2, "evalu": 2, "f3": 2, "bergson": 1}}, "1375": {"id": "1375", "title": "Function Minimization (Algorithm 251 [E4])", "authors": "Fletcher, R.", "words_pool": ["algorithm", "e4", "function", "minim", "fletcher"], "word_count": {"algorithm": 1, "e4": 1, "function": 1, "minim": 1, "fletcher": 1}}, "1376": {"id": "1376", "title": "Modified Graeffee Method (Algorithm 256 [C2])", "authors": "Stern, G.", "words_pool": ["algorithm", "c2", "graeffe", "method", "modifi", "stern"], "word_count": {"algorithm": 1, "c2": 1, "graeffe": 1, "method": 1, "modifi": 1, "stern": 1}}, "1377": {"id": "1377", "title": "Pseudo-Random Numbers (Algorithm 266 [G5])", "authors": "Hansson, L.", "words_pool": ["algorithm", "g5", "number", "pseudo", "random", "hansson"], "word_count": {"algorithm": 1, "g5": 1, "number": 1, "pseudo": 1, "random": 1, "hansson": 1}}, "1378": {"id": "1378", "title": "Pseudo-Random Numbers (Algorithm 266 [G5])", "authors": "Hill, I. D. Pike, M. C.", "words_pool": ["algorithm", "g5", "number", "pseudo", "random", "hill", "pike"], "word_count": {"algorithm": 1, "g5": 1, "number": 1, "pseudo": 1, "random": 1, "hill": 1, "pike": 1}}, "1379": {"id": "1379", "title": "A Final Solution to the Dangling Else of ALGOL 60 and Related Languages", "abstract": "The dangling else problem consists of a class of potential ambiguities in ALGOL-like conditional  statements whose basic form is \"if B1 then if B2 then S1 else S2\" where B1 and B2 are Boolean expressions  and S1 and S2 are basic statements.  The difficulty lies in whether to attach the else to the first if  or to the second one.  Existing solutions to the problem are either ambiguous or unnecessarily restrictive.   Let Sand S1 be statements.  We define S to be closed if \"S else S1\" is not a statement, and to be open  if \"S else S1\" is a statement.  Thus an unconditional statement is  a closed statement.  Open and closed  conditional statements are defined by syntax equations in such a way as to preserve openness and closure.   In each case, an else must always be preceded by a closed statement.  It is shown that the syntax equations  are unambiguous, and that may change in the statement types required within the syntax equations would  lead to either ambiguity or unnecessary restriction.", "authors": "Abrahams, P. W.", "words_pool": ["algol", "ambigu", "ambigu", "ambigu", "attach", "b1", "b2", "basic", "boolean", "case", "chang", "class", "close", "closur", "condit", "consist", "dangl", "defin", "defin", "difficulti", "equat", "exist", "express", "final", "form", "languag", "lead", "let", "lie", "open", "open", "potenti", "preced", "preserv", "problem", "relat", "requir", "restrict", "restrict", "s1", "s2", "sand", "shown", "solut", "solut", "statement", "statement", "syntax", "type", "unambigu", "uncondit", "unnecessarili", "unnecessari", "abraham"], "word_count": {"algol": 1, "ambigu": 3, "attach": 1, "b1": 2, "b2": 2, "basic": 2, "boolean": 1, "case": 1, "chang": 1, "class": 1, "close": 4, "closur": 1, "condit": 2, "consist": 1, "dangl": 1, "defin": 2, "difficulti": 1, "equat": 3, "exist": 1, "express": 1, "final": 1, "form": 1, "languag": 1, "lead": 1, "let": 1, "lie": 1, "open": 3, "potenti": 1, "preced": 1, "preserv": 1, "problem": 2, "relat": 1, "requir": 1, "restrict": 2, "s1": 5, "s2": 2, "sand": 1, "shown": 1, "solut": 1, "statement": 10, "syntax": 3, "type": 1, "unambigu": 1, "uncondit": 1, "unnecessarili": 1, "unnecessari": 1, "abraham": 1}}, "1380": {"id": "1380", "title": "SIMULA-an ALGOL-Based Simulation Language", "abstract": "This paper is an introduction to SIMULA, a programming language designed to provide a systems  analyst with unified concepts which facilitate the concise description of discrete event systems.  A  system description also serves as a source language simulation program.  SIMULA is an extension of ALGOL  60 in which the most important new concepts is that of quasi-parallel processing.", "authors": "Dahl, O. J. Nygaard, K.", "words_pool": ["algol", "analyst", "base", "concept", "concis", "descript", "design", "discret", "event", "extens", "facilit", "import", "introduct", "languag", "paper", "parallel", "process", "program", "program", "provid", "quasi", "serv", "simula", "simul", "sourc", "system", "system", "unifi", "dahl", "nygaard"], "word_count": {"algol": 1, "analyst": 1, "base": 1, "concept": 2, "concis": 1, "descript": 2, "design": 1, "discret": 1, "event": 1, "extens": 1, "facilit": 1, "import": 1, "introduct": 1, "languag": 2, "paper": 1, "parallel": 1, "process": 1, "program": 2, "provid": 1, "quasi": 1, "serv": 1, "simula": 2, "simul": 1, "sourc": 1, "system": 3, "unifi": 1, "dahl": 1, "nygaard": 1}}, "1381": {"id": "1381", "title": "Impact of Computers on the Undergraduate Mathematics Curriculum", "abstract": "The use of computers to permit the widespread application of mathematical ideas requiring computation  in science and technology is extremely significant for the understanding of our current society.  Student  interest in this development is intense and if properly utilized should yield a much better understanding  of mathematical concepts as well as the ideas of programming and logical structure which have been introduced  into many fields by the use of computers.  The present paper suggests that that portion of the undergraduate  mathematical curriculum which is preparation for the use of mathematics by persons who are not professional  mathematicians be modified to include the extensions and clarifications which are possible because of  computers.  An early introduction to programming is desirable to permit a continuing use of automatic  computation to illustrate and clarify mathematical concepts.  Following the calculus equation stage an  intensive introduction to numerical analysis should be added to the current curriculum.  In addition  to providing competence in the mostly used computing techniques, it would permit a more sophisticated  utilization of the advanced mathematical ideas associated with complex variables and transform theories.", "authors": "Murray, F. J.", "words_pool": ["ad", "addit", "advanc", "analysi", "applic", "automat", "calculu", "clarif", "clarifi", "compet", "complex", "comput", "comput", "comput", "concept", "continu", "curriculum", "desir", "develop", "earli", "equat", "extens", "extrem", "field", "idea", "illustr", "impact", "includ", "intens", "intens", "interest", "introduc", "introduct", "logic", "mathemat", "mathematician", "mathemat", "modifi", "numer", "paper", "permit", "person", "portion", "prepar", "present", "profession", "program", "properli", "provid", "requir", "scienc", "signific", "societi", "sophist", "stage", "structur", "student", "suggest", "techniqu", "technolog", "theori", "transform", "undergradu", "understand", "util", "util", "variabl", "widespread", "yield", "murray"], "word_count": {"ad": 1, "addit": 1, "advanc": 1, "analysi": 1, "applic": 1, "automat": 1, "calculu": 1, "clarif": 1, "clarifi": 1, "compet": 1, "complex": 1, "comput": 6, "concept": 2, "continu": 1, "curriculum": 2, "desir": 1, "develop": 1, "earli": 1, "equat": 1, "extens": 1, "extrem": 1, "field": 1, "idea": 3, "illustr": 1, "impact": 1, "includ": 1, "intens": 2, "interest": 1, "introduc": 1, "introduct": 2, "logic": 1, "mathemat": 6, "mathematician": 1, "modifi": 1, "numer": 1, "paper": 1, "permit": 3, "person": 1, "portion": 1, "prepar": 1, "present": 1, "profession": 1, "program": 2, "properli": 1, "provid": 1, "requir": 1, "scienc": 1, "signific": 1, "societi": 1, "sophist": 1, "stage": 1, "structur": 1, "student": 1, "suggest": 1, "techniqu": 1, "technolog": 1, "theori": 1, "transform": 1, "undergradu": 1, "understand": 2, "util": 2, "variabl": 1, "widespread": 1, "yield": 1, "murray": 1}}, "1382": {"id": "1382", "title": "Desired Computer Impact on Undergraduate Mathematics", "abstract": "Three matters relating to the theme of the Symposium are discussed here.  The author examines  some projections concerning the supply and demand for mathematicians in the United States through the  mid-1970s, comments briefly on some of the factors which may influence the professional activities of  applied mathematicians over the next several years, and discusses in broad terms how this information  may relate to the undergraduate training of mathematicians.", "authors": "Macon, N.", "words_pool": ["1970", "activ", "appli", "author", "briefli", "broad", "comment", "comput", "concern", "demand", "desir", "discuss", "discuss", "examin", "factor", "impact", "influenc", "inform", "mathematician", "mathemat", "matter", "mid", "profession", "project", "relat", "relat", "state", "suppli", "symposium", "term", "theme", "train", "undergradu", "unit", "year", "macon"], "word_count": {"1970": 1, "activ": 1, "appli": 1, "author": 1, "briefli": 1, "broad": 1, "comment": 1, "comput": 1, "concern": 1, "demand": 1, "desir": 1, "discuss": 2, "examin": 1, "factor": 1, "impact": 1, "influenc": 1, "inform": 1, "mathematician": 3, "mathemat": 1, "matter": 1, "mid": 1, "profession": 1, "project": 1, "relat": 2, "state": 1, "suppli": 1, "symposium": 1, "term": 1, "theme": 1, "train": 1, "undergradu": 1, "unit": 1, "year": 1, "macon": 1}}, "1383": {"id": "1383", "title": "Implications of the Digital Computer for Education In the Mathematical Sciences", "abstract": "The digital computer has profoundly altered the definition of what is interesting in mathematics.   The importance of applied logic in human affairs is changed by the existence of the \"logical engine.\"   The result is that one should no longer think in terms of a single discipline of mathematics but in  terms of a complex of mathematical sciences.", "authors": "Givens, W.", "words_pool": ["affair", "alter", "appli", "chang", "complex", "comput", "definit", "digit", "disciplin", "educ", "engin", "exist", "human", "implic", "import", "interest", "logic", "logic", "longer", "mathemat", "mathemat", "profoundli", "result", "scienc", "singl", "term", "think", "given"], "word_count": {"affair": 1, "alter": 1, "appli": 1, "chang": 1, "complex": 1, "comput": 1, "definit": 1, "digit": 1, "disciplin": 1, "educ": 1, "engin": 1, "exist": 1, "human": 1, "implic": 1, "import": 1, "interest": 1, "logic": 2, "longer": 1, "mathemat": 3, "profoundli": 1, "result": 1, "scienc": 1, "singl": 1, "term": 2, "think": 1, "given": 1}}, "1384": {"id": "1384", "title": "Mathematics for Undergraduate Computer Scientists", "abstract": "The mathematical requirements for an undergraduate program in Computer Science are a subject  of debate.  The Association for Computing Machinery's Curriculum Committee, however, believes that these  requirements are essentially the same as the mathematical content of physical sciences undergraduate  programs.  The Committee believes that these requirements should assure the student of a broad mathematical  background and should enable him to take a wide variety of courses in other scientific disciplines.   The Committee's concern is to develop a solid scientific  approach to Computer Science.", "authors": "Atchison, W. F.", "words_pool": ["approach", "associ", "assur", "background", "believ", "broad", "committe", "comput", "comput", "concern", "content", "cours", "curriculum", "debat", "develop", "disciplin", "enabl", "essenti", "machineri", "mathemat", "mathemat", "physic", "program", "program", "requir", "scienc", "scienc", "scientif", "scientist", "solid", "student", "subject", "take", "undergradu", "varieti", "wide", "atchison"], "word_count": {"approach": 1, "associ": 1, "assur": 1, "background": 1, "believ": 2, "broad": 1, "committe": 3, "comput": 3, "concern": 1, "content": 1, "cours": 1, "curriculum": 1, "debat": 1, "develop": 1, "disciplin": 1, "enabl": 1, "essenti": 1, "machineri": 1, "mathemat": 3, "physic": 1, "program": 2, "requir": 3, "scienc": 3, "scientif": 2, "scientist": 1, "solid": 1, "student": 1, "subject": 1, "take": 1, "undergradu": 2, "varieti": 1, "wide": 1, "atchison": 1}}, "1385": {"id": "1385", "title": "Computer Technology in Communist China, 1956-1965", "abstract": "Based on information from translations of Communist Chinese news items and periodical literature  for the 1965 period, computer technology in China is reviewed under the following headings: (1) initial  planning, organization and educational aspects of computer technology and automation; (2) machine development  progress: two major specific machines in 1958-59, with Soviet aid; a vacuum in 1960-64 due to the withdrawal  of Soviet aid; then presumably all-Chinese-made machines from 1965 to the present; (3) computer applications;  (4) the trend of automation: control of production processes rather than data processing; and (5) the  \"Yun Ch'ou Hsueh\" (Science of Operation and Programming) campaign of 1958-60, during which an attempt  was made to bring concepts such as linear programming to ordinary Chinese workers and peasants.  Communist  China is adjudged to have a marginal computer capability, with most of its machines probably being of  a binary nature; however, a turning point may have been reached in mid-1965.", "authors": "Audette, D. G.", "words_pool": ["adjudg", "aid", "applic", "aspect", "attempt", "autom", "base", "binari", "bring", "campaign", "capabl", "ch", "china", "chines", "communist", "comput", "concept", "control", "data", "develop", "due", "educ", "head", "hsueh", "inform", "initi", "item", "linear", "literatur", "machin", "machin", "made", "major", "margin", "mid", "natur", "news", "oper", "ordinari", "organ", "ou", "peasant", "period", "period", "plan", "point", "present", "presum", "process", "process", "product", "program", "progress", "reach", "review", "scienc", "soviet", "specif", "technolog", "translat", "trend", "turn", "vacuum", "withdraw", "worker", "yun", "audett"], "word_count": {"adjudg": 1, "aid": 2, "applic": 1, "aspect": 1, "attempt": 1, "autom": 2, "base": 1, "binari": 1, "bring": 1, "campaign": 1, "capabl": 1, "ch": 1, "china": 2, "chines": 3, "communist": 2, "comput": 4, "concept": 1, "control": 1, "data": 1, "develop": 1, "due": 1, "educ": 1, "head": 1, "hsueh": 1, "inform": 1, "initi": 1, "item": 1, "linear": 1, "literatur": 1, "machin": 4, "made": 2, "major": 1, "margin": 1, "mid": 1, "natur": 1, "news": 1, "oper": 1, "ordinari": 1, "organ": 1, "ou": 1, "peasant": 1, "period": 2, "plan": 1, "point": 1, "present": 1, "presum": 1, "process": 2, "product": 1, "program": 2, "progress": 1, "reach": 1, "review": 1, "scienc": 1, "soviet": 2, "specif": 1, "technolog": 2, "translat": 1, "trend": 1, "turn": 1, "vacuum": 1, "withdraw": 1, "worker": 1, "yun": 1, "audett": 1}}, "1386": {"id": "1386", "title": "Symbolic Factoring of Polynomials in Several Variables", "abstract": "An algorithm for finding the symbolic factors of a multi-variate polynomial with integer coefficients  is presented.  The algorithm is an extension of a technique used by Kronecker in a proof that the prime  factoring of any polynomial may be found in a finite number of steps.  The algorithm consists of factoring  single-variable instances of the given polynomial by Kronecker's method and introducing the remaining  variables by interpolation.  Techniques for implementing the algorithm and several examples are discussed.   The algorithm promises sufficient power to be used efficiently in an online system for symbolic mathematics.", "authors": "Jordan, D. E. Kain, R. Y. Clapp, L. C.", "words_pool": ["algorithm", "coeffici", "consist", "discuss", "effici", "exampl", "extens", "factor", "factor", "find", "finit", "found", "implement", "instanc", "integ", "interpol", "introduc", "kroneck", "mathemat", "method", "multi", "number", "onlin", "polynomi", "polynomi", "power", "present", "prime", "promis", "proof", "remain", "singl", "step", "suffici", "symbol", "system", "techniqu", "techniqu", "variabl", "variabl", "variat", "jordan", "kain", "clapp"], "word_count": {"algorithm": 5, "coeffici": 1, "consist": 1, "discuss": 1, "effici": 1, "exampl": 1, "extens": 1, "factor": 3, "find": 1, "finit": 1, "found": 1, "implement": 1, "instanc": 1, "integ": 1, "interpol": 1, "introduc": 1, "kroneck": 2, "mathemat": 1, "method": 1, "multi": 1, "number": 1, "onlin": 1, "polynomi": 3, "power": 1, "present": 1, "prime": 1, "promis": 1, "proof": 1, "remain": 1, "singl": 1, "step": 1, "suffici": 1, "symbol": 2, "system": 1, "techniqu": 2, "variabl": 2, "variat": 1, "jordan": 1, "kain": 1, "clapp": 1}}, "1387": {"id": "1387", "title": "Solution of Systems of Polynomial Equations By Elimination", "abstract": "The elimination procedure as described by Williams has been coded in LISP and FORMAC and used  in solving systems of polynomial equations.  It is found that the method is very effective in the case  of small systems, where it yields all solutions without the need for initial estimates. The method, by  itself, appears in appropriate, however, in the solution of large systems of equation due to the explosive  growth in the intermediate equations and the hazards which arise when the coefficients are truncated.   A comparison is made with difficulties found in other problems in non-numerical mathematics such as  symbolic integration and simplification.", "authors": "Moses, J.", "words_pool": ["appear", "aris", "case", "code", "coeffici", "comparison", "difficulti", "due", "effect", "elimin", "equat", "equat", "estim", "explos", "formac", "found", "growth", "hazard", "initi", "integr", "intermedi", "larg", "lisp", "made", "mathemat", "method", "need", "non", "numer", "polynomi", "problem", "procedur", "simplif", "small", "solut", "solut", "solv", "symbol", "system", "truncat", "william", "yield", "mose"], "word_count": {"appear": 1, "aris": 1, "case": 1, "code": 1, "coeffici": 1, "comparison": 1, "difficulti": 1, "due": 1, "effect": 1, "elimin": 1, "equat": 3, "estim": 1, "explos": 1, "formac": 1, "found": 2, "growth": 1, "hazard": 1, "initi": 1, "integr": 1, "intermedi": 1, "larg": 1, "lisp": 1, "made": 1, "mathemat": 1, "method": 2, "need": 1, "non": 1, "numer": 1, "polynomi": 1, "problem": 1, "procedur": 1, "simplif": 1, "small": 1, "solut": 2, "solv": 1, "symbol": 1, "system": 3, "truncat": 1, "william": 1, "yield": 1, "mose": 1}}, "1388": {"id": "1388", "title": "AUTOMAST: Automatic Mathematical Analysis and Symbolic Translation", "abstract": "A procedure for numerically solving systems of ordinary differential equation is shown to also  generate symbolic solutions.  The procedure is based on a finite Taylor series expansion that includes  an estimate of the error in the final result.  A computer program is described that reads in a system  of such equations and then generates the expansions for all of the dependent variables. The expansions  are determined symbolically, hence any non-numeric parameters in the original equations are carried automatically  into the final expansions.  Thus the exact influence of any parameters on the problem solution can be  easily displayed.", "authors": "Ball, W. E. Berns, R. I.", "words_pool": ["analysi", "automast", "automat", "base", "carri", "comput", "depend", "determin", "differenti", "display", "easili", "equat", "equat", "error", "estim", "exact", "expans", "expans", "final", "finit", "gener", "gener", "includ", "influenc", "mathemat", "non", "numer", "numer", "ordinari", "origin", "paramet", "problem", "procedur", "program", "read", "result", "seri", "shown", "solut", "solut", "solv", "symbol", "symbol", "system", "system", "taylor", "translat", "variabl", "ball", "bern"], "word_count": {"analysi": 1, "automast": 1, "automat": 1, "base": 1, "carri": 1, "comput": 1, "depend": 1, "determin": 1, "differenti": 1, "display": 1, "easili": 1, "equat": 3, "error": 1, "estim": 1, "exact": 1, "expans": 4, "final": 2, "finit": 1, "gener": 2, "includ": 1, "influenc": 1, "mathemat": 1, "non": 1, "numer": 2, "ordinari": 1, "origin": 1, "paramet": 2, "problem": 1, "procedur": 2, "program": 1, "read": 1, "result": 1, "seri": 1, "shown": 1, "solut": 2, "solv": 1, "symbol": 2, "system": 2, "taylor": 1, "translat": 1, "variabl": 1, "ball": 1, "bern": 1}}, "1389": {"id": "1389", "title": "A Programmer's Description of L^6", "abstract": "Bell Telephone Laboratories' Low-Linked List Language L^6 (pronounced \"L-six\") is a new programming  language for list structure manipulations.  It contains many of the facilities which underlie such list  processors as IPL, LISP, COMIT ad SNOBOL, but permits the user to get much closer to machine code in  order to write faster-running programs, to use storage more efficiently and to build a wider variety  of linked data structures.", "authors": "Knowlton, K. C.", "words_pool": ["ad", "bell", "build", "closer", "code", "comit", "data", "descript", "effici", "facil", "faster", "ipl", "laboratori", "languag", "link", "lisp", "list", "low", "machin", "manipul", "order", "permit", "processor", "programm", "program", "program", "pronounc", "run", "snobol", "storag", "structur", "structur", "telephon", "underli", "user", "varieti", "wider", "write", "knowlton"], "word_count": {"ad": 1, "bell": 1, "build": 1, "closer": 1, "code": 1, "comit": 1, "data": 1, "descript": 1, "effici": 1, "facil": 1, "faster": 1, "ipl": 1, "laboratori": 1, "languag": 2, "link": 2, "lisp": 1, "list": 3, "low": 1, "machin": 1, "manipul": 1, "order": 1, "permit": 1, "processor": 1, "programm": 1, "program": 2, "pronounc": 1, "run": 1, "snobol": 1, "storag": 1, "structur": 2, "telephon": 1, "underli": 1, "user": 1, "varieti": 1, "wider": 1, "write": 1, "knowlton": 1}}, "1390": {"id": "1390", "title": "CONVERT", "abstract": "A programming language is described which is applicable to problems conveniently described  by transformation rules.  By this is meant that patterns may be prescribed, each being associated with  a skeleton, so that a series of such pairs may be searched until a pattern is found which matches an  expression to be transformed.  The conditions for a match are governed by a code which also allows subexpressions  to be identified and eventually substituted into the corresponding skeleton.  The primitive patterns  and primitive skeletons are described, as well as the principle which allow their elaboration in to more  complicated patterns and skeletons.  The advantages of the language are that it allows one to apply transformation  rules to lists and arrays as easily as strings, that both patterns and skeletons may be defined recursively,  and that as a consequence programs may be stated quite concisely.", "authors": "Guzman, A. McIntosh, H. V.", "words_pool": ["advantag", "allow", "applic", "appli", "array", "code", "complic", "concis", "condit", "consequ", "conveni", "convert", "defin", "easili", "elabor", "eventu", "express", "found", "govern", "identifi", "languag", "list", "match", "match", "meant", "pair", "pattern", "pattern", "prescrib", "primit", "principl", "problem", "program", "program", "recurs", "rule", "search", "seri", "skeleton", "skeleton", "state", "string", "subexpress", "substitut", "transform", "transform", "guzman", "mcintosh"], "word_count": {"advantag": 1, "allow": 1, "applic": 1, "appli": 1, "array": 1, "code": 1, "complic": 1, "concis": 1, "condit": 1, "consequ": 1, "conveni": 1, "convert": 1, "defin": 1, "easili": 1, "elabor": 1, "eventu": 1, "express": 1, "found": 1, "govern": 1, "identifi": 1, "languag": 2, "list": 1, "match": 2, "meant": 1, "pair": 1, "pattern": 5, "prescrib": 1, "primit": 2, "principl": 1, "problem": 1, "program": 2, "recurs": 1, "rule": 2, "search": 1, "seri": 1, "skeleton": 5, "state": 1, "string": 1, "subexpress": 1, "substitut": 1, "transform": 3, "guzman": 1, "mcintosh": 1}}, "1391": {"id": "1391", "title": "Computer Experiments in Finite Algebra", "abstract": "A medium-scale programming system is written in MAD and FAP on the IBM 7094 to manipulate some  of the objects of modern algebra: finite groups, maps and sets of maps, subsets and sets of subsets,  constant integers and truth-values.  Designed to operate in a time-sharing environment, the system can  serve as a teacher's aid to the undergraduate student of modern algebra, as well as for the working scientist  or engineer wishing to familiarize himself with the subset.", "authors": "Maurer, W. D.", "words_pool": ["aid", "algebra", "comput", "constant", "design", "engin", "environ", "experi", "familiar", "fap", "finit", "group", "ibm", "integ", "mad", "manipul", "map", "medium", "modern", "object", "oper", "program", "scale", "scientist", "serv", "set", "share", "student", "subset", "subset", "system", "teacher", "time", "truth", "undergradu", "valu", "wish", "work", "written", "maurer"], "word_count": {"aid": 1, "algebra": 2, "comput": 1, "constant": 1, "design": 1, "engin": 1, "environ": 1, "experi": 1, "familiar": 1, "fap": 1, "finit": 1, "group": 1, "ibm": 1, "integ": 1, "mad": 1, "manipul": 1, "map": 2, "medium": 1, "modern": 2, "object": 1, "oper": 1, "program": 1, "scale": 1, "scientist": 1, "serv": 1, "set": 2, "share": 1, "student": 1, "subset": 3, "system": 2, "teacher": 1, "time": 1, "truth": 1, "undergradu": 1, "valu": 1, "wish": 1, "work": 1, "written": 1, "maurer": 1}}, "1392": {"id": "1392", "title": "Experience with FORMAC Algorithm Design", "abstract": "Various facets of the design and implementation of mathematical expression manipulation algorithms  are discussed.  Concrete examples are provided by the FORMAC EXPAND and differentiation algorithms, a  basic FORMAC utility routine, and an experiment in the extraction of the skeletal structure of an expression.   One recurrent theme is the need to avoid excessive intermediate expression swell in order to minimize  core storage requirements. Although many details from the FORMAC implementation are presented, an attempt  is made to stress principles and ideas of general relevance in the design of algorithms for manipulating  mathematical expressions.", "authors": "Tobey, R. G.", "words_pool": ["algorithm", "algorithm", "attempt", "avoid", "basic", "concret", "core", "design", "detail", "differenti", "discuss", "exampl", "excess", "expand", "experi", "experi", "express", "express", "extract", "facet", "formac", "gener", "idea", "implement", "intermedi", "made", "manipul", "manipul", "mathemat", "minim", "need", "order", "present", "principl", "provid", "recurr", "relev", "requir", "routin", "skelet", "storag", "stress", "structur", "swell", "theme", "util", "tobey"], "word_count": {"algorithm": 3, "attempt": 1, "avoid": 1, "basic": 1, "concret": 1, "core": 1, "design": 2, "detail": 1, "differenti": 1, "discuss": 1, "exampl": 1, "excess": 1, "expand": 1, "experi": 1, "express": 4, "extract": 1, "facet": 1, "formac": 3, "gener": 1, "idea": 1, "implement": 2, "intermedi": 1, "made": 1, "manipul": 2, "mathemat": 2, "minim": 1, "need": 1, "order": 1, "present": 1, "principl": 1, "provid": 1, "recurr": 1, "relev": 1, "requir": 1, "routin": 1, "skelet": 1, "storag": 1, "stress": 1, "structur": 1, "swell": 1, "theme": 1, "util": 1, "tobey": 1}}, "1393": {"id": "1393", "title": "PM, A System for Polynomial Manipulation", "abstract": "PM is an IBM 7094 program system for formal manipulation of polynomials in any number of variables,  with integral coefficients unrestricted in size.  Some of the formal operations which can be performed  by the system are sums, differences, products, quotients, derivatives, substitutions and greater common  divisors.  PM is based on the REFCO III list processing system, which is described and compared with  the LISP and SLIP systems.  The PM subroutines for arithmetic of large integers are described as constituting  an independently useful subsystem.  PM is compared with the ALPAK system in several respects, including  the choice of canonical forms for polynomials.  A new algorithm for polynomial greatest common divisor  calculation is mentioned, and exaples are included to illustrate its superiority.", "authors": "Collins, G. E.", "words_pool": ["algorithm", "alpak", "arithmet", "base", "calcul", "canon", "choic", "coeffici", "common", "compar", "constitut", "deriv", "differ", "divisor", "divisor", "exapl", "formal", "form", "greater", "greatest", "ibm", "iii", "illustr", "includ", "includ", "independ", "integ", "integr", "larg", "lisp", "list", "manipul", "mention", "number", "oper", "perform", "pm", "polynomi", "polynomi", "process", "product", "program", "quotient", "refco", "respect", "size", "slip", "subroutin", "substitut", "subsystem", "sum", "superior", "system", "system", "unrestrict", "variabl", "collin"], "word_count": {"algorithm": 1, "alpak": 1, "arithmet": 1, "base": 1, "calcul": 1, "canon": 1, "choic": 1, "coeffici": 1, "common": 2, "compar": 2, "constitut": 1, "deriv": 1, "differ": 1, "divisor": 2, "exapl": 1, "formal": 2, "form": 1, "greater": 1, "greatest": 1, "ibm": 1, "iii": 1, "illustr": 1, "includ": 2, "independ": 1, "integ": 1, "integr": 1, "larg": 1, "lisp": 1, "list": 1, "manipul": 1, "mention": 1, "number": 1, "oper": 1, "perform": 1, "pm": 4, "polynomi": 3, "process": 1, "product": 1, "program": 1, "quotient": 1, "refco": 1, "respect": 1, "size": 1, "slip": 1, "subroutin": 1, "substitut": 1, "subsystem": 1, "sum": 1, "superior": 1, "system": 5, "unrestrict": 1, "variabl": 1, "collin": 1}}, "1394": {"id": "1394", "title": "Computation of Algebraic Properties of Elementary Particle Reactions Using a Digital Computer", "abstract": "A large number of calculations in high-energy elementary particle physics involve the manipulation  of complicated algebraic expressions containing both tensor and noncommutative matrix quantities.  Many  of these calculations take several months to complete, although the operations involved follow straightforward  rules.  In this paper a program is described, which has been developed in LISP for solving such problems.   The manner in which these problems are encountered is outlined, and their representation in the computer  discussed.  At present, about six months of human work takes less than fifteen minutes on an IBM 7090.   Limitations of the present system and future plans are also outlined.", "authors": "Hearn, A. C.", "words_pool": ["algebra", "calcul", "complet", "complic", "comput", "comput", "develop", "digit", "discuss", "elementari", "encount", "energi", "express", "fifteen", "follow", "futur", "high", "human", "ibm", "involv", "involv", "larg", "limit", "lisp", "manipul", "manner", "matrix", "minut", "month", "noncommut", "number", "oper", "outlin", "paper", "particl", "physic", "plan", "present", "problem", "program", "properti", "quantiti", "reaction", "represent", "rule", "solv", "straightforward", "system", "take", "take", "tensor", "work", "hearn"], "word_count": {"algebra": 1, "calcul": 2, "complet": 1, "complic": 1, "comput": 1, "develop": 1, "digit": 1, "discuss": 1, "elementari": 1, "encount": 1, "energi": 1, "express": 1, "fifteen": 1, "follow": 1, "futur": 1, "high": 1, "human": 1, "ibm": 1, "involv": 2, "larg": 1, "limit": 1, "lisp": 1, "manipul": 1, "manner": 1, "matrix": 1, "minut": 1, "month": 2, "noncommut": 1, "number": 1, "oper": 1, "outlin": 2, "paper": 1, "particl": 1, "physic": 1, "plan": 1, "present": 2, "problem": 2, "program": 1, "properti": 1, "quantiti": 1, "reaction": 1, "represent": 1, "rule": 1, "solv": 1, "straightforward": 1, "system": 1, "take": 2, "tensor": 1, "work": 1, "hearn": 1}}, "1395": {"id": "1395", "title": "On the Implementation of AMBIT, A Language for Symbol Manipulation", "abstract": "A brief description is given of the implementation technique for the replacement rule of the  AMBIT programming language.  The algorithm for the \"AMBIT scan\" and an example of its application are  given.  The algorithm is applicable to other members of the family of string transformation languages  of which AMBIT is a member, and it provides a rationale for the design of the AMBIT language.", "authors": "Christensen, C.", "words_pool": ["algorithm", "ambit", "applic", "applic", "descript", "design", "famili", "implement", "languag", "languag", "manipul", "member", "member", "program", "rational", "replac", "rule", "scan", "string", "symbol", "techniqu", "transform", "christensen"], "word_count": {"algorithm": 2, "ambit": 4, "applic": 2, "descript": 1, "design": 1, "famili": 1, "implement": 1, "languag": 3, "manipul": 1, "member": 2, "program": 1, "rational": 1, "replac": 1, "rule": 1, "scan": 1, "string": 1, "symbol": 1, "techniqu": 1, "transform": 1, "christensen": 1}}, "1396": {"id": "1396", "title": "Survey of Formula Manipulation", "abstract": "The field of formula manipulation is surveyed, with particular attention to the specific capabilities  of differentiation, integration and the supporting capabilities of simplification, displays and input/output  editing, and precision arithmetic.  General systems-both batch and online-are described.  Finally, some  programs to solve specific applications are discussed.", "authors": "Sammet, J. E.", "words_pool": ["applic", "arithmet", "attent", "batch", "capabl", "differenti", "discuss", "display", "edit", "field", "final", "formula", "gener", "input", "integr", "manipul", "onlin", "output", "precis", "program", "simplif", "solv", "specif", "support", "survey", "survey", "system", "sammet"], "word_count": {"applic": 1, "arithmet": 1, "attent": 1, "batch": 1, "capabl": 2, "differenti": 1, "discuss": 1, "display": 1, "edit": 1, "field": 1, "final": 1, "formula": 1, "gener": 1, "input": 1, "integr": 1, "manipul": 1, "onlin": 1, "output": 1, "precis": 1, "program": 1, "simplif": 1, "solv": 1, "specif": 2, "support": 1, "survey": 1, "system": 1, "sammet": 1}}, "1397": {"id": "1397", "title": "Proceedings of the ACM Symposium on Symbolic and Algebraic Manipulation", "abstract": "The ACM Symposium on Symbolic and Algebraic Manipulation brought together over four hundred  people interested in programming languages designed for manipulation of algebraic formulas and symbol  strings, in their applications, and in algorithms for their implementation.  Twenty-eight papers were  presented, followed by a lively panel discussion of future directions.  Evening meetings were arranged  for several interest groups.  The conference was sponsored by the ACM Special Interest Committee on Symbolic  and Algebraic Manipulation.  The program committee consisted of Chairman Jean E. Sammet, Paul Abrahams,  Thomas E. Cheatham, Max Goldstein, and Douglas Mcllroy.  Conference arrangements were made by Lewis C.  Clapp, Daniel Bobrow and James H. Griesmer.-Robert W. Floyd, Editor", "words_pool": ["abraham", "acm", "algebra", "algorithm", "applic", "arrang", "arrang", "bobrow", "brought", "chairman", "cheatham", "clapp", "committe", "confer", "consist", "daniel", "design", "direct", "discuss", "dougla", "editor", "even", "floyd", "formula", "futur", "goldstein", "griesmer", "group", "hundr", "implement", "interest", "interest", "jame", "jean", "languag", "lewi", "live", "made", "manipul", "max", "mcllroy", "meet", "panel", "paper", "paul", "peopl", "present", "proceed", "program", "program", "robert", "sammet", "special", "sponsor", "string", "symbol", "symbol", "symposium", "thoma", "twenti"], "word_count": {"abraham": 1, "acm": 2, "algebra": 3, "algorithm": 1, "applic": 1, "arrang": 2, "bobrow": 1, "brought": 1, "chairman": 1, "cheatham": 1, "clapp": 1, "committe": 2, "confer": 2, "consist": 1, "daniel": 1, "design": 1, "direct": 1, "discuss": 1, "dougla": 1, "editor": 1, "even": 1, "floyd": 1, "formula": 1, "futur": 1, "goldstein": 1, "griesmer": 1, "group": 1, "hundr": 1, "implement": 1, "interest": 3, "jame": 1, "jean": 1, "languag": 1, "lewi": 1, "live": 1, "made": 1, "manipul": 3, "max": 1, "mcllroy": 1, "meet": 1, "panel": 1, "paper": 1, "paul": 1, "peopl": 1, "present": 1, "proceed": 1, "program": 2, "robert": 1, "sammet": 1, "special": 1, "sponsor": 1, "string": 1, "symbol": 3, "symposium": 1, "thoma": 1, "twenti": 1}}, "1398": {"id": "1398", "title": "Robot Data Screening: A Solution to Multivariate Type Problems in the Biological and Social Sciences", "abstract": "A new approach is outlined toward the solution of the type of multivariate problem that is  found usually in the biological and social sciences as well as in medicine.  This approach uses a \"logical\"  rather than a \"statistical\" criterion by which variables are grouped into a deterministic model.  Algorithm  are developed by which some variables are kept on for further analysis while others are eliminated.   Criteria for the acceptance of a variable as well as the termination of the searching process are derived  from information theory.", "authors": "Sterling, T. Gleser, M. Haberman, S. Pollack, S.", "words_pool": ["accept", "algorithm", "analysi", "approach", "biolog", "criteria", "criterion", "data", "deriv", "determinist", "develop", "elimin", "found", "group", "inform", "logic", "medicin", "model", "multivari", "outlin", "problem", "problem", "process", "robot", "scienc", "screen", "search", "social", "solut", "statist", "termin", "theori", "type", "variabl", "variabl", "sterl", "gleser", "haberman", "pollack"], "word_count": {"accept": 1, "algorithm": 1, "analysi": 1, "approach": 2, "biolog": 1, "criteria": 1, "criterion": 1, "data": 1, "deriv": 1, "determinist": 1, "develop": 1, "elimin": 1, "found": 1, "group": 1, "inform": 1, "logic": 1, "medicin": 1, "model": 1, "multivari": 1, "outlin": 1, "problem": 1, "process": 1, "robot": 1, "scienc": 1, "screen": 1, "search": 1, "social": 1, "solut": 1, "statist": 1, "termin": 1, "theori": 1, "type": 1, "variabl": 3, "sterl": 1, "gleser": 1, "haberman": 1, "pollack": 1}}, "1399": {"id": "1399", "title": "On Top-to-Bottom Recognition and Left Recursion", "abstract": "A procedure is given for obtaining structural descriptions in a context-free grammar by performing  the recognition according to a strongly equivalent,  left-recursion-freegrammar. The effect of allowing  null strings in the rewriting rules is discussed.", "authors": "Kurki-Suonio, R.", "words_pool": ["accord", "allow", "bottom", "context", "descript", "discuss", "effect", "equival", "free", "freegrammar", "grammar", "left", "null", "obtain", "perform", "procedur", "recognit", "recurs", "rewrit", "rule", "string", "strongli", "structur", "top", "kurki", "suonio"], "word_count": {"accord": 1, "allow": 1, "bottom": 1, "context": 1, "descript": 1, "discuss": 1, "effect": 1, "equival": 1, "free": 1, "freegrammar": 1, "grammar": 1, "left": 1, "null": 1, "obtain": 1, "perform": 1, "procedur": 1, "recognit": 1, "recurs": 1, "rewrit": 1, "rule": 1, "string": 1, "strongli": 1, "structur": 1, "top": 1, "kurki": 1, "suonio": 1}}, "1400": {"id": "1400", "title": "Free-Text Inputs to Utility Routines", "abstract": "Through the use of some rather simple techniques, it is frequently possible to produce a program  which will accept free-text inputs.  The techniques are discussed and related to a general tape manipulation  routine.", "authors": "Blum, R. I.", "words_pool": ["accept", "discuss", "free", "frequent", "gener", "input", "manipul", "produc", "program", "relat", "routin", "routin", "simpl", "tape", "techniqu", "text", "util", "blum"], "word_count": {"accept": 1, "discuss": 1, "free": 1, "frequent": 1, "gener": 1, "input": 1, "manipul": 1, "produc": 1, "program": 1, "relat": 1, "routin": 1, "simpl": 1, "tape": 1, "techniqu": 2, "text": 1, "util": 1, "blum": 1}}, "1401": {"id": "1401", "title": "Quasilinearization and the Calculation of Eigenvalues", "abstract": "Several eigenvalue problems for systems of ordinary differential equations are considered.   They are resolved computationally using the quasilinerization technique, a quadratically convergent  successive approximation scheme related to the Newton-Raphson-Kantorovich method.", "authors": "Bellman, R., Kagiwada, H. Kalaba, R.", "words_pool": ["approxim", "calcul", "comput", "consid", "converg", "differenti", "eigenvalu", "eigenvalu", "equat", "kantorovich", "method", "newton", "ordinari", "problem", "quadrat", "quasilinear", "quasiliner", "raphson", "relat", "resolv", "scheme", "success", "system", "techniqu", "bellman", "kagiwada", "kalaba"], "word_count": {"approxim": 1, "calcul": 1, "comput": 1, "consid": 1, "converg": 1, "differenti": 1, "eigenvalu": 1, "equat": 1, "kantorovich": 1, "method": 1, "newton": 1, "ordinari": 1, "problem": 1, "quadrat": 1, "quasilinear": 1, "quasiliner": 1, "raphson": 1, "relat": 1, "resolv": 1, "scheme": 1, "success": 1, "system": 1, "techniqu": 1, "bellman": 1, "kagiwada": 1, "kalaba": 1}}, "1402": {"id": "1402", "title": "Partial Step Integration", "abstract": "A partial step integration equation is derived for use with the Adams or Adams-Bashforth method  of integration of differential equations.  This method of obtaining functional values at points intermediate  to the integration points yields accuracy comparable to the integration and does not require storing  of additional information as in interpolation methods.", "authors": "Glauz, R. D.", "words_pool": ["accuraci", "adam", "addit", "bashforth", "compar", "deriv", "differenti", "equat", "equat", "function", "inform", "integr", "intermedi", "interpol", "method", "method", "obtain", "partial", "point", "requir", "step", "store", "valu", "yield", "glauz"], "word_count": {"accuraci": 1, "adam": 2, "addit": 1, "bashforth": 1, "compar": 1, "deriv": 1, "differenti": 1, "equat": 2, "function": 1, "inform": 1, "integr": 4, "intermedi": 1, "interpol": 1, "method": 3, "obtain": 1, "partial": 1, "point": 2, "requir": 1, "step": 1, "store": 1, "valu": 1, "yield": 1, "glauz": 1}}, "1403": {"id": "1403", "title": "A Method for Finding the m Smallest Values of a Monotonic Function Defined on Ordered Sets of  Positive Integers", "abstract": "The minimum value of a monotonic increasing function defined on a partially ordered set S is  assumed on the set of minimal points of S.  This observation is used to devise an efficient method for  finding the m smallest functional values of monotonic functions defined on ordered pairs of positive  integers.  The method is easily extended to include monotonic functions defined on ordered n-tuples.   Included is a FORTRAN program which was written to implement the procedure for a certain important case.", "authors": "Sigillito, V. G.", "words_pool": ["assum", "case", "defin", "devis", "easili", "effici", "extend", "find", "fortran", "function", "function", "function", "implement", "import", "includ", "includ", "increas", "integ", "method", "minim", "minimum", "monoton", "observ", "order", "pair", "partial", "point", "posit", "procedur", "program", "set", "set", "smallest", "tupl", "valu", "written", "sigillito"], "word_count": {"assum": 1, "case": 1, "defin": 3, "devis": 1, "easili": 1, "effici": 1, "extend": 1, "find": 1, "fortran": 1, "function": 4, "implement": 1, "import": 1, "includ": 2, "increas": 1, "integ": 1, "method": 2, "minim": 1, "minimum": 1, "monoton": 3, "observ": 1, "order": 3, "pair": 1, "partial": 1, "point": 1, "posit": 1, "procedur": 1, "program": 1, "set": 2, "smallest": 1, "tupl": 1, "valu": 1, "written": 1, "sigillito": 1}}, "1404": {"id": "1404", "title": "Computational Aspects of Multiple Covariance Analysis on a Multifactor Structure", "abstract": "The computational procedure for the analysis of multiple covariance in statistics is discussed  with reference to the analysis of variance.  A special operator calculus developed by Hartly for programming  analysis of variance for multifactor experiments is extended to cover the analysis of covariance.  This  extension is accomplished by utilizing the connection between the analysis of covariance and the analysis  of variance and by introducing a new operator.  The results are illustrated by a numerical example for  analysis of covariance, in which the basic computations are shown to be carried out by an analysis-of-variance  program.", "authors": "Peng, K. C.", "words_pool": ["accomplish", "analysi", "aspect", "basic", "calculu", "carri", "comput", "comput", "connect", "covari", "cover", "develop", "discuss", "experi", "extend", "extens", "hartli", "illustr", "introduc", "multifactor", "multipl", "numer", "oper", "procedur", "program", "program", "refer", "result", "shown", "special", "statist", "structur", "util", "varianc", "peng"], "word_count": {"accomplish": 1, "analysi": 8, "aspect": 1, "basic": 1, "calculu": 1, "carri": 1, "comput": 2, "connect": 1, "covari": 4, "cover": 1, "develop": 1, "discuss": 1, "experi": 1, "extend": 1, "extens": 1, "hartli": 1, "illustr": 1, "introduc": 1, "multifactor": 1, "multipl": 1, "numer": 1, "oper": 2, "procedur": 1, "program": 2, "refer": 1, "result": 1, "shown": 1, "special": 1, "statist": 1, "structur": 1, "util": 1, "varianc": 4, "peng": 1}}, "1405": {"id": "1405", "title": "Matrix Triangulation with Integer Arithmetic (Algorithm 287 [F1])", "authors": "Blankinship, W. A.", "words_pool": ["algorithm", "arithmet", "f1", "integ", "matrix", "triangul", "blankinship"], "word_count": {"algorithm": 1, "arithmet": 1, "f1": 1, "integ": 1, "matrix": 1, "triangul": 1, "blankinship": 1}}, "1406": {"id": "1406", "title": "Solution of simultaneous Linear Diophantine Equations (Algorithm 288 [F4])", "authors": "Blankinship, W. A.", "words_pool": ["algorithm", "diophantin", "equat", "f4", "linear", "simultan", "solut", "blankinship"], "word_count": {"algorithm": 1, "diophantin": 1, "equat": 1, "f4": 1, "linear": 1, "simultan": 1, "solut": 1, "blankinship": 1}}, "1407": {"id": "1407", "title": "Confidence Interval for a Ratio (Algorithm 289 [G1])", "authors": "Hill, I. D. Pike, M. C.", "words_pool": ["algorithm", "confid", "g1", "interv", "ratio", "hill", "pike"], "word_count": {"algorithm": 1, "confid": 1, "g1": 1, "interv": 1, "ratio": 1, "hill": 1, "pike": 1}}, "1408": {"id": "1408", "title": "The Eschenbach Drum Scheme", "abstract": "The prime function of a drum, operating in real time, is to perform accesses quickly.  The  usual means for increasing this capacity is to incorporate engineering or hardware improvements.  In  this paper the problem is attacked not by changing the drum, but rather by modifying the manner in which  it operates.  At the outset, a drum is given a functional definition.  Then a simple design scheme (Eschenbach)  is introduced which enormously increases the rate of accessing for drums so defined.  This is shown to  enable a system to perform a job by employing fewer or less expensive drums.  It is suggested that although  the design scheme has a specific use, the method underlying it has more general applicability.  The question  of the efficacy of the drum scheme is then raised.  To deal with this, a standard of efficiency is developed  in light of realistic real-time circumstances.  The drum scheme is then modelled in a manner which permits  it to be analyzed as a problem in queueing theory.  Thus one is enabled to ascertain whether the drum  scheme is efficient enough for its application.  Again, whereas the analysis of the drum scheme has a  specific use, the methods underlying it have more general applicability.", "authors": "Weingarten, A.", "words_pool": ["access", "access", "analysi", "analyz", "applic", "applic", "ascertain", "attack", "capac", "chang", "circumst", "deal", "defin", "definit", "design", "develop", "drum", "drum", "efficaci", "effici", "effici", "employ", "enabl", "enabl", "engin", "enorm", "eschenbach", "expens", "fewer", "function", "function", "gener", "hardwar", "improv", "incorpor", "increas", "increas", "introduc", "job", "light", "manner", "mean", "method", "method", "model", "modifi", "oper", "oper", "outset", "paper", "perform", "permit", "prime", "problem", "question", "queue", "quickli", "rais", "rate", "real", "realist", "scheme", "shown", "simpl", "specif", "standard", "suggest", "system", "theori", "time", "underli", "usual", "weingarten"], "word_count": {"access": 2, "analysi": 1, "analyz": 1, "applic": 3, "ascertain": 1, "attack": 1, "capac": 1, "chang": 1, "circumst": 1, "deal": 1, "defin": 1, "definit": 1, "design": 2, "develop": 1, "drum": 9, "efficaci": 1, "effici": 2, "employ": 1, "enabl": 2, "engin": 1, "enorm": 1, "eschenbach": 1, "expens": 1, "fewer": 1, "function": 2, "gener": 2, "hardwar": 1, "improv": 1, "incorpor": 1, "increas": 2, "introduc": 1, "job": 1, "light": 1, "manner": 2, "mean": 1, "method": 2, "model": 1, "modifi": 1, "oper": 2, "outset": 1, "paper": 1, "perform": 2, "permit": 1, "prime": 1, "problem": 2, "question": 1, "queue": 1, "quickli": 1, "rais": 1, "rate": 1, "real": 2, "realist": 1, "scheme": 6, "shown": 1, "simpl": 1, "specif": 2, "standard": 1, "suggest": 1, "system": 1, "theori": 1, "time": 2, "underli": 2, "usual": 1, "weingarten": 1}}, "1409": {"id": "1409", "title": "NEBULA: A Digital Computer Using a 20 Mc Glass Delay Line Memory", "abstract": "Oregon State University has designed and constructed a medium-speed serial digital computer  using glass delay lines circulating at 22 Mc as memory.  The design objectives as originally conceived  in a special seminar were: (1) to be a research project in computer design; (2) to be usable as an educational  machine;and (3) to have easily modifiable hardware for basic research in computer systems design.  An  unusual arrangement of information within the 22 Mc memory allows a simple interface with the 340 Kc  arithmetic unit, which results in an effective zero latency time and provides possibilities for an associative  memory.  The arithmetic unit has a command structure similar to large parallel machines, and uses flip-flop  arithmetic and control registers throughout.  All hardware development has been aimed toward the concept  of easy modification, elaborate console controls for effective man-machine interaction and low cost.", "authors": "Boles, J. A. Rux, P. T. Weingarten Jr., F. W.", "words_pool": ["aim", "arithmet", "arrang", "associ", "basic", "circul", "command", "comput", "conceiv", "concept", "consol", "construct", "control", "control", "cost", "delay", "design", "design", "develop", "digit", "easili", "easi", "educ", "effect", "elabor", "flip", "flop", "glass", "hardwar", "inform", "interact", "interfac", "kc", "larg", "latenc", "line", "line", "low", "machin", "machin", "man", "mc", "medium", "memori", "modifi", "modif", "nebula", "object", "oregon", "origin", "parallel", "possibl", "project", "regist", "research", "result", "seminar", "serial", "similar", "simpl", "special", "speed", "state", "structur", "system", "time", "unit", "univers", "unusu", "usabl", "bole", "rux", "weingarten", "jr"], "word_count": {"aim": 1, "arithmet": 3, "arrang": 1, "associ": 1, "basic": 1, "circul": 1, "command": 1, "comput": 3, "conceiv": 1, "concept": 1, "consol": 1, "construct": 1, "control": 2, "cost": 1, "delay": 1, "design": 4, "develop": 1, "digit": 1, "easili": 1, "easi": 1, "educ": 1, "effect": 2, "elabor": 1, "flip": 1, "flop": 1, "glass": 1, "hardwar": 2, "inform": 1, "interact": 1, "interfac": 1, "kc": 1, "larg": 1, "latenc": 1, "line": 1, "low": 1, "machin": 3, "man": 1, "mc": 2, "medium": 1, "memori": 3, "modifi": 1, "modif": 1, "nebula": 1, "object": 1, "oregon": 1, "origin": 1, "parallel": 1, "possibl": 1, "project": 1, "regist": 1, "research": 2, "result": 1, "seminar": 1, "serial": 1, "similar": 1, "simpl": 1, "special": 1, "speed": 1, "state": 1, "structur": 1, "system": 1, "time": 1, "unit": 2, "univers": 1, "unusu": 1, "usabl": 1, "bole": 1, "rux": 1, "weingarten": 1, "jr": 1}}, "1410": {"id": "1410", "title": "Interarrival Statistics for Time Sharing Systems", "abstract": "The optimization of time-shared system performance requires the description of the stochastic  processes governing the user inputs and the program activity.  This paper provides a statistical description  of the user input process in the SDC-ARPA general-purpose Time-Sharing System (TSS).  The input process  is assumed to be stationary, and to be defined by the interarrival time distribution.  The data obtained  appear to justify satisfactorily the common assumption that the interarrival times are serially independent.   The data do not appear to justify, except as a very rough approximation, the usual assumption off an  exponential distribution for interarrival time.  A much more satisfactory approximation to the data can  be obtained with a biphase or triphase hyperexponential distribution.", "authors": "Coffman, E. G. Wood, R. C.", "words_pool": ["activ", "approxim", "arpa", "assum", "assumpt", "biphas", "common", "data", "defin", "descript", "distribut", "exponenti", "gener", "govern", "hyperexponenti", "independ", "input", "input", "interarriv", "justifi", "obtain", "optim", "paper", "perform", "process", "process", "program", "purpos", "requir", "rough", "satisfactorili", "satisfactori", "sdc", "serial", "share", "share", "stationari", "statist", "statist", "stochast", "system", "system", "time", "time", "triphas", "tss", "user", "usual", "coffman", "wood"], "word_count": {"activ": 1, "approxim": 2, "arpa": 1, "assum": 1, "assumpt": 2, "biphas": 1, "common": 1, "data": 3, "defin": 1, "descript": 2, "distribut": 3, "exponenti": 1, "gener": 1, "govern": 1, "hyperexponenti": 1, "independ": 1, "input": 3, "interarriv": 3, "justifi": 2, "obtain": 2, "optim": 1, "paper": 1, "perform": 1, "process": 3, "program": 1, "purpos": 1, "requir": 1, "rough": 1, "satisfactorili": 1, "satisfactori": 1, "sdc": 1, "serial": 1, "share": 2, "stationari": 1, "statist": 1, "stochast": 1, "system": 2, "time": 5, "triphas": 1, "tss": 1, "user": 2, "usual": 1, "coffman": 1, "wood": 1}}, "1411": {"id": "1411", "title": "Comparison of Several Algorithms for Computation of Means, Standard Deviations and Correlation  Coefficients", "abstract": "Several algorithms for computation of basic statistics are compared by their performance on  systematically generated test data.  The statistics calculated were the mean, standard deviation and  correlation coefficient.  For each statistic, the algorithm included the usual computing formulas, correction  due to an accumulated error term, and a recursive computation of the current value of the statistic.   The usual computing formulas were also evaluated in double precision.  Large errors were noted for some  calculation using the usual computing formulas.  The most reliable technique was correction of the initial  estimate by use of an accumulated error term.  To eliminate the need for making two passes on the data,  it was suggested that the initial estimate of the mean be obtained from a subset of the data.", "authors": "Neely, P. M.", "words_pool": ["accumul", "algorithm", "algorithm", "basic", "calcul", "calcul", "coeffici", "coeffici", "compar", "comparison", "comput", "comput", "correct", "correl", "data", "deviat", "deviat", "doubl", "due", "elimin", "error", "error", "estim", "evalu", "formula", "gener", "includ", "initi", "larg", "make", "mean", "mean", "need", "note", "obtain", "pass", "perform", "precis", "recurs", "reliabl", "standard", "statist", "statist", "subset", "suggest", "systemat", "techniqu", "term", "test", "usual", "neeli"], "word_count": {"accumul": 2, "algorithm": 2, "basic": 1, "calcul": 2, "coeffici": 1, "compar": 1, "comparison": 1, "comput": 5, "correct": 2, "correl": 1, "data": 3, "deviat": 1, "doubl": 1, "due": 1, "elimin": 1, "error": 3, "estim": 2, "evalu": 1, "formula": 3, "gener": 1, "includ": 1, "initi": 2, "larg": 1, "make": 1, "mean": 2, "need": 1, "note": 1, "obtain": 1, "pass": 1, "perform": 1, "precis": 1, "recurs": 1, "reliabl": 1, "standard": 1, "statist": 4, "subset": 1, "suggest": 1, "systemat": 1, "techniqu": 1, "term": 2, "test": 1, "usual": 3, "neeli": 1}}, "1412": {"id": "1412", "title": "The Banking Information System Concept", "abstract": "Most large commercial banks have progressed to the  point where their major accounting applications  have been automated and more sophisticated usage of data processing equipment is being sought.  This,  coupled with the availability of equipment well suited to real-time, direct access processing,has led  to development within some banks of the central file of data base approach toward a banking information  system.  The banking information system now serves the two-fold purpose of providing real-time responses  to inquires about individual account stasus and providing more complex combinations of information for  management use.  Both kinds of processing draw upon a common store of data contained in the direct access  central file.  This data base includes indexes which facilitate cross referencing of account information  so that all relationships between bank and customer may be discerned.  In introducing the banking information  system concept, a gradual approach to account cross-referencing and file conversion is most prudent.   Generally, this system must interface with other computer applications already existing within the bank.", "authors": "Head, R. V.", "words_pool": ["access", "account", "account", "applic", "approach", "autom", "avail", "bank", "bank", "bank", "base", "central", "combin", "commerci", "common", "complex", "comput", "concept", "contain", "convers", "coupl", "cross", "custom", "data", "develop", "direct", "discern", "draw", "equip", "exist", "facilit", "fold", "gener", "gradual", "includ", "index", "individu", "inform", "inquir", "interfac", "introduc", "kind", "larg", "led", "major", "manag", "point", "process", "progress", "provid", "prudent", "purpos", "real", "referenc", "relationship", "respons", "serv", "sophist", "sought", "stasu", "store", "suit", "system", "time", "usag", "head"], "word_count": {"access": 2, "account": 4, "applic": 2, "approach": 2, "autom": 1, "avail": 1, "bank": 7, "base": 2, "central": 2, "combin": 1, "commerci": 1, "common": 1, "complex": 1, "comput": 1, "concept": 1, "contain": 1, "convers": 1, "coupl": 1, "cross": 2, "custom": 1, "data": 4, "develop": 1, "direct": 2, "discern": 1, "draw": 1, "equip": 2, "exist": 1, "facilit": 1, "fold": 1, "gener": 1, "gradual": 1, "includ": 1, "index": 1, "individu": 1, "inform": 5, "inquir": 1, "interfac": 1, "introduc": 1, "kind": 1, "larg": 1, "led": 1, "major": 1, "manag": 1, "point": 1, "process": 3, "progress": 1, "provid": 2, "prudent": 1, "purpos": 1, "real": 2, "referenc": 2, "relationship": 1, "respons": 1, "serv": 1, "sophist": 1, "sought": 1, "stasu": 1, "store": 1, "suit": 1, "system": 4, "time": 2, "usag": 1, "head": 1}}, "1413": {"id": "1413", "title": "A Vision of Technology and Education", "abstract": "Educational technology is currently quite fashionable.  Here, as in many other branches or  aspects of technology, changes possible in the next generation or two are now known as ideas, discoveries  or inventions.  The unknown is whether the potential will become the actual and, if so, on what time  scale.  This ignorance stems largely from ignorance about the social response to potential technological  change.  The object of this paper is to present a vision of potential educational technology and to raise  questions about the modes of social response and adaptation likely to be evoked by such a vision.", "authors": "Oettinger, A. G.", "words_pool": ["actual", "adapt", "aspect", "branch", "chang", "discoveri", "educ", "educ", "evok", "fashion", "gener", "idea", "ignor", "invent", "known", "larg", "like", "mode", "object", "paper", "potenti", "present", "question", "rais", "respons", "scale", "social", "stem", "technolog", "technolog", "time", "unknown", "vision", "oetting"], "word_count": {"actual": 1, "adapt": 1, "aspect": 1, "branch": 1, "chang": 1, "discoveri": 1, "educ": 2, "evok": 1, "fashion": 1, "gener": 1, "idea": 1, "ignor": 2, "invent": 1, "known": 1, "larg": 1, "like": 1, "mode": 1, "object": 1, "paper": 1, "potenti": 3, "present": 1, "question": 1, "rais": 1, "respons": 2, "scale": 1, "social": 2, "stem": 1, "technolog": 4, "time": 1, "unknown": 1, "vision": 2, "oetting": 1}}, "1414": {"id": "1414", "title": "Twelve-Row Punched-Card Code for Information Interchange* (Proposed American Standard)", "words_pool": ["american", "card", "code", "inform", "interchang", "propos", "punch", "row", "standard", "twelv"], "word_count": {"american": 1, "card": 1, "code": 1, "inform": 1, "interchang": 1, "propos": 1, "punch": 1, "row": 1, "standard": 1, "twelv": 1}}, "1415": {"id": "1415", "title": "Automatic Derivation of Microsentences", "abstract": "The decomposition of long complex English sentences into shorter kernel-like constituent sentences  (microsentences)has often been suggested as an avenue toward conducting automatic retrieval of natural  language messages.  To explore the prospects of such a step, the authors attempted in 1963 to prepare  a general program for deriving microsentences from longer sentences that had been syntactically analyzed  by the Harvard Multipath Analysis Program.  The basic idea was to extract the subject, verb and object  (if any) of each clause and to reassemble these materials into a grammatical microsentence.  A program  is described in this paper, which was designed to operate on the tree structure output of the analyzer,  and the microsentences that were produced are exhibited.  The authors conclude that while microsentences  of the quality achieved do not open up immediate prospects for improving the performance of automatic  message retrieval systems, they may have practical value in man-machine systems using human monitors  to select the preferred syntactic interpretation of a sentence.", "authors": "Carmody, B. T Jones Jr., P. E.", "words_pool": ["achiev", "analysi", "analyz", "analyz", "attempt", "author", "automat", "avenu", "basic", "claus", "complex", "conclud", "conduct", "constitu", "decomposit", "deriv", "deriv", "design", "english", "exhibit", "explor", "extract", "gener", "grammat", "harvard", "human", "idea", "improv", "interpret", "kernel", "languag", "long", "longer", "machin", "man", "materi", "messag", "messag", "microsent", "microsent", "monitor", "multipath", "natur", "object", "open", "oper", "output", "paper", "perform", "practic", "prefer", "prepar", "produc", "program", "prospect", "qualiti", "reassembl", "retriev", "select", "sentenc", "sentenc", "shorter", "step", "structur", "subject", "suggest", "syntact", "syntact", "system", "tree", "verb", "carmodi", "jone", "jr"], "word_count": {"achiev": 1, "analysi": 1, "analyz": 2, "attempt": 1, "author": 2, "automat": 2, "avenu": 1, "basic": 1, "claus": 1, "complex": 1, "conclud": 1, "conduct": 1, "constitu": 1, "decomposit": 1, "deriv": 1, "design": 1, "english": 1, "exhibit": 1, "explor": 1, "extract": 1, "gener": 1, "grammat": 1, "harvard": 1, "human": 1, "idea": 1, "improv": 1, "interpret": 1, "kernel": 1, "languag": 1, "long": 1, "longer": 1, "machin": 1, "man": 1, "materi": 1, "messag": 2, "microsent": 5, "monitor": 1, "multipath": 1, "natur": 1, "object": 1, "open": 1, "oper": 1, "output": 1, "paper": 1, "perform": 1, "practic": 1, "prefer": 1, "prepar": 1, "produc": 1, "program": 3, "prospect": 2, "qualiti": 1, "reassembl": 1, "retriev": 2, "select": 1, "sentenc": 4, "shorter": 1, "step": 1, "structur": 1, "subject": 1, "suggest": 1, "syntact": 2, "system": 2, "tree": 1, "verb": 1, "carmodi": 1, "jone": 1, "jr": 1}}, "1416": {"id": "1416", "title": "A Fortran Technique for Simplifying Input to Report Generators", "abstract": "Typical report generators allow the production of standard forms when tabulating a magnetic  tape file; the extraction of nonstandard sets of information, with suitable annotation, involves troublesome  forms design.  A method of information extraction involving the calculation of suitable FORTRAN FORMAT  statements, which combats this problem, is described.", "authors": "Cleary, J. G.", "words_pool": ["allow", "annot", "calcul", "combat", "design", "extract", "format", "form", "fortran", "gener", "inform", "input", "involv", "involv", "magnet", "method", "nonstandard", "problem", "product", "report", "set", "simplifi", "standard", "statement", "suitabl", "tabul", "tape", "techniqu", "troublesom", "typic", "cleari"], "word_count": {"allow": 1, "annot": 1, "calcul": 1, "combat": 1, "design": 1, "extract": 2, "format": 1, "form": 2, "fortran": 1, "gener": 1, "inform": 2, "input": 1, "involv": 2, "magnet": 1, "method": 1, "nonstandard": 1, "problem": 1, "product": 1, "report": 1, "set": 1, "simplifi": 1, "standard": 1, "statement": 1, "suitabl": 2, "tabul": 1, "tape": 1, "techniqu": 1, "troublesom": 1, "typic": 1, "cleari": 1}}, "1417": {"id": "1417", "title": "Economies of Scale and the IBM System/360", "abstract": "Cost functions among five System/360 models are analyzed through examinations of instruction  times, program kernels and a \"typical\" instruction mix.  Comparisons are made between the data developed  here and Grosch's Law which seems to be applicable to much of the data.  Sizable economies of scale are  unquestionably present in computing equipment.", "authors": "Solomon Jr., M. B.", "words_pool": ["analyz", "applic", "comparison", "comput", "cost", "data", "develop", "economi", "equip", "examin", "function", "grosch", "ibm", "instruct", "kernel", "law", "made", "mix", "model", "present", "program", "scale", "sizabl", "system", "time", "typic", "unquestion", "solomon", "jr"], "word_count": {"analyz": 1, "applic": 1, "comparison": 1, "comput": 1, "cost": 1, "data": 2, "develop": 1, "economi": 1, "equip": 1, "examin": 1, "function": 1, "grosch": 1, "ibm": 1, "instruct": 2, "kernel": 1, "law": 1, "made": 1, "mix": 1, "model": 1, "present": 1, "program": 1, "scale": 1, "sizabl": 1, "system": 1, "time": 1, "typic": 1, "unquestion": 1, "solomon": 1, "jr": 1}}, "1418": {"id": "1418", "title": "Examination Scheduling (Algorithm 286 [ZH])", "authors": "Peck, J. E. L. Williams, M. R.", "words_pool": ["algorithm", "examin", "schedul", "zh", "peck", "william"], "word_count": {"algorithm": 1, "examin": 1, "schedul": 1, "zh": 1, "peck": 1, "william": 1}}, "1419": {"id": "1419", "title": "Chebyshev Quadrature (Algorithm 279 [D1])", "authors": "Hopgood, F. R. A. Litherland, C.", "words_pool": ["algorithm", "chebyshev", "d1", "quadratur", "hopgood", "litherland"], "word_count": {"algorithm": 1, "chebyshev": 1, "d1": 1, "quadratur": 1, "hopgood": 1, "litherland": 1}}, "1420": {"id": "1420", "title": "A New Uniform Pseudorandom Number Generator", "abstract": "A new multiplicative congruential pseudorandom number generator is discussed, in which the  modulus is the largest prime within accumulator capacity and the multiplier is a primitive root of that  prime.  This generator passes the usual statistical tests and in addition the least significant bits  appear to be as random as the most significant bits-a property which generators having modulus 2^k do  not possess.", "authors": "Hutchinson, D. W.", "words_pool": ["accumul", "addit", "bit", "capac", "congruenti", "discuss", "gener", "gener", "largest", "modulu", "multipl", "multipli", "number", "pass", "possess", "prime", "primit", "properti", "pseudorandom", "random", "root", "signific", "statist", "test", "uniform", "usual", "hutchinson"], "word_count": {"accumul": 1, "addit": 1, "bit": 2, "capac": 1, "congruenti": 1, "discuss": 1, "gener": 3, "largest": 1, "modulu": 2, "multipl": 1, "multipli": 1, "number": 1, "pass": 1, "possess": 1, "prime": 2, "primit": 1, "properti": 1, "pseudorandom": 1, "random": 1, "root": 1, "signific": 2, "statist": 1, "test": 1, "uniform": 1, "usual": 1, "hutchinson": 1}}, "1421": {"id": "1421", "title": "A Contribution to the Development of ALGOL", "abstract": "A programming language similar in many respects to ALGOL 60, but incorporating a large number  of improvements based on six years experience with that language, is described in detail.  Part I consists  of an introduction to the new language and a summary of the changes made to ALGOL 60, together with a  discussion of the motives behind there visions.  Part II is a rigorous definition of the proposed language.   Part III describes a set of proposed standard procedures to be used with the language, including facilities  for input/output.", "authors": "Wirth, N. Hoare, C. A. R.", "words_pool": ["algol", "base", "consist", "contribut", "definit", "describ", "detail", "develop", "discuss", "experi", "facil", "ii", "iii", "improv", "includ", "incorpor", "input", "introduct", "languag", "larg", "made", "motiv", "number", "output", "part", "procedur", "program", "propos", "respect", "rigor", "set", "similar", "standard", "summari", "vision", "year", "wirth", "hoar"], "word_count": {"algol": 2, "base": 1, "consist": 1, "contribut": 1, "definit": 1, "describ": 1, "detail": 1, "develop": 1, "discuss": 1, "experi": 1, "facil": 1, "ii": 1, "iii": 1, "improv": 1, "includ": 1, "incorpor": 1, "input": 1, "introduct": 1, "languag": 5, "larg": 1, "made": 1, "motiv": 1, "number": 1, "output": 1, "part": 3, "procedur": 1, "program": 1, "propos": 2, "respect": 1, "rigor": 1, "set": 1, "similar": 1, "standard": 1, "summari": 1, "vision": 1, "year": 1, "wirth": 1, "hoar": 1}}, "1422": {"id": "1422", "title": "Eleven-Sixteenths Inch Perforated Paper Tape (Proposed American Standard)", "words_pool": ["american", "eleven", "inch", "paper", "perfor", "propos", "sixteenth", "standard", "tape"], "word_count": {"american": 1, "eleven": 1, "inch": 1, "paper": 1, "perfor": 1, "propos": 1, "sixteenth": 1, "standard": 1, "tape": 1}}, "1423": {"id": "1423", "title": "A Simple Algorithm for Computing the Generalized Inverse of a Matrix", "abstract": "The generalized inverse of a matrix is important in analysis because it provides an extension  of the concept of an inverse which applies to all matrices.  It also has many applications in numerical  analysis, but it is not widely used because the existing algorithms are fairly complicated and require  considerable storage space.  A simple extension has been found to the conventional orthogonalization  method for inverting non-singular matrices, which gives the generalized inverse with little extra effort  and with no additional storage requirements.  The algorithm gives the generalized inverse for any m by  n matrix A, including the special case when m+n and A is non-singular and the case when m>n and rank(A)  = n.  In the first case the algorithm gives the ordinary inverse of A.  In the second case the algorithm  yields the ordinary least squares transformation matrix INV(A'A)A' and has the advantage of avoiding  the loss of significance which results in forming the product A'A explicitly.", "authors": "Rust, R. Burrus, W. R. Schneeberger, C.", "words_pool": ["addit", "advantag", "algorithm", "algorithm", "analysi", "applic", "appli", "avoid", "case", "complic", "comput", "concept", "consider", "convent", "effort", "exist", "explicitli", "extens", "extra", "fairli", "form", "found", "gener", "import", "includ", "inv", "invers", "invert", "loss", "matric", "matrix", "method", "non", "numer", "ordinari", "orthogon", "product", "rank", "requir", "requir", "result", "signific", "simpl", "singular", "space", "special", "squar", "storag", "transform", "wide", "yield", "rust", "burru", "schneeberg"], "word_count": {"addit": 1, "advantag": 1, "algorithm": 4, "analysi": 2, "applic": 1, "appli": 1, "avoid": 1, "case": 4, "complic": 1, "comput": 1, "concept": 1, "consider": 1, "convent": 1, "effort": 1, "exist": 1, "explicitli": 1, "extens": 2, "extra": 1, "fairli": 1, "form": 1, "found": 1, "gener": 3, "import": 1, "includ": 1, "inv": 1, "invers": 5, "invert": 1, "loss": 1, "matric": 2, "matrix": 3, "method": 1, "non": 2, "numer": 1, "ordinari": 2, "orthogon": 1, "product": 1, "rank": 1, "requir": 2, "result": 1, "signific": 1, "simpl": 1, "singular": 2, "space": 1, "special": 1, "squar": 1, "storag": 2, "transform": 1, "wide": 1, "yield": 1, "rust": 1, "burru": 1, "schneeberg": 1}}, "1424": {"id": "1424", "title": "Automatic Analysis of Electronic Digital Circuits Using List Processing", "abstract": "A mapping from black diagrams of digital circuits to list structures is described, together  with a list processing program written for the Control Data 3600 which uses this mapping to automatically  carry out circuit analysis.", "authors": "Shalla, L.", "words_pool": ["analysi", "automat", "black", "carri", "circuit", "circuit", "control", "data", "diagram", "digit", "electron", "list", "map", "process", "program", "structur", "written", "shalla"], "word_count": {"analysi": 1, "automat": 1, "black": 1, "carri": 1, "circuit": 2, "control": 1, "data": 1, "diagram": 1, "digit": 1, "electron": 1, "list": 2, "map": 2, "process": 1, "program": 1, "structur": 1, "written": 1, "shalla": 1}}, "1425": {"id": "1425", "title": "Flow Diagrams, Turing Machines And Languages With Only Two Formation Rules", "abstract": "In the first part of the paper, flow diagrams are introduced to represent inter al. mappings  of a set into itself.  Although not every diagram is decomposable into a finite number of given base  diagrams, this becomes true at a semantical level due to a suitable extension of the given set and of  the basic mappings defined in it.  Two normalization methods of flow diagrams are given.  The first has  three base diagrams; the second, only two.  In the second part of the paper, the second method is applied  to the theory of Turing machines.  With every Turing machine provided with a two-way half-tape, there  is associated a similar machine, doing essentially the same job, but working on a tape obtained from  the first one by interspersing alternate blank squares.  The new machine belongs to the family, elsewhere  introduced, generated by composition and iteration from the two machines L and R.  That family is a proper  subfamily of the whole family of Turing machines.", "authors": "Bohm, C. Jacopini, G.", "words_pool": ["al", "altern", "appli", "base", "basic", "belong", "blank", "composit", "decompos", "defin", "diagram", "diagram", "due", "essenti", "extens", "famili", "finit", "flow", "format", "gener", "half", "inter", "interspers", "introduc", "iter", "job", "languag", "level", "machin", "machin", "map", "method", "method", "normal", "number", "obtain", "paper", "part", "proper", "provid", "repres", "rule", "semant", "set", "similar", "squar", "subfamili", "suitabl", "tape", "theori", "true", "ture", "work", "bohm", "jacopini"], "word_count": {"al": 1, "altern": 1, "appli": 1, "base": 2, "basic": 1, "belong": 1, "blank": 1, "composit": 1, "decompos": 1, "defin": 1, "diagram": 5, "due": 1, "essenti": 1, "extens": 1, "famili": 3, "finit": 1, "flow": 2, "format": 1, "gener": 1, "half": 1, "inter": 1, "interspers": 1, "introduc": 2, "iter": 1, "job": 1, "languag": 1, "level": 1, "machin": 6, "map": 2, "method": 2, "normal": 1, "number": 1, "obtain": 1, "paper": 2, "part": 2, "proper": 1, "provid": 1, "repres": 1, "rule": 1, "semant": 1, "set": 2, "similar": 1, "squar": 1, "subfamili": 1, "suitabl": 1, "tape": 2, "theori": 1, "true": 1, "ture": 3, "work": 1, "bohm": 1, "jacopini": 1}}, "1426": {"id": "1426", "title": "A Simulation of Hospital Admission Policy", "abstract": "A study is described which simulates different admission policies of a large specialized hospital.   The objective is to determine better policies for stabilization of admission and census rates while  maintaining a reasonably full hospital.  There types of policies were examined: admission based on percentages  of discharge rates, discharge rates plus or minus a constant, and fixed authorizations independent of  discharge rates.  The last type policy produced more stable simulated results, and when put into practice,  improvements were realized.", "authors": "Smith, W. G. Solomon Jr., M. B.", "words_pool": ["admiss", "author", "base", "censu", "constant", "determin", "discharg", "examin", "fix", "full", "hospit", "improv", "independ", "larg", "maintain", "minu", "object", "percentag", "polici", "polici", "practic", "produc", "put", "rate", "realiz", "reason", "result", "simul", "simul", "simul", "special", "stabil", "stabl", "studi", "type", "type", "smith", "solomon", "jr"], "word_count": {"admiss": 3, "author": 1, "base": 1, "censu": 1, "constant": 1, "determin": 1, "discharg": 3, "examin": 1, "fix": 1, "full": 1, "hospit": 2, "improv": 1, "independ": 1, "larg": 1, "maintain": 1, "minu": 1, "object": 1, "percentag": 1, "polici": 4, "practic": 1, "produc": 1, "put": 1, "rate": 4, "realiz": 1, "reason": 1, "result": 1, "simul": 2, "special": 1, "stabil": 1, "stabl": 1, "studi": 1, "type": 2, "smith": 1, "solomon": 1, "jr": 1}}, "1427": {"id": "1427", "title": "Simulation of Radioisotope Scans by Computer", "abstract": "In radioisotope scanning, a field which is assuming increasing importance in medical diagnosis,  the scan is a two-dimensional pattern made up of dots.  Areas of increased source activity are represented  on the scan by areas of increased dot density.  To study the output of scanners with various characteristics,  a program which simulates radioisotope scans has been written  for a PDP-1 computer with auxiliary disk  storage and cathode ray tube display.  Past and present research using the output of the simulator has  shown the flexibility of the system to be important.  The structure of this program can be useful in  the simulation of the output of any quantum-limited system.", "authors": "Pizer, S. M.", "words_pool": ["activ", "area", "assum", "auxiliari", "cathod", "characterist", "comput", "densiti", "diagnosi", "dimension", "disk", "display", "dot", "dot", "field", "flexibl", "import", "import", "increas", "increas", "limit", "made", "medic", "output", "past", "pattern", "pdp", "present", "program", "quantum", "radioisotop", "ray", "repres", "research", "scan", "scanner", "scan", "scan", "shown", "simul", "simul", "simul", "sourc", "storag", "structur", "studi", "system", "tube", "written", "pizer"], "word_count": {"activ": 1, "area": 2, "assum": 1, "auxiliari": 1, "cathod": 1, "characterist": 1, "comput": 1, "densiti": 1, "diagnosi": 1, "dimension": 1, "disk": 1, "display": 1, "dot": 2, "field": 1, "flexibl": 1, "import": 2, "increas": 3, "limit": 1, "made": 1, "medic": 1, "output": 3, "past": 1, "pattern": 1, "pdp": 1, "present": 1, "program": 2, "quantum": 1, "radioisotop": 2, "ray": 1, "repres": 1, "research": 1, "scan": 4, "scanner": 1, "shown": 1, "simul": 3, "sourc": 1, "storag": 1, "structur": 1, "studi": 1, "system": 2, "tube": 1, "written": 1, "pizer": 1}}, "1428": {"id": "1428", "title": "SHOCK III, A Computer System As an Aid in the Management of Critically III Patients", "abstract": "SHOCK III, an online digital computer system to assist the physician, nurse and paramedical  personnel in monitoring and reporting on critically ill patients, is described.", "authors": "Rockwell Jr., M. A. Shubin, H. Weil, M. H. Meagher, P. F.", "words_pool": ["aid", "assist", "comput", "critic", "digit", "iii", "ill", "manag", "monitor", "nurs", "onlin", "paramed", "patient", "personnel", "physician", "report", "shock", "system", "rockwel", "jr", "shubin", "weil", "meagher"], "word_count": {"aid": 1, "assist": 1, "comput": 1, "critic": 1, "digit": 1, "iii": 1, "ill": 1, "manag": 1, "monitor": 1, "nurs": 1, "onlin": 1, "paramed": 1, "patient": 1, "personnel": 1, "physician": 1, "report": 1, "shock": 1, "system": 1, "rockwel": 1, "jr": 1, "shubin": 1, "weil": 1, "meagher": 1}}, "1429": {"id": "1429", "title": "Matrix Reduction Using the Hungarian Method For The Generation of School Timetables", "abstract": "The application of Kuhn's Hungarian Method to the problem of matrix reduction as needed in  Gotlieb's method for timetable generation is described.  The method is suited to both hand and computer  calculation.  Devices to improve the efficiency of the basic algorithm are discussed.", "authors": "Lions, J.", "words_pool": ["algorithm", "applic", "basic", "calcul", "comput", "devic", "discuss", "effici", "gener", "gotlieb", "hand", "hungarian", "improv", "kuhn", "matrix", "method", "need", "problem", "reduct", "school", "suit", "timet", "timet", "lion"], "word_count": {"algorithm": 1, "applic": 1, "basic": 1, "calcul": 1, "comput": 1, "devic": 1, "discuss": 1, "effici": 1, "gener": 1, "gotlieb": 1, "hand": 1, "hungarian": 1, "improv": 1, "kuhn": 1, "matrix": 1, "method": 3, "need": 1, "problem": 1, "reduct": 1, "school": 1, "suit": 1, "timet": 1, "lion": 1}}, "1430": {"id": "1430", "title": "Multiple Precision Floating-Point Conversion from Decimal-to-Binary and Vice Versa", "abstract": "Decimal-to-binary and binary-to-decimal floating-point conversion is often performed by using  a table of the powers 10^i, (ia positive integer) for converting from base 10 to base 2, and by using  a table of the coefficient of a polynomial approximation of 10^x, (0<=x<1) for converting from base 2  to base 10.  These tables occupy a large storage region in the case of a nonsingle precision conversion.   This paper shows that a single small table suffices for a floating-point conversion from decimal to  binary, and vice versa, in any useful precision.", "authors": "Mancino, O. G.", "words_pool": ["approxim", "base", "binari", "case", "coeffici", "convers", "convert", "decim", "float", "ia", "integ", "larg", "multipl", "nonsingl", "occupi", "paper", "perform", "point", "polynomi", "posit", "power", "precis", "region", "show", "singl", "small", "storag", "suffic", "tabl", "tabl", "versa", "vice", "mancino"], "word_count": {"approxim": 1, "base": 4, "binari": 3, "case": 1, "coeffici": 1, "convers": 3, "convert": 2, "decim": 3, "float": 2, "ia": 1, "integ": 1, "larg": 1, "multipl": 1, "nonsingl": 1, "occupi": 1, "paper": 1, "perform": 1, "point": 2, "polynomi": 1, "posit": 1, "power": 1, "precis": 2, "region": 1, "show": 1, "singl": 1, "small": 1, "storag": 1, "suffic": 1, "tabl": 4, "versa": 1, "vice": 1, "mancino": 1}}, "1431": {"id": "1431", "title": "On a Storage Mapping Function For Data Structures", "abstract": "Some basic facts about certain data structures are reviewed and an efficient algorithm is presented  for constructing a storage mapping function for a structure from the structure's definition.", "authors": "Deuel, P.", "words_pool": ["algorithm", "basic", "construct", "data", "definit", "effici", "fact", "function", "map", "present", "review", "storag", "structur", "structur", "deuel"], "word_count": {"algorithm": 1, "basic": 1, "construct": 1, "data": 1, "definit": 1, "effici": 1, "fact": 1, "function": 1, "map": 1, "present": 1, "review": 1, "storag": 1, "structur": 3, "deuel": 1}}, "1432": {"id": "1432", "title": "Incorporation of Nonstandard Input/Output Devices into FORTRAN Systems", "abstract": "A FORTRAN system may readily be modified to handle input/output with nonstandard media on the  same basis on which it handles the standard media.  This is done by providing a character-handling subroutine  suited to the nonstandard medium and arranged to be called by an otherwise unused output statement type  or unit number. This method was used to control output of alphanumeric information on a digital graph  plotter.", "authors": "Cohn, C. E.", "words_pool": ["alphanumer", "arrang", "basi", "call", "charact", "control", "devic", "digit", "fortran", "graph", "handl", "handl", "handl", "incorpor", "inform", "input", "media", "medium", "method", "modifi", "nonstandard", "number", "output", "plotter", "provid", "readili", "standard", "statement", "subroutin", "suit", "system", "system", "type", "unit", "unus", "cohn"], "word_count": {"alphanumer": 1, "arrang": 1, "basi": 1, "call": 1, "charact": 1, "control": 1, "devic": 1, "digit": 1, "fortran": 1, "graph": 1, "handl": 3, "incorpor": 1, "inform": 1, "input": 1, "media": 2, "medium": 1, "method": 1, "modifi": 1, "nonstandard": 2, "number": 1, "output": 3, "plotter": 1, "provid": 1, "readili": 1, "standard": 1, "statement": 1, "subroutin": 1, "suit": 1, "system": 1, "type": 1, "unit": 1, "unus": 1, "cohn": 1}}, "1433": {"id": "1433", "title": "o cut down this expense, an ever increasing effort is made  to design more efficient algorithms.  This paper is meant to support the effort.  It is attempted to  find some characteristics of the way a pivot column is found.  The number of repetitions of a certain  transfer of data from tape to core memory is considered.  After some simplification, the problem is restated  in a general way.  The generating function of the probability distribution and the moment generating  function of the number of repetitions is found.  Asymptotic formulas are given for the moments using  a result from a paper of S. Narumi [1].  The results may be applied to write very efficient routines  that search for an extreme value in a table.  Formulas provide a means of calculating the computer timings  in this case.", "abstract": "As linear programming models grow bigger and bigger in size, much actual data that must be  memorized is often put on magnetic tape or disk, and consequently there is an improportionality fast  rise in the consumption of computer time", "authors": "Roes, P. B. M.", "words_pool": ["actual", "algorithm", "appli", "asymptot", "attempt", "bigger", "calcul", "case", "characterist", "column", "comput", "consid", "consumpt", "core", "cut", "data", "design", "disk", "distribut", "effici", "effort", "expens", "extrem", "fast", "find", "formula", "found", "function", "gener", "gener", "grow", "improportion", "increas", "linear", "made", "magnet", "mean", "meant", "memor", "memori", "model", "moment", "moment", "narumi", "number", "paper", "pivot", "probabl", "problem", "program", "provid", "put", "repetit", "restat", "result", "result", "rise", "routin", "search", "simplif", "size", "support", "tabl", "tape", "time", "time", "transfer", "write", "roe"], "word_count": {"actual": 1, "algorithm": 1, "appli": 1, "asymptot": 1, "attempt": 1, "bigger": 2, "calcul": 1, "case": 1, "characterist": 1, "column": 1, "comput": 1, "consid": 1, "consumpt": 1, "core": 1, "cut": 1, "data": 1, "design": 1, "disk": 1, "distribut": 1, "effici": 2, "effort": 2, "expens": 1, "extrem": 1, "fast": 1, "find": 1, "formula": 2, "found": 2, "function": 2, "gener": 3, "grow": 1, "improportion": 1, "increas": 1, "linear": 1, "made": 1, "magnet": 1, "mean": 1, "meant": 1, "memor": 1, "memori": 1, "model": 1, "moment": 2, "narumi": 1, "number": 2, "paper": 2, "pivot": 1, "probabl": 1, "problem": 1, "program": 1, "provid": 1, "put": 1, "repetit": 2, "restat": 1, "result": 2, "rise": 1, "routin": 1, "search": 1, "simplif": 1, "size": 1, "support": 1, "tabl": 1, "tape": 1, "time": 1, "transfer": 1, "write": 1, "roe": 1}}, "1434": {"id": "1434", "title": "A Monte Carlo Algorithm for Assigning Students to Classes", "abstract": "A technique of random choice is illustrated by application to the problem of assigning students  to a fixed schedule of courses.  Using the technique it is possible to reduce or eliminate difficulties  that result when a popular section is filled and closed before all students requesting and requiring  it have been scheduled.  The effectiveness of automatic scheduling is retained without loss of the students  privilege of picking favorite instructors.", "authors": "Macon, N. Walker, E. E.", "words_pool": ["algorithm", "applic", "assign", "automat", "carlo", "choic", "class", "close", "cours", "difficulti", "effect", "elimin", "favorit", "fill", "fix", "illustr", "instructor", "loss", "mont", "pick", "popular", "privileg", "problem", "random", "reduc", "request", "requir", "result", "retain", "schedul", "schedul", "schedul", "section", "student", "techniqu", "macon", "walker"], "word_count": {"algorithm": 1, "applic": 1, "assign": 1, "automat": 1, "carlo": 1, "choic": 1, "class": 1, "close": 1, "cours": 1, "difficulti": 1, "effect": 1, "elimin": 1, "favorit": 1, "fill": 1, "fix": 1, "illustr": 1, "instructor": 1, "loss": 1, "mont": 1, "pick": 1, "popular": 1, "privileg": 1, "problem": 1, "random": 1, "reduc": 1, "request": 1, "requir": 1, "result": 1, "retain": 1, "schedul": 3, "section": 1, "student": 3, "techniqu": 2, "macon": 1, "walker": 1}}, "1435": {"id": "1435", "title": "Design of Computer Simulation Experiments for Industrial Systems", "abstract": "The aim of this paper is to provide background information on the existing literature on experimental  design techniques which may be applicable to the design of computer simulation experiments for industrial  systems.  Although major emphasis is placed on analysis of variance techniques, three other techniques  of data analysis are considered-multiple ranking procedures, sequential sampling and spectral analysis.   The paper treats four specific experimental design problems and several techniques for solving them.   The four experimental design problems are: (1) the problem of stochastic convergence, (2) the problem  of factor selection, (3) the problem of motive and (4) the many response problem.", "authors": "Burdick, D. S. Naylor, T. H.", "words_pool": ["aim", "analysi", "applic", "background", "comput", "consid", "converg", "data", "design", "emphasi", "exist", "experiment", "experi", "factor", "industri", "inform", "literatur", "major", "motiv", "multipl", "paper", "problem", "problem", "procedur", "provid", "rank", "respons", "sampl", "select", "sequenti", "simul", "solv", "specif", "spectral", "stochast", "system", "techniqu", "treat", "varianc", "burdick", "naylor"], "word_count": {"aim": 1, "analysi": 3, "applic": 1, "background": 1, "comput": 1, "consid": 1, "converg": 1, "data": 1, "design": 4, "emphasi": 1, "exist": 1, "experiment": 3, "experi": 1, "factor": 1, "industri": 1, "inform": 1, "literatur": 1, "major": 1, "motiv": 1, "multipl": 1, "paper": 2, "problem": 6, "procedur": 1, "provid": 1, "rank": 1, "respons": 1, "sampl": 1, "select": 1, "sequenti": 1, "simul": 1, "solv": 1, "specif": 1, "spectral": 1, "stochast": 1, "system": 1, "techniqu": 4, "treat": 1, "varianc": 1, "burdick": 1, "naylor": 1}}, "1436": {"id": "1436", "title": "Interchange of Two Blocks of Data (Algorithm 284 [K2])", "authors": "Fletcher, W.", "words_pool": ["algorithm", "block", "data", "interchang", "k2", "fletcher"], "word_count": {"algorithm": 1, "block": 1, "data": 1, "interchang": 1, "k2": 1, "fletcher": 1}}, "1437": {"id": "1437", "title": "The Mutual Primal-Dual Method (Algorithm 285 [H])", "authors": "Aird, T. J.", "words_pool": ["algorithm", "dual", "method", "mutual", "primal", "aird"], "word_count": {"algorithm": 1, "dual": 1, "method": 1, "mutual": 1, "primal": 1, "aird": 1}}, "1438": {"id": "1438", "title": "A Method for Locating Zeros of Complex Functions", "abstract": "A method for computing the index, or winding number, is developed and applied to the problem  of finding zeros of functions from the plane into the plane.", "authors": "Cain Jr., G. L.", "words_pool": ["appli", "complex", "comput", "develop", "find", "function", "index", "locat", "method", "number", "plane", "problem", "wind", "zero", "cain", "jr"], "word_count": {"appli": 1, "complex": 1, "comput": 1, "develop": 1, "find": 1, "function": 1, "index": 1, "locat": 1, "method": 1, "number": 1, "plane": 2, "problem": 1, "wind": 1, "zero": 1, "cain": 1, "jr": 1}}, "1439": {"id": "1439", "title": "Mechanization of the Curve Fitting Process: DATAN", "abstract": "A process for fitting a curve to approximate data and the problem it creates for the engineer-programmer  is defined.  An approach has also been defined and a system has been written for the SRU 1107 to mechanize  a major portion of this process.  The techniques developed to accomplish the mechanization are largely  empirical, and are dependent for their information only on the actual data points.", "authors": "Simonsen, R. H. Anketell, D. L.", "words_pool": ["accomplish", "actual", "approach", "approxim", "creat", "curv", "data", "datan", "defin", "depend", "develop", "empir", "engin", "fit", "inform", "larg", "major", "mechan", "mechan", "point", "portion", "problem", "process", "programm", "sru", "system", "techniqu", "written", "simonsen", "anketel"], "word_count": {"accomplish": 1, "actual": 1, "approach": 1, "approxim": 1, "creat": 1, "curv": 1, "data": 2, "datan": 1, "defin": 2, "depend": 1, "develop": 1, "empir": 1, "engin": 1, "fit": 1, "inform": 1, "larg": 1, "major": 1, "mechan": 2, "point": 1, "portion": 1, "problem": 1, "process": 2, "programm": 1, "sru": 1, "system": 1, "techniqu": 1, "written": 1, "simonsen": 1, "anketel": 1}}, "1440": {"id": "1440", "title": "Starting Approximations for Square Root Calculation on IBM System/360", "abstract": "Several starting approximations for square root calculation by Newton's method are presented  in a form to facilitate their use in IBM System/360 square root routines.  These approximations include  several for the range [1/16, 1], which is the interval of primary interest on IBM System/360.", "authors": "Fike, C. T.", "words_pool": ["approxim", "calcul", "facilit", "form", "ibm", "includ", "interest", "interv", "method", "newton", "present", "primari", "rang", "root", "routin", "squar", "start", "system", "fike"], "word_count": {"approxim": 2, "calcul": 1, "facilit": 1, "form": 1, "ibm": 2, "includ": 1, "interest": 1, "interv": 1, "method": 1, "newton": 1, "present": 1, "primari": 1, "rang": 1, "root": 2, "routin": 1, "squar": 2, "start": 1, "system": 2, "fike": 1}}, "1441": {"id": "1441", "title": "Methods of Numerical Integration Applied to a System Having Trivial Function Evaluations", "abstract": "A study has been made to determine which methods of numerical integration require the least  computation time for a given amount of truncation error when applied to a particular system of ordinary  differential equations where function evaluations are relatively trivial.  Recent methods due to Butcher  and Gear are compared with classic Runge-Kutta, Kutta-Nystrom and Adams methods.  Some of the newer one-step  methods due to Butcher are found to be slightly superior, but no one method is found to have any great  advantage over the others in the application to this particular problem.", "authors": "Waters, J.", "words_pool": ["adam", "advantag", "amount", "applic", "appli", "butcher", "classic", "compar", "comput", "determin", "differenti", "due", "equat", "error", "evalu", "found", "function", "gear", "great", "integr", "kutta", "made", "method", "method", "newer", "numer", "nystrom", "ordinari", "problem", "recent", "requir", "rung", "slightli", "step", "studi", "superior", "system", "time", "trivial", "truncat", "water"], "word_count": {"adam": 1, "advantag": 1, "amount": 1, "applic": 1, "appli": 1, "butcher": 2, "classic": 1, "compar": 1, "comput": 1, "determin": 1, "differenti": 1, "due": 2, "equat": 1, "error": 1, "evalu": 1, "found": 2, "function": 1, "gear": 1, "great": 1, "integr": 1, "kutta": 2, "made": 1, "method": 5, "newer": 1, "numer": 1, "nystrom": 1, "ordinari": 1, "problem": 1, "recent": 1, "requir": 1, "rung": 1, "slightli": 1, "step": 1, "studi": 1, "superior": 1, "system": 1, "time": 1, "trivial": 1, "truncat": 1, "water": 1}}, "1442": {"id": "1442", "title": "Recorded Magnetic Tape For Information Interchange (800 CPI, NRZI)* (Proposed American Standard)", "words_pool": ["american", "cpi", "inform", "interchang", "magnet", "nrzi", "propos", "record", "standard", "tape"], "word_count": {"american": 1, "cpi": 1, "inform": 1, "interchang": 1, "magnet": 1, "nrzi": 1, "propos": 1, "record": 1, "standard": 1, "tape": 1}}, "1443": {"id": "1443", "title": "A Method for Finding the Least Squares Estimate of the Intersection Point of Two Helices in Space", "abstract": "When the helical trajectories of two charged particles moving away from a common point in a  magnetic field are reconstructed from measurements on the tracks, the reconstructed tracks are perturbed  by measurement and other errors and do not, in general, intersect.  A method is given for adjusting the  reconstructed tracks in a least squares manner so that they do intersect.", "authors": "Royston, R. J. Gregory, J.", "words_pool": ["adjust", "charg", "common", "error", "estim", "field", "find", "gener", "helic", "helic", "intersect", "intersect", "magnet", "manner", "measur", "measur", "method", "move", "particl", "perturb", "point", "reconstruct", "space", "squar", "track", "trajectori", "royston", "gregori"], "word_count": {"adjust": 1, "charg": 1, "common": 1, "error": 1, "estim": 1, "field": 1, "find": 1, "gener": 1, "helic": 1, "intersect": 2, "magnet": 1, "manner": 1, "measur": 2, "method": 1, "move": 1, "particl": 1, "perturb": 1, "point": 1, "reconstruct": 3, "space": 1, "squar": 1, "track": 3, "trajectori": 1, "royston": 1, "gregori": 1}}, "1444": {"id": "1444", "title": "An Algorithm for Generating Projective Reduction Formulas for Matrix Elements of Many-Electron  Wavefunctions", "abstract": "An ALGOL procedure is given for automatically generating formulas for matrix elements arising  in the variational solution of the Schrodinger equation for many-electron systems.", "authors": "Reeves, C. M.", "words_pool": ["algol", "algorithm", "aris", "electron", "element", "equat", "formula", "gener", "matrix", "procedur", "project", "reduct", "schroding", "solut", "system", "variat", "wavefunct", "reev"], "word_count": {"algol": 1, "algorithm": 1, "aris": 1, "electron": 1, "element": 1, "equat": 1, "formula": 1, "gener": 1, "matrix": 1, "procedur": 1, "project": 1, "reduct": 1, "schroding": 1, "solut": 1, "system": 1, "variat": 1, "wavefunct": 1, "reev": 1}}, "1445": {"id": "1445", "title": "Use of the Computer to Teach Introductory Statistics", "abstract": "It has always been obvious that the aid to calculation offered by the computer forces a change  in the curricula of mathematics, statistics, physics, engineering and other courses.  Not so obvious  are the many pedagogic aids the computer can offer in teaching the subject matter.  The possibilities  of giving the student a better technical as well as conceptual understanding of statistics were explored  for a number of years at the College of Medicine of the University of Cincinnati and are reported here.", "authors": "Sterling, T. D. Pollack, S. V.", "words_pool": ["aid", "aid", "calcul", "chang", "cincinnati", "colleg", "comput", "conceptu", "cours", "curricula", "engin", "explor", "forc", "give", "introductori", "mathemat", "matter", "medicin", "number", "obviou", "offer", "offer", "pedagog", "physic", "possibl", "report", "statist", "student", "subject", "teach", "teach", "technic", "understand", "univers", "year", "sterl", "pollack"], "word_count": {"aid": 2, "calcul": 1, "chang": 1, "cincinnati": 1, "colleg": 1, "comput": 2, "conceptu": 1, "cours": 1, "curricula": 1, "engin": 1, "explor": 1, "forc": 1, "give": 1, "introductori": 1, "mathemat": 1, "matter": 1, "medicin": 1, "number": 1, "obviou": 2, "offer": 2, "pedagog": 1, "physic": 1, "possibl": 1, "report": 1, "statist": 2, "student": 1, "subject": 1, "teach": 1, "technic": 1, "understand": 1, "univers": 1, "year": 1, "sterl": 1, "pollack": 1}}, "1446": {"id": "1446", "title": "Chebyshev Quadrature (Algorithm 279 [D1])", "authors": "Hopgood, F. R. A. Litherland, C.", "words_pool": ["algorithm", "chebyshev", "d1", "quadratur", "hopgood", "litherland"], "word_count": {"algorithm": 1, "chebyshev": 1, "d1": 1, "quadratur": 1, "hopgood": 1, "litherland": 1}}, "1447": {"id": "1447", "title": "Abscissas and Weights for Gregory Quadrature [D1])", "authors": "Welsch, J. H.", "words_pool": ["abscissa", "d1", "gregori", "quadratur", "weight", "welsch"], "word_count": {"abscissa": 1, "d1": 1, "gregori": 1, "quadratur": 1, "weight": 1, "welsch": 1}}, "1448": {"id": "1448", "title": "Abscissas and Weights for Romberg Quadrature (Algorithm 281 [D1])", "authors": "Welsch, J. H.", "words_pool": ["abscissa", "algorithm", "d1", "quadratur", "romberg", "weight", "welsch"], "word_count": {"abscissa": 1, "algorithm": 1, "d1": 1, "quadratur": 1, "romberg": 1, "weight": 1, "welsch": 1}}, "1449": {"id": "1449", "title": "Derivatives (Algorithm 282 [S22])", "authors": "Gautschi, W.", "words_pool": ["algorithm", "deriv", "s22", "gautschi"], "word_count": {"algorithm": 1, "deriv": 1, "s22": 1, "gautschi": 1}}, "1450": {"id": "1450", "title": "Simultaneous Displacement of Polynomial Roots if Real and Simple (Algorithm 283 [C2])", "authors": "Kerner, I. O.", "words_pool": ["algorithm", "c2", "displac", "polynomi", "real", "root", "simpl", "simultan", "kerner"], "word_count": {"algorithm": 1, "c2": 1, "displac": 1, "polynomi": 1, "real": 1, "root": 1, "simpl": 1, "simultan": 1, "kerner": 1}}, "1451": {"id": "1451", "title": "Runge-Kutta Integration (Algorithm 9 [D2])", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "d2", "integr", "kutta", "rung", "thacher", "jr"], "word_count": {"algorithm": 1, "d2": 1, "integr": 1, "kutta": 1, "rung": 1, "thacher": 1, "jr": 1}}, "1452": {"id": "1452", "title": "Kutta-Merson (Algorithm 218 [D2]", "authors": "Bayer, G.", "words_pool": ["algorithm", "d2", "kutta", "merson", "bayer"], "word_count": {"algorithm": 1, "d2": 1, "kutta": 1, "merson": 1, "bayer": 1}}, "1453": {"id": "1453", "title": "A Nonrecursive Method of Syntax Specification", "abstract": "The use of the Kleene regular expression notation for describing algebraic language syntax,  in particular of ALGOL, is described in this paper.  A FORTRAN II computer program for carrying out the  elimination algorithm of Gorn,similar to Gaussian elimination for linear systems of algebraic equations,  is described.  This was applied to numerous smaller languages, including some sublanguage of ALGOL.   A hand calculation result of the application of the algorithm to all of ALGOL is given, thus expressing  the Revised ALGOL 1960 syntax in completely nonrecursive terms, as far as its context-free portion is  concerned.  This description in many ways is far more intuitively understood than the previous recursive  description, it is suggested.  The paper also includes results of the machine program, which does not  include a simplification algorithm.", "authors": "Carr III, J. W. Weiland, J.", "words_pool": ["algebra", "algol", "algorithm", "applic", "appli", "calcul", "carri", "complet", "comput", "concern", "context", "describ", "descript", "elimin", "equat", "express", "express", "fortran", "free", "gaussian", "gorn", "hand", "ii", "includ", "includ", "includ", "intuit", "kleen", "languag", "languag", "linear", "machin", "method", "nonrecurs", "notat", "numer", "paper", "portion", "previou", "program", "recurs", "regular", "result", "result", "revis", "similar", "simplif", "smaller", "specif", "sublanguag", "suggest", "syntax", "system", "term", "understood", "way", "carr", "iii", "weiland"], "word_count": {"algebra": 2, "algol": 4, "algorithm": 3, "applic": 1, "appli": 1, "calcul": 1, "carri": 1, "complet": 1, "comput": 1, "concern": 1, "context": 1, "describ": 1, "descript": 2, "elimin": 2, "equat": 1, "express": 2, "fortran": 1, "free": 1, "gaussian": 1, "gorn": 1, "hand": 1, "ii": 1, "includ": 3, "intuit": 1, "kleen": 1, "languag": 2, "linear": 1, "machin": 1, "method": 1, "nonrecurs": 1, "notat": 1, "numer": 1, "paper": 2, "portion": 1, "previou": 1, "program": 2, "recurs": 1, "regular": 1, "result": 2, "revis": 1, "similar": 1, "simplif": 1, "smaller": 1, "specif": 1, "sublanguag": 1, "suggest": 1, "syntax": 2, "system": 1, "term": 1, "understood": 1, "way": 1, "carr": 1, "iii": 1, "weiland": 1}}, "1454": {"id": "1454", "title": "A Simple User-Oriented Compiler Source Language for Programming Automatic Test Equipment", "abstract": "For the nonprogrammer, difficulty in using a language increases rapidly with the number of  nonproblem-oriented conventions.  A simple language, even if inelegant, which considers the user's background  as part of the problem may be more effective than a source language containing subtle and more powerful  capabilities.  The language described in this paper is used to write computer programs which test electronic  equipment.  Because this testing process contains few complex ideas, there is little need for the elegance  and redundancy of a highly syntax-oriented language.  A simple and direct language will suffice for the  problem.  The eventual users of this language are military depot personnel who cannot he expected to  have computer programming skill or significant programming training.  For this nonprogramming-oriented  user, it was essential to create a language using familiar engineering statements; programming-oriented  conventions would have unnecessarily complicated his task.", "authors": "Scheff, B. H.", "words_pool": ["automat", "background", "capabl", "compil", "complex", "complic", "comput", "consid", "convent", "creat", "depot", "difficulti", "direct", "effect", "electron", "eleg", "engin", "equip", "essenti", "eventu", "expect", "familiar", "highli", "idea", "increas", "ineleg", "languag", "militari", "need", "nonproblem", "nonprogramm", "nonprogram", "number", "orient", "paper", "part", "personnel", "power", "problem", "process", "program", "program", "rapidli", "redund", "signific", "simpl", "skill", "sourc", "statement", "subtl", "suffic", "syntax", "task", "test", "test", "train", "unnecessarili", "user", "user", "write", "scheff"], "word_count": {"automat": 1, "background": 1, "capabl": 1, "compil": 1, "complex": 1, "complic": 1, "comput": 2, "consid": 1, "convent": 2, "creat": 1, "depot": 1, "difficulti": 1, "direct": 1, "effect": 1, "electron": 1, "eleg": 1, "engin": 1, "equip": 1, "essenti": 1, "eventu": 1, "expect": 1, "familiar": 1, "highli": 1, "idea": 1, "increas": 1, "ineleg": 1, "languag": 8, "militari": 1, "need": 1, "nonproblem": 1, "nonprogramm": 1, "nonprogram": 1, "number": 1, "orient": 4, "paper": 1, "part": 1, "personnel": 1, "power": 1, "problem": 2, "process": 1, "program": 4, "rapidli": 1, "redund": 1, "signific": 1, "simpl": 2, "skill": 1, "sourc": 1, "statement": 1, "subtl": 1, "suffic": 1, "syntax": 1, "task": 1, "test": 2, "train": 1, "unnecessarili": 1, "user": 3, "write": 1, "scheff": 1}}, "1455": {"id": "1455", "title": "TRAC, A Procedure-Describing Language for the Reactive Typewriter", "abstract": "A description of the TRAC (Text Reckoning And Compiling) language and processing algorithm  is given.  The TRAC language was developed as the basis of a software package for the reactive typewriter.   In the TRAC language, one can write procedures for accepting, naming and storing any character string  from the typewriter; for modifying any string in any way; for treating any string at any time as an executable  procedure, or as a name, or as text; and for printing out any string.  The TRAC language is based upon  an extension and generalization to character strings of the programming concept of the \"macro.\"  Through  the ability of TRAC to accept and store definitions of procedures, the capabilities of the language can  be indefinitely extended, and can deal with character strings, integers and Boolean vector variables.", "authors": "Mooers, C. N.", "words_pool": ["abil", "accept", "accept", "algorithm", "base", "basi", "boolean", "capabl", "charact", "compil", "concept", "deal", "definit", "describ", "descript", "develop", "execut", "extend", "extens", "gener", "indefinit", "integ", "languag", "macro", "modifi", "name", "packag", "print", "procedur", "procedur", "process", "program", "reactiv", "reckon", "softwar", "store", "store", "string", "string", "text", "time", "trac", "treat", "typewrit", "variabl", "vector", "write", "mooer"], "word_count": {"abil": 1, "accept": 2, "algorithm": 1, "base": 1, "basi": 1, "boolean": 1, "capabl": 1, "charact": 3, "compil": 1, "concept": 1, "deal": 1, "definit": 1, "describ": 1, "descript": 1, "develop": 1, "execut": 1, "extend": 1, "extens": 1, "gener": 1, "indefinit": 1, "integ": 1, "languag": 5, "macro": 1, "modifi": 1, "name": 1, "packag": 1, "print": 1, "procedur": 3, "process": 1, "program": 1, "reactiv": 1, "reckon": 1, "softwar": 1, "store": 2, "string": 6, "text": 2, "time": 1, "trac": 5, "treat": 1, "typewrit": 2, "variabl": 1, "vector": 1, "write": 1, "mooer": 1}}, "1456": {"id": "1456", "title": "Storage and Retrieval of Aspects of Meaning in Directed Graph Structures", "abstract": "An experimental system that uses LISP to make a conceptual dictionary is described.  The dictionary  associates with each English word the syntactic information, definitional material, and references to  the contexts in which it has been used to define other words.  Such relations as class inclusion, possession,  and active or passive actions are used as definitional material.  The resulting structure serves as a  powerful vehicle for research on the logic of question answering.  Examples of methods of inputting information  and answering simple English questions are given.  An important conclusion is that, although LISP and  other list processing languages are ideally suited for producing complex associative structures, they  are inadequate vehicles for language processing on any large scale-at east until they can use auxiliary  memory as a continuous extension of core memory.", "authors": "Simmons, R. F.", "words_pool": ["action", "activ", "answer", "aspect", "associ", "associ", "auxiliari", "class", "complex", "conceptu", "conclus", "context", "continu", "core", "defin", "definit", "dictionari", "direct", "east", "english", "exampl", "experiment", "extens", "graph", "ideal", "import", "inadequ", "inclus", "inform", "input", "languag", "languag", "larg", "lisp", "list", "logic", "make", "materi", "mean", "memori", "method", "passiv", "possess", "power", "process", "produc", "question", "question", "refer", "relat", "research", "result", "retriev", "scale", "serv", "simpl", "storag", "structur", "structur", "suit", "syntact", "system", "vehicl", "vehicl", "word", "word", "simmon"], "word_count": {"action": 1, "activ": 1, "answer": 2, "aspect": 1, "associ": 2, "auxiliari": 1, "class": 1, "complex": 1, "conceptu": 1, "conclus": 1, "context": 1, "continu": 1, "core": 1, "defin": 1, "definit": 2, "dictionari": 2, "direct": 1, "east": 1, "english": 2, "exampl": 1, "experiment": 1, "extens": 1, "graph": 1, "ideal": 1, "import": 1, "inadequ": 1, "inclus": 1, "inform": 2, "input": 1, "languag": 2, "larg": 1, "lisp": 2, "list": 1, "logic": 1, "make": 1, "materi": 2, "mean": 1, "memori": 2, "method": 1, "passiv": 1, "possess": 1, "power": 1, "process": 2, "produc": 1, "question": 2, "refer": 1, "relat": 1, "research": 1, "result": 1, "retriev": 1, "scale": 1, "serv": 1, "simpl": 1, "storag": 1, "structur": 2, "suit": 1, "syntact": 1, "system": 1, "vehicl": 2, "word": 2, "simmon": 1}}, "1457": {"id": "1457", "title": "Data Manipulation and Programming Problems in Automatic Information Retrieval", "abstract": "Automatic information retrieval programs require the manipulation of a variety of different  data structures, including linear text, sparse matrices, and tree or list structures.  The main data  manipulations to be performed in automatic information systems are first briefly reviewed.  A variety  of data representations which have been used to describe structured information are then examined, and  the characteristics of various processing languages are outlined in the light of the procedures requiring  implementation.  Advantages of these programming languages for the retrieval application are examined,  and suggestions are made for the design of programming facilities to aid in information retrieval.", "authors": "Salton, G.", "words_pool": ["advantag", "aid", "applic", "automat", "briefli", "characterist", "data", "describ", "design", "examin", "facil", "implement", "includ", "inform", "languag", "light", "linear", "list", "made", "main", "manipul", "manipul", "matric", "outlin", "perform", "problem", "procedur", "process", "program", "program", "represent", "requir", "requir", "retriev", "review", "spars", "structur", "structur", "suggest", "system", "text", "tree", "varieti", "salton"], "word_count": {"advantag": 1, "aid": 1, "applic": 1, "automat": 2, "briefli": 1, "characterist": 1, "data": 3, "describ": 1, "design": 1, "examin": 2, "facil": 1, "implement": 1, "includ": 1, "inform": 4, "languag": 2, "light": 1, "linear": 1, "list": 1, "made": 1, "main": 1, "manipul": 2, "matric": 1, "outlin": 1, "perform": 1, "problem": 1, "procedur": 1, "process": 1, "program": 3, "represent": 1, "requir": 2, "retriev": 3, "review": 1, "spars": 1, "structur": 3, "suggest": 1, "system": 1, "text": 1, "tree": 1, "varieti": 2, "salton": 1}}, "1458": {"id": "1458", "title": "Online Programming", "abstract": "When the transition has been made from off line to online programming, there are a number of  changes in the working conditions noted.  These changes in the environment make necessary corresponding  changes in the processes related to producing and checking out programs.  In the main, it it not the  programming language itself which must be changed to provide a facility for the online user; it is the  system surrounding the programming language.  In this paper the online environment and its effect on  programming are discussed.", "authors": "Schwartz, J. I.", "words_pool": ["chang", "check", "condit", "discuss", "effect", "environ", "facil", "languag", "line", "made", "main", "make", "note", "number", "onlin", "paper", "process", "produc", "program", "program", "provid", "relat", "surround", "system", "transit", "user", "work", "schwartz"], "word_count": {"chang": 1, "check": 1, "condit": 1, "discuss": 1, "effect": 1, "environ": 2, "facil": 1, "languag": 2, "line": 1, "made": 1, "main": 1, "make": 1, "note": 1, "number": 1, "onlin": 3, "paper": 1, "process": 1, "produc": 1, "program": 5, "provid": 1, "relat": 1, "surround": 1, "system": 1, "transit": 1, "user": 1, "work": 1, "schwartz": 1}}, "1459": {"id": "1459", "title": "Requirements for Real-Time Languages", "abstract": "Real-time languages have different requirements from other programming languages because of  the special nature of their applications, the environment in which their object programs are executed  and the environment in which they may be compiled.  It may not be the language extensions that ultimately  advance developments in the field.  Progress may be made by attacking the special compiling and executing  system problems that must be solved.", "authors": "Opler, A.", "words_pool": ["advanc", "applic", "attack", "compil", "compil", "develop", "environ", "execut", "execut", "extens", "field", "languag", "languag", "made", "natur", "object", "problem", "program", "program", "progress", "real", "requir", "solv", "special", "system", "time", "ultim", "opler"], "word_count": {"advanc": 1, "applic": 1, "attack": 1, "compil": 2, "develop": 1, "environ": 2, "execut": 2, "extens": 1, "field": 1, "languag": 3, "made": 1, "natur": 1, "object": 1, "problem": 1, "program": 2, "progress": 1, "real": 1, "requir": 1, "solv": 1, "special": 2, "system": 1, "time": 1, "ultim": 1, "opler": 1}}, "1460": {"id": "1460", "title": "Evolution of the Meta-Assembly Program", "abstract": "A generalized assembler called a \"meta-assembler\" is described.  The meta-assembler is defined  and factors which contributed to its evolution are presented.  How a meta-assembler is made to function  as an assembly program is described. Finally, the implication of meta-assemblers on compiler design is  discussed.", "authors": "Ferguson, D. E.", "words_pool": ["assembl", "assembl", "assembl", "call", "compil", "contribut", "defin", "design", "discuss", "evolut", "factor", "final", "function", "gener", "implic", "made", "meta", "present", "program", "ferguson"], "word_count": {"assembl": 6, "call": 1, "compil": 1, "contribut": 1, "defin": 1, "design": 1, "discuss": 1, "evolut": 1, "factor": 1, "final": 1, "function": 1, "gener": 1, "implic": 1, "made": 1, "meta": 4, "present": 1, "program": 1, "ferguson": 1}}, "1461": {"id": "1461", "title": "Discussion Summary on Operating Systems", "words_pool": ["discuss", "oper", "summari", "system"], "word_count": {"discuss": 1, "oper": 1, "summari": 1, "system": 1}}, "1462": {"id": "1462", "title": "Multilevel Operating Systems", "abstract": "The Basic software for all newer computers is built on the well-established need for standard  operating systems. This implies that all applications-no matter how large, complex or time consuming-must  operate under (or, more precisely, on top of) the standard system.  Large applications require supervisory  monitors which handle problems similar to those of the operating systems, but at a different level.   Sometimes, still a third or even a fourth such level is required or desirable.  This leads naturally  to the concept of multilevel systems-similar vertically, but different horizontally.  Proper division  of responsibility between levels leads to greater efficiency and less logical complexity, while actually  enhancing capability.", "authors": "Orchard-Hays, W.", "words_pool": ["actual", "applic", "basic", "built", "capabl", "complex", "complex", "comput", "concept", "consum", "desir", "divis", "effici", "enhanc", "establish", "fourth", "greater", "handl", "horizont", "impli", "larg", "lead", "level", "level", "logic", "matter", "monitor", "multilevel", "natur", "need", "newer", "oper", "oper", "precis", "problem", "proper", "requir", "requir", "respons", "similar", "softwar", "standard", "supervisori", "system", "system", "time", "top", "vertic", "orchard", "hay"], "word_count": {"actual": 1, "applic": 2, "basic": 1, "built": 1, "capabl": 1, "complex": 2, "comput": 1, "concept": 1, "consum": 1, "desir": 1, "divis": 1, "effici": 1, "enhanc": 1, "establish": 1, "fourth": 1, "greater": 1, "handl": 1, "horizont": 1, "impli": 1, "larg": 2, "lead": 2, "level": 3, "logic": 1, "matter": 1, "monitor": 1, "multilevel": 1, "natur": 1, "need": 1, "newer": 1, "oper": 3, "precis": 1, "problem": 1, "proper": 1, "requir": 2, "respons": 1, "similar": 2, "softwar": 1, "standard": 2, "supervisori": 1, "system": 4, "time": 1, "top": 1, "vertic": 1, "orchard": 1, "hay": 1}}, "1463": {"id": "1463", "title": "More on Extensible Machines", "abstract": "One of the most salient characteristics of extensible machines (EM) is the facility for providing  system control over program-to-program and program-to-data linkage (e.g., address connection).  It is  the intent of this paper to expand and clarify the remarks concerning program-to-program and program-to-data  linkage that were embodied in the authors' previous paper on the EM concepts, and to, finally, trace  the employment of linkage mechanisms through various levels of programming languages.", "authors": "Leonard, G. F. Goodroe, J. R.", "words_pool": ["address", "author", "characterist", "clarifi", "concept", "concern", "connect", "control", "data", "em", "embodi", "employ", "expand", "extens", "facil", "final", "intent", "languag", "level", "linkag", "machin", "mechan", "paper", "previou", "program", "program", "provid", "remark", "salient", "system", "trace", "leonard", "goodro"], "word_count": {"address": 1, "author": 1, "characterist": 1, "clarifi": 1, "concept": 1, "concern": 1, "connect": 1, "control": 1, "data": 2, "em": 2, "embodi": 1, "employ": 1, "expand": 1, "extens": 1, "facil": 1, "final": 1, "intent": 1, "languag": 1, "level": 1, "linkag": 3, "machin": 1, "mechan": 1, "paper": 2, "previou": 1, "program": 7, "provid": 1, "remark": 1, "salient": 1, "system": 1, "trace": 1, "leonard": 1, "goodro": 1}}, "1464": {"id": "1464", "title": "An ALGOL Compiler: Construction and Use in Relation to an Elaborate Operating System", "abstract": "An ALGOL translator has been prepared and integrated into the IBSYS Operating System.  Assembly  and \"go\" features of IBSYS permit immediate execution with optional listings, decks and debugging information.   Using the chain feature of IBSYS, links written in MAP or FORTRAN as well as ALGOL may be called by  the ALGOL main program.  In addition, procedures coded in MAP may be included in any ALGOL program.   Although assembly plus loading time exceeds compilation time, the total time is satisfactory and the  user gets ease and facility which are fully compensating.", "authors": "Boussard, J. C.", "words_pool": ["addit", "algol", "assembl", "call", "chain", "code", "compens", "compil", "compil", "construct", "debug", "deck", "eas", "elabor", "exce", "execut", "facil", "featur", "featur", "fortran", "fulli", "ibsi", "includ", "inform", "integr", "link", "list", "load", "main", "map", "oper", "option", "permit", "prepar", "procedur", "program", "relat", "satisfactori", "system", "time", "total", "translat", "user", "written", "boussard"], "word_count": {"addit": 1, "algol": 4, "assembl": 2, "call": 1, "chain": 1, "code": 1, "compens": 1, "compil": 1, "construct": 1, "debug": 1, "deck": 1, "eas": 1, "elabor": 1, "exce": 1, "execut": 1, "facil": 1, "featur": 2, "fortran": 1, "fulli": 1, "ibsi": 3, "includ": 1, "inform": 1, "integr": 1, "link": 1, "list": 1, "load": 1, "main": 1, "map": 2, "oper": 1, "option": 1, "permit": 1, "prepar": 1, "procedur": 1, "program": 2, "relat": 1, "satisfactori": 1, "system": 1, "time": 3, "total": 1, "translat": 1, "user": 1, "written": 1, "boussard": 1}}, "1465": {"id": "1465", "title": "Program Translation Viewed as a General Data Processing Problem", "abstract": "Efficiency dictates that the overall effectiveness of a compiler be increased by all means  available.  For a compiler to have a substantial useful life it needs a clear logical structure, reliability  and sound data processing techniques.  A compiler must be based on fixed conventions to preserve efficiency  and reliability; empty options and default conventions violate this dictum.  Use of structure to associate  various parts of a program and economy of features promote clarity and reliability.", "authors": "Naur, P.", "words_pool": ["associ", "base", "clariti", "clear", "compil", "convent", "data", "default", "dictat", "dictum", "economi", "effect", "effici", "empti", "featur", "fix", "gener", "increas", "life", "logic", "mean", "need", "option", "part", "preserv", "problem", "process", "program", "promot", "reliabl", "sound", "structur", "substanti", "techniqu", "translat", "view", "violat", "naur"], "word_count": {"associ": 1, "base": 1, "clariti": 1, "clear": 1, "compil": 3, "convent": 2, "data": 1, "default": 1, "dictat": 1, "dictum": 1, "economi": 1, "effect": 1, "effici": 2, "empti": 1, "featur": 1, "fix": 1, "gener": 1, "increas": 1, "life": 1, "logic": 1, "mean": 1, "need": 1, "option": 1, "part": 1, "preserv": 1, "problem": 1, "process": 1, "program": 1, "promot": 1, "reliabl": 3, "sound": 1, "structur": 2, "substanti": 1, "techniqu": 1, "translat": 1, "view": 1, "violat": 1, "naur": 1}}, "1466": {"id": "1466", "title": "Discussion Summary on Graphical Languages", "words_pool": ["discuss", "graphic", "languag", "summari"], "word_count": {"discuss": 1, "graphic": 1, "languag": 1, "summari": 1}}, "1467": {"id": "1467", "title": "A Graphical ServiceSystem With Variable Syntax", "abstract": "Man-machine interaction in many fields of endeavor should be greatly facilitated in the near  future through the use of interactive graphical languages.  To provide a variety of display scope communication  procedures, a Graphic Service system which functions as a generalized graphical language translator,  is being developed to aid the definition as well as the use of new graphical languages.", "authors": "Roberts, L. G.", "words_pool": ["aid", "commun", "definit", "develop", "display", "endeavor", "facilit", "field", "function", "futur", "gener", "graphic", "graphic", "greatli", "interact", "interact", "languag", "languag", "machin", "man", "procedur", "provid", "scope", "servic", "servicesystem", "syntax", "system", "translat", "variabl", "varieti", "robert"], "word_count": {"aid": 1, "commun": 1, "definit": 1, "develop": 1, "display": 1, "endeavor": 1, "facilit": 1, "field": 1, "function": 1, "futur": 1, "gener": 1, "graphic": 4, "greatli": 1, "interact": 2, "languag": 3, "machin": 1, "man": 1, "procedur": 1, "provid": 1, "scope": 1, "servic": 1, "servicesystem": 1, "syntax": 1, "system": 1, "translat": 1, "variabl": 1, "varieti": 1, "robert": 1}}, "1468": {"id": "1468", "title": "Syntax-Directed Interpretation of Classes of Pictures", "abstract": "A descriptive scheme for classes of pictures based on labeling techniques using parallel processing  algorithms was proposed by the author some years ago.  Since then much work has been done in applying  this to bubble chamber pictures.  The parallel processing simulator, originally written for an IBM 7094 system, has now been rewritten for a CDC 3600 system.  This paper descriptive models by considering their  specific application to bubble chamber pictures.  How the description generated in this phase can be  embedded in a larger \"conversation\" program is explained by means of a certain specific example that  has been worked out.  A partial generative grammar for \"handwritten\" English letters is given, as are  also a few computer-generated outputs using this grammar and the parallel processing simulator mentioned  earlier.", "authors": "Narasimhan, R.", "words_pool": ["ago", "algorithm", "applic", "appli", "author", "base", "bubbl", "cdc", "chamber", "class", "comput", "consid", "convers", "descript", "descript", "direct", "earlier", "embed", "english", "explain", "gener", "gener", "grammar", "handwritten", "ibm", "interpret", "label", "larger", "letter", "mean", "mention", "model", "origin", "output", "paper", "parallel", "partial", "phase", "pictur", "process", "program", "propos", "rewritten", "scheme", "simul", "specif", "syntax", "system", "techniqu", "work", "work", "written", "year", "narasimhan"], "word_count": {"ago": 1, "algorithm": 1, "applic": 1, "appli": 1, "author": 1, "base": 1, "bubbl": 2, "cdc": 1, "chamber": 2, "class": 1, "comput": 1, "consid": 1, "convers": 1, "descript": 3, "direct": 1, "earlier": 1, "embed": 1, "english": 1, "explain": 1, "gener": 3, "grammar": 2, "handwritten": 1, "ibm": 1, "interpret": 1, "label": 1, "larger": 1, "letter": 1, "mean": 1, "mention": 1, "model": 1, "origin": 1, "output": 1, "paper": 1, "parallel": 3, "partial": 1, "phase": 1, "pictur": 3, "process": 3, "program": 1, "propos": 1, "rewritten": 1, "scheme": 1, "simul": 2, "specif": 2, "syntax": 1, "system": 2, "techniqu": 1, "work": 2, "written": 1, "year": 1, "narasimhan": 1}}, "1469": {"id": "1469", "title": "The Next 700 Programming Languages", "abstract": "A family of unimplemented computing languages is described that is intended to span differences  of application area by a unified framework.  This framework dictates the rules about the uses of user-coined  names, and the conventions about characterizing functional relationships.  Within this framework the  design of a specific language splits into two independent parts.  One is the choice of written appearances  of programs (or more generally, their physical representation).  The other is the choice of the abstract  entities (such as numbers, character-strings, lists of them, functional relations among them) that can  be referred to in the language.  The system is biased towards \"expressions\" rather than \"statements.\"   It includes a nonprocedural(purely functional) subsystem that aims to expand the class of users' needs  that can be met by a single print-instruction, without sacrificing the important properties that make  conventional right-hand-side expressions easy to construct and understand.", "authors": "Landin, P. J.", "words_pool": ["abstract", "aim", "appear", "applic", "area", "bias", "charact", "character", "choic", "class", "coin", "comput", "construct", "convent", "convent", "design", "dictat", "differ", "easi", "entiti", "expand", "express", "famili", "framework", "function", "gener", "hand", "import", "includ", "independ", "instruct", "intend", "languag", "languag", "list", "make", "met", "name", "need", "nonprocedur", "number", "part", "physic", "print", "program", "program", "properti", "pure", "refer", "relat", "relationship", "represent", "rule", "sacrif", "side", "singl", "span", "specif", "split", "statement", "string", "subsystem", "system", "understand", "unifi", "unimpl", "user", "user", "written", "landin"], "word_count": {"abstract": 1, "aim": 1, "appear": 1, "applic": 1, "area": 1, "bias": 1, "charact": 1, "character": 1, "choic": 2, "class": 1, "coin": 1, "comput": 1, "construct": 1, "convent": 2, "design": 1, "dictat": 1, "differ": 1, "easi": 1, "entiti": 1, "expand": 1, "express": 2, "famili": 1, "framework": 3, "function": 3, "gener": 1, "hand": 1, "import": 1, "includ": 1, "independ": 1, "instruct": 1, "intend": 1, "languag": 3, "list": 1, "make": 1, "met": 1, "name": 1, "need": 1, "nonprocedur": 1, "number": 1, "part": 1, "physic": 1, "print": 1, "program": 1, "properti": 1, "pure": 1, "refer": 1, "relat": 1, "relationship": 1, "represent": 1, "rule": 1, "sacrif": 1, "side": 1, "singl": 1, "span": 1, "specif": 1, "split": 1, "statement": 1, "string": 1, "subsystem": 1, "system": 1, "understand": 1, "unifi": 1, "unimpl": 1, "user": 2, "written": 1, "landin": 1}}, "1470": {"id": "1470", "title": "The Structure of Programming Languages", "abstract": "The following are identified as major components of every programming language: (1) the elementary  program statement, (2) mechanisms for linking elementary statements together, (3) the means by which  a program can obtain data inputs.  Several alternative forms of each of these components are described,  compared and evaluated.  Many examples, frequently from list processing languages, illustrate the forms  described.  Elementary program statements usually take the form of commands, requirements, or implicit  specifications.  A command is an imperative statement that commands the action to be taken.  A requirement  describes the effect to be achieved without saying anything about the actions to be taken.  An implicit  specification is similar to a requirement, but the programmer must understand what actions will be taken  to achieve the desired effect.  Subroutines may be entered explicitly, by execute call, or by function  composition.  Explicitly called subroutines generally require special linkage conventions.  An execute  subroutine call is syntactically indistinguishable from a basic instruction of the programming language.   Function composition is a convenient alternative to the explicit call.  The three principal ways of  getting inputs for routines are (1) by referring to the data itself, (2) by referring to the data by  a \"name\", and (3) by referring to it implicitly by means of variables or functions.  Names are useful  entry points into permanent data structures, but can be error-causing distractions in other contexts.  The author discusses advantages, disadvantages, and factors influencing the choice of a form of component  for a language.   He concludes by suggesting the evolution of programming languages toward one which  will permit all the most convenient ways of structuring programs, organizing systems, and referencing  data.", "authors": "Raphael, B.", "words_pool": ["achiev", "achiev", "action", "action", "advantag", "altern", "author", "basic", "call", "call", "caus", "choic", "command", "command", "compar", "compon", "compon", "composit", "conclud", "context", "conveni", "convent", "data", "describ", "desir", "disadvantag", "discuss", "distract", "effect", "elementari", "enter", "entri", "error", "evalu", "evolut", "exampl", "execut", "explicit", "explicitli", "factor", "form", "form", "frequent", "function", "function", "gener", "get", "identifi", "illustr", "imper", "implicit", "implicitli", "indistinguish", "influenc", "input", "instruct", "languag", "languag", "linkag", "link", "list", "major", "mean", "mechan", "name", "obtain", "organ", "perman", "permit", "point", "princip", "process", "program", "programm", "program", "program", "referenc", "refer", "requir", "requir", "requir", "routin", "say", "similar", "special", "specif", "specif", "statement", "statement", "structur", "structur", "structur", "subroutin", "subroutin", "suggest", "syntact", "system", "take", "understand", "variabl", "way", "raphael"], "word_count": {"achiev": 2, "action": 3, "advantag": 1, "altern": 2, "author": 1, "basic": 1, "call": 4, "caus": 1, "choic": 1, "command": 3, "compar": 1, "compon": 3, "composit": 2, "conclud": 1, "context": 1, "conveni": 2, "convent": 1, "data": 5, "describ": 1, "desir": 1, "disadvantag": 1, "discuss": 1, "distract": 1, "effect": 2, "elementari": 3, "enter": 1, "entri": 1, "error": 1, "evalu": 1, "evolut": 1, "exampl": 1, "execut": 2, "explicit": 1, "explicitli": 2, "factor": 1, "form": 4, "frequent": 1, "function": 3, "gener": 1, "get": 1, "identifi": 1, "illustr": 1, "imper": 1, "implicit": 2, "implicitli": 1, "indistinguish": 1, "influenc": 1, "input": 2, "instruct": 1, "languag": 5, "linkag": 1, "link": 1, "list": 1, "major": 1, "mean": 2, "mechan": 1, "name": 1, "obtain": 1, "organ": 1, "perman": 1, "permit": 1, "point": 1, "princip": 1, "process": 1, "program": 7, "programm": 1, "referenc": 1, "refer": 3, "requir": 4, "routin": 1, "say": 1, "similar": 1, "special": 1, "specif": 2, "statement": 4, "structur": 2, "subroutin": 3, "suggest": 1, "syntact": 1, "system": 1, "take": 1, "understand": 1, "variabl": 1, "way": 2, "raphael": 1}}, "1471": {"id": "1471", "title": "Programming Semantics for Multiprogrammed computations", "abstract": "The semantics are defined for a number of meta-instructions which perform operation essential  to the writing of programs in multiprogrammed computer systems.  These meta-instructions relate to parallel  processing, protection of separate computations, program debugging, and the sharing among users of memory  segments and other computing objects, the names of which are hierarchically structured.  The language  sophistication contemplated is midway between an assembly language and an advanced algebraic language.", "authors": "Dennis,J. B. VanHorn, E. C.", "words_pool": ["advanc", "algebra", "assembl", "comput", "comput", "comput", "contempl", "debug", "defin", "essenti", "hierarch", "instruct", "languag", "memori", "meta", "midway", "multiprogram", "name", "number", "object", "oper", "parallel", "perform", "process", "program", "program", "program", "protect", "relat", "segment", "semant", "separ", "share", "sophist", "structur", "system", "user", "write", "denni", "vanhorn"], "word_count": {"advanc": 1, "algebra": 1, "assembl": 1, "comput": 3, "contempl": 1, "debug": 1, "defin": 1, "essenti": 1, "hierarch": 1, "instruct": 2, "languag": 3, "memori": 1, "meta": 2, "midway": 1, "multiprogram": 1, "name": 1, "number": 1, "object": 1, "oper": 1, "parallel": 1, "perform": 1, "process": 1, "program": 2, "protect": 1, "relat": 1, "segment": 1, "semant": 1, "separ": 1, "share": 1, "sophist": 1, "structur": 1, "system": 1, "user": 1, "write": 1, "denni": 1, "vanhorn": 1}}, "1472": {"id": "1472", "title": "Description of a High Capacity, Fast Turnaround University Computing Center", "abstract": "The operating system for the UNIVAC 1107 at Case Institute is reviewed.  The system is of interest  because of the low turnaround times achieved, the high throughput achieved and the lack of an operating  staff.  Turnaround times below 5 minutes and job volume above 75,000 per quarter year one reported.", "authors": "Lynch, W", "words_pool": ["achiev", "capac", "case", "center", "comput", "descript", "fast", "high", "institut", "interest", "job", "lack", "low", "minut", "oper", "quarter", "report", "review", "staff", "system", "throughput", "time", "turnaround", "univac", "univers", "volum", "year", "lynch"], "word_count": {"achiev": 2, "capac": 1, "case": 1, "center": 1, "comput": 1, "descript": 1, "fast": 1, "high": 1, "institut": 1, "interest": 1, "job": 1, "lack": 1, "low": 1, "minut": 1, "oper": 2, "quarter": 1, "report": 1, "review": 1, "staff": 1, "system": 2, "throughput": 1, "time": 2, "turnaround": 2, "univac": 1, "univers": 1, "volum": 1, "year": 1, "lynch": 1}}, "1473": {"id": "1473", "title": "The Stability of the Fourth Order Runge-Kutta Method for the Solution of Systems of Differential  Equations", "abstract": "The problem of the region of stability of the fourth order-Runge-Kutta method for the solution  of systems of differential equations is studied.  This region can be characterized by means of linear  transformation but can not be given in a closed form.  In the paper, this region is determined by the  electronic digital computer Z22.", "authors": "Karim, A. I. A.", "words_pool": ["character", "close", "comput", "determin", "differenti", "digit", "electron", "equat", "form", "fourth", "kutta", "linear", "mean", "method", "order", "paper", "problem", "region", "rung", "solut", "stabil", "studi", "system", "transform", "z22", "karim"], "word_count": {"character": 1, "close": 1, "comput": 1, "determin": 1, "differenti": 1, "digit": 1, "electron": 1, "equat": 1, "form": 1, "fourth": 1, "kutta": 1, "linear": 1, "mean": 1, "method": 1, "order": 1, "paper": 1, "problem": 1, "region": 3, "rung": 1, "solut": 1, "stabil": 1, "studi": 1, "system": 1, "transform": 1, "z22": 1, "karim": 1}}, "1474": {"id": "1474", "title": "Tests of Probabilistic Models for Propagation of Roundoff Errors", "abstract": "In any prolonged computation it is generally assumed that the accumulated effect of roundoff  errors is in some sense statistical.  The purpose of this paper is to give precise descriptions of certain  probabilistic models for roundoff error, and then to describe a series of experiments for testing the  validity of these models.  It is concluded that the models are in general very good.  Discrepancies are  both rare and mild.  The test techniques can also be used to experiment with various types of special  arithmetic.", "authors": "Hull, T. E. Swenson, J. R.", "words_pool": ["accumul", "arithmet", "assum", "comput", "conclud", "describ", "descript", "discrep", "effect", "error", "error", "experi", "experi", "gener", "gener", "give", "good", "mild", "model", "paper", "precis", "probabilist", "prolong", "propag", "purpos", "rare", "roundoff", "sens", "seri", "special", "statist", "techniqu", "test", "test", "test", "type", "valid", "hull", "swenson"], "word_count": {"accumul": 1, "arithmet": 1, "assum": 1, "comput": 1, "conclud": 1, "describ": 1, "descript": 1, "discrep": 1, "effect": 1, "error": 2, "experi": 2, "gener": 2, "give": 1, "good": 1, "mild": 1, "model": 3, "paper": 1, "precis": 1, "probabilist": 1, "prolong": 1, "propag": 1, "purpos": 1, "rare": 1, "roundoff": 2, "sens": 1, "seri": 1, "special": 1, "statist": 1, "techniqu": 1, "test": 2, "type": 1, "valid": 1, "hull": 1, "swenson": 1}}, "1475": {"id": "1475", "title": "Dribble Posting a Master File", "abstract": "Many business applications employ sequential magnetic tape rather than random-access storage  techniques to process a very small number of transactions against a voluminous master file.  In such  situations, it may prove economical to avoid creating a new master file during each updating run by producing  instead a dribble ledger containing only those master file accounts which have experienced activity.", "authors": "Head, R. V.", "words_pool": ["access", "account", "activ", "applic", "avoid", "busi", "creat", "dribbl", "econom", "employ", "experienc", "ledger", "magnet", "master", "number", "post", "process", "produc", "prove", "random", "run", "sequenti", "situat", "small", "storag", "tape", "techniqu", "transact", "updat", "volumin", "head"], "word_count": {"access": 1, "account": 1, "activ": 1, "applic": 1, "avoid": 1, "busi": 1, "creat": 1, "dribbl": 1, "econom": 1, "employ": 1, "experienc": 1, "ledger": 1, "magnet": 1, "master": 3, "number": 1, "post": 1, "process": 1, "produc": 1, "prove": 1, "random": 1, "run": 1, "sequenti": 1, "situat": 1, "small": 1, "storag": 1, "tape": 1, "techniqu": 1, "transact": 1, "updat": 1, "volumin": 1, "head": 1}}, "1476": {"id": "1476", "title": "Control Procedures for Data Communication-An ASA Progress Report", "abstract": "Sectional Committee X.3 of the American Standards Association, has charged one of its task  groups, X3.3.4, with the responsibility to \"Define and specify functional control requirements and characteristics  governing the operation of digital data generating and receiving systems interconnected by communication  system.\"  This effort is primarily directed toward systems employing the American Standard Code for Information  Interchange (ASCII).  This paper represents a progress report on the work of this group toward a proposal  for national and international standardization in the field of control procedures.  It describes both  the old and new work of the task group.  The new work is presented in detail, while the work that has  been presented in earlier papers [\"Control Procedures for Data Communication,\" Task Group document X3.3.4/44,  May 1964: \"Transparent-Mode Control Procedures for Data Communication,\" Task Group document X3.3.4/58,  December, 1964: Comm. ACM 8 (Apr. 1965), 203-206; \"Control Procedures for Data Communications,\" Task  Group document X3.3.4/60, March, 1965] is retained here in summary form.  Many of the concepts and principles  described herein have been submitted to the International Organization for Standardization via earlier  papers and are now embodied in working papers of that organization.", "words_pool": ["acm", "american", "apr", "asa", "ascii", "associ", "characterist", "charg", "code", "comm", "committe", "commun", "commun", "concept", "control", "data", "decemb", "defin", "describ", "detail", "digit", "direct", "document", "earlier", "effort", "embodi", "employ", "field", "form", "function", "gener", "govern", "group", "group", "inform", "interchang", "interconnect", "intern", "march", "mode", "nation", "oper", "organ", "paper", "paper", "present", "primarili", "principl", "procedur", "progress", "propos", "receiv", "report", "repres", "requir", "respons", "retain", "section", "standard", "standard", "standard", "submit", "summari", "system", "system", "task", "transpar", "work", "work", "x3"], "word_count": {"acm": 1, "american": 2, "apr": 1, "asa": 1, "ascii": 1, "associ": 1, "characterist": 1, "charg": 1, "code": 1, "comm": 1, "committe": 1, "commun": 4, "concept": 1, "control": 5, "data": 4, "decemb": 1, "defin": 1, "describ": 1, "detail": 1, "digit": 1, "direct": 1, "document": 3, "earlier": 2, "effort": 1, "embodi": 1, "employ": 1, "field": 1, "form": 1, "function": 1, "gener": 1, "govern": 1, "group": 6, "inform": 1, "interchang": 1, "interconnect": 1, "intern": 2, "march": 1, "mode": 1, "nation": 1, "oper": 1, "organ": 2, "paper": 4, "present": 2, "primarili": 1, "principl": 1, "procedur": 4, "progress": 1, "propos": 1, "receiv": 1, "report": 1, "repres": 1, "requir": 1, "respons": 1, "retain": 1, "section": 1, "standard": 4, "submit": 1, "summari": 1, "system": 3, "task": 5, "transpar": 1, "work": 5, "x3": 4}}, "1477": {"id": "1477", "title": "EULER: A Generalization of ALGOL, and its Formal Definition: Part II*", "authors": "Wirth, N. Weber, H.", "words_pool": ["algol", "definit", "euler", "formal", "gener", "ii", "part", "wirth", "weber"], "word_count": {"algol": 1, "definit": 1, "euler": 1, "formal": 1, "gener": 1, "ii": 1, "part": 1, "wirth": 1, "weber": 1}}, "1478": {"id": "1478", "title": "Exponential Curve Fit (Algorithm 275 [E2])", "authors": "Deily, G. R.", "words_pool": ["algorithm", "curv", "e2", "exponenti", "fit", "deili"], "word_count": {"algorithm": 1, "curv": 1, "e2": 1, "exponenti": 1, "fit": 1, "deili": 1}}, "1479": {"id": "1479", "title": "Constrained Exponential Curve Fit (Algorithm 276 [E2])", "authors": "Deily, G. R.", "words_pool": ["algorithm", "constrain", "curv", "e2", "exponenti", "fit", "deili"], "word_count": {"algorithm": 1, "constrain": 1, "curv": 1, "e2": 1, "exponenti": 1, "fit": 1, "deili": 1}}, "1480": {"id": "1480", "title": "Computation of Chebyshev Series Coefficients (Algorithm 277[C6])", "authors": "Smith, L. B.", "words_pool": ["algorithm", "c6", "chebyshev", "coeffici", "comput", "seri", "smith"], "word_count": {"algorithm": 1, "c6": 1, "chebyshev": 1, "coeffici": 1, "comput": 1, "seri": 1, "smith": 1}}, "1481": {"id": "1481", "title": "Graph Plotter (Algorithm 278 [J6])", "authors": "Lloyd, P.", "words_pool": ["algorithm", "graph", "j6", "plotter", "lloyd"], "word_count": {"algorithm": 1, "graph": 1, "j6": 1, "plotter": 1, "lloyd": 1}}, "1482": {"id": "1482", "title": "BUGSYS: A Programming System for Picture Processing-Not for Debugging", "abstract": "BUGSYS is a picture processing and measuring system that depends upon a pictorial input to  the computer's memory.  BUGSYS can be used for many types of applications.  In particular, the authors  have used the system for the analysis of linear graphs.  The main concept of the system is the use of  a collection of programmable pointers, which are visualized as a family of \"bugs.\"", "authors": "Ledley, R. S. Jacobsen, J. Belson, M.", "words_pool": ["analysi", "applic", "author", "bug", "bugsi", "collect", "comput", "concept", "debug", "depend", "famili", "graph", "input", "linear", "main", "measur", "memori", "pictori", "pictur", "pointer", "process", "programm", "program", "system", "type", "visual", "ledley", "jacobsen", "belson"], "word_count": {"analysi": 1, "applic": 1, "author": 1, "bug": 1, "bugsi": 2, "collect": 1, "comput": 1, "concept": 1, "debug": 1, "depend": 1, "famili": 1, "graph": 1, "input": 1, "linear": 1, "main": 1, "measur": 1, "memori": 1, "pictori": 1, "pictur": 1, "pointer": 1, "process": 1, "programm": 1, "program": 1, "system": 3, "type": 1, "visual": 1, "ledley": 1, "jacobsen": 1, "belson": 1}}, "1483": {"id": "1483", "title": "A Comparison of the FORTRAN Language Implementation for Several Computers", "abstract": "A feature-by-feature comparison is made of five different implementations of FORTRAN IV representing  three different manufacturers.  A table is constructed showing, where possible, the use of each feature  in each implementation.  Only those items which are different from, or have been added to FORTRAN II  are shown.", "authors": "Wright, D. L.", "words_pool": ["ad", "comparison", "comput", "construct", "featur", "fortran", "ii", "implement", "implement", "item", "iv", "languag", "made", "manufactur", "repres", "show", "shown", "tabl", "wright"], "word_count": {"ad": 1, "comparison": 1, "comput": 1, "construct": 1, "featur": 3, "fortran": 2, "ii": 1, "implement": 2, "item": 1, "iv": 1, "languag": 1, "made": 1, "manufactur": 1, "repres": 1, "show": 1, "shown": 1, "tabl": 1, "wright": 1}}, "1484": {"id": "1484", "title": "A Language for Describing the Functions of Synchronous Systems*", "abstract": "Before the design of a system is started, the exact function desired of it should be specified.   It is suggested that a computer-oriented language be used for this purpose.  The inadequacies of the  standard programming languages for the description of systems are discussed, and a dialect of ALGOL which  is suitable for describing synchronous systems is introduced.  These descriptions can be used for simulation  and automatic design of the system described, in addition to communicating system specifications.", "authors": "Parnas, D. L.", "words_pool": ["addit", "algol", "automat", "commun", "comput", "describ", "descript", "descript", "design", "desir", "dialect", "discuss", "exact", "function", "function", "inadequaci", "introduc", "languag", "languag", "orient", "program", "purpos", "simul", "specif", "standard", "start", "suggest", "suitabl", "synchron", "system", "system", "parna"], "word_count": {"addit": 1, "algol": 1, "automat": 1, "commun": 1, "comput": 1, "describ": 1, "descript": 2, "design": 2, "desir": 1, "dialect": 1, "discuss": 1, "exact": 1, "function": 1, "inadequaci": 1, "introduc": 1, "languag": 2, "orient": 1, "program": 1, "purpos": 1, "simul": 1, "specif": 1, "standard": 1, "start": 1, "suggest": 1, "suitabl": 1, "synchron": 1, "system": 5, "parna": 1}}, "1485": {"id": "1485", "title": "The Structure of Programming Languages", "abstract": "In this paper the major components of every programming language are identified as: (1) the  elementary program statement, (2) mechanisms for linking elementary statements together, (3) the means  by which a program can obtain data inputs.  Several alternative forms of each of these components are  also described, compared and evaluated.  Many examples, frequently from list processing languages, illustrate  the forms described.  The advantages, disadvantages and factors influencing the choice of a form of component  for a language are discussed, and the paper concludes with the suggestion that programming languages  evolve toward one which will permit all the most convenient ways of structuring programs, organizing  systems and referencing data.", "authors": "Raphael, B.", "words_pool": ["advantag", "altern", "choic", "compar", "compon", "compon", "conclud", "conveni", "data", "disadvantag", "discuss", "elementari", "evalu", "evolv", "exampl", "factor", "form", "form", "frequent", "identifi", "illustr", "influenc", "input", "languag", "languag", "link", "list", "major", "mean", "mechan", "obtain", "organ", "paper", "permit", "process", "program", "program", "program", "referenc", "statement", "statement", "structur", "structur", "suggest", "system", "way", "raphael"], "word_count": {"advantag": 1, "altern": 1, "choic": 1, "compar": 1, "compon": 3, "conclud": 1, "conveni": 1, "data": 2, "disadvantag": 1, "discuss": 1, "elementari": 2, "evalu": 1, "evolv": 1, "exampl": 1, "factor": 1, "form": 3, "frequent": 1, "identifi": 1, "illustr": 1, "influenc": 1, "input": 1, "languag": 4, "link": 1, "list": 1, "major": 1, "mean": 1, "mechan": 1, "obtain": 1, "organ": 1, "paper": 2, "permit": 1, "process": 1, "program": 5, "referenc": 1, "statement": 2, "structur": 1, "suggest": 1, "system": 1, "way": 1, "raphael": 1}}, "1486": {"id": "1486", "title": "A Reprogramming Machine", "abstract": "In this paper a description is given of a model programming system which is directed by a programming  language and has a library for storing the user's items.  Rules are given for transforming programs written  in the language and for rearranging the items in the library so that they share their common parts.   Some speculations are made about how the mechanical detection of common parts or patterns of library  items could help a user to solve his problems, and about the relationships between the behavior of the  reprogramming machine and human intelligent behavior.", "authors": "Burge, W. H.", "words_pool": ["behavior", "common", "descript", "detect", "direct", "help", "human", "intellig", "item", "languag", "librari", "machin", "made", "mechan", "model", "paper", "part", "pattern", "problem", "program", "program", "rearrang", "relationship", "reprogram", "rule", "share", "solv", "specul", "store", "system", "transform", "user", "written", "burg"], "word_count": {"behavior": 2, "common": 2, "descript": 1, "detect": 1, "direct": 1, "help": 1, "human": 1, "intellig": 1, "item": 3, "languag": 2, "librari": 3, "machin": 1, "made": 1, "mechan": 1, "model": 1, "paper": 1, "part": 2, "pattern": 1, "problem": 1, "program": 3, "rearrang": 1, "relationship": 1, "reprogram": 1, "rule": 1, "share": 1, "solv": 1, "specul": 1, "store": 1, "system": 1, "transform": 1, "user": 2, "written": 1, "burg": 1}}, "1487": {"id": "1487", "title": "ELIZA-A Computer Program For the Study ofNatural Language Communication Between Man And Machine", "abstract": "ELIZA is a program operating within the MAC time-sharing system at MIT which makes certain  kinds of natural language conversation between man and computer possible.  Input sentences are analyzed  on the basis of decomposition rules which are triggered by key words appearing in the input text.  Responses  are generated by reassembly rules associated with selected decomposition rules.  the fundamental technical  problems with which ELIZA is concerned are: (1)the identification of key words, (2) the discovery of  minimal context, (3) the choice of appropriate transformations, (4) generation of responses in the absence  of key words, and (5) the provision of an editing capability for ELIZA \"scripts\".  A discussion of some  psychological issues relevant to the ELIZA approach as well as of future developments concludes the paper.", "authors": "Weizenbaum, J.", "words_pool": ["absenc", "analyz", "appear", "approach", "basi", "capabl", "choic", "commun", "comput", "concern", "conclud", "context", "convers", "decomposit", "develop", "discoveri", "discuss", "edit", "eliza", "fundament", "futur", "gener", "gener", "identif", "input", "issu", "key", "kind", "languag", "mac", "machin", "make", "man", "minim", "mit", "natur", "ofnatur", "oper", "paper", "problem", "program", "provis", "psycholog", "reassembl", "relev", "respons", "rule", "script", "select", "sentenc", "share", "studi", "system", "technic", "text", "time", "transform", "trigger", "word", "weizenbaum"], "word_count": {"absenc": 1, "analyz": 1, "appear": 1, "approach": 1, "basi": 1, "capabl": 1, "choic": 1, "commun": 1, "comput": 1, "concern": 1, "conclud": 1, "context": 1, "convers": 1, "decomposit": 2, "develop": 1, "discoveri": 1, "discuss": 1, "edit": 1, "eliza": 4, "fundament": 1, "futur": 1, "gener": 2, "identif": 1, "input": 2, "issu": 1, "key": 3, "kind": 1, "languag": 1, "mac": 1, "machin": 1, "make": 1, "man": 1, "minim": 1, "mit": 1, "natur": 1, "ofnatur": 1, "oper": 1, "paper": 1, "problem": 1, "program": 1, "provis": 1, "psycholog": 1, "reassembl": 1, "relev": 1, "respons": 2, "rule": 3, "script": 1, "select": 1, "sentenc": 1, "share": 1, "studi": 1, "system": 1, "technic": 1, "text": 1, "time": 1, "transform": 1, "trigger": 1, "word": 3, "weizenbaum": 1}}, "1488": {"id": "1488", "title": "Programming Decision Tables in FORTRAN, COBOL or ALGOL", "abstract": "A simple broad-based approach for programming decision tables in FORTRAN or COBOL is developed  and presented.  With inputs in standard form, as defined in the paper, the programming of any decision  table can be done with one or two FORTRAN statements, or with two COBOL statements, if the COMPUTE verb  is available in the COBOL processor.  It is  shown that the method is applicable even when there are  more than two mutually exclusive states of one, two or more table conditions.  It is further shown that  multi-state conditions in decision tables can often simplify the programming.  The method outlined has  the further advantage that all possible combinations of conditions are considered.  It is shown that  the suggested procedure is easily implemented in ALGOL.", "authors": "Veinott, C. G.", "words_pool": ["advantag", "algol", "applic", "approach", "base", "broad", "cobol", "combin", "comput", "condit", "consid", "decis", "defin", "develop", "easili", "exclus", "form", "fortran", "implement", "input", "method", "multi", "mutual", "outlin", "paper", "present", "procedur", "processor", "program", "shown", "simpl", "simplifi", "standard", "state", "statement", "state", "suggest", "tabl", "tabl", "verb", "veinott"], "word_count": {"advantag": 1, "algol": 1, "applic": 1, "approach": 1, "base": 1, "broad": 1, "cobol": 3, "combin": 1, "comput": 1, "condit": 3, "consid": 1, "decis": 3, "defin": 1, "develop": 1, "easili": 1, "exclus": 1, "form": 1, "fortran": 2, "implement": 1, "input": 1, "method": 2, "multi": 1, "mutual": 1, "outlin": 1, "paper": 1, "present": 1, "procedur": 1, "processor": 1, "program": 3, "shown": 3, "simpl": 1, "simplifi": 1, "standard": 1, "state": 2, "statement": 2, "suggest": 1, "tabl": 4, "verb": 1, "veinott": 1}}, "1489": {"id": "1489", "title": "Data, Documentation and Decision Tables", "abstract": "In business data processing systems, it is necessary to be able to define and document data,  files, programs and decision rules in a way that adequately represents both (1) their changing information  content, and (2) their continuous interaction.  Tabular description makes this possible, being notably  objective, through and economical in cost and time when systems must be analyzed and programs prepared  or modified.  To show how quickly tabular techniques make an unfamiliar system manageable, a detailed  example and a self-test are provided.", "authors": "Fisher, D. L.", "words_pool": ["abl", "adequ", "analyz", "busi", "chang", "content", "continu", "cost", "data", "decis", "defin", "descript", "detail", "document", "document", "econom", "inform", "interact", "make", "make", "manag", "modifi", "notabl", "object", "prepar", "process", "program", "provid", "quickli", "repres", "rule", "show", "system", "system", "tabl", "tabular", "techniqu", "test", "time", "unfamiliar", "fisher"], "word_count": {"abl": 1, "adequ": 1, "analyz": 1, "busi": 1, "chang": 1, "content": 1, "continu": 1, "cost": 1, "data": 2, "decis": 1, "defin": 1, "descript": 1, "detail": 1, "document": 1, "econom": 1, "inform": 1, "interact": 1, "make": 2, "manag": 1, "modifi": 1, "notabl": 1, "object": 1, "prepar": 1, "process": 1, "program": 2, "provid": 1, "quickli": 1, "repres": 1, "rule": 1, "show": 1, "system": 3, "tabl": 1, "tabular": 2, "techniqu": 1, "test": 1, "time": 1, "unfamiliar": 1, "fisher": 1}}, "1490": {"id": "1490", "title": "One Inch Perforated Paper Tape for Information Interchange (Proposed American Standard)", "words_pool": ["american", "inch", "inform", "interchang", "paper", "perfor", "propos", "standard", "tape"], "word_count": {"american": 1, "inch": 1, "inform": 1, "interchang": 1, "paper": 1, "perfor": 1, "propos": 1, "standard": 1, "tape": 1}}, "1491": {"id": "1491", "title": "EULER: A Generalization ALGOL, and its Formal Definition: Part I*", "abstract": "A method for defining programming languages is developed which introduces a rigorous relationship  between structure and meaning.  The structure of a language is defined by a phrase structure syntax,  the meaning in terms of the effects which the execution of a sequence of interpretation rules exerts  upon a fixed set of variables, called the Environment.  There exists a one-to-one correspondence between  syntactic rules and interpretation rules is determined by the sequence of corresponding syntactic reductions  which constitute a parse.  The individual interpretation rules are explained in terms of an elementary  an d obvious algorithmic notation.  A constructive method for evaluating a text is provided, and for  certain decidable classes of languages their unambiguity is proved.  As an example, a generalization  of ALGOL is described in full detail to demonstrate that concepts like block-structure, procedures, parameters,  etc. can be defined adequately and precisely by this method.", "authors": "Wirth, N. Weber, H.", "words_pool": ["adequ", "algol", "algorithm", "block", "call", "class", "concept", "constitut", "construct", "correspond", "decid", "defin", "defin", "definit", "demonstr", "detail", "determin", "develop", "effect", "elementari", "environ", "euler", "evalu", "execut", "exert", "exist", "explain", "fix", "formal", "full", "gener", "individu", "interpret", "introduc", "languag", "languag", "mean", "method", "notat", "obviou", "paramet", "pars", "part", "phrase", "precis", "procedur", "program", "prove", "provid", "reduct", "relationship", "rigor", "rule", "sequenc", "set", "structur", "syntact", "syntax", "term", "text", "unambigu", "variabl", "wirth", "weber"], "word_count": {"adequ": 1, "algol": 1, "algorithm": 1, "block": 1, "call": 1, "class": 1, "concept": 1, "constitut": 1, "construct": 1, "correspond": 1, "decid": 1, "defin": 3, "definit": 1, "demonstr": 1, "detail": 1, "determin": 1, "develop": 1, "effect": 1, "elementari": 1, "environ": 1, "euler": 1, "evalu": 1, "execut": 1, "exert": 1, "exist": 1, "explain": 1, "fix": 1, "formal": 1, "full": 1, "gener": 1, "individu": 1, "interpret": 3, "introduc": 1, "languag": 3, "mean": 2, "method": 3, "notat": 1, "obviou": 1, "paramet": 1, "pars": 1, "part": 1, "phrase": 1, "precis": 1, "procedur": 1, "program": 1, "prove": 1, "provid": 1, "reduct": 1, "relationship": 1, "rigor": 1, "rule": 4, "sequenc": 2, "set": 1, "structur": 4, "syntact": 2, "syntax": 1, "term": 2, "text": 1, "unambigu": 1, "variabl": 1, "wirth": 1, "weber": 1}}, "1492": {"id": "1492", "title": "Serrev (Algorithm 273 [C1])", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "c1", "serrev", "thacher", "jr"], "word_count": {"algorithm": 1, "c1": 1, "serrev": 1, "thacher": 1, "jr": 1}}, "1493": {"id": "1493", "title": "Generation of Hilbert Derived Test Matrix (Algorithm 274 [F1])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "deriv", "f1", "gener", "hilbert", "matrix", "test", "boothroyd"], "word_count": {"algorithm": 1, "deriv": 1, "f1": 1, "gener": 1, "hilbert": 1, "matrix": 1, "test": 1, "boothroyd": 1}}, "1494": {"id": "1494", "title": "Complete Elliptic Integral of the Second Kind (Algorithm 56 [S21])", "authors": "Larssen, G. M.", "words_pool": ["algorithm", "complet", "ellipt", "integr", "kind", "s21", "larssen"], "word_count": {"algorithm": 1, "complet": 1, "ellipt": 1, "integr": 1, "kind": 1, "s21": 1, "larssen": 1}}, "1495": {"id": "1495", "title": "Solution of Transcendental Equations by Series Reversion", "abstract": "An algorithm is developed for expressing the solution Y, of the equation F(Y) = G(X) as a power  series in (X - X0) when f and g are given as power series,and the root Y0, is known at Y=X0.  The algorithm  is illustrated for the equation Y^Y = X, i.e., (1+y)*ln(1+y) = ln(1+x).", "authors": "Thacher Jr., H. C.", "words_pool": ["algorithm", "develop", "equat", "equat", "express", "illustr", "known", "ln", "power", "revers", "root", "seri", "solut", "transcendent", "x0", "y0", "thacher", "jr"], "word_count": {"algorithm": 2, "develop": 1, "equat": 2, "express": 1, "illustr": 1, "known": 1, "ln": 2, "power": 2, "revers": 1, "root": 1, "seri": 2, "solut": 1, "transcendent": 1, "x0": 2, "y0": 1, "thacher": 1, "jr": 1}}, "1496": {"id": "1496", "title": "A Formal Semantics for Computer Languages and its Application In a Compiler-Compiler", "abstract": "A semantic meta-language has been developed for representing the meanings of statements in  a large class of computer languages.  This meta-language has been the basis for construction of an efficient,  functioning compiler-compiler.  An informal discussion of the meta-language based on the example of a  complete translator for a small language is presented.", "authors": "Feldman, J. A.", "words_pool": ["applic", "base", "basi", "class", "compil", "complet", "comput", "construct", "develop", "discuss", "effici", "formal", "function", "inform", "languag", "languag", "larg", "mean", "meta", "present", "repres", "semant", "semant", "small", "statement", "translat", "feldman"], "word_count": {"applic": 1, "base": 1, "basi": 1, "class": 1, "compil": 2, "complet": 1, "comput": 1, "construct": 1, "develop": 1, "discuss": 1, "effici": 1, "formal": 1, "function": 1, "inform": 1, "languag": 5, "larg": 1, "mean": 1, "meta": 3, "present": 1, "repres": 1, "semant": 1, "small": 1, "statement": 1, "translat": 1, "feldman": 1}}, "1497": {"id": "1497", "title": "On the Normalization Requirement of Divisor in Divide- and- Correct Methods", "abstract": "This paper presents an analysis on the normalization requirement of the divisor in a divide-and-correct  method.  This analysis is made subject to the condition that not more than one correction is required  to obtain the true quotient character, from the trial estimate got from the division of a two-precision  segment of every partial remainder by a suitably rounded single-precision divisor.  (This segmented division  is denoted here as a (2, 1) precision basic division.)  It is found that the normalization requirement  could be narrowed down to a smaller range of divisors, provided the magnitude of the character next to  the leading character of the divisor is known.  If, however, the normalization is to be eliminated one  has to choose proper higher precision segments of operands for the basic division.  Also considered is  the possibility of eliminating the normalization by an increase on the number of corrections on the quotient  estimate got from a (2, 1) precision basic division.  It is shown that such a scheme is economical only  for small radices.", "authors": "Krishnamurthy, E. V. Nandi, S. K.", "words_pool": ["analysi", "basic", "charact", "choos", "condit", "consid", "correct", "correct", "correct", "denot", "divid", "divis", "divisor", "divisor", "econom", "elimin", "elimin", "estim", "found", "higher", "increas", "known", "lead", "made", "magnitud", "method", "method", "narrow", "normal", "number", "obtain", "operand", "paper", "partial", "possibl", "precis", "present", "proper", "provid", "quotient", "radic", "rang", "remaind", "requir", "requir", "round", "scheme", "segment", "segment", "segment", "shown", "singl", "small", "smaller", "subject", "suitabl", "trial", "true", "krishnamurthi", "nandi"], "word_count": {"analysi": 2, "basic": 3, "charact": 3, "choos": 1, "condit": 1, "consid": 1, "correct": 3, "denot": 1, "divid": 1, "divis": 5, "divisor": 4, "econom": 1, "elimin": 2, "estim": 2, "found": 1, "higher": 1, "increas": 1, "known": 1, "lead": 1, "made": 1, "magnitud": 1, "method": 1, "narrow": 1, "normal": 4, "number": 1, "obtain": 1, "operand": 1, "paper": 1, "partial": 1, "possibl": 1, "precis": 5, "present": 1, "proper": 1, "provid": 1, "quotient": 2, "radic": 1, "rang": 1, "remaind": 1, "requir": 3, "round": 1, "scheme": 1, "segment": 3, "shown": 1, "singl": 1, "small": 1, "smaller": 1, "subject": 1, "suitabl": 1, "trial": 1, "true": 1, "krishnamurthi": 1, "nandi": 1}}, "1498": {"id": "1498", "title": "The ALCOR Illinois 7090/7094 Post Mortem Dump", "abstract": "A dump technique for programs written in ALGOL 60 is described.  This technique provides an  intelligible analysis of an unsuccessful computation process in terms of the original source program.", "authors": "Bayer, R. Gries, D. Paul, M. Wiehle, H. R.", "words_pool": ["alcor", "algol", "analysi", "comput", "dump", "illinoi", "intellig", "mortem", "origin", "post", "process", "program", "program", "sourc", "techniqu", "term", "unsuccess", "written", "bayer", "gri", "paul", "wiehl"], "word_count": {"alcor": 1, "algol": 1, "analysi": 1, "comput": 1, "dump": 1, "illinoi": 1, "intellig": 1, "mortem": 1, "origin": 1, "post": 1, "process": 1, "program": 2, "sourc": 1, "techniqu": 2, "term": 1, "unsuccess": 1, "written": 1, "bayer": 1, "gri": 1, "paul": 1, "wiehl": 1}}, "1499": {"id": "1499", "title": "Chebyschev Curve-Fit (revised) (Algorithm 318 [E2])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "chebyschev", "curv", "e2", "fit", "revis", "boothroyd"], "word_count": {"algorithm": 1, "chebyschev": 1, "curv": 1, "e2": 1, "fit": 1, "revis": 1, "boothroyd": 1}}, "1500": {"id": "1500", "title": "Chebyschev Curve-Fit (Algorithm 91 [E2])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "chebyschev", "curv", "e2", "fit", "boothroyd"], "word_count": {"algorithm": 1, "chebyschev": 1, "curv": 1, "e2": 1, "fit": 1, "boothroyd": 1}}, "1501": {"id": "1501", "title": "Eigenvectors of a 2n x 2n Matrix", "abstract": "It has been known that the eigenvalues of a certain 2n x 2n matrix can be obtained by use of  two smaller matrices of order n which can be easily constructed.  An algorithm is given to obtain the  eigenvectors of the 2n x 2n matrix by use of the eigenvectors of the smaller matrices.", "authors": "Charmonman, S.", "words_pool": ["2n", "algorithm", "construct", "easili", "eigenvalu", "eigenvector", "known", "matric", "matrix", "obtain", "obtain", "order", "smaller", "charmonman"], "word_count": {"2n": 4, "algorithm": 1, "construct": 1, "easili": 1, "eigenvalu": 1, "eigenvector": 2, "known": 1, "matric": 2, "matrix": 2, "obtain": 2, "order": 1, "smaller": 2, "charmonman": 1}}, "1502": {"id": "1502", "title": "An Online Editor", "abstract": "An online, interactive system for test editing is described in detail, with remarks on the  theoretical and experimental justification for its form.  Emphasis throughout the system is on providing  maximum convenience and power for the user.  Notable features are its ability to handle any piece of  text, the content-searching facility, and the character-by-character editing operations.  The editor  can be programmed to a limited extent.", "authors": "Deutsch, L. P. Lampson, B. W.", "words_pool": ["abil", "charact", "content", "conveni", "detail", "edit", "editor", "emphasi", "experiment", "extent", "facil", "featur", "form", "handl", "interact", "justif", "limit", "maximum", "notabl", "onlin", "oper", "piec", "power", "program", "provid", "remark", "search", "system", "test", "text", "theoret", "user", "deutsch", "lampson"], "word_count": {"abil": 1, "charact": 2, "content": 1, "conveni": 1, "detail": 1, "edit": 2, "editor": 1, "emphasi": 1, "experiment": 1, "extent": 1, "facil": 1, "featur": 1, "form": 1, "handl": 1, "interact": 1, "justif": 1, "limit": 1, "maximum": 1, "notabl": 1, "onlin": 1, "oper": 1, "piec": 1, "power": 1, "program": 1, "provid": 1, "remark": 1, "search": 1, "system": 2, "test": 1, "text": 1, "theoret": 1, "user": 1, "deutsch": 1, "lampson": 1}}, "1503": {"id": "1503", "title": "A SIMSCRIPT-FORTRAN Case Study", "abstract": "Two programs for a vehicle dispatching model, one written in 7040 SIMSCRIPT and the other in  7040 FORTRAN IV are compared. The comparison is made in terms of basic program design decisions, storage  requirements, computer time used, and the ease of making changes.  In the SIMSCRIPT program, the primary  design considerations center around the choice of model variables, model changing events, and model testing.   In the FORTRAN program, basic design problems relate to the representation of the passage of time, the  allocation of storage, and the organization of input data.  The comparison of these differently designed  programs shows that the SIMSCRIPT program uses more computer storage and more computer time, but requires  fewer program changes to introduce model revisions.", "authors": "Weinert, A. E.", "words_pool": ["alloc", "basic", "case", "center", "chang", "choic", "compar", "comparison", "comput", "consider", "data", "decis", "design", "design", "differ", "dispatch", "eas", "event", "fewer", "fortran", "input", "introduc", "iv", "made", "make", "model", "organ", "passag", "primari", "problem", "program", "program", "relat", "represent", "requir", "requir", "revis", "show", "simscript", "storag", "studi", "term", "test", "time", "variabl", "vehicl", "written", "weinert"], "word_count": {"alloc": 1, "basic": 2, "case": 1, "center": 1, "chang": 1, "choic": 1, "compar": 1, "comparison": 2, "comput": 3, "consider": 1, "data": 1, "decis": 1, "design": 4, "differ": 1, "dispatch": 1, "eas": 1, "event": 1, "fewer": 1, "fortran": 2, "input": 1, "introduc": 1, "iv": 1, "made": 1, "make": 1, "model": 5, "organ": 1, "passag": 1, "primari": 1, "problem": 1, "program": 7, "relat": 1, "represent": 1, "requir": 2, "revis": 1, "show": 1, "simscript": 3, "storag": 3, "studi": 1, "term": 1, "test": 1, "time": 3, "variabl": 1, "vehicl": 1, "written": 1, "weinert": 1}}, "1504": {"id": "1504", "title": "Algorithms for Finding a Fundamental Set of Cycles for an Undirected Linear Graph", "abstract": "Given the adjacency matrix of the graph, the algorithm presented in this paper finds a spanning  tree and then constructs the set of fundamental cycles.  Our algorithm is slower than an algorithm presented  by Welch by a ratio of N/3 (N is the number of nodes) but requires less storage.  For graphs with a large  number of nodes and edges, when storage is limited our algorithm is superior to Welch's; however, when  the graphs are small, or machine storage is very large, Welch's algorithm is superior.  Timing estimates  and storage requirements for both methods are presented.", "authors": "Gotlieb, C. C. Corneil, D. G.", "words_pool": ["adjac", "algorithm", "algorithm", "construct", "cycl", "edg", "estim", "find", "find", "fundament", "graph", "graph", "larg", "limit", "linear", "machin", "matrix", "method", "node", "number", "paper", "present", "ratio", "requir", "requir", "set", "slower", "small", "span", "storag", "superior", "time", "tree", "undirect", "welch", "gotlieb", "corneil"], "word_count": {"adjac": 1, "algorithm": 5, "construct": 1, "cycl": 1, "edg": 1, "estim": 1, "find": 1, "fundament": 1, "graph": 3, "larg": 2, "limit": 1, "linear": 1, "machin": 1, "matrix": 1, "method": 1, "node": 2, "number": 2, "paper": 1, "present": 3, "ratio": 1, "requir": 2, "set": 1, "slower": 1, "small": 1, "span": 1, "storag": 4, "superior": 2, "time": 1, "tree": 1, "undirect": 1, "welch": 3, "gotlieb": 1, "corneil": 1}}, "1505": {"id": "1505", "title": "A System Organization for Resource Allocation", "abstract": "This paper introduces a system for resource management using the concepts of \"process,\" facility,\"  and \"event.\"  Except for the processor no attempt has been made to give serious suggestions for the policy  to be followed for resource allocation.  However, a basic framework is provided in which a system analyst  can express solutions to resource management problems.  The paper is divided into a tutorial presentation,  a description of the system primitives, and a small collection of examples of the use of the primitives.", "authors": "Dahm, D. M. Gerbstadt, F. H. Pacelli, M. M.", "words_pool": ["alloc", "analyst", "attempt", "basic", "collect", "concept", "descript", "divid", "event", "exampl", "express", "facil", "framework", "give", "introduc", "made", "manag", "organ", "paper", "polici", "present", "primit", "problem", "process", "processor", "provid", "resourc", "small", "solut", "suggest", "system", "tutori", "dahm", "gerbstadt", "pacelli"], "word_count": {"alloc": 1, "analyst": 1, "attempt": 1, "basic": 1, "collect": 1, "concept": 1, "descript": 1, "divid": 1, "event": 1, "exampl": 1, "express": 1, "facil": 1, "framework": 1, "give": 1, "introduc": 1, "made": 1, "manag": 2, "organ": 1, "paper": 2, "polici": 1, "present": 1, "primit": 2, "problem": 1, "process": 1, "processor": 1, "provid": 1, "resourc": 3, "small": 1, "solut": 1, "suggest": 1, "system": 3, "tutori": 1, "dahm": 1, "gerbstadt": 1, "pacelli": 1}}, "1506": {"id": "1506", "title": "The LACONIQ Monitor: Time Sharing for Online Dialogues", "abstract": "The LACONIQ (Laboratory Computer Online Inquiry) Monitor was developed primarily to support  non-numerical applications such as retrieval from very large files by means of a \"dialogue\" between a  system user and a retrieval application.  The monitor was designed so that it could work with a small  computer (an IBM System 360/30).  Therefore techniques for resource allocation were important.  For this  reason the use of core storage, computational facilities, and input-output were all scheduled.  An unusual  feature of the system is that it is event-driven rather than clock-driven.  The program segments called  into execution by the remote CRT consoles are invariably run to completion rather than \"rolled-out\" to  be brought back at a later time.", "authors": "Drew, D. L.", "words_pool": ["alloc", "applic", "applic", "back", "brought", "call", "clock", "complet", "comput", "comput", "consol", "core", "crt", "design", "develop", "dialogu", "dialogu", "driven", "event", "execut", "facil", "featur", "ibm", "import", "input", "inquiri", "invari", "laboratori", "laconiq", "larg", "later", "mean", "monitor", "non", "numer", "onlin", "output", "primarili", "program", "reason", "remot", "resourc", "retriev", "roll", "run", "schedul", "segment", "share", "small", "storag", "support", "system", "techniqu", "time", "unusu", "user", "work", "drew"], "word_count": {"alloc": 1, "applic": 2, "back": 1, "brought": 1, "call": 1, "clock": 1, "complet": 1, "comput": 3, "consol": 1, "core": 1, "crt": 1, "design": 1, "develop": 1, "dialogu": 1, "driven": 2, "event": 1, "execut": 1, "facil": 1, "featur": 1, "ibm": 1, "import": 1, "input": 1, "inquiri": 1, "invari": 1, "laboratori": 1, "laconiq": 1, "larg": 1, "later": 1, "mean": 1, "monitor": 2, "non": 1, "numer": 1, "onlin": 1, "output": 1, "primarili": 1, "program": 1, "reason": 1, "remot": 1, "resourc": 1, "retriev": 2, "roll": 1, "run": 1, "schedul": 1, "segment": 1, "share": 1, "small": 1, "storag": 1, "support": 1, "system": 3, "techniqu": 1, "time": 1, "unusu": 1, "user": 1, "work": 1, "drew": 1}}, "1507": {"id": "1507", "title": "A Multiprogramming Environment for Online Data Acquis ition and Analysis", "abstract": "An experimental system for acquis ition and analysis of large bodies of data derived from scientific  experiments is described.  Its architecture and implementation is largely based on certain objectives  and characteristics of a general data analysis scheme.  Early applications have been oriented towards  the investigation of data obtained in biological research.  Some of the problems encountered by the chosen  approach are discussed.", "authors": "Lockemann, P. C. Knutsen, W. D.", "words_pool": ["acqui", "analysi", "applic", "approach", "architectur", "base", "biolog", "bodi", "characterist", "chosen", "data", "deriv", "discuss", "earli", "encount", "environ", "experiment", "experi", "gener", "implement", "investig", "ition", "larg", "larg", "multiprogram", "object", "obtain", "onlin", "orient", "problem", "research", "scheme", "scientif", "system", "lockemann", "knutsen"], "word_count": {"acqui": 1, "analysi": 2, "applic": 1, "approach": 1, "architectur": 1, "base": 1, "biolog": 1, "bodi": 1, "characterist": 1, "chosen": 1, "data": 3, "deriv": 1, "discuss": 1, "earli": 1, "encount": 1, "environ": 1, "experiment": 1, "experi": 1, "gener": 1, "implement": 1, "investig": 1, "ition": 1, "larg": 2, "multiprogram": 1, "object": 1, "obtain": 1, "onlin": 1, "orient": 1, "problem": 1, "research": 1, "scheme": 1, "scientif": 1, "system": 1, "lockemann": 1, "knutsen": 1}}, "1508": {"id": "1508", "title": "Magnetic Tape Labels for Information Interchange (Proposed USA Standard)", "words_pool": ["inform", "interchang", "label", "magnet", "propos", "standard", "tape", "usa"], "word_count": {"inform": 1, "interchang": 1, "label": 1, "magnet": 1, "propos": 1, "standard": 1, "tape": 1, "usa": 1}}, "1509": {"id": "1509", "title": "Recorded Magnetic Tape for Information Interchange (200 CPI, NRZI) (Proposed USA Standard)", "words_pool": ["cpi", "inform", "interchang", "magnet", "nrzi", "propos", "record", "standard", "tape", "usa"], "word_count": {"cpi": 1, "inform": 1, "interchang": 1, "magnet": 1, "nrzi": 1, "propos": 1, "record": 1, "standard": 1, "tape": 1, "usa": 1}}, "1510": {"id": "1510", "title": "Finding a Solution of N Functional Equations in N Unknown (Algorithm 314 [C5])", "authors": "Dulley, D", "words_pool": ["algorithm", "c5", "equat", "find", "function", "solut", "unknown", "dulley"], "word_count": {"algorithm": 1, "c5": 1, "equat": 1, "find": 1, "function": 1, "solut": 1, "unknown": 1, "dulley": 1}}, "1511": {"id": "1511", "title": "The Damped Taylor's Series Method for Minimizing a Sum of Squares and for Solving Systems of  Nonlinear Equations", "authors": "Spath, H.", "words_pool": ["damp", "equat", "method", "minim", "nonlinear", "seri", "solv", "squar", "sum", "system", "taylor", "spath"], "word_count": {"damp": 1, "equat": 1, "method": 1, "minim": 1, "nonlinear": 1, "seri": 1, "solv": 1, "squar": 1, "sum": 1, "system": 1, "taylor": 1, "spath": 1}}, "1512": {"id": "1512", "title": "Solution of Simultaneous Non-Linear Equations (Algorithm 316[C5])", "authors": "Brown, K. M.", "words_pool": ["algorithm", "c5", "equat", "linear", "non", "simultan", "solut", "brown"], "word_count": {"algorithm": 1, "c5": 1, "equat": 1, "linear": 1, "non": 1, "simultan": 1, "solut": 1, "brown": 1}}, "1513": {"id": "1513", "title": "PERMUTATION (Algorithm 317 [G6])", "authors": "Robinson, C. L.", "words_pool": ["algorithm", "g6", "permut", "robinson"], "word_count": {"algorithm": 1, "g6": 1, "permut": 1, "robinson": 1}}, "1514": {"id": "1514", "title": "On the Expected Gain From Adjust ing Matched Term Retrieval Systems", "abstract": "A file adjustment procedure based on maximizing the Bayes expected gain proposed for matched  term retrieval systems.  The expected gain and its probability distribution are derived as a function  of: (1) the prior proportion of omitted terms, and (2) the coefficient of separation between two distributions  corresponding to values of an adjustment statistic.  An example evaluates the gain parameters for a typical  information retrieval system.", "authors": "Shumway, R. H.", "words_pool": ["adjust", "adjust", "base", "bay", "coeffici", "deriv", "distribut", "distribut", "evalu", "expect", "function", "gain", "inform", "ing", "match", "maxim", "omit", "paramet", "prior", "probabl", "procedur", "proport", "propos", "retriev", "separ", "statist", "system", "system", "term", "term", "typic", "valu", "shumway"], "word_count": {"adjust": 2, "base": 1, "bay": 1, "coeffici": 1, "deriv": 1, "distribut": 2, "evalu": 1, "expect": 2, "function": 1, "gain": 3, "inform": 1, "ing": 1, "match": 1, "maxim": 1, "omit": 1, "paramet": 1, "prior": 1, "probabl": 1, "procedur": 1, "proport": 1, "propos": 1, "retriev": 2, "separ": 1, "statist": 1, "system": 2, "term": 2, "typic": 1, "valu": 1, "shumway": 1}}, "1515": {"id": "1515", "title": "A Computer System for Inference Execution and Data Retrieval", "abstract": "This paper presents a RAND project concerned with the use of computers as assistants in the  logical analysis of large collections of factual data.  A system called Relational Data File was developed  for this purpose.  The Relational Data File is briefly detailed and problems arising from its implementation  are discussed.", "authors": "Levien, R. E.", "words_pool": ["analysi", "aris", "assist", "briefli", "call", "collect", "comput", "comput", "concern", "data", "detail", "develop", "discuss", "execut", "factual", "implement", "infer", "larg", "logic", "paper", "present", "problem", "project", "purpos", "rand", "relat", "retriev", "system", "levien"], "word_count": {"analysi": 1, "aris": 1, "assist": 1, "briefli": 1, "call": 1, "collect": 1, "comput": 1, "concern": 1, "data": 3, "detail": 1, "develop": 1, "discuss": 1, "execut": 1, "factual": 1, "implement": 1, "infer": 1, "larg": 1, "logic": 1, "paper": 1, "present": 1, "problem": 1, "project": 1, "purpos": 1, "rand": 1, "relat": 2, "retriev": 1, "system": 1, "levien": 1}}, "1516": {"id": "1516", "title": "Automatic Data Compression", "abstract": "The \"information explosion\" noted in recent years makes it essential that storage requirements  for all information be kept to a minimum.  A fully automatic and rapid three-part compressor which can  be used with \"any\" body of information to greatly reduce slow external storage requirements and to increase  the rate of information transmission through a computer is described in this paper.  The system will  also automatically decode the compressed information on an item-by-item basis when it is required.  The  three component compressors, which can be used separately to accomplish their specific tasks, are discussed:  NUPAK for the automatic compression of numerical data, ANPAK for the automatic compression of \"any\" information,  and IOPAK for further compression of information to be stored on tape or cards.", "authors": "Marron, B. A. DeMaine, P. A. D.", "words_pool": ["accomplish", "anpak", "automat", "basi", "bodi", "card", "compon", "compress", "compress", "compressor", "compressor", "comput", "data", "decod", "discuss", "essenti", "explos", "extern", "fulli", "greatli", "increas", "inform", "iopak", "item", "make", "minimum", "note", "numer", "nupak", "paper", "part", "rapid", "rate", "recent", "reduc", "requir", "requir", "separ", "slow", "specif", "storag", "store", "system", "tape", "task", "transmiss", "year", "marron", "demain"], "word_count": {"accomplish": 1, "anpak": 1, "automat": 3, "basi": 1, "bodi": 1, "card": 1, "compon": 1, "compress": 4, "compressor": 2, "comput": 1, "data": 1, "decod": 1, "discuss": 1, "essenti": 1, "explos": 1, "extern": 1, "fulli": 1, "greatli": 1, "increas": 1, "inform": 7, "iopak": 1, "item": 2, "make": 1, "minimum": 1, "note": 1, "numer": 1, "nupak": 1, "paper": 1, "part": 1, "rapid": 1, "rate": 1, "recent": 1, "reduc": 1, "requir": 3, "separ": 1, "slow": 1, "specif": 1, "storag": 2, "store": 1, "system": 1, "tape": 1, "task": 1, "transmiss": 1, "year": 1, "marron": 1, "demain": 1}}, "1517": {"id": "1517", "title": "Methods for Analyzing Data from Computer Simulation Experiments", "abstract": "This paper addresses itself to the problem of analyzing data generated by computer simulations  of economic systems.  We first turn to a hypothetical firm, whose operation is represented by  single-channel,  multistation queueing model.  The firm seeks to maximize total expected profit for the coming period  by selecting one of five operating plans, where each plan incorporates a certain marketing strategy,  an allocation of productive inputs, and a total cost.  The results of the simulated activity under each  plan are subjected to an F-test, two multiple comparison methods, and a multiple ranking method.  We  illustrate, compare, and evaluate these techniques.  The paper adopts the position that the particular  technique of analysis (possibly not any one of the above) chosen by the experimenter should be an expression  of his experimental objective: The F-test tests the homogeneity of the plans; multiple comparison methods  quantify their differences; and multiple ranking methods directly identify the one best plan or best  plans.", "authors": "Naylor, T. H. Wertz, K. Wonnacott, T. H.", "words_pool": ["activ", "address", "adopt", "alloc", "analysi", "analyz", "channel", "chosen", "come", "compar", "comparison", "comput", "cost", "data", "differ", "directli", "econom", "evalu", "expect", "experiment", "experiment", "experi", "express", "firm", "gener", "homogen", "hypothet", "identifi", "illustr", "incorpor", "input", "market", "maxim", "method", "method", "model", "multipl", "multist", "object", "oper", "oper", "paper", "period", "plan", "plan", "posit", "possibl", "problem", "product", "profit", "quantifi", "queue", "rank", "repres", "result", "seek", "select", "simul", "simul", "simul", "singl", "strategi", "subject", "system", "techniqu", "techniqu", "test", "test", "total", "turn", "naylor", "wertz", "wonnacott"], "word_count": {"activ": 1, "address": 1, "adopt": 1, "alloc": 1, "analysi": 1, "analyz": 1, "channel": 1, "chosen": 1, "come": 1, "compar": 1, "comparison": 2, "comput": 1, "cost": 1, "data": 1, "differ": 1, "directli": 1, "econom": 1, "evalu": 1, "expect": 1, "experiment": 2, "experi": 1, "express": 1, "firm": 2, "gener": 1, "homogen": 1, "hypothet": 1, "identifi": 1, "illustr": 1, "incorpor": 1, "input": 1, "market": 1, "maxim": 1, "method": 4, "model": 1, "multipl": 4, "multist": 1, "object": 1, "oper": 2, "paper": 2, "period": 1, "plan": 6, "posit": 1, "possibl": 1, "problem": 1, "product": 1, "profit": 1, "quantifi": 1, "queue": 1, "rank": 2, "repres": 1, "result": 1, "seek": 1, "select": 1, "simul": 2, "singl": 1, "strategi": 1, "subject": 1, "system": 1, "techniqu": 2, "test": 3, "total": 2, "turn": 1, "naylor": 1, "wertz": 1, "wonnacott": 1}}, "1518": {"id": "1518", "title": "An Experimental Model of System/360", "abstract": "The problem of predicting the performance of modern computer systems is formidable.  One general  technique which can ease this problem is macroscopic simulation.  This paper reports on the applicability  of that technique to System/360.  The paper describes an experimental model of System/360-its hardware,  software, and its environment.  The measures of system performance produced by the model consist of statistics  relating to turnaround time, throughput, hardware utilization, software utilization, and queueing processes.   The model is mechanized in SIMSCRIPT and consists of some 1750 statements.  An auxiliary programs, the  Job Generator, creates automatically the properties of System/360 jobs that get simulated.", "authors": "Katz, J. H.", "words_pool": ["applic", "auxiliari", "comput", "consist", "consist", "creat", "describ", "eas", "environ", "experiment", "formid", "gener", "gener", "hardwar", "job", "job", "macroscop", "measur", "mechan", "model", "modern", "paper", "perform", "predict", "problem", "process", "produc", "program", "properti", "queue", "relat", "report", "simscript", "simul", "simul", "softwar", "statement", "statist", "system", "system", "techniqu", "throughput", "time", "turnaround", "util", "katz"], "word_count": {"applic": 1, "auxiliari": 1, "comput": 1, "consist": 2, "creat": 1, "describ": 1, "eas": 1, "environ": 1, "experiment": 1, "formid": 1, "gener": 2, "hardwar": 2, "job": 2, "macroscop": 1, "measur": 1, "mechan": 1, "model": 3, "modern": 1, "paper": 2, "perform": 2, "predict": 1, "problem": 2, "process": 1, "produc": 1, "program": 1, "properti": 1, "queue": 1, "relat": 1, "report": 1, "simscript": 1, "simul": 2, "softwar": 2, "statement": 1, "statist": 1, "system": 5, "techniqu": 2, "throughput": 1, "time": 1, "turnaround": 1, "util": 2, "katz": 1}}, "1519": {"id": "1519", "title": ". 1900, and can handle a large number of online console users while at the same time running several  off line (background) jobs.  The system is not oriented towards either mode and can be either a batch  processing system (such as the ATLAS Supervisor, IBSYS, or GECOS), or a multiaccess system (resembling,  to the user, CTSS or MULTICS), or both simultaneously, depending on the installation, which can adjust  the Schedulers.  Both online users and off line jobs use a common Command Language.  The system includes  a Multilevel device-independent File Store.", "abstract": "An Operating System is described which will run on a wide variety of configurations of the  I", "authors": "Oestreicher, M. D. Bailey, M. J. Strauss, J. I.", "words_pool": ["adjust", "atla", "background", "batch", "command", "common", "configur", "consol", "ctss", "depend", "devic", "geco", "handl", "ibsi", "includ", "independ", "instal", "job", "languag", "larg", "line", "mode", "multiaccess", "multic", "multilevel", "number", "onlin", "oper", "orient", "process", "resembl", "run", "run", "schedul", "simultan", "store", "supervisor", "system", "time", "user", "user", "varieti", "wide", "oestreich", "bailey", "strauss"], "word_count": {"adjust": 1, "atla": 1, "background": 1, "batch": 1, "command": 1, "common": 1, "configur": 1, "consol": 1, "ctss": 1, "depend": 1, "devic": 1, "geco": 1, "handl": 1, "ibsi": 1, "includ": 1, "independ": 1, "instal": 1, "job": 2, "languag": 1, "larg": 1, "line": 2, "mode": 1, "multiaccess": 1, "multic": 1, "multilevel": 1, "number": 1, "onlin": 2, "oper": 1, "orient": 1, "process": 1, "resembl": 1, "run": 1, "schedul": 1, "simultan": 1, "store": 1, "supervisor": 1, "system": 1, "time": 1, "user": 3, "varieti": 1, "wide": 1, "oestreich": 1, "bailey": 1, "strauss": 1}}, "1520": {"id": "1520", "title": "Absolute Value and Square Root of a Complex Number (Algorithm 312 [A2])", "authors": "Friedland, P.", "words_pool": ["a2", "absolut", "algorithm", "complex", "number", "root", "squar", "friedland"], "word_count": {"a2": 1, "absolut": 1, "algorithm": 1, "complex": 1, "number": 1, "root": 1, "squar": 1, "friedland": 1}}, "1521": {"id": "1521", "title": "Multi-Dimensional Partition Generator (Algorithm 313 [A1])", "authors": "Bratley, P. McKay, J. K. S.", "words_pool": ["a1", "algorithm", "dimension", "gener", "multi", "partit", "bratley", "mckay"], "word_count": {"a1": 1, "algorithm": 1, "dimension": 1, "gener": 1, "multi": 1, "partit": 1, "bratley": 1, "mckay": 1}}, "1522": {"id": "1522", "title": "Chebyschev Quadrature (Algorithm 279 [D1])", "authors": "Hillstrom, K.", "words_pool": ["algorithm", "chebyschev", "d1", "quadratur", "hillstrom"], "word_count": {"algorithm": 1, "chebyschev": 1, "d1": 1, "quadratur": 1, "hillstrom": 1}}, "1523": {"id": "1523", "title": "SHARER, a Time Sharing System for the CDC 6600", "abstract": "A time sharing system embedded within the standard batch processing system for the CDC 6600  is described.  The system is general purpose and file-based, providing facilities for file input, manipulation,  editing, compilation, and conversational execution.  It uses a simple scheme for system extension for  a machine with only one relocation and memory bound register.  No attempt was made to use reentrant code,  or to simulate segmentation or paging.  Implementation time was approximately six man-years, with the  majority of the code being written in FORTRAN.", "authors": "Harrison, M. C. Schwartz, J. T.", "words_pool": ["approxim", "attempt", "base", "batch", "bound", "cdc", "code", "compil", "convers", "edit", "embed", "execut", "extens", "facil", "fortran", "gener", "implement", "input", "machin", "made", "major", "man", "manipul", "memori", "page", "process", "provid", "purpos", "reentrant", "regist", "reloc", "scheme", "segment", "sharer", "share", "simpl", "simul", "standard", "system", "time", "written", "year", "harrison", "schwartz"], "word_count": {"approxim": 1, "attempt": 1, "base": 1, "batch": 1, "bound": 1, "cdc": 1, "code": 2, "compil": 1, "convers": 1, "edit": 1, "embed": 1, "execut": 1, "extens": 1, "facil": 1, "fortran": 1, "gener": 1, "implement": 1, "input": 1, "machin": 1, "made": 1, "major": 1, "man": 1, "manipul": 1, "memori": 1, "page": 1, "process": 1, "provid": 1, "purpos": 1, "reentrant": 1, "regist": 1, "reloc": 1, "scheme": 1, "segment": 1, "sharer": 1, "share": 1, "simpl": 1, "simul": 1, "standard": 1, "system": 4, "time": 2, "written": 1, "year": 1, "harrison": 1, "schwartz": 1}}, "1524": {"id": "1524", "title": "A Stopping Criterion for Polynomial Root Finding", "abstract": "When searching for the root of a polynomial, it is generally difficult to know just when to  accept a number as an adequate approximation to the root.  In this paper an algorithm is presented which  allows one to terminate the iteration process on the basis of calculated bounds for the roundoff error  which occurs in evaluating the polynomial.  This stopping criterion has been tested on numerous examples  and has been found to serve as a satisfactory means for accepting a complex number as a zero of a real  polynomial.", "authors": "Adams, D. A.", "words_pool": ["accept", "accept", "adequ", "algorithm", "approxim", "basi", "bound", "calcul", "complex", "criterion", "difficult", "error", "evalu", "exampl", "find", "found", "gener", "iter", "know", "mean", "number", "numer", "occur", "paper", "polynomi", "present", "process", "real", "root", "roundoff", "satisfactori", "search", "serv", "stop", "termin", "test", "adam"], "word_count": {"accept": 2, "adequ": 1, "algorithm": 1, "approxim": 1, "basi": 1, "bound": 1, "calcul": 1, "complex": 1, "criterion": 1, "difficult": 1, "error": 1, "evalu": 1, "exampl": 1, "find": 1, "found": 1, "gener": 1, "iter": 1, "know": 1, "mean": 1, "number": 2, "numer": 1, "occur": 1, "paper": 1, "polynomi": 3, "present": 1, "process": 1, "real": 1, "root": 2, "roundoff": 1, "satisfactori": 1, "search": 1, "serv": 1, "stop": 1, "termin": 1, "test": 1, "adam": 1}}, "1525": {"id": "1525", "title": "On Computing The Fast Fourier Transform", "abstract": "Cooley and Tukey have proposed a fast algorithm for computing complex Fourier transform and  have shown major time savings in using it to compute large transforms on a digital computer.  With n  a power of two, computing time for this algorithm is proportional to n log2 n, a major improvement over  other methods with computing time proportional to n^2.  In this paper, the fast Fourier transform algorithm  is briefly reviewed and fast difference equation methods for accurately computing the needed trigonometric  function values are given.  The problem of computing a large Fourier transform on a system with virtual  memory is considered, and a solution is proposed.  This method has been used to compute complex Fourier  transforms of size n = 2^16 on a computer with 2^15 words of core storage; this exceeds by a factor of  eight the maximum radix two transform size with fixed allocation of this amount of core storage.  The  method has also been used to compute large mixed radix transforms.  A scaling plan for computing the  fast Fourier transform with fixed-point arithmetic is also given.", "authors": "Singleton, R. C.", "words_pool": ["accur", "algorithm", "alloc", "amount", "arithmet", "briefli", "complex", "comput", "comput", "comput", "consid", "cooley", "core", "differ", "digit", "equat", "exce", "factor", "fast", "fix", "fourier", "function", "improv", "larg", "log2", "major", "maximum", "memori", "method", "method", "mix", "need", "paper", "plan", "point", "power", "problem", "proport", "propos", "radix", "review", "save", "scale", "shown", "size", "solut", "storag", "system", "time", "transform", "transform", "trigonometr", "tukey", "valu", "virtual", "word", "singleton"], "word_count": {"accur": 1, "algorithm": 3, "alloc": 1, "amount": 1, "arithmet": 1, "briefli": 1, "complex": 2, "comput": 11, "consid": 1, "cooley": 1, "core": 2, "differ": 1, "digit": 1, "equat": 1, "exce": 1, "factor": 1, "fast": 4, "fix": 2, "fourier": 5, "function": 1, "improv": 1, "larg": 3, "log2": 1, "major": 2, "maximum": 1, "memori": 1, "method": 4, "mix": 1, "need": 1, "paper": 1, "plan": 1, "point": 1, "power": 1, "problem": 1, "proport": 2, "propos": 2, "radix": 2, "review": 1, "save": 1, "scale": 1, "shown": 1, "size": 2, "solut": 1, "storag": 2, "system": 1, "time": 3, "transform": 8, "trigonometr": 1, "tukey": 1, "valu": 1, "virtual": 1, "word": 1, "singleton": 1}}, "1526": {"id": "1526", "title": "Multiprogramming under a Page on Demand Strategy", "abstract": "A model of multiprogramming for a particular computer system using a page on demand strategy  is developed.  Analysis of this model is used to predict performance (measured by the average usage of  the CPU) when user programs are typical of those arising from an interactive time sharing environment.   The effect of several hardware modifications is also analyzed.  A parameter, readily calculated from  the hardware characteristics and the program statistics, is proposed for gauging the effect of multiprogramming.", "authors": "Smith, J. L.", "words_pool": ["analysi", "analyz", "aris", "averag", "calcul", "characterist", "comput", "cpu", "demand", "develop", "effect", "environ", "gaug", "hardwar", "interact", "measur", "model", "modif", "multiprogram", "page", "paramet", "perform", "predict", "program", "program", "propos", "readili", "share", "statist", "strategi", "system", "time", "typic", "usag", "user", "smith"], "word_count": {"analysi": 1, "analyz": 1, "aris": 1, "averag": 1, "calcul": 1, "characterist": 1, "comput": 1, "cpu": 1, "demand": 1, "develop": 1, "effect": 2, "environ": 1, "gaug": 1, "hardwar": 2, "interact": 1, "measur": 1, "model": 2, "modif": 1, "multiprogram": 2, "page": 1, "paramet": 1, "perform": 1, "predict": 1, "program": 2, "propos": 1, "readili": 1, "share": 1, "statist": 1, "strategi": 1, "system": 1, "time": 1, "typic": 1, "usag": 1, "user": 1, "smith": 1}}, "1527": {"id": "1527", "title": "A Grammar Base Question Answering Procedure", "abstract": "The subject of this paper is a procedure for the automatic retrieval of certain segments of  stored information, either explicitly or implicitly represented, through questions posed in natural language  sentences.  This procedure makes use of a sentence recognition device for the class of grammars which  will correctly decide between the grammatical and ungrammatical sentences of a natural language.  It  is possible to make use of a recognition device of this sort for the following reason: Much data is fully  expressible as a set of sentences in a natural language, a set which can be exhaustively and exclusively  generated by a grammar.  Based upon the rules of this grammar, a sentence recognizer will evaluate sentences,  questions in the normal situation.  Since the recognition function succeeds just in case the posed question  is drawn from the set of sentences expressing the data, or, more correctly, is grammatical in terms of  the grammar for this set of sentences, sentence recognition itself is a procedure for retrieving information.   When the recognition function succeeds, its value represents the requested information.", "authors": "Rosenbaum, P.", "words_pool": ["answer", "automat", "base", "base", "case", "class", "correctli", "data", "decid", "devic", "drawn", "evalu", "exclus", "exhaust", "explicitli", "express", "express", "fulli", "function", "gener", "grammar", "grammar", "grammat", "implicitli", "inform", "languag", "make", "make", "natur", "normal", "paper", "pose", "procedur", "question", "question", "reason", "recognit", "recogn", "repres", "repres", "request", "retriev", "retriev", "rule", "segment", "sentenc", "sentenc", "set", "situat", "sort", "store", "subject", "succe", "term", "ungrammat", "rosenbaum"], "word_count": {"answer": 1, "automat": 1, "base": 1, "case": 1, "class": 1, "correctli": 2, "data": 2, "decid": 1, "devic": 2, "drawn": 1, "evalu": 1, "exclus": 1, "exhaust": 1, "explicitli": 1, "express": 2, "fulli": 1, "function": 2, "gener": 1, "grammar": 4, "grammat": 2, "implicitli": 1, "inform": 3, "languag": 3, "make": 2, "natur": 3, "normal": 1, "paper": 1, "pose": 2, "procedur": 3, "question": 3, "reason": 1, "recognit": 5, "recogn": 1, "repres": 2, "request": 1, "retriev": 2, "rule": 1, "segment": 1, "sentenc": 9, "set": 4, "situat": 1, "sort": 1, "store": 1, "subject": 1, "succe": 2, "term": 1, "ungrammat": 1, "rosenbaum": 1}}, "1528": {"id": "1528", "title": "Three Fonts of Computer Drawn Letters", "abstract": "Detailed descriptions are given for three fonts of letters.  Letter shapes are entirely described  by numbers.  The basic vectors are in a general form so the fonts may be easily drawn on a variety of  computers and cathode-ray tubes.  The fonts include both upper and lower case Roman letters, mathematical  signs, and upper and lower case Greek letters.  Design of the fonts is described.  However, the principal  contribution of this paper concerns the fonts themselves.", "authors": "Mathews, M. V. Lochbaum, C. Moss, J. A.", "words_pool": ["basic", "case", "cathod", "comput", "comput", "concern", "contribut", "descript", "design", "detail", "drawn", "easili", "entir", "font", "form", "gener", "greek", "includ", "letter", "letter", "lower", "mathemat", "number", "paper", "princip", "ray", "roman", "shape", "sign", "tube", "upper", "varieti", "vector", "mathew", "lochbaum", "moss"], "word_count": {"basic": 1, "case": 2, "cathod": 1, "comput": 1, "concern": 1, "contribut": 1, "descript": 1, "design": 1, "detail": 1, "drawn": 1, "easili": 1, "entir": 1, "font": 5, "form": 1, "gener": 1, "greek": 1, "includ": 1, "letter": 4, "lower": 2, "mathemat": 1, "number": 1, "paper": 1, "princip": 1, "ray": 1, "roman": 1, "shape": 1, "sign": 1, "tube": 1, "upper": 2, "varieti": 1, "vector": 1, "mathew": 1, "lochbaum": 1, "moss": 1}}, "1529": {"id": "1529", "title": "Decomposition Programming An Analysis of Matrix Substructure", "abstract": "A petroleum blending problem was analyzed in order to compare the primal and primal-dual decomposition  algorithms.  In the course of the analysis, a substructure was discovered which has relevance to the  relative performance of the two algorithms and to their absolute performance as compared with a standard  primal-Simplex solution without decomposition.", "authors": "Bell, E. J.", "words_pool": ["absolut", "algorithm", "analysi", "analyz", "blend", "compar", "compar", "cours", "decomposit", "discov", "dual", "matrix", "order", "perform", "petroleum", "primal", "problem", "program", "rel", "relev", "simplex", "solut", "standard", "substructur", "bell"], "word_count": {"absolut": 1, "algorithm": 2, "analysi": 1, "analyz": 1, "blend": 1, "compar": 2, "cours": 1, "decomposit": 2, "discov": 1, "dual": 1, "matrix": 1, "order": 1, "perform": 2, "petroleum": 1, "primal": 3, "problem": 1, "program": 1, "rel": 1, "relev": 1, "simplex": 1, "solut": 1, "standard": 1, "substructur": 1, "bell": 1}}, "1530": {"id": "1530", "title": ". Atlas 2 computers and is intended as a tool to allow users to extend any existing programming  language by incorporating new statements and other syntactic forms of their own choosing and in their  own notation.  This allows a complete user-oriented language to be built up with relative ease.", "abstract": "A general purpose macro processor called ML/I is described.  ML/I has been implemented on the  PDP-7 and I", "authors": "Brown, P. J.", "words_pool": ["allow", "atla", "built", "call", "choos", "complet", "comput", "eas", "exist", "extend", "form", "gener", "implement", "incorpor", "intend", "languag", "macro", "ml", "notat", "orient", "pdp", "processor", "program", "purpos", "rel", "statement", "syntact", "tool", "user", "user", "brown"], "word_count": {"allow": 1, "atla": 1, "built": 1, "call": 1, "choos": 1, "complet": 1, "comput": 1, "eas": 1, "exist": 1, "extend": 1, "form": 1, "gener": 1, "implement": 1, "incorpor": 1, "intend": 1, "languag": 2, "macro": 1, "ml": 2, "notat": 1, "orient": 1, "pdp": 1, "processor": 1, "program": 1, "purpos": 1, "rel": 1, "statement": 1, "syntact": 1, "tool": 1, "user": 2, "brown": 1}}, "1531": {"id": "1531", "title": "The Remaining Trouble Spots in ALGOL 60", "abstract": "This paper lists the ambiguities remaining in the language ALGOL 60, which have been noticed  since the publication of the Revised ALGOL 60 Report in 1963.", "authors": "Knuth, D. E.", "words_pool": ["algol", "ambigu", "languag", "list", "notic", "paper", "public", "remain", "report", "revis", "spot", "troubl", "knuth"], "word_count": {"algol": 2, "ambigu": 1, "languag": 1, "list": 1, "notic": 1, "paper": 1, "public": 1, "remain": 1, "report": 1, "revis": 1, "spot": 1, "troubl": 1, "knuth": 1}}, "1532": {"id": "1532", "title": "The Hardware-Software Complementarity", "authors": "Oettinger, A. G.", "words_pool": ["complementar", "hardwar", "softwar", "oetting"], "word_count": {"complementar": 1, "hardwar": 1, "softwar": 1, "oetting": 1}}, "1533": {"id": "1533", "title": "A Marovian Model of the University of Michigan Executive System", "abstract": "A mathematical model of a computer's executive system is postulated and its parameters estimated  with the aid of extensive data on the system's operation.  Although simplifying assumptions are made,  the results predicted by the model agree reasonable well with actual results.  The model is used to study  the effects of changes in the executive system and in one of its compilers.  Further applications of  the model are discussed.", "authors": "Foley, J. D.", "words_pool": ["actual", "agre", "aid", "applic", "assumpt", "compil", "comput", "data", "discuss", "effect", "estim", "execut", "extens", "made", "marovian", "mathemat", "michigan", "model", "oper", "paramet", "postul", "predict", "reason", "result", "simplifi", "studi", "system", "univers", "foley"], "word_count": {"actual": 1, "agre": 1, "aid": 1, "applic": 1, "assumpt": 1, "compil": 1, "comput": 1, "data": 1, "discuss": 1, "effect": 1, "estim": 1, "execut": 2, "extens": 1, "made": 1, "marovian": 1, "mathemat": 1, "michigan": 1, "model": 4, "oper": 1, "paramet": 1, "postul": 1, "predict": 1, "reason": 1, "result": 2, "simplifi": 1, "studi": 1, "system": 3, "univers": 1, "foley": 1}}, "1534": {"id": "1534", "title": "DAD, The C.S", "words_pool": ["dad"], "word_count": {"dad": 1}}, ".R.O. Operating System": {"id": ".R.O. Operating System", "abstract": "The design and implementation of the C.S", "words_pool": ["design", "implement"], "word_count": {"design": 1, "implement": 1}}, ".R.O. operating system, DAD, is described in detail.   This system is designed for the Control Data 3600 using a large drum backing store and is intended to  allow the integration of a remote console (display) subsystem into a conventional job stack environment.   The use of the drums, the buffering of input and output on slow peripherals, and the execution of normal  job stack work are described.  The display subsystem is described only as it integrates into the rest  of the system.  The techniques found useful in the development of DAD are given, and an assessment is  made of the validity of various design decisions.  Performance figures based on several months of operation  are tabulated.": {"id": ".R.O. operating system, DAD, is described in detail.   This system is designed for the Control Data 3600 using a large drum backing store and is intended to  allow the integration of a remote console (display) subsystem into a conventional job stack environment.   The use of the drums, the buffering of input and output on slow peripherals, and the execution of normal  job stack work are described.  The display subsystem is described only as it integrates into the rest  of the system.  The techniques found useful in the development of DAD are given, and an assessment is  made of the validity of various design decisions.  Performance figures based on several months of operation  are tabulated.", "authors": "Austin, B. J. Holden, T. S. Hudson, R. H.", "words_pool": ["austin", "holden", "hudson"], "word_count": {"austin": 1, "holden": 1, "hudson": 1}}, "1535": {"id": "1535", "title": "A Comment on Index Register Allocation", "abstract": "A technique is presented to reduce the enumeration required by a known procedure for optimal  index register allocation in straight-line programs.  This technique is based on the construction of  a link diagram, which shows at any step the future occurrences of indexes which must be loaded into index  registers.  This diagram determines in advance the required register configuration at certain steps of  the program, so that the program is subdivided into separate portions to which the allocation procedure  may be applied independently.", "authors": "Luccio, F.", "words_pool": ["advanc", "alloc", "appli", "base", "comment", "configur", "construct", "determin", "diagram", "enumer", "futur", "independ", "index", "index", "known", "line", "link", "load", "occurr", "optim", "portion", "present", "procedur", "program", "program", "reduc", "regist", "regist", "requir", "separ", "show", "step", "step", "straight", "subdivid", "techniqu", "luccio"], "word_count": {"advanc": 1, "alloc": 2, "appli": 1, "base": 1, "comment": 1, "configur": 1, "construct": 1, "determin": 1, "diagram": 2, "enumer": 1, "futur": 1, "independ": 1, "index": 3, "known": 1, "line": 1, "link": 1, "load": 1, "occurr": 1, "optim": 1, "portion": 1, "present": 1, "procedur": 2, "program": 3, "reduc": 1, "regist": 3, "requir": 2, "separ": 1, "show": 1, "step": 2, "straight": 1, "subdivid": 1, "techniqu": 2, "luccio": 1}}, "1536": {"id": "1536", "title": "Dynamic Computation of Derivatives", "abstract": "It is shown how Wengert's procedure for computation of derivatives can be implemented conveniently  by use of compiler-generated complex addition, subtraction, and linkage to complex arithmetic subroutines.  Evaluation of a function and derivative proceed in parallel, as in Wengert's procedure, but with the  \"imaginary\" parts of variables declared complex bearing the values of the derivatives of the real parts.   This technique provides a simple way to compute the derivatives of a function, without the need for  deriving and programming the evaluation of explicit formulas for the derivatives.", "authors": "Lesk, A. M.", "words_pool": ["addit", "arithmet", "bear", "compil", "complex", "comput", "comput", "conveni", "declar", "deriv", "deriv", "deriv", "dynam", "evalu", "explicit", "formula", "function", "gener", "imaginari", "implement", "linkag", "need", "parallel", "part", "procedur", "proceed", "program", "real", "shown", "simpl", "subroutin", "subtract", "techniqu", "valu", "variabl", "wengert", "lesk"], "word_count": {"addit": 1, "arithmet": 1, "bear": 1, "compil": 1, "complex": 3, "comput": 2, "conveni": 1, "declar": 1, "deriv": 6, "dynam": 1, "evalu": 2, "explicit": 1, "formula": 1, "function": 2, "gener": 1, "imaginari": 1, "implement": 1, "linkag": 1, "need": 1, "parallel": 1, "part": 2, "procedur": 2, "proceed": 1, "program": 1, "real": 1, "shown": 1, "simpl": 1, "subroutin": 1, "subtract": 1, "techniqu": 1, "valu": 1, "variabl": 1, "wengert": 2, "lesk": 1}}, "1537": {"id": "1537", "title": "Prime Number Generator 1 (Algorithm 310 [A1])", "authors": "Chartres, B. A.", "words_pool": ["a1", "algorithm", "gener", "number", "prime", "chartr"], "word_count": {"a1": 1, "algorithm": 1, "gener": 1, "number": 1, "prime": 1, "chartr": 1}}, "1538": {"id": "1538", "title": "Prime Number Generator 2 (Algorithm 311 [A1])", "authors": "Chartres, B. A.", "words_pool": ["a1", "algorithm", "gener", "number", "prime", "chartr"], "word_count": {"a1": 1, "algorithm": 1, "gener": 1, "number": 1, "prime": 1, "chartr": 1}}, "1539": {"id": "1539", "title": "Prime Number Generator 1; Prime Number Generator 2 (Algorithm 35[A1]; Algorithm 310[A1]; Algorithm  311[A1])", "authors": "Chartres, B. A.", "words_pool": ["a1", "algorithm", "gener", "number", "prime", "chartr"], "word_count": {"a1": 3, "algorithm": 3, "gener": 2, "number": 2, "prime": 2, "chartr": 1}}, "1540": {"id": "1540", "title": "An Algorithm for Class Scheduling With Section Preference", "abstract": "An algorithm for assignment of students to classes in a fixed time schedule that allows students  to give a preference for sections within courses is given.  If consistent with the objective of balanced  sections, these preferences will be honored.  The algorithm is more stochastic than Monte Carlo in nature.   Results are given that compare it to a nonpreference assignment algorithm.", "authors": "Busam, V. A.", "words_pool": ["algorithm", "assign", "balanc", "carlo", "class", "class", "compar", "consist", "cours", "fix", "give", "honor", "mont", "natur", "nonprefer", "object", "prefer", "prefer", "result", "schedul", "schedul", "section", "section", "stochast", "student", "time", "busam"], "word_count": {"algorithm": 3, "assign": 2, "balanc": 1, "carlo": 1, "class": 1, "compar": 1, "consist": 1, "cours": 1, "fix": 1, "give": 1, "honor": 1, "mont": 1, "natur": 1, "nonprefer": 1, "object": 1, "prefer": 2, "result": 1, "schedul": 1, "section": 2, "stochast": 1, "student": 2, "time": 1, "busam": 1}}, "1541": {"id": "1541", "title": "A Language for Modeling and Simulating Dynamic Systems", "abstract": "The general objective of this language is to facilitate both the modeling and experimental  aspects of simulation studies.  The ability to represent systems containing highly interactive processes  is an essential feature.  The nature of the language, and the role of the process concept, is presented  by means of an extended example.", "authors": "Parente, R. J. Krasnow, H. S.", "words_pool": ["abil", "aspect", "concept", "dynam", "essenti", "experiment", "extend", "facilit", "featur", "gener", "highli", "interact", "languag", "mean", "model", "natur", "object", "present", "process", "process", "repres", "role", "simul", "simul", "studi", "system", "parent", "krasnow"], "word_count": {"abil": 1, "aspect": 1, "concept": 1, "dynam": 1, "essenti": 1, "experiment": 1, "extend": 1, "facilit": 1, "featur": 1, "gener": 1, "highli": 1, "interact": 1, "languag": 2, "mean": 1, "model": 1, "natur": 1, "object": 1, "present": 1, "process": 2, "repres": 1, "role": 1, "simul": 1, "studi": 1, "system": 1, "parent": 1, "krasnow": 1}}, "1542": {"id": "1542", "title": "A Microprogrammed Implementation of EULER on IBM System/360 Model 30", "abstract": "An experimental processing system for the algorithmic language EULER has been implemented in  microprogramming on an IBM System/360 Model 30 using a second Read-Only Storage unit.  The system consists  of a microprogrammed compiler and a microprogrammed String Language Interpreter, and of an I/O control  program written in 360 machine language.  The system is described and results are given in terms of microprogram  and main storage space required and compiler and interpreter performance obtained.  The role of microprogramming  is stressed, which opens a new dimension in the processing of interpretive code.  The structure and content  of a higher level language can be matched by an appropriate interpretive language which can be executed  efficiently by microprograms on existing computer hardware.", "authors": "Weber, H.", "words_pool": ["algorithm", "code", "compil", "comput", "consist", "content", "control", "dimens", "effici", "euler", "execut", "exist", "experiment", "hardwar", "higher", "ibm", "implement", "implement", "interpret", "interpret", "languag", "level", "machin", "main", "match", "microprogram", "microprogram", "microprogram", "microprogram", "model", "obtain", "open", "perform", "process", "program", "read", "requir", "result", "role", "space", "storag", "stress", "string", "structur", "system", "term", "unit", "written", "weber"], "word_count": {"algorithm": 1, "code": 1, "compil": 2, "comput": 1, "consist": 1, "content": 1, "control": 1, "dimens": 1, "effici": 1, "euler": 1, "execut": 1, "exist": 1, "experiment": 1, "hardwar": 1, "higher": 1, "ibm": 1, "implement": 1, "interpret": 4, "languag": 5, "level": 1, "machin": 1, "main": 1, "match": 1, "microprogram": 6, "model": 1, "obtain": 1, "open": 1, "perform": 1, "process": 2, "program": 1, "read": 1, "requir": 1, "result": 1, "role": 1, "space": 1, "storag": 2, "stress": 1, "string": 1, "structur": 1, "system": 4, "term": 1, "unit": 1, "written": 1, "weber": 1}}, "1543": {"id": "1543", "title": "Computer Formulation of the Equations of Motion Using Tensor Notation", "abstract": "A means is described for extending the area of application of digital computers beyond the  numerical data processing stage and reducing the need for human participation in the formulation of certain  types of computer problems.  By the use of tensor calculus and a computer language designed to facilitate  symbolic mathematical computation, a method has been devised whereby a digital computer can be used to  do non-numeric work, that is, symbolic algebraic manipulation and differentiation. To illustrate the  techniques involved, a digital computer has been used to derive the equations of motion of a point mass  in a general orthogonal curvilinear coordinate system.  Since this operation involves a formulation in  terms of first- and second-order differential coefficients, it provides a good demonstration of a computer's  capability to do non-numeric work and to assist in the formulation process which normally precedes the  numerical data processing stage.  Moreover, this particular problem serves to illustrate the advantages  of the mathematical techniques employed.  With the program prepared for this purpose the computer will  derive the equations of motion in any coordinate system requested by the user.   Results are presented  for the following coordinate systems: cylindrical polar, spherical polar, and prolate spheroidal.", "authors": "Howard, J. C.", "words_pool": ["advantag", "algebra", "applic", "area", "assist", "calculu", "capabl", "coeffici", "comput", "comput", "comput", "coordin", "curvilinear", "cylindr", "data", "demonstr", "deriv", "design", "devis", "differenti", "differenti", "digit", "employ", "equat", "extend", "facilit", "formul", "gener", "good", "human", "illustr", "involv", "involv", "languag", "manipul", "mass", "mathemat", "mean", "method", "motion", "need", "non", "notat", "numer", "numer", "oper", "order", "orthogon", "particip", "point", "polar", "preced", "prepar", "present", "problem", "problem", "process", "process", "program", "prolat", "purpos", "reduc", "request", "result", "serv", "spheric", "spheroid", "stage", "symbol", "system", "system", "techniqu", "tensor", "term", "type", "user", "work", "howard"], "word_count": {"advantag": 1, "algebra": 1, "applic": 1, "area": 1, "assist": 1, "calculu": 1, "capabl": 1, "coeffici": 1, "comput": 8, "coordin": 3, "curvilinear": 1, "cylindr": 1, "data": 2, "demonstr": 1, "deriv": 2, "design": 1, "devis": 1, "differenti": 2, "digit": 3, "employ": 1, "equat": 2, "extend": 1, "facilit": 1, "formul": 3, "gener": 1, "good": 1, "human": 1, "illustr": 2, "involv": 2, "languag": 1, "manipul": 1, "mass": 1, "mathemat": 2, "mean": 1, "method": 1, "motion": 2, "need": 1, "non": 2, "notat": 1, "numer": 4, "oper": 1, "order": 1, "orthogon": 1, "particip": 1, "point": 1, "polar": 2, "preced": 1, "prepar": 1, "present": 1, "problem": 2, "process": 3, "program": 1, "prolat": 1, "purpos": 1, "reduc": 1, "request": 1, "result": 1, "serv": 1, "spheric": 1, "spheroid": 1, "stage": 2, "symbol": 2, "system": 3, "techniqu": 2, "tensor": 1, "term": 1, "type": 1, "user": 1, "work": 2, "howard": 1}}, "1544": {"id": "1544", "title": "Tele-CUPL: A Telephone Time Sharing System", "abstract": "A general purpose, remote access, computing system is described, that employs twelve-key keyboard  telephones as terminals.  Audio output is provided directly to the telephone terminals, but the system  will normally be used in conjunction with remotely located high speed printing devices.  The system is  a compatible extension of an existing batch processing system.  A significant element of the system is  a scheme for transmitting alphanumeric information by single strokes on a numeric keyboard.  The programmed  scanner uses context to eliminate the ambiguity in transmission.", "authors": "Conway, R. W. Morgan, H. L.", "words_pool": ["access", "alphanumer", "ambigu", "audio", "batch", "compat", "comput", "conjunct", "context", "cupl", "devic", "directli", "element", "elimin", "employ", "exist", "extens", "gener", "high", "inform", "key", "keyboard", "locat", "numer", "output", "print", "process", "program", "provid", "purpos", "remot", "remot", "scanner", "scheme", "share", "signific", "singl", "speed", "stroke", "system", "tele", "telephon", "telephon", "termin", "time", "transmiss", "transmit", "twelv", "conway", "morgan"], "word_count": {"access": 1, "alphanumer": 1, "ambigu": 1, "audio": 1, "batch": 1, "compat": 1, "comput": 1, "conjunct": 1, "context": 1, "cupl": 1, "devic": 1, "directli": 1, "element": 1, "elimin": 1, "employ": 1, "exist": 1, "extens": 1, "gener": 1, "high": 1, "inform": 1, "key": 1, "keyboard": 2, "locat": 1, "numer": 1, "output": 1, "print": 1, "process": 1, "program": 1, "provid": 1, "purpos": 1, "remot": 2, "scanner": 1, "scheme": 1, "share": 1, "signific": 1, "singl": 1, "speed": 1, "stroke": 1, "system": 5, "tele": 1, "telephon": 2, "termin": 2, "time": 1, "transmiss": 1, "transmit": 1, "twelv": 1, "conway": 1, "morgan": 1}}, "1545": {"id": "1545", "title": "Legal Safeguards to Insure Privacy in a Computer Society", "authors": "Westin, A. F.", "words_pool": ["comput", "insur", "legal", "privaci", "safeguard", "societi", "westin"], "word_count": {"comput": 1, "insur": 1, "legal": 1, "privaci": 1, "safeguard": 1, "societi": 1, "westin": 1}}, "1546": {"id": "1546", "title": "Toward Standards for Handwritten Zero and Oh", "authors": "Bemer, R. W.", "words_pool": ["handwritten", "standard", "bemer"], "word_count": {"handwritten": 1, "standard": 1, "bemer": 1}}, "1547": {"id": "1547", "title": "Gamma Function with Arbitrary Precision (Algorithm 309 [S14])", "authors": "Filho, A. M.S. Schwachheim, G.", "words_pool": ["algorithm", "arbitrari", "function", "gamma", "precis", "s14", "filho", "schwachheim"], "word_count": {"algorithm": 1, "arbitrari": 1, "function": 1, "gamma": 1, "precis": 1, "s14": 1, "filho": 1, "schwachheim": 1}}, "1548": {"id": "1548", "title": "Parsing of Decision Tables", "abstract": "Reduction in the size of decision tables can be accomplished by several techniques.  The techniques  considered in this paper are on the parsing of decision tables with regard to horizontal and vertical  data structures, job identity, hardware and job priorities, and context relationships.  Such parsing  rests upon some conventions for the linkage of decision tables.", "authors": "Chapin, N.", "words_pool": ["accomplish", "consid", "context", "convent", "data", "decis", "hardwar", "horizont", "ident", "job", "linkag", "paper", "pars", "prioriti", "reduct", "regard", "relationship", "rest", "size", "structur", "tabl", "techniqu", "vertic", "chapin"], "word_count": {"accomplish": 1, "consid": 1, "context": 1, "convent": 1, "data": 1, "decis": 3, "hardwar": 1, "horizont": 1, "ident": 1, "job": 2, "linkag": 1, "paper": 1, "pars": 2, "prioriti": 1, "reduct": 1, "regard": 1, "relationship": 1, "rest": 1, "size": 1, "structur": 1, "tabl": 3, "techniqu": 2, "vertic": 1, "chapin": 1}}, "1549": {"id": "1549", "title": "An Efficient Machine-Independent Procedure for Garbage Collection in Various List Structures", "abstract": "A method for returning registers to the free list is an essential part of any list processing  system.  In this paper, past solutions of the recovery problem are reviewed and compared.  A new algorithm  is presented which offers significant advantages of speed and storage utilization.  The routine for implementing  this algorithm can be written in the list language with which it is to be used, thus insuring a degree  of machine independence.  Finally, the application of the algorithm to a number of different list structures  appearing in the literature is indicated.", "authors": "Schorr, H. Waite, W. M.", "words_pool": ["advantag", "algorithm", "appear", "applic", "collect", "compar", "degre", "effici", "essenti", "final", "free", "garbag", "implement", "independ", "independ", "insur", "languag", "list", "literatur", "machin", "method", "number", "offer", "paper", "part", "past", "present", "problem", "procedur", "process", "recoveri", "regist", "return", "review", "routin", "signific", "solut", "speed", "storag", "structur", "system", "util", "written", "schorr", "wait"], "word_count": {"advantag": 1, "algorithm": 3, "appear": 1, "applic": 1, "collect": 1, "compar": 1, "degre": 1, "effici": 1, "essenti": 1, "final": 1, "free": 1, "garbag": 1, "implement": 1, "independ": 1, "insur": 1, "languag": 1, "list": 4, "literatur": 1, "machin": 1, "method": 1, "number": 1, "offer": 1, "paper": 1, "part": 1, "past": 1, "present": 1, "problem": 1, "procedur": 1, "process": 1, "recoveri": 1, "regist": 1, "return": 1, "review": 1, "routin": 1, "signific": 1, "solut": 1, "speed": 1, "storag": 1, "structur": 1, "system": 1, "util": 1, "written": 1, "schorr": 1, "wait": 1}}, "1550": {"id": "1550", "title": "A Comparison of Batch Processing and Instant Turnaround", "abstract": "A study of the programming efforts of students in an introductory programming course is presented  and the effects of having instant turnaround (a few minutes) as opposed to conventional batch processing  with turnaround times of a few hours are examined.  Among the items compared are the number of computer  runs per trip to the computation center, program preparation time, keypunching time, debugging time,  number of runs, and elapsed time from the first run to the last run on each problem.  Even though the  results are influenced by the fact that \"bonus points\" were given for completion of a programming problem in less than a specified number of runs, there is evidence to support \"Instant\" over \"Batch\".", "authors": "Smith, L. B.", "words_pool": ["batch", "bonu", "center", "compar", "comparison", "complet", "comput", "comput", "convent", "cours", "debug", "effect", "effort", "elaps", "evid", "examin", "fact", "hour", "influenc", "instant", "introductori", "item", "keypunch", "minut", "number", "oppos", "point", "prepar", "present", "problem", "process", "program", "program", "result", "run", "run", "student", "studi", "support", "time", "time", "trip", "turnaround", "smith"], "word_count": {"batch": 2, "bonu": 1, "center": 1, "compar": 1, "comparison": 1, "complet": 1, "comput": 2, "convent": 1, "cours": 1, "debug": 1, "effect": 1, "effort": 1, "elaps": 1, "evid": 1, "examin": 1, "fact": 1, "hour": 1, "influenc": 1, "instant": 2, "introductori": 1, "item": 1, "keypunch": 1, "minut": 1, "number": 3, "oppos": 1, "point": 1, "prepar": 1, "present": 1, "problem": 2, "process": 1, "program": 4, "result": 1, "run": 5, "student": 1, "studi": 1, "support": 1, "time": 5, "trip": 1, "turnaround": 2, "smith": 1}}, "1551": {"id": "1551", "title": "On Compiling Algorithms for Arithmetic Expressions", "abstract": "This paper deals with algorithms concerning arithmetic expressions used in a FORTRAN IV compiler  for a HITAC-5020 computer having n accumulators.  The algorithms generate an object code which minimizes  the frequency of storing and recovering the partial results of the arithmetic expressions in cases where  there are several accumulators.", "authors": "Nakata, I.", "words_pool": ["accumul", "algorithm", "arithmet", "case", "code", "compil", "compil", "comput", "concern", "deal", "express", "fortran", "frequenc", "gener", "hitac", "iv", "minim", "object", "paper", "partial", "recov", "result", "store", "nakata"], "word_count": {"accumul": 2, "algorithm": 2, "arithmet": 2, "case": 1, "code": 1, "compil": 1, "comput": 1, "concern": 1, "deal": 1, "express": 2, "fortran": 1, "frequenc": 1, "gener": 1, "hitac": 1, "iv": 1, "minim": 1, "object": 1, "paper": 1, "partial": 1, "recov": 1, "result": 1, "store": 1, "nakata": 1}}, "1552": {"id": "1552", "title": "The AED Free Storage Package", "abstract": "The most fundamental underlying problem in sophisticated software systems involving elaborate,  changing data structure is dynamic storage allocation for flexible problem modeling.  The Free Storage  Package of the AED-1 Compiler Systems allows blocks of available storage to be obtained and returned  for reuse.  The total available space is partitioned into a hierarchy of free storage zones, each of  which has its own characteristics.  Blocks may be of any size, and special provisions allow efficient  handling of selected sizes, control of shattering and garbage collection, and sharing of physical space  between zones.  The routines of the package perform high level functions automatically, but also allow  access and control of fine internal details as well.", "authors": "Ross, D. T.", "words_pool": ["access", "a", "alloc", "allow", "block", "chang", "characterist", "collect", "compil", "control", "data", "detail", "dynam", "effici", "elabor", "fine", "flexibl", "free", "function", "fundament", "garbag", "handl", "hierarchi", "high", "intern", "involv", "level", "model", "obtain", "packag", "partit", "perform", "physic", "problem", "provis", "reus", "routin", "select", "share", "shatter", "size", "size", "softwar", "sophist", "space", "special", "storag", "structur", "system", "total", "underli", "zone", "ross"], "word_count": {"access": 1, "a": 1, "alloc": 1, "allow": 2, "block": 2, "chang": 1, "characterist": 1, "collect": 1, "compil": 1, "control": 2, "data": 1, "detail": 1, "dynam": 1, "effici": 1, "elabor": 1, "fine": 1, "flexibl": 1, "free": 2, "function": 1, "fundament": 1, "garbag": 1, "handl": 1, "hierarchi": 1, "high": 1, "intern": 1, "involv": 1, "level": 1, "model": 1, "obtain": 1, "packag": 2, "partit": 1, "perform": 1, "physic": 1, "problem": 2, "provis": 1, "reus": 1, "routin": 1, "select": 1, "share": 1, "shatter": 1, "size": 2, "softwar": 1, "sophist": 1, "space": 2, "special": 1, "storag": 4, "structur": 1, "system": 2, "total": 1, "underli": 1, "zone": 2, "ross": 1}}, "1553": {"id": "1553", "title": "Contextual Understanding by Computers", "abstract": "A further development of a computer program (ELIZA) capable of conversing in natural language  is discussed.  The importance of context to both human and machine understanding is stressed.  It is  argued that the adequacy of the level of understanding achieved in a particular conversation depends  on the purpose of that conversation, and that absolute understanding on the part of either humans or  machines is impossible.", "authors": "Weizenbaum, J.", "words_pool": ["absolut", "achiev", "adequaci", "argu", "capabl", "comput", "comput", "context", "contextu", "convers", "convers", "depend", "develop", "discuss", "eliza", "human", "human", "import", "imposs", "languag", "level", "machin", "machin", "natur", "part", "program", "purpos", "stress", "understand", "weizenbaum"], "word_count": {"absolut": 1, "achiev": 1, "adequaci": 1, "argu": 1, "capabl": 1, "comput": 1, "context": 1, "contextu": 1, "convers": 3, "depend": 1, "develop": 1, "discuss": 1, "eliza": 1, "human": 2, "import": 1, "imposs": 1, "languag": 1, "level": 1, "machin": 2, "natur": 1, "part": 1, "program": 1, "purpos": 1, "stress": 1, "understand": 3, "weizenbaum": 1}}, "1554": {"id": "1554", "title": "A Computer Technique for Displaying n-Dimensional Hyperobjects", "abstract": "A digital computer and automatic plotter have been used to generate three-dimensional stereoscopic  movies of the three-dimensional parallel and perspective projections of four-dimensional hyperobjects  rotating in four-dimensional space.  The observed projections and their motions were a direct extension of three-dimensional experience, but no profound \"feeling\" or insight into the fourth spatial dimension  was obtained.  The technique can be generalized to n-dimensions and applied to any n-dimensional hyperobject  or hypersurface.", "authors": "Noll, A. M.", "words_pool": ["appli", "automat", "comput", "digit", "dimens", "dimension", "dimens", "direct", "display", "experi", "extens", "feel", "fourth", "gener", "gener", "hyperobject", "hyperobject", "hypersurfac", "insight", "motion", "movi", "observ", "obtain", "parallel", "perspect", "plotter", "profound", "project", "rotat", "space", "spatial", "stereoscop", "techniqu", "noll"], "word_count": {"appli": 1, "automat": 1, "comput": 1, "digit": 1, "dimens": 2, "dimension": 6, "direct": 1, "display": 1, "experi": 1, "extens": 1, "feel": 1, "fourth": 1, "gener": 2, "hyperobject": 2, "hypersurfac": 1, "insight": 1, "motion": 1, "movi": 1, "observ": 1, "obtain": 1, "parallel": 1, "perspect": 1, "plotter": 1, "profound": 1, "project": 2, "rotat": 1, "space": 1, "spatial": 1, "stereoscop": 1, "techniqu": 1, "noll": 1}}, "1555": {"id": "1555", "title": "Symmetric Polynomials (Algorithm 305 [C1])", "authors": "Bratley, P. McKay, J. K. S.", "words_pool": ["algorithm", "c1", "polynomi", "symmetr", "bratley", "mckay"], "word_count": {"algorithm": 1, "c1": 1, "polynomi": 1, "symmetr": 1, "bratley": 1, "mckay": 1}}, "1556": {"id": "1556", "title": "Permutations with Repetitions (Algorithm 306 [G6])", "authors": "Bratley, P.", "words_pool": ["algorithm", "g6", "permut", "repetit", "bratley"], "word_count": {"algorithm": 1, "g6": 1, "permut": 1, "repetit": 1, "bratley": 1}}, "1557": {"id": "1557", "title": "Symmetric Group Characters (Algorithm 307 [A1])", "authors": "McKay, J. K. S.", "words_pool": ["a1", "algorithm", "charact", "group", "symmetr", "mckay"], "word_count": {"a1": 1, "algorithm": 1, "charact": 1, "group": 1, "symmetr": 1, "mckay": 1}}, "1558": {"id": "1558", "title": "Generation of Permutations in Pseudo-Lexicographic Order (Algorithm  [G6])", "authors": "Ord-Smith, R. J.", "words_pool": ["algorithm", "g6", "gener", "lexicograph", "order", "permut", "pseudo", "ord", "smith"], "word_count": {"algorithm": 1, "g6": 1, "gener": 1, "lexicograph": 1, "order": 1, "permut": 1, "pseudo": 1, "ord": 1, "smith": 1}}, "1559": {"id": "1559", "title": "Permutation Generator; Permutation in Lexicographical Order; Permute; Generation of Permutations  in Lexicographical Order (Algorithm 87[G6]; Algorithm 102[G6]; Algorithm 130[G6]; Algorithm 202[G6])", "authors": "Ord-Smith, R. J.", "words_pool": ["algorithm", "g6", "gener", "gener", "lexicograph", "order", "permut", "permut", "permut", "ord", "smith"], "word_count": {"algorithm": 4, "g6": 4, "gener": 2, "lexicograph": 2, "order": 2, "permut": 4, "ord": 1, "smith": 1}}, "1560": {"id": "1560", "title": "Transport; Transportation Problem (Algorithm 258[H]; Algorithm 293[H])", "authors": "Sims, L. S.", "words_pool": ["algorithm", "problem", "transport", "transport", "sim"], "word_count": {"algorithm": 2, "problem": 1, "transport": 2, "sim": 1}}, "1561": {"id": "1561", "title": "The Mutual Primal-Dual Method (Algorithm 285 [H])", "authors": "Spath, H.", "words_pool": ["algorithm", "dual", "method", "mutual", "primal", "spath"], "word_count": {"algorithm": 1, "dual": 1, "method": 1, "mutual": 1, "primal": 1, "spath": 1}}, "1562": {"id": "1562", "title": "Airy Function (Algorithm 301 [S20])", "authors": "Pitteway, M. L. V.", "words_pool": ["airi", "algorithm", "function", "s20", "pitteway"], "word_count": {"airi": 1, "algorithm": 1, "function": 1, "s20": 1, "pitteway": 1}}, "1563": {"id": "1563", "title": "A Method for Finding Hamilton Paths and Knight's Tours", "abstract": "The use of Warnsdorff's rule for finding a knight's tour is generalized and applied to the  problem of finding a Hamilton path in a graph.  A graph-theoretic justification for the method is given.", "authors": "Pohl, I.", "words_pool": ["appli", "find", "gener", "graph", "hamilton", "justif", "knight", "method", "path", "path", "problem", "rule", "theoret", "tour", "tour", "warnsdorff", "pohl"], "word_count": {"appli": 1, "find": 2, "gener": 1, "graph": 2, "hamilton": 1, "justif": 1, "knight": 1, "method": 1, "path": 1, "problem": 1, "rule": 1, "theoret": 1, "tour": 1, "warnsdorff": 1, "pohl": 1}}, "1564": {"id": "1564", "title": "Description of Basic Algorithm in DETAB/65 Preprocessor", "abstract": "The basic algorithm for the conversion of decision tables into COBOL code is contained in the generator portion of the DETAB/65 preprocessor.  The generator analyzes a decision table and produces  simple COBOL conditional statements.  Core storage is saved by using queueing techniques and extensive  indexing and also by outputting the code as it is generated, a line at a time.  The only optimization  attempted is the elimination of obviously unnecessary tests on certain conditions in the decision table.   Since the preprocessor and this language associated with it were developed for COBOL users, the preprocessor  was written in a modular form in required COBOL-61.", "authors": "Callahan, M. D. Chapman, A. E.", "words_pool": ["algorithm", "analyz", "attempt", "basic", "cobol", "code", "condit", "condit", "contain", "convers", "core", "decis", "descript", "detab", "develop", "elimin", "extens", "form", "gener", "gener", "index", "languag", "line", "modular", "obvious", "optim", "output", "portion", "preprocessor", "produc", "queue", "requir", "save", "simpl", "statement", "storag", "tabl", "tabl", "techniqu", "test", "time", "unnecessari", "user", "written", "callahan", "chapman"], "word_count": {"algorithm": 1, "analyz": 1, "attempt": 1, "basic": 1, "cobol": 4, "code": 2, "condit": 2, "contain": 1, "convers": 1, "core": 1, "decis": 3, "descript": 1, "detab": 1, "develop": 1, "elimin": 1, "extens": 1, "form": 1, "gener": 3, "index": 1, "languag": 1, "line": 1, "modular": 1, "obvious": 1, "optim": 1, "output": 1, "portion": 1, "preprocessor": 3, "produc": 1, "queue": 1, "requir": 1, "save": 1, "simpl": 1, "statement": 1, "storag": 1, "tabl": 3, "techniqu": 1, "test": 1, "time": 1, "unnecessari": 1, "user": 1, "written": 1, "callahan": 1, "chapman": 1}}, "1565": {"id": "1565", "title": "A Language-Independent Macro Processor", "abstract": "A macro processor is described which can be used with almost any source language.  It provides  all features normally associated with a macro facility, plus the ability to make arbitrary transformations  of the argument strings.  The program is used at the Basser Computing Department, University of Sydney,  Sydney, Australia, to process text for eight different compilers.", "authors": "Waite, W. M.", "words_pool": ["abil", "arbitrari", "argument", "australia", "basser", "compil", "comput", "depart", "facil", "featur", "independ", "languag", "macro", "make", "process", "processor", "program", "sourc", "string", "sydney", "text", "transform", "univers", "wait"], "word_count": {"abil": 1, "arbitrari": 1, "argument": 1, "australia": 1, "basser": 1, "compil": 1, "comput": 1, "depart": 1, "facil": 1, "featur": 1, "independ": 1, "languag": 1, "macro": 2, "make": 1, "process": 1, "processor": 1, "program": 1, "sourc": 1, "string": 1, "sydney": 2, "text": 1, "transform": 1, "univers": 1, "wait": 1}}, "1566": {"id": "1566", "title": "Optimal Starting Values for Newton-Raphson Calculation of SQRT(x)", "abstract": "The problem of obtaining starting values for the Newton-Raphson calculation of SQRT(x) on a  digital computer is considered.  It is shown that the conventionally used best uniform approximations  to SQRT(x) do not provide optimal starting values.  The problem of obtaining optimal starting values.   The problem of obtaining optimal starting values is stated, and several basic results are proved.  A  table of optimal polynomial starting values is given.", "authors": "Moursund, D. G.", "words_pool": ["approxim", "basic", "calcul", "comput", "consid", "convent", "digit", "newton", "obtain", "optim", "polynomi", "problem", "prove", "provid", "raphson", "result", "shown", "sqrt", "start", "state", "tabl", "uniform", "valu", "moursund"], "word_count": {"approxim": 1, "basic": 1, "calcul": 1, "comput": 1, "consid": 1, "convent": 1, "digit": 1, "newton": 1, "obtain": 3, "optim": 4, "polynomi": 1, "problem": 3, "prove": 1, "provid": 1, "raphson": 1, "result": 1, "shown": 1, "sqrt": 2, "start": 5, "state": 1, "tabl": 1, "uniform": 1, "valu": 5, "moursund": 1}}, "1567": {"id": "1567", "title": "On the Representation of Symmetric Polynomials", "abstract": "Relations are given between certain symmetric polynomials in the light of the theory of the  symmetric group.  Such an approach unifies earlier work and lends insight to previously published work  by Aaron Booker.  A generalization of Graeffe's root-squaring technique for the determination of the  roots of a polynomial is suggested.", "authors": "McKay, J. K. S.", "words_pool": ["aaron", "approach", "booker", "determin", "earlier", "gener", "graeff", "group", "insight", "lend", "light", "polynomi", "polynomi", "previous", "publish", "relat", "represent", "root", "root", "squar", "suggest", "symmetr", "techniqu", "theori", "unifi", "work", "mckay"], "word_count": {"aaron": 1, "approach": 1, "booker": 1, "determin": 1, "earlier": 1, "gener": 1, "graeff": 1, "group": 1, "insight": 1, "lend": 1, "light": 1, "polynomi": 2, "previous": 1, "publish": 1, "relat": 1, "represent": 1, "root": 2, "squar": 1, "suggest": 1, "symmetr": 2, "techniqu": 1, "theori": 1, "unifi": 1, "work": 2, "mckay": 1}}, "1568": {"id": "1568", "title": "Plotting a Function of Three Independent Variables", "abstract": "A method is developed for constructing an approximate plot of a function of three independent  variables.  The plot is similar to a conventional contour map except that there are three scales to represent  the independent variables.  Scale values of the three independent variables are added vectorially, and  the value of the function is then read from the values associated with nearby contours.", "authors": "Stineman, R. W.", "words_pool": ["ad", "approxim", "construct", "contour", "contour", "convent", "develop", "function", "independ", "map", "method", "nearbi", "plot", "plot", "read", "repres", "scale", "scale", "similar", "valu", "variabl", "vectori", "stineman"], "word_count": {"ad": 1, "approxim": 1, "construct": 1, "contour": 2, "convent": 1, "develop": 1, "function": 2, "independ": 3, "map": 1, "method": 1, "nearbi": 1, "plot": 2, "read": 1, "repres": 1, "scale": 2, "similar": 1, "valu": 2, "variabl": 3, "vectori": 1, "stineman": 1}}, "1569": {"id": "1569", "title": "Implementing Phrase-Structure Productions in PL/I", "abstract": "A method is described for implementing the productions of a context-free phrase structure grammar  in a PL/I procedure whose structure and statements parallel the structure and notation of the grammar.", "authors": "Irwin, L.", "words_pool": ["context", "free", "grammar", "implement", "method", "notat", "parallel", "phrase", "pl", "procedur", "product", "statement", "structur", "irwin"], "word_count": {"context": 1, "free": 1, "grammar": 2, "implement": 1, "method": 1, "notat": 1, "parallel": 1, "phrase": 1, "pl": 1, "procedur": 1, "product": 1, "statement": 1, "structur": 3, "irwin": 1}}, "1570": {"id": "1570", "title": "String Processing Techniques", "abstract": "The internal organization of string processing systems is discussed.  Six techniques for data  structures are presented and evaluated on the basis of: (1) creation of strings; (2) examination of strings;  and (3) alteration of strings.  Speed of operation, storage requirements, effect on paging, and programmer  convenience are also considered.  One of the techniques, single-word linked blocks, is used in an example  demonstrating an implementation of a SNOBOL string processing language on an IBM System/360.", "authors": "Madnick, S. E.", "words_pool": ["alter", "basi", "block", "consid", "conveni", "creation", "data", "demonstr", "discuss", "effect", "evalu", "examin", "ibm", "implement", "intern", "languag", "link", "oper", "organ", "page", "present", "process", "programm", "requir", "singl", "snobol", "speed", "storag", "string", "string", "structur", "system", "system", "techniqu", "word", "madnick"], "word_count": {"alter": 1, "basi": 1, "block": 1, "consid": 1, "conveni": 1, "creation": 1, "data": 1, "demonstr": 1, "discuss": 1, "effect": 1, "evalu": 1, "examin": 1, "ibm": 1, "implement": 1, "intern": 1, "languag": 1, "link": 1, "oper": 1, "organ": 1, "page": 1, "present": 1, "process": 2, "programm": 1, "requir": 1, "singl": 1, "snobol": 1, "speed": 1, "storag": 1, "string": 5, "structur": 1, "system": 2, "techniqu": 2, "word": 1, "madnick": 1}}, "1571": {"id": "1571", "title": "A User-Oriented Time-Shared Online System", "abstract": "An existing system and planned additions within the Data Processing Laboratory of the Brain  Research Institute at UCLA is described.  The system represents an attempt to provide research workers  of the Institute with the ability to interact directly with a highly sophisticated digital computing  complex in the most direct and simple fashion possible.  It is anticipated that, with the accumulation  of experience using the present system, significant advances will be possible in the system design through  determination of interface parameters between the biological scientist and the digital computer.", "authors": "Betyar, L.", "words_pool": ["abil", "accumul", "addit", "advanc", "anticip", "attempt", "biolog", "brain", "complex", "comput", "comput", "data", "design", "determin", "digit", "direct", "directli", "exist", "experi", "fashion", "highli", "institut", "interact", "interfac", "laboratori", "onlin", "orient", "paramet", "plan", "present", "process", "provid", "repres", "research", "scientist", "share", "signific", "simpl", "sophist", "system", "time", "ucla", "user", "worker", "betyar"], "word_count": {"abil": 1, "accumul": 1, "addit": 1, "advanc": 1, "anticip": 1, "attempt": 1, "biolog": 1, "brain": 1, "complex": 1, "comput": 2, "data": 1, "design": 1, "determin": 1, "digit": 2, "direct": 1, "directli": 1, "exist": 1, "experi": 1, "fashion": 1, "highli": 1, "institut": 2, "interact": 1, "interfac": 1, "laboratori": 1, "onlin": 1, "orient": 1, "paramet": 1, "plan": 1, "present": 1, "process": 1, "provid": 1, "repres": 1, "research": 2, "scientist": 1, "share": 1, "signific": 1, "simpl": 1, "sophist": 1, "system": 4, "time": 1, "ucla": 1, "user": 1, "worker": 1, "betyar": 1}}, "1572": {"id": "1572", "title": "The Simulation of Time sharing Systems", "abstract": "The development of new large scale time-sharing systems has raised a number of problems for  computation center management.  Not only is it necessary to develop an appropriate hardware configuration  for these systems, but appropriate software adjustments must be made.  Unfortunately, these systems often  do not respond to changes in the manner that intuition would suggest, and there are few guides to assist  in the analysis of performance characteristics.  The development of a comprehensive simulation model  to assist in the investigation of these questions is described in this paper.  The resulting model has  a general purpose design and can be used to study a variety of time-sharing systems.  It can also be  used to assist in the design and development of new time-sharing algorithms or techniques.  For the sake  of efficiency and greater applicability, the model was implemented in a limited FORTRAN subset that is  compatible with most FORTRAN IV compilers. The use of the simulation is demonstrated by a study of the  IBM 360/67 time-sharing system.", "authors": "Nielsen, N. R.", "words_pool": ["adjust", "algorithm", "analysi", "applic", "assist", "center", "characterist", "compat", "compil", "comprehens", "comput", "configur", "demonstr", "design", "develop", "develop", "effici", "fortran", "gener", "greater", "guid", "hardwar", "ibm", "implement", "intuit", "investig", "iv", "larg", "limit", "made", "manag", "manner", "model", "number", "paper", "perform", "problem", "purpos", "question", "rais", "respond", "result", "sake", "scale", "share", "simul", "softwar", "studi", "subset", "suggest", "system", "system", "techniqu", "time", "unfortun", "varieti", "nielsen"], "word_count": {"adjust": 1, "algorithm": 1, "analysi": 1, "applic": 1, "assist": 3, "center": 1, "characterist": 1, "compat": 1, "compil": 1, "comprehens": 1, "comput": 1, "configur": 1, "demonstr": 1, "design": 2, "develop": 4, "effici": 1, "fortran": 2, "gener": 1, "greater": 1, "guid": 1, "hardwar": 1, "ibm": 1, "implement": 1, "intuit": 1, "investig": 1, "iv": 1, "larg": 1, "limit": 1, "made": 1, "manag": 1, "manner": 1, "model": 3, "number": 1, "paper": 1, "perform": 1, "problem": 1, "purpos": 1, "question": 1, "rais": 1, "respond": 1, "result": 1, "sake": 1, "scale": 1, "share": 4, "simul": 2, "softwar": 1, "studi": 2, "subset": 1, "suggest": 1, "system": 5, "techniqu": 1, "time": 4, "unfortun": 1, "varieti": 1, "nielsen": 1}}, "1573": {"id": "1573", "title": "An Adaptive Quadrature Procedure with Random Panel Sizes (Algorithm [D1])", "authors": "Gallaher, L. J.", "words_pool": ["adapt", "algorithm", "d1", "panel", "procedur", "quadratur", "random", "size", "gallah"], "word_count": {"adapt": 1, "algorithm": 1, "d1": 1, "panel": 1, "procedur": 1, "quadratur": 1, "random": 1, "size": 1, "gallah": 1}}, "1574": {"id": "1574", "title": "Normal Curve Integral (Algorithm 304 [S15])", "authors": "Hill, I. D. Joyce, S. A.", "words_pool": ["algorithm", "curv", "integr", "normal", "s15", "hill", "joyc"], "word_count": {"algorithm": 1, "curv": 1, "integr": 1, "normal": 1, "s15": 1, "hill": 1, "joyc": 1}}, "1575": {"id": "1575", "title": "Incomplete Beta Ratio (Algorithm 179 [S14])", "authors": "Pike, M. C. Hill, I. D.", "words_pool": ["algorithm", "beta", "incomplet", "ratio", "s14", "pike", "hill"], "word_count": {"algorithm": 1, "beta": 1, "incomplet": 1, "ratio": 1, "s14": 1, "pike": 1, "hill": 1}}, "1576": {"id": "1576", "title": "Eigenvalues of a Real Symmetric Matrix by the QR Method (Algorithm 253 [F2])", "authors": "Welsch, J. H.", "words_pool": ["algorithm", "eigenvalu", "f2", "matrix", "method", "qr", "real", "symmetr", "welsch"], "word_count": {"algorithm": 1, "eigenvalu": 1, "f2": 1, "matrix": 1, "method": 1, "qr": 1, "real": 1, "symmetr": 1, "welsch": 1}}, "1577": {"id": "1577", "title": "Eigenvalues and Eigenvectors of a Real Symmetric Matrix by the QR Method (Algorithm 254 [F2])", "authors": "Welsch, J. H.", "words_pool": ["algorithm", "eigenvalu", "eigenvector", "f2", "matrix", "method", "qr", "real", "symmetr", "welsch"], "word_count": {"algorithm": 1, "eigenvalu": 1, "eigenvector": 1, "f2": 1, "matrix": 1, "method": 1, "qr": 1, "real": 1, "symmetr": 1, "welsch": 1}}, "1578": {"id": "1578", "title": "Generalized Least Squares Fit By Orthogonal Polynomials (Algorithm 296 [E2])", "authors": "Makinson, G. J.", "words_pool": ["algorithm", "e2", "fit", "gener", "orthogon", "polynomi", "squar", "makinson"], "word_count": {"algorithm": 1, "e2": 1, "fit": 1, "gener": 1, "orthogon": 1, "polynomi": 1, "squar": 1, "makinson": 1}}, "1579": {"id": "1579", "title": "Real Error Function, ERF(x) (Algorithm 123 [S15])", "authors": "Hill, I. D. Joyce, S. A.", "words_pool": ["algorithm", "erf", "error", "function", "real", "s15", "hill", "joyc"], "word_count": {"algorithm": 1, "erf": 1, "error": 1, "function": 1, "real": 1, "s15": 1, "hill": 1, "joyc": 1}}, "1580": {"id": "1580", "title": "Error Function-Large X (Algorithm 180 [S15])", "authors": "Hill, I. D. Joyce, S. A.", "words_pool": ["algorithm", "error", "function", "larg", "s15", "hill", "joyc"], "word_count": {"algorithm": 1, "error": 1, "function": 1, "larg": 1, "s15": 1, "hill": 1, "joyc": 1}}, "1581": {"id": "1581", "title": "Complementary Error Function-Large X (Algorithm 181 [S15])", "authors": "Hill, I. D. Joyce, S. A.", "words_pool": ["algorithm", "complementari", "error", "function", "larg", "s15", "hill", "joyc"], "word_count": {"algorithm": 1, "complementari": 1, "error": 1, "function": 1, "larg": 1, "s15": 1, "hill": 1, "joyc": 1}}, "1582": {"id": "1582", "title": "GAUSS (Algorithm 209 [S15])", "authors": "Hill, I. D. Joyce, S. A.", "words_pool": ["algorithm", "gauss", "s15", "hill", "joyc"], "word_count": {"algorithm": 1, "gauss": 1, "s15": 1, "hill": 1, "joyc": 1}}, "1583": {"id": "1583", "title": "Normal Distribution Function (Algorithm 226 [S15])", "authors": "Hill, I. D. Joyce, S. A.", "words_pool": ["algorithm", "distribut", "function", "normal", "s15", "hill", "joyc"], "word_count": {"algorithm": 1, "distribut": 1, "function": 1, "normal": 1, "s15": 1, "hill": 1, "joyc": 1}}, "1584": {"id": "1584", "title": "Procedure for the Normal Distribution Functions (Algorithm 272 [S15])", "authors": "Hill, I. D. Joyce, S. A.", "words_pool": ["algorithm", "distribut", "function", "normal", "procedur", "s15", "hill", "joyc"], "word_count": {"algorithm": 1, "distribut": 1, "function": 1, "normal": 1, "procedur": 1, "s15": 1, "hill": 1, "joyc": 1}}, "1585": {"id": "1585", "title": "Normal Curve Integral (Algorithm 304 [S15])", "authors": "Hill, I. D. Joyce, S. A.", "words_pool": ["algorithm", "curv", "integr", "normal", "s15", "hill", "joyc"], "word_count": {"algorithm": 1, "curv": 1, "integr": 1, "normal": 1, "s15": 1, "hill": 1, "joyc": 1}}, "1586": {"id": "1586", "title": "A Generalized Bairstow Algorithm", "abstract": "The Bairstow algorithm is generalized to the case of a polynomial which is itself a linear  combination of polynomials satisfying a three-term recursion.  Convergence properties of the method are  derived.", "authors": "Golub, G. H. Robertson, T. N.", "words_pool": ["algorithm", "bairstow", "case", "combin", "converg", "deriv", "gener", "linear", "method", "polynomi", "polynomi", "properti", "recurs", "satisfi", "term", "golub", "robertson"], "word_count": {"algorithm": 1, "bairstow": 1, "case": 1, "combin": 1, "converg": 1, "deriv": 1, "gener": 1, "linear": 1, "method": 1, "polynomi": 2, "properti": 1, "recurs": 1, "satisfi": 1, "term": 1, "golub": 1, "robertson": 1}}, "1587": {"id": "1587", "title": "Storage Allocation in a Certain Iterative Process", "abstract": "A method of core storage allocation in a certain iterative process is described and estimates  of the machine time required are given.  The method is applicable to iterative processes in which input  data items once chosen are never again needed.  In this method the input data is continuously relocated  and the space made available apportioned to the output tables when an overflow occurs.  Some important  special cases are considered in which considerable simplification occurs.", "authors": "Abramowich, J.", "words_pool": ["alloc", "applic", "apport", "case", "chosen", "consider", "consid", "continu", "core", "data", "estim", "import", "input", "item", "iter", "machin", "made", "method", "need", "occur", "output", "overflow", "process", "process", "reloc", "requir", "simplif", "space", "special", "storag", "tabl", "time", "abramowich"], "word_count": {"alloc": 1, "applic": 1, "apport": 1, "case": 1, "chosen": 1, "consider": 1, "consid": 1, "continu": 1, "core": 1, "data": 2, "estim": 1, "import": 1, "input": 2, "item": 1, "iter": 2, "machin": 1, "made": 1, "method": 3, "need": 1, "occur": 2, "output": 1, "overflow": 1, "process": 2, "reloc": 1, "requir": 1, "simplif": 1, "space": 1, "special": 1, "storag": 1, "tabl": 1, "time": 1, "abramowich": 1}}, "1588": {"id": "1588", "title": "PL/I List Processing", "abstract": "The concepts of list processing have been introduced into the PL/I language.  With these new  facilities, it is possible to write PL/I procedures that operate on simple and complex data list organizations.   Most list-processing languages have suffered from their inability to deal directly with complex data  structures and/or from their inability to perform the complete range of programming language operations  upon the data list structures.  These two problems have been eliminated in the list-processing facilities  of PL/I.  The basic concepts of list processing and the philosophy of the PL/I language extensions are  discussed.  In addition, several detailed list-processing examples are provided.", "authors": "Lawson Jr., H. W.", "words_pool": ["addit", "basic", "complet", "complex", "concept", "data", "deal", "detail", "directli", "discuss", "elimin", "exampl", "extens", "facil", "inabl", "introduc", "languag", "languag", "list", "oper", "oper", "organ", "perform", "philosophi", "pl", "problem", "procedur", "process", "program", "provid", "rang", "simpl", "structur", "suffer", "write", "lawson", "jr"], "word_count": {"addit": 1, "basic": 1, "complet": 1, "complex": 2, "concept": 2, "data": 3, "deal": 1, "detail": 1, "directli": 1, "discuss": 1, "elimin": 1, "exampl": 1, "extens": 1, "facil": 2, "inabl": 2, "introduc": 1, "languag": 4, "list": 7, "oper": 2, "organ": 1, "perform": 1, "philosophi": 1, "pl": 4, "problem": 1, "procedur": 1, "process": 5, "program": 1, "provid": 1, "rang": 1, "simpl": 1, "structur": 2, "suffer": 1, "write": 1, "lawson": 1, "jr": 1}}, "1589": {"id": "1589", "title": "DIALOG: A Conversational Programming System with a Graphical Orientation", "abstract": "DIALOG is an algebraic language for online use with a graphical input-output console device.   It is a computational aid for the casual user, which provides basic facilities for graphical and numeric  input and display, online and off line program preparation and storage, and hard copy presentation of  results.  Use of the system requires a minimum of experience or instruction, since the growth of an overlaying  system control language has been prevented, and there are no processor-oriented statements, like variable  type or dimension declarations.  Moreover, in the online situation the processor interacts with the graphical  keyboard on a character-by-character basis so as to restrict the programmer's choice of input symbols  to those which are syntactically correct. DIALOG has been in daily operation at the IIT Research Institute  since February, 1966.", "authors": "Cameron, S. H. Ewing, D. Liveright, M.", "words_pool": ["aid", "algebra", "basic", "basi", "casual", "charact", "choic", "comput", "consol", "control", "convers", "copi", "correct", "daili", "declar", "devic", "dialog", "dimens", "display", "experi", "facil", "februari", "graphic", "growth", "hard", "iit", "input", "institut", "instruct", "interact", "keyboard", "languag", "line", "minimum", "numer", "onlin", "oper", "orient", "orient", "output", "overlay", "prepar", "present", "prevent", "processor", "program", "programm", "program", "requir", "research", "restrict", "result", "situat", "statement", "storag", "symbol", "syntact", "system", "type", "user", "variabl", "cameron", "ewe", "liveright"], "word_count": {"aid": 1, "algebra": 1, "basic": 1, "basi": 1, "casual": 1, "charact": 2, "choic": 1, "comput": 1, "consol": 1, "control": 1, "convers": 1, "copi": 1, "correct": 1, "daili": 1, "declar": 1, "devic": 1, "dialog": 2, "dimens": 1, "display": 1, "experi": 1, "facil": 1, "februari": 1, "graphic": 3, "growth": 1, "hard": 1, "iit": 1, "input": 3, "institut": 1, "instruct": 1, "interact": 1, "keyboard": 1, "languag": 2, "line": 1, "minimum": 1, "numer": 1, "onlin": 3, "oper": 1, "orient": 1, "output": 1, "overlay": 1, "prepar": 1, "present": 1, "prevent": 1, "processor": 2, "program": 1, "programm": 1, "requir": 1, "research": 1, "restrict": 1, "result": 1, "situat": 1, "statement": 1, "storag": 1, "symbol": 1, "syntact": 1, "system": 2, "type": 1, "user": 1, "variabl": 1, "cameron": 1, "ewe": 1, "liveright": 1}}, "1590": {"id": "1590", "title": "Pitch Period Determination of Speech Sounds", "abstract": "A computer procedure which determines pitch periods by the recognition of the peak structure  of the speech waveform is described.  Speech sounds were sampled by a microphone and an analog-to-digital  converter attached to an interconnected IBM 7090-PDP-1 system.  These utterances were recorded at the  normal noise level of the computer room but were not band-compressed or phase-distorted in any manner.   A sequence of operations defined on the speech wave selects a list of points along the waveform as candidates  for pitch markers.  These markers are validated by an error detection and correction procedure", "authors": "Reddy, D. R.", "words_pool": ["analog", "attach", "band", "candid", "compress", "comput", "convert", "correct", "defin", "detect", "determin", "determin", "digit", "distort", "error", "ibm", "interconnect", "level", "list", "manner", "marker", "microphon", "nois", "normal", "oper", "pdp", "peak", "period", "period", "phase", "pitch", "point", "procedur", "recognit", "record", "room", "sampl", "select", "sequenc", "sound", "speech", "structur", "system", "utter", "valid", "wave", "waveform", "reddi"], "word_count": {"analog": 1, "attach": 1, "band": 1, "candid": 1, "compress": 1, "comput": 2, "convert": 1, "correct": 1, "defin": 1, "detect": 1, "determin": 1, "digit": 1, "distort": 1, "error": 1, "ibm": 1, "interconnect": 1, "level": 1, "list": 1, "manner": 1, "marker": 2, "microphon": 1, "nois": 1, "normal": 1, "oper": 1, "pdp": 1, "peak": 1, "period": 1, "phase": 1, "pitch": 2, "point": 1, "procedur": 2, "recognit": 1, "record": 1, "room": 1, "sampl": 1, "select": 1, "sequenc": 1, "sound": 1, "speech": 3, "structur": 1, "system": 1, "utter": 1, "valid": 1, "wave": 1, "waveform": 2, "reddi": 1}}, "1591": {"id": "1591", "title": "A Model for a Multifunctional Teaching System", "abstract": "A teaching system model that was incorporated into an operating system of a large computer  is described.  The model transferred control to the operating system to execute functions other than  teaching, and then recovered control in order to resume teaching.  The teaching system (ABAC-II) was  written to run under the operating system (IBSYS) for the IBM 7044 Graphic System.  Because the teaching  system automatically terminated and rescheduled itself, a student studying a course presented at a cathode-ray  display terminal could switch readily between student mode and programmer mode.  During the latter, the  full resources of the operating system (language processors, compilers, library and user's programs)  were at his disposal.  He could for example, write, assemble, debug, and execute at the terminal a program  written in any language processed by the operating system.  A course could therefore include text material  interleaved with programming problems which the student could solve without leaving the terminal.  Exercises  in simulation and gaming could also be provided.  The implications of a teaching system with this degree  of flexibility for industrial and executive training as well as academic education are discussed.  In  addition, the advantages of this type of system for computer programming and operation are also considered.", "authors": "Engvold, K. J. Hughes, J. L.", "words_pool": ["abac", "academ", "addit", "advantag", "assembl", "cathod", "compil", "comput", "consid", "control", "cours", "debug", "degre", "discuss", "display", "dispos", "educ", "execut", "execut", "exercis", "flexibl", "full", "function", "game", "graphic", "ibm", "ibsi", "ii", "implic", "includ", "incorpor", "industri", "interleav", "languag", "larg", "leav", "librari", "materi", "mode", "model", "multifunct", "oper", "oper", "order", "present", "problem", "process", "processor", "program", "programm", "program", "program", "provid", "ray", "readili", "recov", "reschedul", "resourc", "resum", "run", "simul", "solv", "student", "studi", "switch", "system", "teach", "termin", "termin", "text", "train", "transfer", "type", "user", "write", "written", "engvold", "hugh"], "word_count": {"abac": 1, "academ": 1, "addit": 1, "advantag": 1, "assembl": 1, "cathod": 1, "compil": 1, "comput": 2, "consid": 1, "control": 2, "cours": 2, "debug": 1, "degre": 1, "discuss": 1, "display": 1, "dispos": 1, "educ": 1, "execut": 3, "exercis": 1, "flexibl": 1, "full": 1, "function": 1, "game": 1, "graphic": 1, "ibm": 1, "ibsi": 1, "ii": 1, "implic": 1, "includ": 1, "incorpor": 1, "industri": 1, "interleav": 1, "languag": 2, "larg": 1, "leav": 1, "librari": 1, "materi": 1, "mode": 2, "model": 2, "multifunct": 1, "oper": 6, "order": 1, "present": 1, "problem": 1, "process": 1, "processor": 1, "program": 4, "programm": 1, "provid": 1, "ray": 1, "readili": 1, "recov": 1, "reschedul": 1, "resourc": 1, "resum": 1, "run": 1, "simul": 1, "solv": 1, "student": 3, "studi": 1, "switch": 1, "system": 11, "teach": 6, "termin": 4, "text": 1, "train": 1, "transfer": 1, "type": 1, "user": 1, "write": 1, "written": 2, "engvold": 1, "hugh": 1}}, "1592": {"id": "1592", "title": "String Similarity and Misspellings", "abstract": "The problem of programming a computer to determine whether or not a string of characters is  a misspelling of a given word was considered.  A numberof algorithms were evaluated-some proposed by  other writers, some by the author.  These techniques were tested on a collection of misspellings made  by students at various grade levels.  While many of the methods were clearly unsatisfactory, some gave  as few as 2.1 percent incorrect determinations.", "authors": "Alberga, C. N.", "words_pool": ["algorithm", "author", "charact", "clearli", "collect", "comput", "consid", "determin", "determin", "evalu", "gave", "grade", "incorrect", "level", "made", "method", "misspel", "misspel", "numberof", "percent", "problem", "program", "propos", "similar", "string", "student", "techniqu", "test", "unsatisfactori", "word", "writer", "alberga"], "word_count": {"algorithm": 1, "author": 1, "charact": 1, "clearli": 1, "collect": 1, "comput": 1, "consid": 1, "determin": 2, "evalu": 1, "gave": 1, "grade": 1, "incorrect": 1, "level": 1, "made": 1, "method": 1, "misspel": 2, "numberof": 1, "percent": 1, "problem": 1, "program": 1, "propos": 1, "similar": 1, "string": 1, "student": 1, "techniqu": 1, "test": 1, "unsatisfactori": 1, "word": 1, "writer": 1, "alberga": 1}}, "1593": {"id": "1593", "title": "A Simple Technique for Digital Division", "abstract": "A simple and economical method for digital division is described.  The method is suitable for  divisors whose leading character is either radix less one or is unity with the next character equal to  zero; also the method is direct and needs only half the number of arithmetic operations needed by a variant  of the Harvard iterative method, described by Gilman, which is suitable for similar divisors.", "authors": "Nandi, S. K. Krishnamurthy, E. V.", "words_pool": ["arithmet", "charact", "digit", "direct", "divis", "divisor", "econom", "equal", "gilman", "half", "harvard", "iter", "lead", "method", "need", "need", "number", "oper", "radix", "similar", "simpl", "suitabl", "techniqu", "uniti", "variant", "nandi", "krishnamurthi"], "word_count": {"arithmet": 1, "charact": 2, "digit": 1, "direct": 1, "divis": 1, "divisor": 2, "econom": 1, "equal": 1, "gilman": 1, "half": 1, "harvard": 1, "iter": 1, "lead": 1, "method": 4, "need": 2, "number": 1, "oper": 1, "radix": 1, "similar": 1, "simpl": 1, "suitabl": 2, "techniqu": 1, "uniti": 1, "variant": 1, "nandi": 1, "krishnamurthi": 1}}, "1594": {"id": "1594", "title": "An Algorithm for Generating Permutations", "abstract": "An algorithm is described which under repeated application generates all permutations of K  elements.  Only the previously generated permutation, the constant K, and a temporary index are needed.   Starting with a particular ordering of K elements (abcd), repeated application of the algorithm will  generate K-1 additional permutations by K-1 successive rotations.  From the initial circular ordering  of K objects, another circular ordering can be obtained by rotating the K-1 lowest elements.  For each  new K-1 circular ordering, another K-2 can be obtained by rotating the K-2 lowest elements.  By continuing  in this manner, applications of the algorithm will generate all (K-1)! circular orderings, or since each  circular ordering yields K permutations the algorithm generates all K! permutations.", "authors": "Langdon Jr., G. G.", "words_pool": ["abcd", "addit", "algorithm", "applic", "applic", "circular", "constant", "continu", "element", "gener", "gener", "gener", "gener", "index", "initi", "lowest", "manner", "need", "object", "obtain", "order", "order", "permut", "permut", "previous", "repeat", "rotat", "rotat", "start", "success", "temporari", "yield", "langdon", "jr"], "word_count": {"abcd": 1, "addit": 1, "algorithm": 4, "applic": 3, "circular": 5, "constant": 1, "continu": 1, "element": 4, "gener": 5, "index": 1, "initi": 1, "lowest": 2, "manner": 1, "need": 1, "object": 1, "obtain": 2, "order": 6, "permut": 5, "previous": 1, "repeat": 2, "rotat": 3, "start": 1, "success": 1, "temporari": 1, "yield": 1, "langdon": 1, "jr": 1}}, "1595": {"id": "1595", "title": "On the Computer Enumeration of Finite Topologies", "abstract": "The problem of enumerating the number of topologies which can be formed from a finite point  set is considered both theoretically and computationally.  Certain fundamental results are established,  leading to an algorithm for enumerating finite topologies, and computed results are given for n <= 7.   An interesting side result of the computational work was the unearthing of a theoretical error which  had been induced into the literature; the use of the computer in combinatorics represents, chronologically,  an early application, and this side result underscores its continuing usefulness in this area.", "authors": "Evans, J. W. Harary, F. Lynn, M. S.", "words_pool": ["algorithm", "applic", "area", "chronolog", "combinator", "comput", "comput", "comput", "comput", "consid", "continu", "earli", "enumer", "enumer", "error", "establish", "finit", "form", "fundament", "induc", "interest", "lead", "literatur", "number", "point", "problem", "repres", "result", "result", "set", "side", "theoret", "theoret", "topolog", "underscor", "unearth", "use", "work", "evan", "harari", "lynn"], "word_count": {"algorithm": 1, "applic": 1, "area": 1, "chronolog": 1, "combinator": 1, "comput": 4, "consid": 1, "continu": 1, "earli": 1, "enumer": 2, "error": 1, "establish": 1, "finit": 2, "form": 1, "fundament": 1, "induc": 1, "interest": 1, "lead": 1, "literatur": 1, "number": 1, "point": 1, "problem": 1, "repres": 1, "result": 4, "set": 1, "side": 2, "theoret": 2, "topolog": 2, "underscor": 1, "unearth": 1, "use": 1, "work": 1, "evan": 1, "harari": 1, "lynn": 1}}, "1596": {"id": "1596", "title": "Airy Function (Algorithm 301 [S20])", "authors": "Bond, G. Pitteway, M. L. V.", "words_pool": ["airi", "algorithm", "function", "s20", "bond", "pitteway"], "word_count": {"airi": 1, "algorithm": 1, "function": 1, "s20": 1, "bond": 1, "pitteway": 1}}, "1597": {"id": "1597", "title": "Transpose Vector Stored Array (Algorithm 302 [K2])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "array", "k2", "store", "transpos", "vector", "boothroyd"], "word_count": {"algorithm": 1, "array": 1, "k2": 1, "store": 1, "transpos": 1, "vector": 1, "boothroyd": 1}}, "1598": {"id": "1598", "title": "Least Squares Fit By Orthogonal Polynomials (Algorithm 28 [E2])", "authors": "Makinson, G. J.", "words_pool": ["algorithm", "e2", "fit", "orthogon", "polynomi", "squar", "makinson"], "word_count": {"algorithm": 1, "e2": 1, "fit": 1, "orthogon": 1, "polynomi": 1, "squar": 1, "makinson": 1}}, "1599": {"id": "1599", "title": "Numerical Solution of the Polynomial Equation (Algorithm 300 [C2])", "authors": "Kohfeld, J. J.", "words_pool": ["algorithm", "c2", "equat", "numer", "polynomi", "solut", "kohfeld"], "word_count": {"algorithm": 1, "c2": 1, "equat": 1, "numer": 1, "polynomi": 1, "solut": 1, "kohfeld": 1}}, "1600": {"id": "1600", "title": "Chebyshev Quadrature (Algorithm 279 [D1])", "authors": "Hillstrom, K.", "words_pool": ["algorithm", "chebyshev", "d1", "quadratur", "hillstrom"], "word_count": {"algorithm": 1, "chebyshev": 1, "d1": 1, "quadratur": 1, "hillstrom": 1}}, "1601": {"id": "1601", "title": "Parallel Numerical Methods for the Solution of Equations", "abstract": "Classical iterative procedures for the numerical solution of equations provide at each stage  a single new approximation to the root in question.  A technique is given for the development of numerical  procedures which provide, at each stage, several approximations to a solution of an equation.  The s8everal  approximations obtained in any iteration are computationally independent, making the methods of interest  in a parallel processing environment.  Convergence is insured by extracting the \"best information\" at  each iteration.  Several families of numerical procedures which use the technique of the procedures in  a parallel processing environment are developed and measurements of these statistics are reported.  These  measurements are interpreted in a parallel processing environment.  In such an environment the procedures  obtained are superior to standard algorithms.", "authors": "Shedler, G. S.", "words_pool": ["algorithm", "approxim", "approxim", "classic", "comput", "converg", "develop", "develop", "environ", "equat", "equat", "extract", "famili", "independ", "inform", "insur", "interest", "interpret", "iter", "iter", "make", "measur", "method", "numer", "obtain", "parallel", "procedur", "process", "provid", "question", "report", "root", "s8ever", "singl", "solut", "stage", "standard", "statist", "superior", "techniqu", "shedler"], "word_count": {"algorithm": 1, "approxim": 3, "classic": 1, "comput": 1, "converg": 1, "develop": 2, "environ": 4, "equat": 2, "extract": 1, "famili": 1, "independ": 1, "inform": 1, "insur": 1, "interest": 1, "interpret": 1, "iter": 3, "make": 1, "measur": 2, "method": 1, "numer": 3, "obtain": 2, "parallel": 3, "procedur": 5, "process": 3, "provid": 2, "question": 1, "report": 1, "root": 1, "s8ever": 1, "singl": 1, "solut": 2, "stage": 2, "standard": 1, "statist": 1, "superior": 1, "techniqu": 2, "shedler": 1}}, "1602": {"id": "1602", "title": "POSE: A Language for Posing Problems to a Computer", "abstract": "A language, POSE, is described which is a drastic departure from the FORTRAN/ALGOL type, though  it does utilize FORTRAN formula and logic representations (and actually contains FORTRAN VI as a subset).   With the new language, the user need only describe his problem in \"equation-like\" form. The method  of solution is automatically provided in conjunction with the translation from equation form to computer  instruction. In this way the POSE language user can solve difficult computational problems (like the  solution of differential equation) without requiring a knowledge of numerical methods or the intricacies  of computer subroutine logic. Essentially all clerical operations now required for FORTRAN programming  have been automated so that the POSE programmer need not be concerned with these details.", "authors": "Schlesinger, S. Sashkin, L.", "words_pool": ["actual", "algol", "autom", "cleric", "comput", "comput", "concern", "conjunct", "departur", "describ", "detail", "differenti", "difficult", "drastic", "equat", "essenti", "form", "formula", "fortran", "instruct", "intricaci", "knowledg", "languag", "logic", "method", "method", "need", "numer", "oper", "pose", "pose", "problem", "problem", "programm", "program", "provid", "represent", "requir", "requir", "solut", "solv", "subroutin", "subset", "translat", "type", "user", "util", "vi", "schlesing", "sashkin"], "word_count": {"actual": 1, "algol": 1, "autom": 1, "cleric": 1, "comput": 3, "concern": 1, "conjunct": 1, "departur": 1, "describ": 1, "detail": 1, "differenti": 1, "difficult": 1, "drastic": 1, "equat": 3, "essenti": 1, "form": 2, "formula": 1, "fortran": 4, "instruct": 1, "intricaci": 1, "knowledg": 1, "languag": 3, "logic": 2, "method": 2, "need": 2, "numer": 1, "oper": 1, "pose": 3, "problem": 2, "programm": 1, "program": 1, "provid": 1, "represent": 1, "requir": 2, "solut": 2, "solv": 1, "subroutin": 1, "subset": 1, "translat": 1, "type": 1, "user": 2, "util": 1, "vi": 1, "schlesing": 1, "sashkin": 1}}, "1603": {"id": "1603", "title": "A Multiprogramming Monitor for Small Machines", "abstract": "INT, a combination hardware/software monitor designed to control a wide variety of real-time  input/output devices, is described.  The simple hardware additions provide a uniform device to machine  interface for such elements as keyboards graphic input devices, and interval timers.  The software relieves  the user program from the details of input/output timing, buffering, and task scheduling and provides  parallel processing capability.  User programs communicate with the monitor through a small set of meta-instruction  which consists mostly of machine-language subroutine calls.", "authors": "Hornbuckle, G. D.", "words_pool": ["addit", "buffer", "call", "capabl", "combin", "commun", "consist", "control", "design", "detail", "devic", "devic", "element", "graphic", "hardwar", "input", "instruct", "int", "interfac", "interv", "keyboard", "languag", "machin", "machin", "meta", "monitor", "multiprogram", "output", "parallel", "process", "program", "program", "provid", "real", "reliev", "schedul", "set", "simpl", "small", "softwar", "subroutin", "task", "time", "timer", "time", "uniform", "user", "varieti", "wide", "hornbuckl"], "word_count": {"addit": 1, "buffer": 1, "call": 1, "capabl": 1, "combin": 1, "commun": 1, "consist": 1, "control": 1, "design": 1, "detail": 1, "devic": 3, "element": 1, "graphic": 1, "hardwar": 2, "input": 3, "instruct": 1, "int": 1, "interfac": 1, "interv": 1, "keyboard": 1, "languag": 1, "machin": 2, "meta": 1, "monitor": 2, "multiprogram": 1, "output": 2, "parallel": 1, "process": 1, "program": 2, "provid": 1, "real": 1, "reliev": 1, "schedul": 1, "set": 1, "simpl": 1, "small": 1, "softwar": 2, "subroutin": 1, "task": 1, "time": 2, "timer": 1, "uniform": 1, "user": 2, "varieti": 1, "wide": 1, "hornbuckl": 1}}, "1604": {"id": "1604", "title": "Further Analysis of a Computing Center Environment", "abstract": "Empirical distributions of program lengths, execution times, processing times, and loading  times of over 10,000 jobs serviced in a university computing center environment are presented.  The data  are subdivided according to certain characteristics of users and jobs to obtain selected empirical conditional  distributions of those time properties as well as statistical measures of other interesting properties.   The results are interpreted in terms of the properties of the system studied.", "authors": "Walter, E. S. Wallace, V. L.", "words_pool": ["accord", "analysi", "center", "characterist", "comput", "condit", "data", "distribut", "empir", "environ", "execut", "interest", "interpret", "job", "length", "load", "measur", "obtain", "present", "process", "program", "properti", "result", "select", "servic", "statist", "studi", "subdivid", "system", "term", "time", "time", "univers", "user", "walter", "wallac"], "word_count": {"accord": 1, "analysi": 1, "center": 1, "characterist": 1, "comput": 1, "condit": 1, "data": 1, "distribut": 2, "empir": 2, "environ": 1, "execut": 1, "interest": 1, "interpret": 1, "job": 2, "length": 1, "load": 1, "measur": 1, "obtain": 1, "present": 1, "process": 1, "program": 1, "properti": 3, "result": 1, "select": 1, "servic": 1, "statist": 1, "studi": 1, "subdivid": 1, "system": 1, "term": 1, "time": 4, "univers": 1, "user": 1, "walter": 1, "wallac": 1}}, "1605": {"id": "1605", "title": "An Experimental Comparison of Time Sharing and Batch Processing", "abstract": "The effectiveness for program development of the MIT Compatible Time-Sharing System (CTSS)  was compared with that of the IBM IBSYS batch-processing system by means of a statistically designed  experiment.  An identical set of four programming problems was assigned to each of a group of four programming  subjects.  Influences external to the systems, such as the sequence of problem solution, and programmer  and problem characteristics, were specified as design factors in the experiment.  Data was obtained for  six variables (e.g., programmer time, computer time, elapsed time, etc.) which were considered to be  definitive of \"system effectiveness,\" and analysis of variance techniques were employed to estimate system  differences in these variables after differences due to the design factors had been eliminated.  Statistical  analysis of the experimental results provided strong evidence of important system differences, as well  as a critique of the experimental design itself with implications for further experimentation.", "authors": "Schatzoff, M. Tsao, R. Wiig, R.", "words_pool": ["analysi", "assign", "batch", "characterist", "compar", "comparison", "compat", "comput", "consid", "critiqu", "ctss", "data", "definit", "design", "design", "develop", "differ", "due", "effect", "elaps", "elimin", "employ", "estim", "evid", "experi", "experiment", "experiment", "extern", "factor", "group", "ibm", "ibsi", "ident", "implic", "import", "influenc", "mean", "mit", "obtain", "problem", "problem", "process", "program", "programm", "program", "provid", "result", "sequenc", "set", "share", "solut", "statist", "statist", "strong", "subject", "system", "system", "techniqu", "time", "variabl", "varianc", "schatzoff", "tsao", "wiig"], "word_count": {"analysi": 2, "assign": 1, "batch": 1, "characterist": 1, "compar": 1, "comparison": 1, "compat": 1, "comput": 1, "consid": 1, "critiqu": 1, "ctss": 1, "data": 1, "definit": 1, "design": 4, "develop": 1, "differ": 3, "due": 1, "effect": 2, "elaps": 1, "elimin": 1, "employ": 1, "estim": 1, "evid": 1, "experi": 2, "experiment": 3, "extern": 1, "factor": 2, "group": 1, "ibm": 1, "ibsi": 1, "ident": 1, "implic": 1, "import": 1, "influenc": 1, "mean": 1, "mit": 1, "obtain": 1, "problem": 3, "process": 1, "program": 3, "programm": 2, "provid": 1, "result": 1, "sequenc": 1, "set": 1, "share": 1, "solut": 1, "statist": 2, "strong": 1, "subject": 1, "system": 6, "techniqu": 1, "time": 4, "variabl": 2, "varianc": 1, "schatzoff": 1, "tsao": 1, "wiig": 1}}, "1606": {"id": "1606", "title": "Chi-Squared Integral (Algorithm 299 [S15])", "authors": "Hill, I. D. Pike, M. C.", "words_pool": ["algorithm", "chi", "integr", "s15", "squar", "hill", "pike"], "word_count": {"algorithm": 1, "chi": 1, "integr": 1, "s15": 1, "squar": 1, "hill": 1, "pike": 1}}, "1607": {"id": "1607", "title": "Coulomb Wave Functions (Algorithm 300 [S22])", "authors": "Gunn, J. H.", "words_pool": ["algorithm", "coulomb", "function", "s22", "wave", "gunn"], "word_count": {"algorithm": 1, "coulomb": 1, "function": 1, "s22": 1, "wave": 1, "gunn": 1}}, "1608": {"id": "1608", "title": "Numerical Integration of Function That Has a Pole", "abstract": "It is common to need to integrate numerically functions that diverge somewhere outside the  range of integration.  Even if the divergence occurs quite far away, integration formulas like Simpson's,  that depend on fitting a polynomial, usually will be inaccurate: near a pole they will be very bad.   A method is described that gives formulas that will integrate functions of this kind accurately if the  orders and positions of the poles are known.  Explicit formulas are given that are easy to use on an  automatic computer.  It is shown that they can be used for some other singularities as well as poles.   If the integral converges, integration can be carried to the singularity.  The accuracy of the integration  with a pole of second order is discussed, and, as an example, the new formula is compared with Simpson's.   The new formulas are useful even far from the pole, while near the pole their advantage is overwhelming.", "authors": "Eisner, E.", "words_pool": ["accuraci", "accur", "advantag", "automat", "bad", "carri", "common", "compar", "comput", "converg", "depend", "discuss", "diverg", "diverg", "easi", "explicit", "fit", "formula", "formula", "function", "function", "inaccur", "integr", "integr", "integr", "kind", "known", "method", "need", "numer", "numer", "occur", "order", "order", "overwhelm", "pole", "pole", "polynomi", "posit", "rang", "shown", "simpson", "singular", "singular", "eisner"], "word_count": {"accuraci": 1, "accur": 1, "advantag": 1, "automat": 1, "bad": 1, "carri": 1, "common": 1, "compar": 1, "comput": 1, "converg": 1, "depend": 1, "discuss": 1, "diverg": 2, "easi": 1, "explicit": 1, "fit": 1, "formula": 5, "function": 2, "inaccur": 1, "integr": 7, "kind": 1, "known": 1, "method": 1, "need": 1, "numer": 1, "occur": 1, "order": 2, "overwhelm": 1, "pole": 6, "polynomi": 1, "posit": 1, "rang": 1, "shown": 1, "simpson": 2, "singular": 2, "eisner": 1}}, "1609": {"id": "1609", "title": "Scheduling University Course Examinations by Computer", "abstract": "A new approach to the problem of scheduling course examinations is presented.  In principle,  an examination schedule which requires a minimum number of examination periods and satisfies the constraint  that no student be required to take two examinations simultaneously can be found in two steps.  First,  course which may have their examinations scheduled at the same period are grouped together in all possible  ways.  Then a minimum number of these groups, such that each course is included at least once, are selected.   By removing multiple occurrences of courses and then scheduling each group at a different period a minimal  schedule can be obtained.  Known algorithms for carrying out these procedures are prohibitively expensive.   Approximations to the ideal procedure outlined above are given which yield nonminimal but feasible schedules  with a very small expenditure of time.  Results of experiments using these techniques are given.  These  are encouraging and indicate that further experimentation would be worthwhile.", "authors": "Hall Jr., A. D. Acton, F. S.", "words_pool": ["algorithm", "approach", "approxim", "carri", "comput", "constraint", "cours", "cours", "encourag", "examin", "examin", "expenditur", "expens", "experiment", "experi", "feasibl", "found", "group", "group", "group", "ideal", "includ", "known", "minim", "minimum", "multipl", "nonminim", "number", "obtain", "occurr", "outlin", "period", "period", "present", "principl", "problem", "procedur", "procedur", "prohibit", "remov", "requir", "requir", "result", "satisfi", "schedul", "schedul", "schedul", "schedul", "select", "simultan", "small", "step", "student", "take", "techniqu", "time", "univers", "way", "worthwhil", "yield", "hall", "jr", "acton"], "word_count": {"algorithm": 1, "approach": 1, "approxim": 1, "carri": 1, "comput": 1, "constraint": 1, "cours": 4, "encourag": 1, "examin": 5, "expenditur": 1, "expens": 1, "experiment": 1, "experi": 1, "feasibl": 1, "found": 1, "group": 3, "ideal": 1, "includ": 1, "known": 1, "minim": 1, "minimum": 2, "multipl": 1, "nonminim": 1, "number": 2, "obtain": 1, "occurr": 1, "outlin": 1, "period": 3, "present": 1, "principl": 1, "problem": 1, "procedur": 2, "prohibit": 1, "remov": 1, "requir": 2, "result": 1, "satisfi": 1, "schedul": 6, "select": 1, "simultan": 1, "small": 1, "step": 1, "student": 1, "take": 1, "techniqu": 1, "time": 1, "univers": 1, "way": 1, "worthwhil": 1, "yield": 1, "hall": 1, "jr": 1, "acton": 1}}, "1610": {"id": "1610", "title": "A Method for the Solution of Transportation Problems with Tall Matrices", "abstract": "A method is presented for the solution of the transportation problem having a cost matrix with  few columns.  The computer implementation of this method shows it to be very fast and efficient.  Application  are indicted for the personnel classification problem as well as the classical transportation problem.   An example is worked out in detail.", "authors": "Dwyer, P. S. Galler, B. A.", "words_pool": ["applic", "classic", "classif", "column", "comput", "cost", "detail", "effici", "fast", "implement", "indict", "matric", "matrix", "method", "personnel", "present", "problem", "problem", "show", "solut", "tall", "transport", "work", "dwyer", "galler"], "word_count": {"applic": 1, "classic": 1, "classif": 1, "column": 1, "comput": 1, "cost": 1, "detail": 1, "effici": 1, "fast": 1, "implement": 1, "indict": 1, "matric": 1, "matrix": 1, "method": 2, "personnel": 1, "present": 1, "problem": 3, "show": 1, "solut": 1, "tall": 1, "transport": 2, "work": 1, "dwyer": 1, "galler": 1}}, "1611": {"id": "1611", "title": "Scheduling Project Networks", "abstract": "Some of the basic concepts and terminology of project networking are developed.  The Critical  Path Algorithm incorporated in the C-E-I-R proprietary scheduling system RAMPS (Resource Allocation and  Multi-Project Scheduling) is described.  The error detection and network analysis features of the algorithm  are also described.", "authors": "Klein, M. M.", "words_pool": ["algorithm", "alloc", "analysi", "basic", "concept", "critic", "detect", "develop", "error", "featur", "incorpor", "multi", "network", "network", "network", "path", "project", "proprietari", "ramp", "resourc", "schedul", "system", "terminolog", "klein"], "word_count": {"algorithm": 2, "alloc": 1, "analysi": 1, "basic": 1, "concept": 1, "critic": 1, "detect": 1, "develop": 1, "error": 1, "featur": 1, "incorpor": 1, "multi": 1, "network": 2, "path": 1, "project": 2, "proprietari": 1, "ramp": 1, "resourc": 1, "schedul": 2, "system": 1, "terminolog": 1, "klein": 1}}, "1612": {"id": "1612", "title": "Top-to-bottom Parsing Rehabilitated?", "abstract": "This note is concerned with the efficiency of the Top-to-Bottom parsing algorithm as used in  connection with programming language grammars.  It is shown, for instance, that retracing of unprofitable  paths can often be eliminated by a suitable rearrangement of the productions defining the grammar.  The  essential weakness of the method is in dealing with complicated syntactic structures which are in practice  only sparsely occupied, e.g., arithmetic expressions.", "authors": "Brooker, R. A.", "words_pool": ["algorithm", "arithmet", "bottom", "complic", "concern", "connect", "deal", "defin", "effici", "elimin", "essenti", "express", "grammar", "grammar", "instanc", "languag", "method", "note", "occupi", "pars", "path", "practic", "product", "program", "rearrang", "rehabilit", "retrac", "shown", "spars", "structur", "suitabl", "syntact", "top", "unprofit", "weak", "brooker"], "word_count": {"algorithm": 1, "arithmet": 1, "bottom": 1, "complic": 1, "concern": 1, "connect": 1, "deal": 1, "defin": 1, "effici": 1, "elimin": 1, "essenti": 1, "express": 1, "grammar": 2, "instanc": 1, "languag": 1, "method": 1, "note": 1, "occupi": 1, "pars": 1, "path": 1, "practic": 1, "product": 1, "program": 1, "rearrang": 1, "rehabilit": 1, "retrac": 1, "shown": 1, "spars": 1, "structur": 1, "suitabl": 1, "syntact": 1, "top": 1, "unprofit": 1, "weak": 1, "brooker": 1}}, "1613": {"id": "1613", "title": "One-Pass Compilation of Arithmetic Expressions for a Parallel Processor", "abstract": "Under the assumption that a processor may have a multiplicity of arithmetic units, a compiler  for such a processor should produce object code to take advantage of possible parallelism of operation.   Most of the presently known compilation techniques are inadequate for such a processor because they  produce expression structures that must be evaluated serially.  A technique is presented here for compiling  arithmetic expressions into structures that can be evaluated with a high degree of parallelism.  The  algorithm is a variant of the so-called \"top-down\" analysis technique, and requires only one pass of  the input text.", "authors": "Stone, H. S.", "words_pool": ["advantag", "algorithm", "analysi", "arithmet", "assumpt", "call", "code", "compil", "compil", "compil", "degre", "evalu", "express", "express", "high", "inadequ", "input", "known", "multipl", "object", "oper", "parallel", "parallel", "pass", "present", "present", "processor", "produc", "requir", "serial", "structur", "take", "techniqu", "techniqu", "text", "top", "unit", "variant", "stone"], "word_count": {"advantag": 1, "algorithm": 1, "analysi": 1, "arithmet": 2, "assumpt": 1, "call": 1, "code": 1, "compil": 3, "degre": 1, "evalu": 2, "express": 2, "high": 1, "inadequ": 1, "input": 1, "known": 1, "multipl": 1, "object": 1, "oper": 1, "parallel": 2, "pass": 1, "present": 2, "processor": 3, "produc": 2, "requir": 1, "serial": 1, "structur": 2, "take": 1, "techniqu": 3, "text": 1, "top": 1, "unit": 1, "variant": 1, "stone": 1}}, "1614": {"id": "1614", "title": "A Proposal for Definitions in ALGOL", "abstract": "An extension to ALGOL is proposed for adding new data types and operators to the language.   Definitions may occur in any block heading and terminate with the block.  They are an integral part  of the program and are not fixed in the language.  Even the behavior of existing operators may be redefined.   The processing of text containing defined contexts features a \"replacement rule\" that eliminates unnecessary  iterations and temporary storage.  Examples of definition sets are given for real and complex matrices,  complex numbers, file processing, and list manipulation.", "authors": "Galler, B. A. Perlis, A. J.", "words_pool": ["ad", "algol", "behavior", "block", "complex", "context", "data", "defin", "definit", "definit", "elimin", "exampl", "exist", "extens", "featur", "fix", "head", "integr", "iter", "languag", "list", "manipul", "matric", "number", "occur", "oper", "part", "process", "program", "propos", "propos", "real", "redefin", "replac", "rule", "set", "storag", "temporari", "termin", "text", "type", "unnecessari", "galler", "perli"], "word_count": {"ad": 1, "algol": 1, "behavior": 1, "block": 2, "complex": 2, "context": 1, "data": 1, "defin": 1, "definit": 2, "elimin": 1, "exampl": 1, "exist": 1, "extens": 1, "featur": 1, "fix": 1, "head": 1, "integr": 1, "iter": 1, "languag": 2, "list": 1, "manipul": 1, "matric": 1, "number": 1, "occur": 1, "oper": 2, "part": 1, "process": 2, "program": 1, "propos": 1, "real": 1, "redefin": 1, "replac": 1, "rule": 1, "set": 1, "storag": 1, "temporari": 1, "termin": 1, "text": 1, "type": 1, "unnecessari": 1, "galler": 1, "perli": 1}}, "1615": {"id": "1615", "title": "An Algorithm for Generating Root Locus Diagrams", "abstract": "A technique for using a digital computer to draw both ordinary and time-lag root locus diagrams  is described.  Ordinary diagrams are drawn much faster and more accurately than ever before.  Time-lag  diagrams, which had been impossible to obtain, are drawn with the same speed and accuracy as ordinary  diagrams.", "authors": "Krall, A. M. Fornaro, R.", "words_pool": ["accuraci", "accur", "algorithm", "comput", "diagram", "digit", "draw", "drawn", "faster", "gener", "imposs", "lag", "locu", "obtain", "ordinari", "root", "speed", "techniqu", "time", "krall", "fornaro"], "word_count": {"accuraci": 1, "accur": 1, "algorithm": 1, "comput": 1, "diagram": 4, "digit": 1, "draw": 1, "drawn": 2, "faster": 1, "gener": 1, "imposs": 1, "lag": 2, "locu": 1, "obtain": 1, "ordinari": 3, "root": 1, "speed": 1, "techniqu": 1, "time": 2, "krall": 1, "fornaro": 1}}, "1616": {"id": "1616", "title": "Tensor Calculations on Computer: Appendix", "abstract": "In the main text of the paper [Comm. ACM 9, 12 (Dec. 196), 864], a FORMAC program was discussed  which is capable of calculating various quantities of interest in tensor calculus.  This Appendix is  intended as an example of the program output.  Chrisoffel symbols calculated for 12 basic orthogonal  coordinate systems are listed.", "authors": "Walton, J. J.", "words_pool": ["acm", "appendix", "basic", "calcul", "calcul", "calcul", "calculu", "capabl", "chrisoffel", "comm", "comput", "coordin", "dec", "discuss", "formac", "intend", "interest", "list", "main", "orthogon", "output", "paper", "program", "quantiti", "symbol", "system", "tensor", "text", "walton"], "word_count": {"acm": 1, "appendix": 1, "basic": 1, "calcul": 2, "calculu": 1, "capabl": 1, "chrisoffel": 1, "comm": 1, "comput": 1, "coordin": 1, "dec": 1, "discuss": 1, "formac": 1, "intend": 1, "interest": 1, "list": 1, "main": 1, "orthogon": 1, "output": 1, "paper": 1, "program": 2, "quantiti": 1, "symbol": 1, "system": 1, "tensor": 1, "text": 1, "walton": 1}}, "1617": {"id": "1617", "title": "Eigenvalues and Eigenvectors of the Symmetric System (Algorithm 297 [F2])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "eigenvalu", "eigenvector", "f2", "symmetr", "system", "boothroyd"], "word_count": {"algorithm": 1, "eigenvalu": 1, "eigenvector": 1, "f2": 1, "symmetr": 1, "system": 1, "boothroyd": 1}}, "1618": {"id": "1618", "title": "Determination of the Square-Root of a Positive Definite Matrix (Algorithm 298 [F1])", "authors": "Spath, H.", "words_pool": ["algorithm", "definit", "determin", "f1", "matrix", "posit", "root", "squar", "spath"], "word_count": {"algorithm": 1, "definit": 1, "determin": 1, "f1": 1, "matrix": 1, "posit": 1, "root": 1, "squar": 1, "spath": 1}}, "1619": {"id": "1619", "title": "Error-Free Methods for Statistical Computations", "abstract": "Neely has discussed computational error generated by some algorithms used to compute various  statistics.  In the present paper methods are described which are error-free, simple in concept, and  usually less costly in machine time than those mentioned by Neely.", "authors": "Rodden, B. E.", "words_pool": ["algorithm", "comput", "comput", "comput", "concept", "costli", "discuss", "error", "free", "gener", "machin", "mention", "method", "neeli", "paper", "present", "simpl", "statist", "statist", "time", "rodden"], "word_count": {"algorithm": 1, "comput": 2, "concept": 1, "costli": 1, "discuss": 1, "error": 2, "free": 1, "gener": 1, "machin": 1, "mention": 1, "method": 1, "neeli": 2, "paper": 1, "present": 1, "simpl": 1, "statist": 1, "time": 1, "rodden": 1}}, "1620": {"id": "1620", "title": "Methods of Evaluating Polynomial Approximations in Function Evaluation Routines", "abstract": "The method of nested multiplication is commonly used in function evaluation routines to evaluate  approximation polynomials.  New polynomial evaluation methods have been developed in recent years which  require fewer multiplications than nested multiplication and may therefore be preferable for use in function  evaluation routines.  Although some of these methods do not appear to be practically useful because of  rounding-error difficulties, several methods of evaluating low-degree polynomials have been found to  be satisfactory.  Three such methods are described and illustrated.", "authors": "File, C. T.", "words_pool": ["approxim", "approxim", "commonli", "degre", "develop", "difficulti", "error", "evalu", "evalu", "evalu", "fewer", "found", "function", "illustr", "low", "method", "method", "multipl", "multipl", "nest", "polynomi", "polynomi", "practic", "prefer", "recent", "requir", "round", "routin", "satisfactori", "year"], "word_count": {"approxim": 1, "commonli": 1, "degre": 1, "develop": 1, "difficulti": 1, "error": 1, "evalu": 5, "fewer": 1, "found": 1, "function": 2, "illustr": 1, "low": 1, "method": 5, "multipl": 3, "nest": 2, "polynomi": 3, "practic": 1, "prefer": 1, "recent": 1, "requir": 1, "round": 1, "routin": 2, "satisfactori": 1, "year": 1}}, "1621": {"id": "1621", "title": "Computer Typesetting of ALGOL", "abstract": "An application of computer-aided typesetting is introduced.  A working method is described  for publishing ALGOL by computerized translation from Hardware into Reference representation, computerized  planning of typographical lay-out and computerized control of a typesetting machine.  The point is made  that experts in science, technology, and programming are guaranteed a correct ALGOL documentation without  spending valuable time and power on typographic considerations and proofreading.", "authors": "Sydow, L. V.", "words_pool": ["aid", "algol", "applic", "comput", "computer", "consider", "control", "correct", "document", "expert", "guarante", "hardwar", "introduc", "lay", "machin", "made", "method", "plan", "point", "power", "program", "proofread", "publish", "refer", "represent", "scienc", "spend", "technolog", "time", "translat", "typeset", "typograph", "typograph", "valuabl", "work", "sydow"], "word_count": {"aid": 1, "algol": 2, "applic": 1, "comput": 1, "computer": 3, "consider": 1, "control": 1, "correct": 1, "document": 1, "expert": 1, "guarante": 1, "hardwar": 1, "introduc": 1, "lay": 1, "machin": 1, "made": 1, "method": 1, "plan": 1, "point": 1, "power": 1, "program": 1, "proofread": 1, "publish": 1, "refer": 1, "represent": 1, "scienc": 1, "spend": 1, "technolog": 1, "time": 1, "translat": 1, "typeset": 2, "typograph": 2, "valuabl": 1, "work": 1, "sydow": 1}}, "1622": {"id": "1622", "title": "An Efficient Procedure for the Generation of Closed Subsets", "abstract": "An efficient algorithm is described for generating subsets of a set S which satisfy constraints  of the form: \"If s(i) is a member of the subset, then s(j) must also be a member of the subset.\"  The  algorithm has been programmed in the WISP language and successfully run on the IBM 7094 in connection  with a routine to detect feedback in multidimensional iterative networks.", "authors": "Waite, W. M.", "words_pool": ["algorithm", "close", "connect", "constraint", "detect", "effici", "feedback", "form", "gener", "gener", "ibm", "iter", "languag", "member", "multidimension", "network", "procedur", "program", "routin", "run", "satisfi", "set", "subset", "subset", "success", "wisp", "wait"], "word_count": {"algorithm": 2, "close": 1, "connect": 1, "constraint": 1, "detect": 1, "effici": 1, "feedback": 1, "form": 1, "gener": 1, "ibm": 1, "iter": 1, "languag": 1, "member": 2, "multidimension": 1, "network": 1, "procedur": 1, "program": 1, "routin": 1, "run": 1, "satisfi": 1, "set": 1, "subset": 3, "success": 1, "wisp": 1, "wait": 1}}, "1623": {"id": "1623", "title": "An Application of FORMAC", "abstract": "A nonlinear circuit analysis problem is stated and the way in which it was solved using FORMAC  is indicated.  The solution of the problem using FORMAC was notable since several other methods that  were tried failed.  The problem is straightforward (although untenable by hand) but nevertheless involved  an elaborate use of the FORMAC language.  The program was fairly large and utilized practically every  command.  In particular, it made extensive use of the PART command.  Several tricks were necessary in  order to circumvent some of the shortcomings of the FORMAC system.  This paper is more concerned with  the use of programming techniques in FORMAC than with the actual engineering problem, although readers  may be interested in the problem because it is stated in a general (mathematical) sense and could be  of interest in areas other than circuit analysis.", "authors": "Neidleman, L. D.", "words_pool": ["actual", "analysi", "applic", "area", "circuit", "circumv", "command", "concern", "elabor", "engin", "extens", "fail", "fairli", "formac", "gener", "hand", "interest", "interest", "involv", "languag", "larg", "made", "mathemat", "method", "nonlinear", "notabl", "order", "paper", "part", "practic", "problem", "program", "program", "reader", "sens", "shortcom", "solut", "solv", "state", "straightforward", "system", "techniqu", "trick", "tri", "unten", "util", "neidleman"], "word_count": {"actual": 1, "analysi": 2, "applic": 1, "area": 1, "circuit": 2, "circumv": 1, "command": 2, "concern": 1, "elabor": 1, "engin": 1, "extens": 1, "fail": 1, "fairli": 1, "formac": 5, "gener": 1, "hand": 1, "interest": 2, "involv": 1, "languag": 1, "larg": 1, "made": 1, "mathemat": 1, "method": 1, "nonlinear": 1, "notabl": 1, "order": 1, "paper": 1, "part": 1, "practic": 1, "problem": 5, "program": 2, "reader": 1, "sens": 1, "shortcom": 1, "solut": 1, "solv": 1, "state": 2, "straightforward": 1, "system": 1, "techniqu": 1, "trick": 1, "tri": 1, "unten": 1, "util": 1, "neidleman": 1}}, "1624": {"id": "1624", "title": "Automatic Dimensioning", "abstract": "Examples of algorithm that will accomplish automatic storage reservation without the need for  explicit array declarations are described.", "authors": "Klerer, M. May, J.", "words_pool": ["accomplish", "algorithm", "array", "automat", "declar", "dimens", "exampl", "explicit", "need", "reserv", "storag", "klerer"], "word_count": {"accomplish": 1, "algorithm": 1, "array": 1, "automat": 1, "declar": 1, "dimens": 1, "exampl": 1, "explicit": 1, "need": 1, "reserv": 1, "storag": 1, "klerer": 1}}, "1625": {"id": "1625", "title": "On the Automatic Simplification of Source-Language Programs", "abstract": "Methods of simplification that can be applied automatically to programs written in an ALGOL-like  language are discussed.  The simplifications are based on the form of the program and the knowledge obtained  by a processor, without any understanding of what the program is supposed to do.  These methods have  been implemented in a processor called SURE that accepts a program written in JOVIAL and outputs an equivalent  JOVIAL program that may be shorter and may be executed faster than the original.  SURE is described,  some of the problems encountered in automatic improvement at the source-language level are discussed,  and further types of automatic program improvement are suggested.", "authors": "Clark, E. R.", "words_pool": ["accept", "algol", "appli", "automat", "base", "call", "discuss", "encount", "equival", "execut", "faster", "form", "implement", "improv", "jovial", "knowledg", "languag", "level", "method", "obtain", "origin", "output", "problem", "processor", "program", "program", "shorter", "simplif", "simplif", "sourc", "suggest", "suppos", "sure", "type", "understand", "written", "clark"], "word_count": {"accept": 1, "algol": 1, "appli": 1, "automat": 2, "base": 1, "call": 1, "discuss": 2, "encount": 1, "equival": 1, "execut": 1, "faster": 1, "form": 1, "implement": 1, "improv": 2, "jovial": 2, "knowledg": 1, "languag": 2, "level": 1, "method": 2, "obtain": 1, "origin": 1, "output": 1, "problem": 1, "processor": 2, "program": 6, "shorter": 1, "simplif": 2, "sourc": 1, "suggest": 1, "suppos": 1, "sure": 2, "type": 1, "understand": 1, "written": 2, "clark": 1}}, "1626": {"id": "1626", "title": "Structure of a LISP System Using Two-Level Storage", "abstract": "In an ideal list-processing system there would be enough core memory to contain all the data  and programs.  Described in this paper are a number of techniques that have been used to build a LISP  system utilizing a drum for its principal storage medium,  with a surprisingly low time penalty for use  of this slow storage device.  The techniques include careful segmentation of system programs, allocation  of virtual memory to allow address arithmetic for type determination, and a special algorithm for building  reasonably linearized lists.  A scheme for binding variables is described which is good in this environment  and allows for complete compatibility between compiled and interpreted programs with no special declarations.", "authors": "Bobrow, D. G. Murphy, D. L.", "words_pool": ["address", "algorithm", "alloc", "allow", "arithmet", "bind", "build", "build", "care", "compat", "compil", "complet", "core", "data", "declar", "determin", "devic", "drum", "environ", "good", "ideal", "includ", "interpret", "level", "linear", "lisp", "list", "list", "low", "medium", "memori", "number", "paper", "penalti", "princip", "process", "program", "reason", "scheme", "segment", "slow", "special", "storag", "structur", "surprisingli", "system", "techniqu", "time", "type", "util", "variabl", "virtual", "bobrow", "murphi"], "word_count": {"address": 1, "algorithm": 1, "alloc": 1, "allow": 1, "arithmet": 1, "bind": 1, "build": 2, "care": 1, "compat": 1, "compil": 1, "complet": 1, "core": 1, "data": 1, "declar": 1, "determin": 1, "devic": 1, "drum": 1, "environ": 1, "good": 1, "ideal": 1, "includ": 1, "interpret": 1, "level": 1, "linear": 1, "lisp": 1, "list": 2, "low": 1, "medium": 1, "memori": 2, "number": 1, "paper": 1, "penalti": 1, "princip": 1, "process": 1, "program": 3, "reason": 1, "scheme": 1, "segment": 1, "slow": 1, "special": 2, "storag": 2, "structur": 1, "surprisingli": 1, "system": 3, "techniqu": 2, "time": 1, "type": 1, "util": 1, "variabl": 1, "virtual": 1, "bobrow": 1, "murphi": 1}}, "1627": {"id": "1627", "title": "Application of Level Changing to a Multilevel Storage Organization", "abstract": "A technique for organizing the devices of a computer storage system is described.  This technique,  called the multilevel store, provides a means for economically satisfying the requirements for very large  storage capacities of certain data management and information retrieval systems.  The concept of level  changing is introduced and its application to the multilevel store is discussed.  A possible means for  physically organizing the information for efficient use of the multilevel store is presented.", "authors": "Morenoff, E. McLean, J. B.", "words_pool": ["applic", "call", "capac", "chang", "comput", "concept", "data", "devic", "discuss", "econom", "effici", "inform", "introduc", "larg", "level", "manag", "mean", "multilevel", "organ", "organ", "physic", "present", "requir", "retriev", "satisfi", "storag", "store", "system", "system", "techniqu", "morenoff", "mclean"], "word_count": {"applic": 1, "call": 1, "capac": 1, "chang": 1, "comput": 1, "concept": 1, "data": 1, "devic": 1, "discuss": 1, "econom": 1, "effici": 1, "inform": 2, "introduc": 1, "larg": 1, "level": 1, "manag": 1, "mean": 2, "multilevel": 3, "organ": 2, "physic": 1, "present": 1, "requir": 1, "retriev": 1, "satisfi": 1, "storag": 2, "store": 3, "system": 2, "techniqu": 2, "morenoff": 1, "mclean": 1}}, "1628": {"id": "1628", "title": "The Emergence of a Profession", "abstract": "Computer programming deals with an enormous variety of activities and is carried on by people  with a great variety of backgrounds.  It seems clear that part but not all of this activity is evolving  toward a distinct professional field, but that the scope of this emerging profession, and some of its  economic, social, and educational characteristics are as yet by no means well defined.  In this paper,  these issues are examined and some opinions about them are expressed.", "authors": "Orden, A.", "words_pool": ["activ", "activ", "background", "carri", "characterist", "clear", "comput", "deal", "defin", "distinct", "econom", "educ", "emerg", "emerg", "enorm", "evolv", "examin", "express", "field", "great", "issu", "mean", "opinion", "paper", "part", "peopl", "profess", "profession", "program", "scope", "social", "varieti", "orden"], "word_count": {"activ": 2, "background": 1, "carri": 1, "characterist": 1, "clear": 1, "comput": 1, "deal": 1, "defin": 1, "distinct": 1, "econom": 1, "educ": 1, "emerg": 1, "enorm": 1, "evolv": 1, "examin": 1, "express": 1, "field": 1, "great": 1, "issu": 1, "mean": 1, "opinion": 1, "paper": 1, "part": 1, "peopl": 1, "profess": 1, "profession": 1, "program": 1, "scope": 1, "social": 1, "varieti": 2, "orden": 1}}, "1629": {"id": "1629", "title": "Stat-Pack: A Biostatistical Programming Package", "abstract": "A package of FORTRAN statistical programs for use on almost any small to medium size (40k characters  or 8k words) for which a FORTRAN II compiler exists is described and its availability is announced.   The major design criteria of ease of use, ease of modification, flexibility of input and detail of output  are described.", "authors": "Shannon, S. Henschke, C.", "words_pool": ["40k", "8k", "announc", "avail", "biostatist", "charact", "compil", "criteria", "design", "detail", "eas", "exist", "flexibl", "fortran", "ii", "input", "major", "medium", "modif", "output", "pack", "packag", "program", "program", "size", "small", "stat", "statist", "word", "shannon", "henschk"], "word_count": {"40k": 1, "8k": 1, "announc": 1, "avail": 1, "biostatist": 1, "charact": 1, "compil": 1, "criteria": 1, "design": 1, "detail": 1, "eas": 2, "exist": 1, "flexibl": 1, "fortran": 2, "ii": 1, "input": 1, "major": 1, "medium": 1, "modif": 1, "output": 1, "pack": 1, "packag": 1, "program": 1, "size": 1, "small": 1, "stat": 1, "statist": 1, "word": 1, "shannon": 1, "henschk": 1}}, "1630": {"id": "1630", "title": "Computer Representation of Planar Regions by Their Skeletons", "abstract": "Any region can be regarded as a union of maximal neighborhoods of its points, and can be specified  by the centers and radii of these neighborhoods; this set is a sort of\"skeleton\" of the region.  The  storage required to represent a region in this way is comparable to that required when it is represented  by encoding its boundary.  Moreover, the skeleton representation seems to have advantages when it is  necessary to determine repeatedly whether points are inside or outside the region, or to perform set-theoretic  operations on regions.", "authors": "Pfaltz, J. L. Rosenfeld, A.", "words_pool": ["advantag", "boundari", "center", "compar", "comput", "determin", "encod", "insid", "maxim", "neighborhood", "oper", "perform", "planar", "point", "radii", "regard", "region", "region", "repeatedli", "repres", "represent", "repres", "requir", "set", "skeleton", "skeleton", "sort", "storag", "theoret", "union", "pfaltz", "rosenfeld"], "word_count": {"advantag": 1, "boundari": 1, "center": 1, "compar": 1, "comput": 1, "determin": 1, "encod": 1, "insid": 1, "maxim": 1, "neighborhood": 2, "oper": 1, "perform": 1, "planar": 1, "point": 2, "radii": 1, "regard": 1, "region": 5, "repeatedli": 1, "repres": 2, "represent": 1, "requir": 2, "set": 2, "skeleton": 2, "sort": 1, "storag": 1, "theoret": 1, "union": 1, "pfaltz": 1, "rosenfeld": 1}}, "1631": {"id": "1631", "title": "Testing a Random Number Generator", "abstract": "The first 1,000,000 numbers produced by the random number generator used in the General Purpose  Systems Simulator (GPSS) were subjected to statistical tests.  The tests are described and the results  of the tests are presented.  These particular tests indicate that the numbers are satisfactory.  It is  recommended that suitable tests be applied to all random numbers used in computer simulations.", "authors": "Gorenstein, S.", "words_pool": ["appli", "comput", "gener", "gener", "gpss", "number", "number", "present", "produc", "purpos", "random", "recommend", "result", "satisfactori", "simul", "simul", "statist", "subject", "suitabl", "system", "test", "test", "gorenstein"], "word_count": {"appli": 1, "comput": 1, "gener": 2, "gpss": 1, "number": 4, "present": 1, "produc": 1, "purpos": 1, "random": 2, "recommend": 1, "result": 1, "satisfactori": 1, "simul": 2, "statist": 1, "subject": 1, "suitabl": 1, "system": 1, "test": 5, "gorenstein": 1}}, "1632": {"id": "1632", "title": "Programming the Tabular Method of Analysis of Variance for Factorial Experiments", "abstract": "The ease of programming the tabular method of analysis of variance for complete factorial experiments  in a FORTRAN language is demonstrated.  In this method, the total sum of squares is partitioned into  orthogonal single degree of freedom sums of squares; main effect and interaction sums of squares are  then obtained by appropriate pooling of the single degree of freedom sums of squares.  Program segments  to accomplish the procedure are presented.  Modifications to handle hierarchical designs and replicated  experiments are mentioned. A FORTRAN II program for an IBM 7094 is described briefly.", "authors": "Carmer, S. G.", "words_pool": ["accomplish", "analysi", "briefli", "complet", "degre", "demonstr", "design", "eas", "effect", "experi", "factori", "fortran", "freedom", "handl", "hierarch", "ibm", "ii", "interact", "languag", "main", "mention", "method", "modif", "obtain", "orthogon", "partit", "pool", "present", "procedur", "program", "program", "replic", "segment", "singl", "squar", "sum", "sum", "tabular", "total", "varianc", "carmer"], "word_count": {"accomplish": 1, "analysi": 1, "briefli": 1, "complet": 1, "degre": 2, "demonstr": 1, "design": 1, "eas": 1, "effect": 1, "experi": 2, "factori": 1, "fortran": 2, "freedom": 2, "handl": 1, "hierarch": 1, "ibm": 1, "ii": 1, "interact": 1, "languag": 1, "main": 1, "mention": 1, "method": 2, "modif": 1, "obtain": 1, "orthogon": 1, "partit": 1, "pool": 1, "present": 1, "procedur": 1, "program": 3, "replic": 1, "segment": 1, "singl": 2, "squar": 4, "sum": 4, "tabular": 1, "total": 1, "varianc": 1, "carmer": 1}}, "1633": {"id": "1633", "title": "A Modified Newton Method for Polynomials", "abstract": "A modified Newton method for polynomials is discussed.  It is assumed one has approximations  for all the roots of the polynomial.  Three variations are described.  If the roots are simple, it is  shown that under appropriate conditions, two of the variations are cubically convergent.", "authors": "Ehrlich, L. W.", "words_pool": ["approxim", "assum", "condit", "converg", "cubic", "discuss", "method", "modifi", "newton", "polynomi", "polynomi", "root", "shown", "simpl", "variat", "ehrlich"], "word_count": {"approxim": 1, "assum": 1, "condit": 1, "converg": 1, "cubic": 1, "discuss": 1, "method": 1, "modifi": 1, "newton": 1, "polynomi": 2, "root": 2, "shown": 1, "simpl": 1, "variat": 2, "ehrlich": 1}}, "1634": {"id": "1634", "title": "27 bits Are Not Enough for 8-digit Accuracy", "abstract": "From the inequality 10^8 < 2^27, we are likely to conclude that we can represent 8-digit decimal  floating-point numbers accurately by 27-bit floating-point numbers.  However, we need 28 significant  bits to represent some 8-digit numbers accurately.  In general, we can show that if 10^p < 2^q-1, then  q significant bits are always enough for p-digit decimal accuracy.  Finally, we can define a compact  27-bit floating-point representation that will give 28 significant bits, for numbers of practical importance.", "authors": "Goldberg, I. B.", "words_pool": ["accuraci", "accur", "bit", "bit", "compact", "conclud", "decim", "defin", "digit", "final", "float", "gener", "give", "import", "inequ", "like", "need", "number", "point", "practic", "repres", "represent", "show", "signific", "goldberg"], "word_count": {"accuraci": 1, "accur": 2, "bit": 5, "compact": 1, "conclud": 1, "decim": 2, "defin": 1, "digit": 3, "final": 1, "float": 3, "gener": 1, "give": 1, "import": 1, "inequ": 1, "like": 1, "need": 1, "number": 4, "point": 3, "practic": 1, "repres": 2, "represent": 1, "show": 1, "signific": 3, "goldberg": 1}}, "1635": {"id": "1635", "title": "Parameters for Pseudo Runge-Kutta Methods", "abstract": "The object of this note is to present a choice of the free parameters in the third- and fourth-order  pseudo Runge-Kutta methods involving two points. This choice of parameters causes a bound on the principal  part of the truncation error term to be near the minimum for the fourth-order method and at the minimum  for the third-order method.", "authors": "Byrne, G. D.", "words_pool": ["bound", "choic", "error", "fourth", "free", "involv", "kutta", "method", "method", "minimum", "note", "object", "order", "paramet", "part", "point", "present", "princip", "pseudo", "rung", "term", "truncat", "byrn"], "word_count": {"bound": 1, "choic": 2, "error": 1, "fourth": 2, "free": 1, "involv": 1, "kutta": 1, "method": 3, "minimum": 2, "note": 1, "object": 1, "order": 3, "paramet": 2, "part": 1, "point": 1, "present": 1, "princip": 1, "pseudo": 1, "rung": 1, "term": 1, "truncat": 1, "byrn": 1}}, "1636": {"id": "1636", "title": "Invariant Imbeding and the Numerical Integration of Boundary-Value Problems for Unstable Linear  Systems of Ordinary Differential Equations", "abstract": "In such diverse areas as radiative transfer in planetary atmospheres and optimal guidance and  control, two-point boundary-value problems for unstable systems arise, greatly complicating the numerical  solution.  An invariant imbeding technique is presented which is useful in overcoming these frequently  encountered instabilities, and the results of some numerical experiments are given.", "authors": "Belman, R. E. Kagiwada, H. H. Kalaba, R. E.", "words_pool": ["area", "aris", "atmospher", "boundari", "complic", "control", "differenti", "divers", "encount", "equat", "experi", "frequent", "greatli", "guidanc", "imbed", "instabl", "integr", "invari", "linear", "numer", "optim", "ordinari", "overcom", "planetari", "point", "present", "problem", "radi", "result", "solut", "system", "techniqu", "transfer", "unstabl", "belman", "kagiwada", "kalaba"], "word_count": {"area": 1, "aris": 1, "atmospher": 1, "boundari": 1, "complic": 1, "control": 1, "differenti": 1, "divers": 1, "encount": 1, "equat": 1, "experi": 1, "frequent": 1, "greatli": 1, "guidanc": 1, "imbed": 1, "instabl": 1, "integr": 1, "invari": 1, "linear": 1, "numer": 2, "optim": 1, "ordinari": 1, "overcom": 1, "planetari": 1, "point": 1, "present": 1, "problem": 1, "radi": 1, "result": 1, "solut": 1, "system": 1, "techniqu": 1, "transfer": 1, "unstabl": 1, "belman": 1, "kagiwada": 1, "kalaba": 1}}, "1637": {"id": "1637", "title": "Problems in the Statistical Analysis of Simulation Experiments: The Comparison of Means and the  Length of Sample Records", "abstract": "Research is continued into statistical analysis of simulation experiments containing autocorrelated  time series.  It is shown how to estimate the lengths of sample records needed to use certain large sample  results in measuring stability.  Analogies between autocorrelated data and independent observations are  described.  A way to test the difference of the mean of two experiments is suggested.  It is shown how  the variance of the sample mean relates to the spectrum of the generating process, and estimation of  the quantities of interest is described. The results expand the possibilities of statistical spectral  analysis as applied to simulation experiments.", "authors": "Fishman, G. S.", "words_pool": ["analog", "analysi", "appli", "autocorrel", "comparison", "continu", "data", "differ", "estim", "estim", "expand", "experi", "gener", "independ", "interest", "larg", "length", "length", "mean", "mean", "measur", "need", "observ", "possibl", "problem", "process", "quantiti", "record", "relat", "research", "result", "sampl", "seri", "shown", "simul", "spectral", "spectrum", "stabil", "statist", "suggest", "test", "time", "varianc", "fishman"], "word_count": {"analog": 1, "analysi": 2, "appli": 1, "autocorrel": 2, "comparison": 1, "continu": 1, "data": 1, "differ": 1, "estim": 2, "expand": 1, "experi": 3, "gener": 1, "independ": 1, "interest": 1, "larg": 1, "length": 1, "mean": 2, "measur": 1, "need": 1, "observ": 1, "possibl": 1, "problem": 1, "process": 1, "quantiti": 1, "record": 1, "relat": 1, "research": 1, "result": 2, "sampl": 3, "seri": 1, "shown": 2, "simul": 2, "spectral": 1, "spectrum": 1, "stabil": 1, "statist": 2, "suggest": 1, "test": 1, "time": 1, "varianc": 1, "fishman": 1}}, "1638": {"id": "1638", "title": "Sorting by Replacement Selecting", "abstract": "In sorting by replacement selecting, the expected length of a sequence beginning with the i-th  element (i>1) is proved to be 2F, in accordance with a conjecture of E. H. Friend, where F is the number  of memory cells used.  The expected length of the j-th sequence is determined to be F times a j-th degree  polynomial in e, such that the value of this polynomial approaches 2 as j approaches infinity.  Recursive  formulas are obtained for both the mean and the standard deviation of the length of the j-th sequence.   The mathematical proofs of these results are based upon the assumption that n, the number of items to  be sorted, is infinite, but it is shown that the error due to the finiteness of n approaches zero rapidly  as n increases.", "authors": "Gasner, B. J.", "words_pool": ["2f", "accord", "approach", "assumpt", "base", "begin", "cell", "conjectur", "degre", "determin", "deviat", "due", "element", "error", "expect", "finit", "formula", "friend", "increas", "infinit", "infin", "item", "length", "mathemat", "mean", "memori", "number", "obtain", "polynomi", "proof", "prove", "rapidli", "recurs", "replac", "result", "select", "sequenc", "shown", "sort", "sort", "standard", "th", "time", "gasner"], "word_count": {"2f": 1, "accord": 1, "approach": 3, "assumpt": 1, "base": 1, "begin": 1, "cell": 1, "conjectur": 1, "degre": 1, "determin": 1, "deviat": 1, "due": 1, "element": 1, "error": 1, "expect": 2, "finit": 1, "formula": 1, "friend": 1, "increas": 1, "infinit": 1, "infin": 1, "item": 1, "length": 3, "mathemat": 1, "mean": 1, "memori": 1, "number": 2, "obtain": 1, "polynomi": 2, "proof": 1, "prove": 1, "rapidli": 1, "recurs": 1, "replac": 1, "result": 1, "select": 1, "sequenc": 3, "shown": 1, "sort": 2, "standard": 1, "th": 4, "time": 1, "gasner": 1}}, "1639": {"id": "1639", "title": "Exponential Curve Fit (Algorithm 295 [E2])", "authors": "Spath, H.", "words_pool": ["algorithm", "curv", "e2", "exponenti", "fit", "spath"], "word_count": {"algorithm": 1, "curv": 1, "e2": 1, "exponenti": 1, "fit": 1, "spath": 1}}, "1640": {"id": "1640", "title": "Generalized Least Squared Fit By Orthogonal Polynomials (Algorithm 296 [E2])", "authors": "Makinson, G. J.", "words_pool": ["algorithm", "e2", "fit", "gener", "orthogon", "polynomi", "squar", "makinson"], "word_count": {"algorithm": 1, "e2": 1, "fit": 1, "gener": 1, "orthogon": 1, "polynomi": 1, "squar": 1, "makinson": 1}}, "1641": {"id": "1641", "title": "A Use of Fast and Slow Memories in List-Processing Languages", "abstract": "A scheme is described which permitting a substantial increase in memory space utilized to store  list-structured data.  It consists in reducing to one level a nonhomogeneous store composed of fast (core)  and slow (disk or drum) memories.  The space available in slow memory is divided into pages each containing  a given number of machine words.  The reduction to a one-level memory is performed by a program which  leaves the most often called pages in the fast memory.  When a new page from slow store is requested,  the page in core having the longest period of inactivity is transferred back to the slow store.  The  complete scheme has been implemented in connection with a LISP embedding into ALGOL, using an IBM 7044  with 32k of core memory and disks.  Gains in memory space were about 100-fold.  As often happens in programming  applications the price of the additional space is computer time.  Although the disks have an access time  10^4 times slower than core, tests indicate that the actual slow down varied from 3 to 10, depending  on the number of pages available in the fast store.", "authors": "Cohen, J.", "words_pool": ["32k", "access", "actual", "addit", "algol", "applic", "back", "call", "complet", "compos", "comput", "connect", "consist", "core", "data", "depend", "disk", "disk", "divid", "drum", "embed", "fast", "fold", "gain", "happen", "ibm", "implement", "inact", "increas", "languag", "leav", "level", "lisp", "list", "longest", "machin", "memori", "memori", "nonhomogen", "number", "page", "page", "perform", "period", "permit", "price", "process", "program", "program", "reduc", "reduct", "request", "scheme", "slow", "slower", "space", "store", "structur", "substanti", "test", "time", "time", "transfer", "util", "vari", "word", "cohen"], "word_count": {"32k": 1, "access": 1, "actual": 1, "addit": 1, "algol": 1, "applic": 1, "back": 1, "call": 1, "complet": 1, "compos": 1, "comput": 1, "connect": 1, "consist": 1, "core": 4, "data": 1, "depend": 1, "disk": 3, "divid": 1, "drum": 1, "embed": 1, "fast": 3, "fold": 1, "gain": 1, "happen": 1, "ibm": 1, "implement": 1, "inact": 1, "increas": 1, "languag": 1, "leav": 1, "level": 2, "lisp": 1, "list": 1, "longest": 1, "machin": 1, "memori": 7, "nonhomogen": 1, "number": 2, "page": 5, "perform": 1, "period": 1, "permit": 1, "price": 1, "process": 1, "program": 2, "reduc": 1, "reduct": 1, "request": 1, "scheme": 2, "slow": 5, "slower": 1, "space": 4, "store": 5, "structur": 1, "substanti": 1, "test": 1, "time": 3, "transfer": 1, "util": 1, "vari": 1, "word": 1, "cohen": 1}}, "1642": {"id": "1642", "title": "Time Sharing on a Computer with a Small Memory", "abstract": "Techniques to make time sharing attractive on a computer with a small central memory are presented.   \"Small\" is taken to mean that only one user program plus a monitor will fit into the memory at any time.   The techniques depend on having two levels of secondary storage: level 1, several times larger than  the main memory and quite fast; and level 2, many times larger and slower than level 1.", "authors": "Fisher, R. O. Shepard, C. D.", "words_pool": ["attract", "central", "comput", "depend", "fast", "fit", "larger", "level", "level", "main", "make", "mean", "memori", "monitor", "present", "program", "secondari", "share", "slower", "small", "storag", "techniqu", "time", "time", "user", "fisher", "shepard"], "word_count": {"attract": 1, "central": 1, "comput": 1, "depend": 1, "fast": 1, "fit": 1, "larger": 2, "level": 4, "main": 1, "make": 1, "mean": 1, "memori": 3, "monitor": 1, "present": 1, "program": 1, "secondari": 1, "share": 1, "slower": 1, "small": 2, "storag": 1, "techniqu": 2, "time": 4, "user": 1, "fisher": 1, "shepard": 1}}, "1643": {"id": "1643", "title": "An Improvement to Iterative Methods of Polynomial Factorization", "abstract": "Methods of polynomial factorization which find the zeros one at a time require the division  of the polynomial by the accepted factor.  It is shown how the accuracy of this division may be increased  by dividing in order of both ascending and descending powers of the variable and choosing a crossover  point which minimizes a very simply calculated error criterion.", "authors": "Bingham, J. A. C.", "words_pool": ["accept", "accuraci", "ascend", "calcul", "choos", "criterion", "crossov", "descend", "divid", "divis", "error", "factor", "factor", "find", "improv", "increas", "iter", "method", "minim", "order", "point", "polynomi", "power", "requir", "shown", "simpli", "time", "variabl", "zero", "bingham"], "word_count": {"accept": 1, "accuraci": 1, "ascend": 1, "calcul": 1, "choos": 1, "criterion": 1, "crossov": 1, "descend": 1, "divid": 1, "divis": 2, "error": 1, "factor": 2, "find": 1, "improv": 1, "increas": 1, "iter": 1, "method": 1, "minim": 1, "order": 1, "point": 1, "polynomi": 2, "power": 1, "requir": 1, "shown": 1, "simpli": 1, "time": 1, "variabl": 1, "zero": 1, "bingham": 1}}, "1644": {"id": "1644", "title": "On the Computation of Least Squares Polynomials", "abstract": "Rounding error accumulated during digital computation of a least squares polynomial makes the  computed polynomial only an approximation to the true least square polynomial.  A simple method for adjust ing  the constant term of the computed polynomial to get a better approximation to the true least squares  polynomial is described.", "authors": "Goldberg, M.", "words_pool": ["accumul", "adjust", "approxim", "comput", "comput", "constant", "digit", "error", "ing", "make", "method", "polynomi", "polynomi", "round", "simpl", "squar", "squar", "term", "true", "goldberg"], "word_count": {"accumul": 1, "adjust": 1, "approxim": 2, "comput": 3, "constant": 1, "digit": 1, "error": 1, "ing": 1, "make": 1, "method": 1, "polynomi": 5, "round": 1, "simpl": 1, "squar": 3, "term": 1, "true": 2, "goldberg": 1}}, "1645": {"id": "1645", "title": "A Note on Computing Approximations to the Exponential Function", "abstract": "Two methods are discussed which result in near minimax rational approximations to the exponential  function and at the same time retain the desirable property that the approximation for negative values  of the argument is the reciprocal of the approximation for corresponding positive values.  These methods  lead to approximations which are much superior to the commonly used convergents of the Gaussian continued  fraction for the exponential.  Coefficients and errors are given for the intervals [-.5*ln 2, .5*ln 2]  and [-ln 2, ln 2].", "authors": "Cody, W. J. Ralston, A.", "words_pool": ["approxim", "approxim", "argument", "coeffici", "commonli", "comput", "continu", "converg", "desir", "discuss", "error", "exponenti", "fraction", "function", "gaussian", "interv", "lead", "ln", "method", "minimax", "neg", "note", "posit", "properti", "ration", "reciproc", "result", "retain", "superior", "time", "valu", "codi", "ralston"], "word_count": {"approxim": 4, "argument": 1, "coeffici": 1, "commonli": 1, "comput": 1, "continu": 1, "converg": 1, "desir": 1, "discuss": 1, "error": 1, "exponenti": 2, "fraction": 1, "function": 1, "gaussian": 1, "interv": 1, "lead": 1, "ln": 4, "method": 2, "minimax": 1, "neg": 1, "note": 1, "posit": 1, "properti": 1, "ration": 1, "reciproc": 1, "result": 1, "retain": 1, "superior": 1, "time": 1, "valu": 2, "codi": 1, "ralston": 1}}, "1646": {"id": "1646", "title": "DITRAN-A Compiler Emphasizing Diagnostics", "abstract": "DITRAN (Diagnostic FORTRAN) is an implementation of ASA Basic FORTRAN with rather extensive  error checking capabilities both at compilation time and during execution of a program.  The need for  improved diagnostic capabilities and some objectives to be met by any compiler are discussed.  Attention  is given to the design and implementation of DITRAN and the particular techniques employed to provide  the diagnostic features.  The handling of error messages by a general macro approach is described.  Special  features which provide teaching aids for use by instructors are noted.", "authors": "Moulton, P. G. Muller, M. E.", "words_pool": ["aid", "approach", "asa", "attent", "basic", "capabl", "check", "compil", "compil", "design", "diagnost", "diagnost", "discuss", "ditran", "emphas", "employ", "error", "execut", "extens", "featur", "fortran", "gener", "handl", "implement", "improv", "instructor", "macro", "messag", "met", "need", "note", "object", "program", "provid", "special", "teach", "techniqu", "time", "moulton", "muller"], "word_count": {"aid": 1, "approach": 1, "asa": 1, "attent": 1, "basic": 1, "capabl": 2, "check": 1, "compil": 2, "design": 1, "diagnost": 3, "discuss": 1, "ditran": 2, "emphas": 1, "employ": 1, "error": 2, "execut": 1, "extens": 1, "featur": 2, "fortran": 2, "gener": 1, "handl": 1, "implement": 2, "improv": 1, "instructor": 1, "macro": 1, "messag": 1, "met": 1, "need": 1, "note": 1, "object": 1, "program": 1, "provid": 2, "special": 1, "teach": 1, "techniqu": 1, "time": 1, "moulton": 1, "muller": 1}}, "1647": {"id": "1647", "title": "WATFOR-The University of Waterloo FORTRAN IV Compiler", "abstract": "WATFOR is an in-core, load-and-go compiler which has been implemented within the IBM 7040/44  operating system.  FORTRAN IV was selected as the source language in order to achieve maximum language  compatibility with other available compiling systems, in particular the IBM 7040/44 FORTRAN IV system.   The principal advantage of the WATFOR compiler is that it translates FORTRAN IV programs at speeds of  up to 100 statements per second.  Since the compiler resides core there is virtually no system overhead,  and hence large batches of \"student\" programs may be processed very efficiently.  The compiler also provides  extensive error diagnostics, during both the compilation and the execution phases of a program run.   This feature makes the system attractive to both learners and learned users alike.", "authors": "Shantz, P. W. German, R. A. Mitchell, J. G.", "words_pool": ["achiev", "advantag", "alik", "attract", "batch", "compat", "compil", "compil", "compil", "core", "diagnost", "effici", "error", "execut", "extens", "featur", "fortran", "ibm", "implement", "iv", "languag", "larg", "learn", "learner", "load", "make", "maximum", "oper", "order", "overhead", "phase", "princip", "process", "program", "program", "resid", "run", "select", "sourc", "speed", "statement", "student", "system", "system", "translat", "univers", "user", "virtual", "waterloo", "watfor", "shantz", "german", "mitchel"], "word_count": {"achiev": 1, "advantag": 1, "alik": 1, "attract": 1, "batch": 1, "compat": 1, "compil": 6, "core": 2, "diagnost": 1, "effici": 1, "error": 1, "execut": 1, "extens": 1, "featur": 1, "fortran": 3, "ibm": 2, "implement": 1, "iv": 3, "languag": 2, "larg": 1, "learn": 1, "learner": 1, "load": 1, "make": 1, "maximum": 1, "oper": 1, "order": 1, "overhead": 1, "phase": 1, "princip": 1, "process": 1, "program": 3, "resid": 1, "run": 1, "select": 1, "sourc": 1, "speed": 1, "statement": 1, "student": 1, "system": 5, "translat": 1, "univers": 1, "user": 1, "virtual": 1, "waterloo": 1, "watfor": 2, "shantz": 1, "german": 1, "mitchel": 1}}, "1648": {"id": "1648", "title": "Uniform Random (Algorithm 294 [G5])", "authors": "Strome, W. M.", "words_pool": ["algorithm", "g5", "random", "uniform", "strome"], "word_count": {"algorithm": 1, "g5": 1, "random": 1, "uniform": 1, "strome": 1}}, "1649": {"id": "1649", "title": "Data Directed Input-Output in FORTRAN", "abstract": "A statement which is similar to the NAMELIST statement of FORTRAN IV has been incorporated  in the FORTRAN 63 compiler.  The FORTRAN 63 implementation allows a greater flexibility and simplicity  than the FORTRAN IV feature.  The Hollerith names, the location, the mode and the dimensions of a variable  can be discovered by means of standard FORTRAN statements.  Methods of using this information are illustrated  in relation to general purpose data directed input and output routines; some other uses such as matrix  manipulation are discussed.", "authors": "Hassitt, A.", "words_pool": ["compil", "data", "dimens", "direct", "discov", "discuss", "featur", "flexibl", "fortran", "gener", "greater", "hollerith", "illustr", "implement", "incorpor", "inform", "input", "iv", "locat", "manipul", "matrix", "mean", "method", "mode", "namelist", "name", "output", "purpos", "relat", "routin", "similar", "simplic", "standard", "statement", "statement", "variabl", "hassitt"], "word_count": {"compil": 1, "data": 1, "dimens": 1, "direct": 1, "discov": 1, "discuss": 1, "featur": 1, "flexibl": 1, "fortran": 5, "gener": 1, "greater": 1, "hollerith": 1, "illustr": 1, "implement": 1, "incorpor": 1, "inform": 1, "input": 1, "iv": 2, "locat": 1, "manipul": 1, "matrix": 1, "mean": 1, "method": 1, "mode": 1, "namelist": 1, "name": 1, "output": 1, "purpos": 1, "relat": 1, "routin": 1, "similar": 1, "simplic": 1, "standard": 1, "statement": 3, "variabl": 1, "hassitt": 1}}, "1650": {"id": "1650", "title": "A Unifying Computational Method for the Analysis of Complete Factorial Experiments", "abstract": "A computational method which may be used for the calculation of sums of squares in the analysis  of variance of complete factorial experiments and in the computation of main effect or interaction means  is described.  The method is elucidated as unifying since one method can be used for a variety of purposes  each previously requiring different methods.  The programming advantages of such a method are obvious.   The following variants are discussed: (1) the standard analysis of variance; (2) analyses omitting certain  levels of one or more factors; (3) separate analyses for some levels of a factor or for combinations  of levels of more than one factor.  These are performed simultaneously; (4) the calculation of main effect  or interaction means.  The mean expects the data in standard order and it leaves the data in that order  so that many analyses of the same data can be performed without rearrangement.  The total sum of squares,  excluding a replication sum of squares, is partitioned into all polynomial partitions and their interactions  each with one degree of freedom.  This is so even if factors have unequally spaced factor levels.", "authors": "Cooper, B. E.", "words_pool": ["advantag", "analys", "analysi", "calcul", "combin", "complet", "comput", "comput", "data", "degre", "discuss", "effect", "elucid", "exclud", "expect", "experi", "factor", "factori", "factor", "freedom", "interact", "interact", "leav", "level", "main", "mean", "mean", "method", "method", "obviou", "omit", "order", "partit", "partit", "perform", "polynomi", "previous", "program", "purpos", "rearrang", "replic", "requir", "separ", "simultan", "space", "squar", "standard", "sum", "sum", "total", "unequ", "unifi", "varianc", "variant", "varieti", "cooper"], "word_count": {"advantag": 1, "analys": 3, "analysi": 2, "calcul": 2, "combin": 1, "complet": 1, "comput": 2, "data": 3, "degre": 1, "discuss": 1, "effect": 2, "elucid": 1, "exclud": 1, "expect": 1, "experi": 1, "factor": 5, "factori": 1, "freedom": 1, "interact": 3, "leav": 1, "level": 4, "main": 2, "mean": 3, "method": 5, "obviou": 1, "omit": 1, "order": 2, "partit": 2, "perform": 2, "polynomi": 1, "previous": 1, "program": 1, "purpos": 1, "rearrang": 1, "replic": 1, "requir": 1, "separ": 1, "simultan": 1, "space": 1, "squar": 3, "standard": 2, "sum": 3, "total": 1, "unequ": 1, "unifi": 1, "varianc": 2, "variant": 1, "varieti": 1, "cooper": 1}}, "1651": {"id": "1651", "title": "An Interpretive Input Routine for Linear Programming", "abstract": "In this descriptive article an input code is presented which greatly simplifies data input  to any linear programming solution routine, for subsequent use either as a pedagogical device or for  solving rather small LP problems.  This latter (limited) use derives not at all from inherent limitations  in the code itself, but from an efficiency evaluation: large LP problems would doubtless benefit from  an input system more suited for bulk data handling than the input code described.  From a user's standpoint,  input appears almost exactly as a textbook presentation of the LP problem (limited only by a keypunch's  inability to write subscripts, etc.).  The input interpreter scans column wise, thus no fixed format  data preparation is required.  The user may also, under very general requirements only, liberally use  editorial comments throughout the input deck as an aid in identification, e.g., of row constraints.   The article includes examples of input, output from a solution routine presently in use, and a skeleton  flowchart of the input interpreter.", "authors": "Aigner, D. J.", "words_pool": ["aid", "appear", "articl", "benefit", "bulk", "code", "column", "comment", "constraint", "data", "deck", "deriv", "descript", "devic", "doubtless", "editori", "effici", "evalu", "exactli", "exampl", "fix", "flowchart", "format", "gener", "greatli", "handl", "identif", "inabl", "includ", "inher", "input", "interpret", "interpret", "keypunch", "larg", "liber", "limit", "limit", "linear", "lp", "output", "pedagog", "prepar", "present", "present", "present", "problem", "problem", "program", "requir", "requir", "routin", "row", "scan", "simplifi", "skeleton", "small", "solut", "solv", "standpoint", "subscript", "subsequ", "suit", "system", "textbook", "user", "wise", "write", "aigner"], "word_count": {"aid": 1, "appear": 1, "articl": 2, "benefit": 1, "bulk": 1, "code": 3, "column": 1, "comment": 1, "constraint": 1, "data": 3, "deck": 1, "deriv": 1, "descript": 1, "devic": 1, "doubtless": 1, "editori": 1, "effici": 1, "evalu": 1, "exactli": 1, "exampl": 1, "fix": 1, "flowchart": 1, "format": 1, "gener": 1, "greatli": 1, "handl": 1, "identif": 1, "inabl": 1, "includ": 1, "inher": 1, "input": 9, "interpret": 2, "keypunch": 1, "larg": 1, "liber": 1, "limit": 3, "linear": 1, "lp": 3, "output": 1, "pedagog": 1, "prepar": 1, "present": 3, "problem": 3, "program": 1, "requir": 2, "routin": 2, "row": 1, "scan": 1, "simplifi": 1, "skeleton": 1, "small": 1, "solut": 2, "solv": 1, "standpoint": 1, "subscript": 1, "subsequ": 1, "suit": 1, "system": 1, "textbook": 1, "user": 2, "wise": 1, "write": 1, "aigner": 1}}, "1652": {"id": "1652", "title": "A Code for Non-numeric Information Processing Applications in Online Systems", "abstract": "A code has been specifically designed to simplify the internal information processing operations  within an online computer system with respect to non-numeric applications, and to maximize the transfer  rate of the information channel linking the system and the system user.  The code has direct application  to problems in area such as information retrieval, document classification, computer-aided teaching and  text editing.  This code, called IPC (Information Processing Code), is an 8-bit code set constructed  so that 7, 6, 5 and 4-bit subsets can be easily derived from the basic set.  The code set is organized  so that simple binary operations can distinguish between the numeric alphabetic, special symbol and control  character codes.  The number of usable characters within the basic set size may be expanded either by  use of escape codes included in the set, or by suitable interpretation of otherwise unassigned codes  on the basis of the requirements of local environments.", "authors": "Morenoff, E. McLean, J. B.", "words_pool": ["aid", "alphabet", "applic", "applic", "area", "basic", "basi", "binari", "bit", "call", "channel", "charact", "charact", "classif", "code", "code", "comput", "construct", "control", "deriv", "design", "direct", "distinguish", "document", "easili", "edit", "environ", "escap", "expand", "includ", "inform", "intern", "interpret", "ipc", "link", "local", "maxim", "non", "number", "numer", "onlin", "oper", "organ", "problem", "process", "rate", "requir", "respect", "retriev", "set", "simpl", "simplifi", "size", "special", "specif", "subset", "suitabl", "symbol", "system", "system", "teach", "text", "transfer", "unassign", "usabl", "user", "morenoff", "mclean"], "word_count": {"aid": 1, "alphabet": 1, "applic": 2, "area": 1, "basic": 2, "basi": 1, "binari": 1, "bit": 2, "call": 1, "channel": 1, "charact": 2, "classif": 1, "code": 9, "comput": 2, "construct": 1, "control": 1, "deriv": 1, "design": 1, "direct": 1, "distinguish": 1, "document": 1, "easili": 1, "edit": 1, "environ": 1, "escap": 1, "expand": 1, "includ": 1, "inform": 4, "intern": 1, "interpret": 1, "ipc": 1, "link": 1, "local": 1, "maxim": 1, "non": 1, "number": 1, "numer": 2, "onlin": 1, "oper": 2, "organ": 1, "problem": 1, "process": 2, "rate": 1, "requir": 1, "respect": 1, "retriev": 1, "set": 5, "simpl": 1, "simplifi": 1, "size": 1, "special": 1, "specif": 1, "subset": 1, "suitabl": 1, "symbol": 1, "system": 3, "teach": 1, "text": 1, "transfer": 1, "unassign": 1, "usabl": 1, "user": 1, "morenoff": 1, "mclean": 1}}, "1653": {"id": "1653", "title": "System Performance Evaluation: Survey and Appraisal", "abstract": "The state of the art of system performance evaluation is reviewed and evaluation goals and  problems are examined.  Throughput, turnaround, and availability are defined as fundamental measures  of performance; overhead and CPU speed are placed in perspective.  The appropriateness of instruction  mixes, kernels, simulators, and other tools is discussed, as well as pitfalls which may be encountered  when using them.  Analysis, simulation, and synthesis are presented as three levels of approach to evaluation,  requiring successively greater amounts of information.  The central role of measurement in performance  evaluation and in the development of evaluation methods is explored.", "authors": "Calingaert, P.", "words_pool": ["amount", "analysi", "apprais", "approach", "appropri", "art", "avail", "central", "cpu", "defin", "develop", "discuss", "encount", "evalu", "examin", "explor", "fundament", "goal", "greater", "inform", "instruct", "kernel", "level", "measur", "measur", "method", "mix", "overhead", "perform", "perspect", "pitfal", "present", "problem", "requir", "review", "role", "simul", "simul", "speed", "state", "success", "survey", "synthesi", "system", "throughput", "tool", "turnaround", "calingaert"], "word_count": {"amount": 1, "analysi": 1, "apprais": 1, "approach": 1, "appropri": 1, "art": 1, "avail": 1, "central": 1, "cpu": 1, "defin": 1, "develop": 1, "discuss": 1, "encount": 1, "evalu": 5, "examin": 1, "explor": 1, "fundament": 1, "goal": 1, "greater": 1, "inform": 1, "instruct": 1, "kernel": 1, "level": 1, "measur": 2, "method": 1, "mix": 1, "overhead": 1, "perform": 3, "perspect": 1, "pitfal": 1, "present": 1, "problem": 1, "requir": 1, "review": 1, "role": 1, "simul": 2, "speed": 1, "state": 1, "success": 1, "survey": 1, "synthesi": 1, "system": 1, "throughput": 1, "tool": 1, "turnaround": 1, "calingaert": 1}}, "1654": {"id": "1654", "title": "A University's Educational Program in Computer Science", "abstract": "After a review of the power of contemporary computers, computer science is defined in several  ways.  The objectives of computer science education are stated, and it is asserted that in a North American  university these will be achieved only through a computer science department.  The program at Stanford  University is reviewed as an example.  The appendices include syllabic of Ph.D. qualifying examinations  for Stanford's Computer Science Department.", "authors": "Forsythe, G. E.", "words_pool": ["achiev", "american", "appendic", "assert", "comput", "comput", "contemporari", "defin", "depart", "educ", "educ", "examin", "includ", "north", "object", "ph", "power", "program", "qualifi", "review", "review", "scienc", "stanford", "state", "syllab", "univers", "way", "forsyth"], "word_count": {"achiev": 1, "american": 1, "appendic": 1, "assert": 1, "comput": 5, "contemporari": 1, "defin": 1, "depart": 2, "educ": 1, "examin": 1, "includ": 1, "north": 1, "object": 1, "ph": 1, "power": 1, "program": 1, "qualifi": 1, "review": 2, "scienc": 4, "stanford": 2, "state": 1, "syllab": 1, "univers": 2, "way": 1, "forsyth": 1}}, "1655": {"id": "1655", "title": "Code Extension Procedures for Information Interchange* (Proposed USA Standard)", "words_pool": ["code", "extens", "inform", "interchang", "procedur", "propos", "standard", "usa"], "word_count": {"code": 1, "extens": 1, "inform": 1, "interchang": 1, "procedur": 1, "propos": 1, "standard": 1, "usa": 1}}, "1656": {"id": "1656", "title": "Procedures for the Standardization Process* (Proposed USA Standard)", "words_pool": ["procedur", "process", "propos", "standard", "standard", "usa"], "word_count": {"procedur": 1, "process": 1, "propos": 1, "standard": 2, "usa": 1}}, "1657": {"id": "1657", "title": "Implementation of the SHARER2 Time-Sharing System", "abstract": "A simple mechanism is described for the execution of part of a program with its own memory  protection.  This allows such a program to act as a suboperating system.  An improved version of the  SHARER time-sharing system using this feature is described.", "authors": "Harrison, M. C.", "words_pool": ["act", "execut", "featur", "implement", "improv", "mechan", "memori", "part", "program", "protect", "sharer", "sharer2", "share", "simpl", "suboper", "system", "time", "version", "harrison"], "word_count": {"act": 1, "execut": 1, "featur": 1, "implement": 1, "improv": 1, "mechan": 1, "memori": 1, "part": 1, "program": 2, "protect": 1, "sharer": 1, "sharer2": 1, "share": 1, "simpl": 1, "suboper": 1, "system": 2, "time": 1, "version": 1, "harrison": 1}}, "1658": {"id": "1658", "title": "Analysis of Algorithms for the Zero-One Programming Problem", "abstract": "This paper is concerned with a review and examination of several existing algorithms for the  zero-one programming problem.  Computational experience is summarized.  The machine time and storage  requirements of several of the algorithms are compared over several test problems of small and intermediate  size.  Computer experiments still provide little hope of solving problems with over 100 variables with  a reasonable amount of machine time.", "authors": "Gue, R. L. Liggett, J. C. Cain, K. C.", "words_pool": ["algorithm", "amount", "analysi", "compar", "comput", "comput", "concern", "examin", "exist", "experi", "experi", "hope", "intermedi", "machin", "paper", "problem", "problem", "program", "provid", "reason", "requir", "review", "size", "small", "solv", "storag", "summar", "test", "time", "variabl", "gue", "liggett", "cain"], "word_count": {"algorithm": 2, "amount": 1, "analysi": 1, "compar": 1, "comput": 2, "concern": 1, "examin": 1, "exist": 1, "experi": 2, "hope": 1, "intermedi": 1, "machin": 2, "paper": 1, "problem": 3, "program": 1, "provid": 1, "reason": 1, "requir": 1, "review": 1, "size": 1, "small": 1, "solv": 1, "storag": 1, "summar": 1, "test": 1, "time": 2, "variabl": 1, "gue": 1, "liggett": 1, "cain": 1}}, "1659": {"id": "1659", "title": "Computational Linguistics in a Ph.D. Computer Science Program", "abstract": "This report contains recommendations for a course curriculum on computational linguistics in  a Ph.D. computer science program.  A classification of the subject areas contained in computational linguistics  is presented, and ten courses in these areas are described.  A basic bibliography in computational linguistics  is appended.", "authors": "Kuno, S. Oettinger, A. G.", "words_pool": ["append", "area", "basic", "bibliographi", "classif", "comput", "comput", "contain", "cours", "cours", "curriculum", "linguist", "ph", "present", "program", "recommend", "report", "scienc", "subject", "ten", "kuno", "oetting"], "word_count": {"append": 1, "area": 2, "basic": 1, "bibliographi": 1, "classif": 1, "comput": 4, "contain": 1, "cours": 2, "curriculum": 1, "linguist": 3, "ph": 1, "present": 1, "program": 1, "recommend": 1, "report": 1, "scienc": 1, "subject": 1, "ten": 1, "kuno": 1, "oetting": 1}}, "1660": {"id": "1660", "title": "Index By Subject To algorithms, 1960-1968", "words_pool": ["algorithm", "index", "subject"], "word_count": {"algorithm": 1, "index": 1, "subject": 1}}, "1661": {"id": "1661", "title": "Multint (Algorithm 32 [D1])", "authors": "Kolbig, K. S.", "words_pool": ["algorithm", "d1", "multint", "kolbig"], "word_count": {"algorithm": 1, "d1": 1, "multint": 1, "kolbig": 1}}, "1662": {"id": "1662", "title": "Eigenvalues and Eigenvectors of a Real General Matrix [F2])", "authors": "Grad, J. Brebner, M. A.", "words_pool": ["eigenvalu", "eigenvector", "f2", "gener", "matrix", "real", "grad", "brebner"], "word_count": {"eigenvalu": 1, "eigenvector": 1, "f2": 1, "gener": 1, "matrix": 1, "real": 1, "grad": 1, "brebner": 1}}, "1663": {"id": "1663", "title": "Generator of Random Numbers Satisfying the Poisson distribution [G5])", "authors": "Snow, R. H.", "words_pool": ["distribut", "g5", "gener", "number", "poisson", "random", "satisfi", "snow"], "word_count": {"distribut": 1, "g5": 1, "gener": 1, "number": 1, "poisson": 1, "random": 1, "satisfi": 1, "snow": 1}}, "1664": {"id": "1664", "title": "An Algorithm for Deriving the Equations of Mathematical Physics by Symbolic Manipulation", "abstract": "A method is described whereby a digital computer can be used to derive the equations of mathematical  physics in any curvilinear coordinate system requested by the user.  The effectiveness of the technique  is demonstrated by using it to derive the Navier-Stokes equations of fluid motion and the continuity  equation.  To derive these equations by this method, the user need know only the coordinate transformation  equations relating the curvilinear coordinates of interest to an orthogonal Cartesian triad. When this  program is used and the coordinate transformation equations are supplied as input, the computer will  derive the Navier-Stokes equations and the continuity equation.  The equations obtained will be relative  to the curvilinear coordinate system specified by the transformation equations used as input.  In this  paper the emphasis is on theoretical considerations and methodology rather than on programming details.   Results are presented for cylindrical polar and spherical polar coordinate systems.", "authors": "Howard, J. C. Tashjian, H.", "words_pool": ["algorithm", "cartesian", "comput", "consider", "continu", "coordin", "coordin", "curvilinear", "cylindr", "demonstr", "deriv", "deriv", "detail", "digit", "effect", "emphasi", "equat", "equat", "fluid", "input", "interest", "know", "manipul", "mathemat", "method", "methodolog", "motion", "navier", "need", "obtain", "orthogon", "paper", "physic", "polar", "present", "program", "program", "relat", "rel", "request", "result", "spheric", "stoke", "suppli", "symbol", "system", "system", "techniqu", "theoret", "transform", "triad", "user", "howard", "tashjian"], "word_count": {"algorithm": 1, "cartesian": 1, "comput": 2, "consider": 1, "continu": 2, "coordin": 6, "curvilinear": 3, "cylindr": 1, "demonstr": 1, "deriv": 4, "detail": 1, "digit": 1, "effect": 1, "emphasi": 1, "equat": 10, "fluid": 1, "input": 2, "interest": 1, "know": 1, "manipul": 1, "mathemat": 1, "method": 2, "methodolog": 1, "motion": 1, "navier": 2, "need": 1, "obtain": 1, "orthogon": 1, "paper": 1, "physic": 1, "polar": 2, "present": 1, "program": 2, "relat": 1, "rel": 1, "request": 1, "result": 1, "spheric": 1, "stoke": 2, "suppli": 1, "symbol": 1, "system": 3, "techniqu": 1, "theoret": 1, "transform": 3, "triad": 1, "user": 2, "howard": 1, "tashjian": 1}}, "1665": {"id": "1665", "title": "Automatic Generation of Efficient Lexical Processors Using Finite State Techniques", "abstract": "The practical application of the theory of finite-state automata to automatically generate  lexical processors is dealt with in this tutorial article by the use of the AED RWORD system, developed  at M", "words_pool": ["a", "applic", "articl", "automata", "automat", "dealt", "develop", "effici", "finit", "gener", "gener", "lexic", "practic", "processor", "rword", "state", "system", "techniqu", "theori", "tutori"], "word_count": {"a": 1, "applic": 1, "articl": 1, "automata": 1, "automat": 1, "dealt": 1, "develop": 1, "effici": 1, "finit": 1, "gener": 1, "lexic": 1, "practic": 1, "processor": 1, "rword": 1, "state": 1, "system": 1, "techniqu": 1, "theori": 1, "tutori": 1}}, "": {"id": "", "title": ".'s  Lincoln Laboratory under the LEAP Language and Data Structure,  A comparison of the hardware approach  with the software simulation illustrates the advantages of the hardware associative memory in three areas:  (1) processing speed, (2) storage requirements, and (3) flexibility.  The major problem areas of hardware  associative memory technology, namely input/output and cost effectiveness, are also addressed.", "authors": "Stillman, N. J. Berra, P. B.", "words_pool": ["address", "advantag", "approach", "area", "associ", "comparison", "cost", "data", "effect", "flexibl", "hardwar", "illustr", "input", "laboratori", "languag", "leap", "lincoln", "major", "memori", "output", "problem", "process", "requir", "simul", "softwar", "speed", "storag", "structur", "technolog", "stillman", "berra"], "word_count": {"address": 1, "advantag": 1, "approach": 1, "area": 2, "associ": 2, "comparison": 1, "cost": 1, "data": 1, "effect": 1, "flexibl": 1, "hardwar": 3, "illustr": 1, "input": 1, "laboratori": 1, "languag": 1, "leap": 1, "lincoln": 1, "major": 1, "memori": 2, "output": 1, "problem": 1, "process": 1, "requir": 1, "simul": 1, "softwar": 1, "speed": 1, "storag": 1, "structur": 1, "technolog": 1, "stillman": 1, "berra": 1}}, "1666": {"id": "1666", "title": "Solution of Linear Programs in 0-1 Variables by Implicit Enumeration (Algorithm 341 [H])", "authors": "Byrne, J. L. Proll, L. G.", "words_pool": ["algorithm", "enumer", "implicit", "linear", "program", "solut", "variabl", "byrn", "proll"], "word_count": {"algorithm": 1, "enumer": 1, "implicit": 1, "linear": 1, "program": 1, "solut": 1, "variabl": 1, "byrn": 1, "proll": 1}}, "1667": {"id": "1667", "title": "Roots of Polynomials by a Root-Squaring and Resultant Routine (Algorithm 340 [C2])", "authors": "Noltemeier, A.", "words_pool": ["algorithm", "c2", "polynomi", "result", "root", "root", "routin", "squar", "noltemei"], "word_count": {"algorithm": 1, "c2": 1, "polynomi": 1, "result": 1, "root": 2, "routin": 1, "squar": 1, "noltemei": 1}}, "1668": {"id": "1668", "title": "An Algol Procedure for the Fast Fourier Transform with Arbitrary Factors (Algorithm 339 [C6])", "authors": "Singleton, R. C.", "words_pool": ["algol", "algorithm", "arbitrari", "c6", "factor", "fast", "fourier", "procedur", "transform", "singleton"], "word_count": {"algol": 1, "algorithm": 1, "arbitrari": 1, "c6": 1, "factor": 1, "fast": 1, "fourier": 1, "procedur": 1, "transform": 1, "singleton": 1}}, "1669": {"id": "1669", "title": "Algol Procedures for the Fast Fourier Transform (Algorithm 338 [C6])", "authors": "Singleton, R. C.", "words_pool": ["algol", "algorithm", "c6", "fast", "fourier", "procedur", "transform", "singleton"], "word_count": {"algol": 1, "algorithm": 1, "c6": 1, "fast": 1, "fourier": 1, "procedur": 1, "transform": 1, "singleton": 1}}, "1670": {"id": "1670", "title": "Correspondences of 8-Bit and Hollerith Codes for Computer Environments (A USASI Tutorial Standard)", "words_pool": ["bit", "code", "comput", "correspond", "environ", "hollerith", "standard", "tutori", "usasi"], "word_count": {"bit": 1, "code": 1, "comput": 1, "correspond": 1, "environ": 1, "hollerith": 1, "standard": 1, "tutori": 1, "usasi": 1}}, "1671": {"id": "1671", "title": "A Phonological Rule Tester", "abstract": "The design and implementation of a system to alleviate the problem of rule evaluation for the  linguist in the area of phonology are presented.  It permits the user to define, on-line, sets of rules  statable within the framework presented in The Sound Patterns of English by Chomsky and Halle, 1968,  to define phonemes as bundles of specified distinctive features, to define data as strings of phonemes  with associated grammatical structure, to test the effect of applying rules to the data, and to store  both the definitions and results.  The rule application facility described in detail was implemented  by translating linguistic rules to rules in FLIP, a format-directed list processor embedded in LISP.   This made the system construction easy while providing sophisticated capabilities for the linguist.   The system is written in BBN LISP on the Scientific Data System 940 computer and is designed to be used  on-line in interactive fashion, with control returned to the user after each command is executed.", "authors": "Borrow, D. G. Fraser, J. B.", "words_pool": ["allevi", "applic", "appli", "area", "bbn", "bundl", "capabl", "chomski", "command", "comput", "construct", "control", "data", "defin", "definit", "design", "design", "detail", "direct", "distinct", "easi", "effect", "embed", "english", "evalu", "execut", "facil", "fashion", "featur", "flip", "format", "framework", "grammat", "hall", "implement", "implement", "interact", "line", "linguist", "linguist", "lisp", "list", "made", "pattern", "permit", "phonem", "phonolog", "phonolog", "present", "problem", "processor", "provid", "result", "rule", "rule", "scientif", "set", "sophist", "sound", "statabl", "store", "string", "structur", "system", "test", "tester", "translat", "user", "written", "borrow", "fraser"], "word_count": {"allevi": 1, "applic": 1, "appli": 1, "area": 1, "bbn": 1, "bundl": 1, "capabl": 1, "chomski": 1, "command": 1, "comput": 1, "construct": 1, "control": 1, "data": 3, "defin": 3, "definit": 1, "design": 2, "detail": 1, "direct": 1, "distinct": 1, "easi": 1, "effect": 1, "embed": 1, "english": 1, "evalu": 1, "execut": 1, "facil": 1, "fashion": 1, "featur": 1, "flip": 1, "format": 1, "framework": 1, "grammat": 1, "hall": 1, "implement": 2, "interact": 1, "line": 2, "linguist": 3, "lisp": 2, "list": 1, "made": 1, "pattern": 1, "permit": 1, "phonem": 2, "phonolog": 1, "present": 2, "problem": 1, "processor": 1, "provid": 1, "result": 1, "rule": 6, "scientif": 1, "set": 1, "sophist": 1, "sound": 1, "statabl": 1, "store": 1, "string": 1, "structur": 1, "system": 4, "test": 1, "tester": 1, "translat": 1, "user": 2, "written": 1, "borrow": 1, "fraser": 1}}, "1672": {"id": "1672", "title": "Practical Error Coefficients in the Integration of Periodic Analytic Functions by the Trapezoidal  Rule", "abstract": "Theoretical and practical values of error coefficients useful in bounding the error in integrating  periodic analytic functions with the trapezoidal rule are tabulated for various ranges of the parameters.", "authors": "Rabinowitz, P.", "words_pool": ["analyt", "bound", "coeffici", "error", "function", "integr", "integr", "paramet", "period", "practic", "rang", "rule", "tabul", "theoret", "trapezoid", "valu", "rabinowitz"], "word_count": {"analyt": 1, "bound": 1, "coeffici": 1, "error": 2, "function": 1, "integr": 1, "paramet": 1, "period": 1, "practic": 1, "rang": 1, "rule": 1, "tabul": 1, "theoret": 1, "trapezoid": 1, "valu": 1, "rabinowitz": 1}}, "1673": {"id": "1673", "title": "Approximate Solution of Initial Boundary Wave Equation Problems by Boundary-Value Techniques", "abstract": "A new boundary-value technique is proposed for the treatment of initial-boundary-value problems  for linear and mildly nonlinear wave equations.   Several illustrative examples are offered to demonstrate  the ease with which the method can be applied.", "authors": "Greenspan, D.", "words_pool": ["appli", "approxim", "boundari", "demonstr", "eas", "equat", "equat", "exampl", "illustr", "initi", "linear", "method", "mildli", "nonlinear", "offer", "problem", "propos", "solut", "techniqu", "techniqu", "treatment", "wave", "greenspan"], "word_count": {"appli": 1, "approxim": 1, "boundari": 2, "demonstr": 1, "eas": 1, "equat": 1, "exampl": 1, "illustr": 1, "initi": 1, "linear": 1, "method": 1, "mildli": 1, "nonlinear": 1, "offer": 1, "problem": 1, "propos": 1, "solut": 1, "techniqu": 1, "treatment": 1, "wave": 1, "greenspan": 1}}, "1674": {"id": "1674", "title": "One-Line Random Number Generators and Their Use in Combinations", "abstract": "Some one-line random number generators, i.e. generators requiring a single FORTRAN instruction  are discussed, and some short FORTRAN programs which mix several such generators are described.  The  aim is to provide methods for incorporating random number generators directly in FORTRAN programs, by  means of a few in-line instructions.  The advantages are speed (avoiding linkage to and from a subroutine),  convenience, and versatility.  Anyone wishing to experiment with generators, either using congruential  generators by themselves or mixing several generators to provide a composite with potentially better  statistical properties than the library generators currently available, may wish to consider some of  the simple FORTRAN program discussed here.", "authors": "Marsaglia, G. Bray, T. A.", "words_pool": ["advantag", "aim", "avoid", "combin", "composit", "congruenti", "consid", "conveni", "directli", "discuss", "experi", "fortran", "gener", "incorpor", "instruct", "instruct", "librari", "line", "linkag", "mean", "method", "mix", "mix", "number", "potenti", "program", "program", "properti", "provid", "random", "requir", "short", "simpl", "singl", "speed", "statist", "subroutin", "versatil", "wish", "wish", "marsaglia", "bray"], "word_count": {"advantag": 1, "aim": 1, "avoid": 1, "combin": 1, "composit": 1, "congruenti": 1, "consid": 1, "conveni": 1, "directli": 1, "discuss": 2, "experi": 1, "fortran": 4, "gener": 8, "incorpor": 1, "instruct": 2, "librari": 1, "line": 2, "linkag": 1, "mean": 1, "method": 1, "mix": 2, "number": 2, "potenti": 1, "program": 3, "properti": 1, "provid": 2, "random": 2, "requir": 1, "short": 1, "simpl": 1, "singl": 1, "speed": 1, "statist": 1, "subroutin": 1, "versatil": 1, "wish": 2, "marsaglia": 1, "bray": 1}}, "1675": {"id": "1675", "title": "A Note on a Relevance Estimate and Its Improvement", "abstract": "In this paper the effect of iterating the improvement procedure is examined.  It is shown that  applications of the improvement factor beyond the first time are ineffectual, and that the factor is  but a scale factor.", "authors": "Korfhage, R. R.", "words_pool": ["applic", "effect", "estim", "examin", "factor", "improv", "ineffectu", "iter", "note", "paper", "procedur", "relev", "scale", "shown", "time", "korfhag"], "word_count": {"applic": 1, "effect": 1, "estim": 1, "examin": 1, "factor": 3, "improv": 2, "ineffectu": 1, "iter": 1, "note": 1, "paper": 1, "procedur": 1, "relev": 1, "scale": 1, "shown": 1, "time": 1, "korfhag": 1}}, "1676": {"id": "1676", "title": "The LRLTRAN Compiler", "abstract": "Extensive software problems confront an organization which possesses a number of different  computers and which frequently acquires new ones.  To maintain cohesion, a system must be developed,  written in a high level language, which minimizes machine dependencies and isolates those which are necessary.   A language and a compiler for the language are discussed here.  The language, called LRLTRAN, is a heavily  augmented FORTRAN.  The tree-pass compiler makes use internally of a postfix Polish notation (pass I  to pass II) and a tree representation referred to as a \"composite blocking table\" (pass I to pass III).   Machine-independent optimization occurs in pass II and DO-loop and machine-dependent optimization in  pass III.", "authors": "Mendicino, S. F. Martin, J. T. Ranelletti, J. E. Zwakenberg, R. G.", "words_pool": ["acquir", "augment", "block", "call", "cohes", "compil", "composit", "comput", "confront", "depend", "depend", "develop", "discuss", "extens", "fortran", "frequent", "heavili", "high", "ii", "iii", "independ", "intern", "isol", "languag", "level", "loop", "lrltran", "machin", "maintain", "make", "minim", "notat", "number", "occur", "optim", "organ", "pass", "polish", "possess", "postfix", "problem", "refer", "represent", "softwar", "system", "tabl", "tree", "written", "mendicino", "martin", "ranelletti", "zwakenberg"], "word_count": {"acquir": 1, "augment": 1, "block": 1, "call": 1, "cohes": 1, "compil": 2, "composit": 1, "comput": 1, "confront": 1, "depend": 2, "develop": 1, "discuss": 1, "extens": 1, "fortran": 1, "frequent": 1, "heavili": 1, "high": 1, "ii": 2, "iii": 2, "independ": 1, "intern": 1, "isol": 1, "languag": 4, "level": 1, "loop": 1, "lrltran": 1, "machin": 3, "maintain": 1, "make": 1, "minim": 1, "notat": 1, "number": 1, "occur": 1, "optim": 2, "organ": 1, "pass": 7, "polish": 1, "possess": 1, "postfix": 1, "problem": 1, "refer": 1, "represent": 1, "softwar": 1, "system": 1, "tabl": 1, "tree": 2, "written": 1, "mendicino": 1, "martin": 1, "ranelletti": 1, "zwakenberg": 1}}, "1677": {"id": "1677", "title": "Storage Organization in Programming Systems", "abstract": "The system of program and data representation that has been in use on the Rice University computer  for five years is described.  Each logical entity in storage occupies a block of consecutive memory locations.   Each block is labeled by a codeword and may contain a program, a data vector, or codewords which in  turn label blocks to form arrays.  This storage arrangement is discussed with its realized advantages  or programming systems: simplicity of programmed addressing, flexibility of data structures, efficiency  of memory utilization, variability of system composition during execution, means of linkage between programs  and from programs to data, and basis for storage protection.  The application of labeled blocks may be  extended to areas of time-sharing and multimedia storage control.  On the basis of experience at rice,  some ideas on such extensions are presented.", "authors": "Jodeit, J. G.", "words_pool": ["address", "advantag", "applic", "area", "arrang", "array", "basi", "block", "block", "codeword", "codeword", "composit", "comput", "consecut", "control", "data", "discuss", "effici", "entiti", "execut", "experi", "extend", "extens", "flexibl", "form", "idea", "label", "label", "linkag", "locat", "logic", "mean", "memori", "multimedia", "occupi", "organ", "present", "program", "program", "program", "program", "protect", "realiz", "represent", "rice", "share", "simplic", "storag", "structur", "system", "system", "time", "turn", "univers", "util", "variabl", "vector", "year", "jodeit"], "word_count": {"address": 1, "advantag": 1, "applic": 1, "area": 1, "arrang": 1, "array": 1, "basi": 2, "block": 4, "codeword": 2, "composit": 1, "comput": 1, "consecut": 1, "control": 1, "data": 4, "discuss": 1, "effici": 1, "entiti": 1, "execut": 1, "experi": 1, "extend": 1, "extens": 1, "flexibl": 1, "form": 1, "idea": 1, "label": 3, "linkag": 1, "locat": 1, "logic": 1, "mean": 1, "memori": 2, "multimedia": 1, "occupi": 1, "organ": 1, "present": 1, "program": 6, "protect": 1, "realiz": 1, "represent": 1, "rice": 2, "share": 1, "simplic": 1, "storag": 4, "structur": 1, "system": 3, "time": 1, "turn": 1, "univers": 1, "util": 1, "variabl": 1, "vector": 1, "year": 1, "jodeit": 1}}, "1678": {"id": "1678", "title": "Automata, Formal Languages, Abstract Switching, and Computability in a Ph.D. Computer Science  Program", "abstract": "A number of courses are listed in the area describe as automata, formal languages, abstract  switching, and computability, that might be available to a Ph.D. student in computer science.  A brief  catalog description of each course is applied and the role of each of the courses in the graduate program  is discussed.", "authors": "McNaughton, R.", "words_pool": ["abstract", "appli", "area", "automata", "catalog", "comput", "comput", "cours", "cours", "describ", "descript", "discuss", "formal", "graduat", "languag", "list", "number", "ph", "program", "role", "scienc", "student", "switch", "mcnaughton"], "word_count": {"abstract": 1, "appli": 1, "area": 1, "automata": 1, "catalog": 1, "comput": 2, "cours": 3, "describ": 1, "descript": 1, "discuss": 1, "formal": 1, "graduat": 1, "languag": 1, "list": 1, "number": 1, "ph": 1, "program": 1, "role": 1, "scienc": 1, "student": 1, "switch": 1, "mcnaughton": 1}}, "1679": {"id": "1679", "title": "A Fast Fourier Transform Algorithm for Real-Valued Series", "abstract": "A new procedure is presented for calculating the complex, discrete Fourier transform of real-valued  time series.  This procedure is described for an example where the number of points in the series is  an integral power of two.  This algorithm preserves the order and symmetry of the Cooley-Turkey fast  Fourier transform algorithm while effecting the two-to-one reduction in computation and storage which  can be achieved when the series is real.  Also discussed are hardware and software implementations of  the algorithm which perform only (N/4) log2 (N/2) complex multiply and add operations, and which require  only N real storage locations in analyzing each N-point record.", "authors": "Bergland, G. D.", "words_pool": ["achiev", "add", "algorithm", "analyz", "calcul", "complex", "comput", "cooley", "discret", "discuss", "effect", "fast", "fourier", "hardwar", "implement", "integr", "locat", "log2", "multipli", "number", "oper", "order", "perform", "point", "point", "power", "present", "preserv", "procedur", "real", "record", "reduct", "requir", "seri", "softwar", "storag", "symmetri", "time", "transform", "turkey", "valu", "bergland"], "word_count": {"achiev": 1, "add": 1, "algorithm": 3, "analyz": 1, "calcul": 1, "complex": 2, "comput": 1, "cooley": 1, "discret": 1, "discuss": 1, "effect": 1, "fast": 1, "fourier": 2, "hardwar": 1, "implement": 1, "integr": 1, "locat": 1, "log2": 1, "multipli": 1, "number": 1, "oper": 1, "order": 1, "perform": 1, "point": 2, "power": 1, "present": 1, "preserv": 1, "procedur": 2, "real": 3, "record": 1, "reduct": 1, "requir": 1, "seri": 3, "softwar": 1, "storag": 2, "symmetri": 1, "time": 1, "transform": 2, "turkey": 1, "valu": 1, "bergland": 1}}, "1680": {"id": "1680", "title": "A General-Purpose Display Processing and Tutorial System", "abstract": "ADEPT (A display-Expedited Processing and Tutorial) system is described.  This system was designed  to improve man-computer communications by employing a display unit to interleave tutoring with other  computer operations such as simulation, programming, and information retrieval.  It is written in FORTRAN  IV (G) for the IBM System/360, Model 40, and the IBM 2250 display Unit under Operating System/360.  Adept  is a cataloged program that controls the standard operating system by terminating and rescheduling itself  automatically, relinquishing computer resources allocated to it, and surrendering control to the operating  system to perform other jobs.  It expands the power and flexibility of computer-assisted instruction  by making immediately available to students, teachers, and other users, the full resources (system-cataloged  programs) of the operating system.  Language processors and compilers, simulation models, mathematical  solution techniques, stored data, and all other library and user programs can be incorporated into instructional  material without reprogramming.  Illustrations of the various applications are presented and their implications  are discussed.", "authors": "Engvold, K. J. Hughes, J. L.", "words_pool": ["adept", "alloc", "applic", "assist", "catalog", "commun", "compil", "comput", "control", "control", "data", "design", "discuss", "display", "employ", "expand", "expedit", "flexibl", "fortran", "full", "gener", "ibm", "illustr", "immedi", "implic", "improv", "incorpor", "inform", "instruct", "instruct", "interleav", "iv", "job", "languag", "librari", "make", "man", "materi", "mathemat", "model", "model", "oper", "oper", "perform", "power", "present", "process", "processor", "program", "program", "program", "purpos", "relinquish", "reprogram", "reschedul", "resourc", "retriev", "simul", "solut", "standard", "store", "student", "surrend", "system", "teacher", "techniqu", "termin", "tutori", "tutor", "unit", "user", "user", "written", "engvold", "hugh"], "word_count": {"adept": 2, "alloc": 1, "applic": 1, "assist": 1, "catalog": 2, "commun": 1, "compil": 1, "comput": 4, "control": 2, "data": 1, "design": 1, "discuss": 1, "display": 3, "employ": 1, "expand": 1, "expedit": 1, "flexibl": 1, "fortran": 1, "full": 1, "gener": 1, "ibm": 2, "illustr": 1, "immedi": 1, "implic": 1, "improv": 1, "incorpor": 1, "inform": 1, "instruct": 2, "interleav": 1, "iv": 1, "job": 1, "languag": 1, "librari": 1, "make": 1, "man": 1, "materi": 1, "mathemat": 1, "model": 2, "oper": 5, "perform": 1, "power": 1, "present": 1, "process": 1, "processor": 1, "program": 4, "purpos": 1, "relinquish": 1, "reprogram": 1, "reschedul": 1, "resourc": 2, "retriev": 1, "simul": 2, "solut": 1, "standard": 1, "store": 1, "student": 1, "surrend": 1, "system": 8, "teacher": 1, "techniqu": 1, "termin": 1, "tutori": 1, "tutor": 1, "unit": 2, "user": 2, "written": 1, "engvold": 1, "hugh": 1}}, "1681": {"id": "1681", "title": "Easy English,a Language for Information Retrieval Through a Remote Typewriter Console", "abstract": "Easy English is a natural command language designed to simplify communication between man and  machine through remote typewriter console.  It has been developed for retrieval of documents from a computerized  data base, the Moore School Information Systems Laboratory files.  Requests are formulated in a standardized  syntactical form (examples of which are presented), and this form is then transformed into an equivalent  query expressed in the retrieval system's original Symbolic Command Language, which is briefly described.   Operation of easy English is detailed by illustration of the transformations performed upon a sample  request up to the point at which the request string is sent to the system.  A macro flowchart of Easy  English is included, and an Appendix provides the printout of a retrieval demonstration.", "authors": "Rubinoff, M. Bergman, S. Cautin, H. Rapp, F.", "words_pool": ["appendix", "base", "briefli", "command", "commun", "computer", "consol", "data", "demonstr", "design", "detail", "develop", "document", "easi", "english", "equival", "exampl", "express", "flowchart", "form", "formul", "illustr", "includ", "inform", "laboratori", "languag", "machin", "macro", "man", "moor", "natur", "oper", "origin", "perform", "point", "present", "printout", "queri", "remot", "request", "request", "retriev", "sampl", "school", "simplifi", "standard", "string", "symbol", "syntact", "system", "system", "transform", "transform", "typewrit", "rubinoff", "bergman", "cautin", "rapp"], "word_count": {"appendix": 1, "base": 1, "briefli": 1, "command": 2, "commun": 1, "computer": 1, "consol": 1, "data": 1, "demonstr": 1, "design": 1, "detail": 1, "develop": 1, "document": 1, "easi": 3, "english": 3, "equival": 1, "exampl": 1, "express": 1, "flowchart": 1, "form": 2, "formul": 1, "illustr": 1, "includ": 1, "inform": 1, "laboratori": 1, "languag": 2, "machin": 1, "macro": 1, "man": 1, "moor": 1, "natur": 1, "oper": 1, "origin": 1, "perform": 1, "point": 1, "present": 1, "printout": 1, "queri": 1, "remot": 1, "request": 3, "retriev": 3, "sampl": 1, "school": 1, "simplifi": 1, "standard": 1, "string": 1, "symbol": 1, "syntact": 1, "system": 3, "transform": 2, "typewrit": 1, "rubinoff": 1, "bergman": 1, "cautin": 1, "rapp": 1}}, "1682": {"id": "1682", "title": "The Implementation of a BASIC System in a Multiprogramming Environment", "abstract": "The implementation of a remote terminal BASIC system within the context of an existing multiprogramming  computer system, the Burroughs B5500, is described.  This implementation combines a unique mixture of  machine language and interpretive techniques with an incremental compiler.", "authors": "Braden, H. V. Wulf, W. A.", "words_pool": ["b5500", "basic", "burrough", "combin", "compil", "comput", "context", "environ", "exist", "implement", "increment", "interpret", "languag", "machin", "mixtur", "multiprogram", "remot", "system", "techniqu", "termin", "uniqu", "braden", "wulf"], "word_count": {"b5500": 1, "basic": 1, "burrough": 1, "combin": 1, "compil": 1, "comput": 1, "context": 1, "environ": 1, "exist": 1, "implement": 2, "increment": 1, "interpret": 1, "languag": 1, "machin": 1, "mixtur": 1, "multiprogram": 1, "remot": 1, "system": 2, "techniqu": 1, "termin": 1, "uniqu": 1, "braden": 1, "wulf": 1}}, "1683": {"id": "1683", "title": "Boolean matrix Methods for the Detection of Simple Precedence Grammars", "abstract": "A mechanical procedure is derived for determining whether a given context-free phrase structure  grammar is a simple precedence grammar.  This procedure consists of elementary operations on suitably  defined Boolean matrices.  Application of the procedure to operator grammars is also given.", "authors": "Martin, D. F.", "words_pool": ["applic", "boolean", "consist", "context", "defin", "deriv", "detect", "determin", "elementari", "free", "grammar", "grammar", "matric", "matrix", "mechan", "method", "oper", "oper", "phrase", "preced", "procedur", "simpl", "structur", "suitabl", "martin"], "word_count": {"applic": 1, "boolean": 1, "consist": 1, "context": 1, "defin": 1, "deriv": 1, "detect": 1, "determin": 1, "elementari": 1, "free": 1, "grammar": 3, "matric": 1, "matrix": 1, "mechan": 1, "method": 1, "oper": 2, "phrase": 1, "preced": 1, "procedur": 3, "simpl": 1, "structur": 1, "suitabl": 1, "martin": 1}}, "1684": {"id": "1684", "title": "Ambiguity in Limited Entry Decision Tables", "abstract": "The use of decision tables as a tool in systems analysis and for program specification is now  becoming accepted.  Rules on redundancy, contradiction, and completeness for limited entry tables were  published in 1963.  These are usually used for checking, preceded if necessary by a conversion from extended  to limited entry form.  Processors which automatically translate tables to more conventional program  usually base their diagnostic facilities on these rules.  In this paper it is suggested that these rules  are unsatisfactory and that the important aspect of checking is to eliminate ambiguity from tables.   Ambiguity is defined and discussed, and a procedure for producing checked-out decision tables is proposed.   The theoretical basis of the algorithm used is established. The importance of well-designed diagnostic  facilities in decision table processors is emphasized.", "authors": "King, P. J. H.", "words_pool": ["accept", "algorithm", "ambigu", "analysi", "aspect", "base", "basi", "check", "check", "complet", "contradict", "convent", "convers", "decis", "defin", "design", "diagnost", "discuss", "elimin", "emphas", "entri", "establish", "extend", "facil", "form", "import", "import", "limit", "paper", "preced", "procedur", "processor", "produc", "program", "propos", "publish", "redund", "rule", "specif", "suggest", "system", "tabl", "tabl", "theoret", "tool", "translat", "unsatisfactori", "king"], "word_count": {"accept": 1, "algorithm": 1, "ambigu": 2, "analysi": 1, "aspect": 1, "base": 1, "basi": 1, "check": 3, "complet": 1, "contradict": 1, "convent": 1, "convers": 1, "decis": 3, "defin": 1, "design": 1, "diagnost": 2, "discuss": 1, "elimin": 1, "emphas": 1, "entri": 2, "establish": 1, "extend": 1, "facil": 2, "form": 1, "import": 2, "limit": 2, "paper": 1, "preced": 1, "procedur": 1, "processor": 2, "produc": 1, "program": 2, "propos": 1, "publish": 1, "redund": 1, "rule": 3, "specif": 1, "suggest": 1, "system": 1, "tabl": 6, "theoret": 1, "tool": 1, "translat": 1, "unsatisfactori": 1, "king": 1}}, "1685": {"id": "1685", "title": "GAN, a System for Generating and Analyzing Activity Networks", "abstract": "GAN, a system for generating activity networks, is designed to save time in the preparation  of activity networks and to deal conveniently with network programs.  A defining description of a programming  language designed for generating activity network from a set of standard networks is presented.  Also,  a general idea of a language for performing calculations on activity networks (scheduling activity networks)  is given.", "authors": "Schurmann, A.", "words_pool": ["activ", "analyz", "calcul", "conveni", "deal", "defin", "descript", "design", "gan", "gener", "gener", "idea", "languag", "network", "network", "perform", "prepar", "present", "program", "program", "save", "schedul", "set", "standard", "system", "time", "schurmann"], "word_count": {"activ": 5, "analyz": 1, "calcul": 1, "conveni": 1, "deal": 1, "defin": 1, "descript": 1, "design": 2, "gan": 1, "gener": 3, "idea": 1, "languag": 2, "network": 7, "perform": 1, "prepar": 1, "present": 1, "program": 2, "save": 1, "schedul": 1, "set": 1, "standard": 1, "system": 1, "time": 1, "schurmann": 1}}, "1686": {"id": "1686", "title": "Computer Synthesis of Holograms for 3-D Display", "abstract": "Optical and digital holography are reviewed.  The mathematical model and computational techniques  of the authors' digital holographic process are discussed, and applications of computer holography are  suggested.  Computer holograms have been made of three-dimensional objects which give faithful reconstructions,  even in white light.  A new approach based on point apertures for the image is discussed.  Photographs  of the images reconstructed from digital holograms are presented.", "authors": "Lesem, L. B. Hirsch, P. M.", "words_pool": ["apertur", "applic", "approach", "author", "base", "comput", "comput", "digit", "dimension", "discuss", "display", "faith", "give", "hologram", "holograph", "holographi", "imag", "imag", "light", "made", "mathemat", "model", "object", "optic", "photograph", "point", "present", "process", "reconstruct", "reconstruct", "review", "suggest", "synthesi", "techniqu", "white", "lesem", "hirsch"], "word_count": {"apertur": 1, "applic": 1, "approach": 1, "author": 1, "base": 1, "comput": 3, "digit": 3, "dimension": 1, "discuss": 2, "display": 1, "faith": 1, "give": 1, "hologram": 2, "holograph": 1, "holographi": 2, "imag": 2, "light": 1, "made": 1, "mathemat": 1, "model": 1, "object": 1, "optic": 1, "photograph": 1, "point": 1, "present": 1, "process": 1, "reconstruct": 2, "review": 1, "suggest": 1, "synthesi": 1, "techniqu": 1, "white": 1, "lesem": 1, "hirsch": 1}}, "1687": {"id": "1687", "title": "Netflow (Algorithm 248 [H])", "authors": "Bray, T. A. Witzgall, C.", "words_pool": ["algorithm", "netflow", "bray", "witzgal"], "word_count": {"algorithm": 1, "netflow": 1, "bray": 1, "witzgal": 1}}, "1688": {"id": "1688", "title": "Netflow (Algorithm 248 [H])", "authors": "Henderson, J. H.", "words_pool": ["algorithm", "netflow", "henderson"], "word_count": {"algorithm": 1, "netflow": 1, "henderson": 1}}, "1689": {"id": "1689", "title": "Calculation of a Polynomial and its Derivative Values by Horner Scheme (Algorithm 337 [C1])", "authors": "Pankiewicz, W.", "words_pool": ["algorithm", "c1", "calcul", "deriv", "horner", "polynomi", "scheme", "valu", "pankiewicz"], "word_count": {"algorithm": 1, "c1": 1, "calcul": 1, "deriv": 1, "horner": 1, "polynomi": 1, "scheme": 1, "valu": 1, "pankiewicz": 1}}, "1690": {"id": "1690", "title": "Netflow (Algorithm 336 [H])", "authors": "Bray, T. A. Witzgall, C.", "words_pool": ["algorithm", "netflow", "bray", "witzgal"], "word_count": {"algorithm": 1, "netflow": 1, "bray": 1, "witzgal": 1}}, "1691": {"id": "1691", "title": "A Comparison of the Correlational Behavior of Random Number Generators for the IBM 360", "abstract": "Hutchinson states that the \"new\" (prime modulo) multiplicative congruential pseudorandom generator,  attributed to D. H. Lehmer, has passed the usual statistical tests for random number generators.  It  is here empirically shown that generators of this type can produce sequences whose autocorrelation functions  up to lag 50 exhibit evidence of nonrandomness for many multiplicative constants.  An alternative generator  proposed by Tausworthe, which uses irreducible polynomials over the field of characteristic two, is shown  to be free from this defect.  The applicability of these two generators to the IBM 360 is then discussed.   Since computer word size can affect a generator's statistical behavior the older mixed and simple congruential  generators, although extensively tested on computers having 36 or more bits per word, may not be optimum  generators for the IBM 360.", "authors": "Whittlesey, J. R.", "words_pool": ["affect", "altern", "applic", "attribut", "autocorrel", "behavior", "bit", "characterist", "comparison", "comput", "comput", "congruenti", "constant", "correl", "defect", "discuss", "empir", "evid", "exhibit", "extens", "field", "free", "function", "gener", "gener", "hutchinson", "ibm", "irreduc", "lag", "lehmer", "mix", "modulo", "multipl", "nonrandom", "number", "older", "optimum", "pass", "polynomi", "prime", "produc", "propos", "pseudorandom", "random", "sequenc", "shown", "simpl", "size", "state", "statist", "tausworth", "test", "test", "type", "usual", "word", "whittlesey"], "word_count": {"affect": 1, "altern": 1, "applic": 1, "attribut": 1, "autocorrel": 1, "behavior": 1, "bit": 1, "characterist": 1, "comparison": 1, "comput": 2, "congruenti": 2, "constant": 1, "correl": 1, "defect": 1, "discuss": 1, "empir": 1, "evid": 1, "exhibit": 1, "extens": 1, "field": 1, "free": 1, "function": 1, "gener": 8, "hutchinson": 1, "ibm": 2, "irreduc": 1, "lag": 1, "lehmer": 1, "mix": 1, "modulo": 1, "multipl": 2, "nonrandom": 1, "number": 1, "older": 1, "optimum": 1, "pass": 1, "polynomi": 1, "prime": 1, "produc": 1, "propos": 1, "pseudorandom": 1, "random": 1, "sequenc": 1, "shown": 2, "simpl": 1, "size": 1, "state": 1, "statist": 2, "tausworth": 1, "test": 2, "type": 1, "usual": 1, "word": 2, "whittlesey": 1}}, "1692": {"id": "1692", "title": "Numerical Solution of a Thin Plate Heat Transfer Problem", "abstract": ". Lick, D. W.", "authors": "Stewart III, G", "words_pool": ["heat", "lick", "numer", "plate", "problem", "solut", "thin", "transfer", "stewart", "iii"], "word_count": {"heat": 1, "lick": 1, "numer": 1, "plate": 1, "problem": 1, "solut": 1, "thin": 1, "transfer": 1, "stewart": 1, "iii": 1}}, "1693": {"id": "1693", "title": "GPL, a Truly General Purpose Language", "abstract": "A truly general purpose programming language, GPL, is described which contains facilities for  constructing (within the language) new data types as well as facilities for operations performed upon  them.  The basic language is minimal in the sense that no basic element can be derived from the others  with high efficiency in the object programs.  Constructs like the ALGOL 60 for-statements,and if-statements  are not basic; they are special types of procedures.  New \"symbols\" (underlined words in ALGOL 60) are  implicitly defined by usage in other declarations.  As part words are definable, packed words are handled  as easily as full words.  \"Address\" variables (pointers) are included in full generality.", "authors": "Garwick, J. V.", "words_pool": ["address", "algol", "basic", "construct", "construct", "data", "declar", "defin", "defin", "deriv", "easili", "effici", "element", "facil", "full", "gener", "gener", "gpl", "handl", "high", "implicitli", "includ", "languag", "minim", "object", "oper", "pack", "part", "perform", "pointer", "procedur", "program", "program", "purpos", "sens", "special", "statement", "symbol", "truli", "type", "underlin", "usag", "variabl", "word", "garwick"], "word_count": {"address": 1, "algol": 2, "basic": 3, "construct": 2, "data": 1, "declar": 1, "defin": 2, "deriv": 1, "easili": 1, "effici": 1, "element": 1, "facil": 2, "full": 2, "gener": 2, "gpl": 1, "handl": 1, "high": 1, "implicitli": 1, "includ": 1, "languag": 3, "minim": 1, "object": 1, "oper": 1, "pack": 1, "part": 1, "perform": 1, "pointer": 1, "procedur": 1, "program": 2, "purpos": 1, "sens": 1, "special": 1, "statement": 2, "symbol": 1, "truli": 1, "type": 2, "underlin": 1, "usag": 1, "variabl": 1, "word": 4, "garwick": 1}}, "1694": {"id": "1694", "title": "An Algorithm for the Probability of the Union of a Large Number of Events", "abstract": "An algorithm is presented which efficiently evaluates the probability for the union of n independent  and not mutually exclusive events. The problem is that of evaluating the sums of the products of all  possible combinations of n variables in minimum time and storage space.", "authors": "Miller, G. D.", "words_pool": ["algorithm", "combin", "effici", "evalu", "evalu", "event", "exclus", "independ", "larg", "minimum", "mutual", "number", "present", "probabl", "problem", "product", "space", "storag", "sum", "time", "union", "variabl", "miller"], "word_count": {"algorithm": 1, "combin": 1, "effici": 1, "evalu": 2, "event": 1, "exclus": 1, "independ": 1, "larg": 1, "minimum": 1, "mutual": 1, "number": 1, "present": 1, "probabl": 1, "problem": 1, "product": 1, "space": 1, "storag": 1, "sum": 1, "time": 1, "union": 1, "variabl": 1, "miller": 1}}, "1695": {"id": "1695", "title": "PLEXUS-An On-Line System for Modeling Neural Networks", "abstract": "A description is presented of PLEXUS, a system which enables a user to construct and specify  a neural network, to analyze the output data produced by the network, and to store and retrieve networks  and data from a library.  The system, operated entirely from a digital display unit, interacts directly  with the user and permits easy and rapid transitions between the various phases of the modeling process.   PLEXUS is designed to complement neurophysiological research so that the systematic development of neural  models can be coordinated with experimental work.  PLEXUS networks are built up from components representing  individual neurons, external stimuli, and interconnecting fibers, each component being of a relatively  detailed nature.  Provision is also made for the use of experimental data as input to a network.  Convenient  means for specification and modification of a network and extensive error-checking capabilities are provided.  Data resulting from the simulation of a network may be analyzed by a variety of techniques ranging from  examinations of the gross characteristics of the data to the determination of detailed statistical properties.", "authors": "Dill, J. C. Randall, D. L. Richer, I.", "words_pool": ["analyz", "analyz", "built", "capabl", "characterist", "check", "complement", "compon", "compon", "construct", "conveni", "coordin", "data", "descript", "design", "detail", "determin", "develop", "digit", "directli", "display", "easi", "enabl", "entir", "error", "examin", "experiment", "extens", "extern", "fiber", "gross", "individu", "input", "interact", "interconnect", "librari", "line", "made", "mean", "model", "model", "modif", "natur", "network", "network", "neural", "neuron", "neurophysiolog", "oper", "output", "permit", "phase", "plexu", "present", "process", "produc", "properti", "provid", "provis", "rang", "rapid", "repres", "research", "result", "retriev", "simul", "specif", "statist", "stimuli", "store", "system", "systemat", "techniqu", "transit", "unit", "user", "varieti", "work", "dill", "randal", "richer"], "word_count": {"analyz": 2, "built": 1, "capabl": 1, "characterist": 1, "check": 1, "complement": 1, "compon": 2, "construct": 1, "conveni": 1, "coordin": 1, "data": 5, "descript": 1, "design": 1, "detail": 2, "determin": 1, "develop": 1, "digit": 1, "directli": 1, "display": 1, "easi": 1, "enabl": 1, "entir": 1, "error": 1, "examin": 1, "experiment": 2, "extens": 1, "extern": 1, "fiber": 1, "gross": 1, "individu": 1, "input": 1, "interact": 1, "interconnect": 1, "librari": 1, "line": 1, "made": 1, "mean": 1, "model": 2, "modif": 1, "natur": 1, "network": 7, "neural": 2, "neuron": 1, "neurophysiolog": 1, "oper": 1, "output": 1, "permit": 1, "phase": 1, "plexu": 3, "present": 1, "process": 1, "produc": 1, "properti": 1, "provid": 1, "provis": 1, "rang": 1, "rapid": 1, "repres": 1, "research": 1, "result": 1, "retriev": 1, "simul": 1, "specif": 1, "statist": 1, "stimuli": 1, "store": 1, "system": 2, "systemat": 1, "techniqu": 1, "transit": 1, "unit": 1, "user": 2, "varieti": 1, "work": 1, "dill": 1, "randal": 1, "richer": 1}}, "1696": {"id": "1696", "title": "An Algorithm for Identifying the Ergodic Subchains and Transient States of a Stochastic Matrix", "abstract": "An algorithm for identifying the ergodic subchains and transient states of a stochastic matrix is presented.  Applications in Markov renewal programming and in the construction of variable length  codes are reviewed, and an updating procedure for dealing with certain sequences of stochastic matrices  is discussed.  Computation times are investigated experimentally and compared with those of another recently  propose method.", "authors": "Fox, B. L. Landi, D. M.", "words_pool": ["algorithm", "applic", "code", "compar", "comput", "construct", "deal", "discuss", "ergod", "experiment", "identifi", "investig", "length", "markov", "matric", "matrix", "method", "present", "procedur", "program", "propos", "recent", "renew", "review", "sequenc", "state", "stochast", "subchain", "time", "transient", "updat", "variabl", "fox", "landi"], "word_count": {"algorithm": 1, "applic": 1, "code": 1, "compar": 1, "comput": 1, "construct": 1, "deal": 1, "discuss": 1, "ergod": 1, "experiment": 1, "identifi": 1, "investig": 1, "length": 1, "markov": 1, "matric": 1, "matrix": 1, "method": 1, "present": 1, "procedur": 1, "program": 1, "propos": 1, "recent": 1, "renew": 1, "review": 1, "sequenc": 1, "state": 1, "stochast": 2, "subchain": 1, "time": 1, "transient": 1, "updat": 1, "variabl": 1, "fox": 1, "landi": 1}}, "1697": {"id": "1697", "title": "Graphical Input/Output of Nonstandard Characters", "abstract": "A system developed at Harvard for graphically inputting and outputting nonstandard characters  on a computer is printed.  In principle, the system can deal with any orthography, although at present  it is limited to 4000 Chinese characters and some mathematical symbols.  New characters can be added  to the repertoire of the system by graphical input on a display scope.  Text inputting is accomplished  via a display scope or a Rand Tablet.  The organization and operation of the current system are described,  and a discussion of the relative merits of such a system is given.  Illustrations of the computer input  and output of Chinese characters are included.", "authors": "Hayashl, H. Duncan, S. Kuno, S.", "words_pool": ["accomplish", "ad", "charact", "chines", "comput", "deal", "develop", "discuss", "display", "graphic", "graphic", "harvard", "illustr", "includ", "input", "input", "limit", "mathemat", "merit", "nonstandard", "oper", "organ", "orthographi", "output", "output", "present", "principl", "print", "rand", "rel", "repertoir", "scope", "symbol", "system", "tablet", "text", "hayashl", "duncan", "kuno"], "word_count": {"accomplish": 1, "ad": 1, "charact": 4, "chines": 2, "comput": 2, "deal": 1, "develop": 1, "discuss": 1, "display": 2, "graphic": 2, "harvard": 1, "illustr": 1, "includ": 1, "input": 4, "limit": 1, "mathemat": 1, "merit": 1, "nonstandard": 1, "oper": 1, "organ": 1, "orthographi": 1, "output": 2, "present": 1, "principl": 1, "print": 1, "rand": 1, "rel": 1, "repertoir": 1, "scope": 2, "symbol": 1, "system": 5, "tablet": 1, "text": 1, "hayashl": 1, "duncan": 1, "kuno": 1}}, "1698": {"id": "1698", "title": "A Statistical Model for Console Behavior in Multiuser Computers", "abstract": "The ability of a computer system to communicate with the outside world efficiently is as important  as its ability to perform computations efficiently.  It is quite difficult to characterize a particular  user, but rather easy to characterize the entire user community.  Based on the properties of this community  we have postulated a hypothetical \"virtual console.\"  No claim is made that a virtual console behaves  like any actual console, but the entire collection of virtual consoles models the collection of actual  consoles.  Using the model we answer questions like:  How many processes are suspended waiting for console  input?  What is the maximum rate at which a process can execute?  What bounds can be set on overall buffer  requirements?  Answers to these and similar questions are needed in certain aspects of operating system  design.", "authors": "Denning, P. J.", "words_pool": ["abil", "actual", "answer", "answer", "aspect", "base", "behav", "behavior", "bound", "buffer", "character", "claim", "collect", "commun", "commun", "comput", "comput", "comput", "consol", "consol", "design", "difficult", "easi", "effici", "entir", "execut", "hypothet", "import", "input", "made", "maximum", "model", "model", "multius", "need", "oper", "perform", "postul", "process", "process", "properti", "question", "rate", "requir", "set", "similar", "statist", "suspend", "system", "user", "virtual", "wait", "world", "den"], "word_count": {"abil": 2, "actual": 2, "answer": 2, "aspect": 1, "base": 1, "behav": 1, "behavior": 1, "bound": 1, "buffer": 1, "character": 2, "claim": 1, "collect": 2, "commun": 3, "comput": 2, "consol": 6, "design": 1, "difficult": 1, "easi": 1, "effici": 2, "entir": 2, "execut": 1, "hypothet": 1, "import": 1, "input": 1, "made": 1, "maximum": 1, "model": 2, "multius": 1, "need": 1, "oper": 1, "perform": 1, "postul": 1, "process": 2, "properti": 1, "question": 2, "rate": 1, "requir": 1, "set": 1, "similar": 1, "statist": 1, "suspend": 1, "system": 2, "user": 2, "virtual": 3, "wait": 1, "world": 1, "den": 1}}, "1699": {"id": "1699", "title": "Experimental Evaluation of Information Retrieval Through a Teletypewriter", "abstract": "Experiments designed to evaluate the capabilities of mechanized information retrieval systems,  with emphasis on interactive (man-machine) language and on some of the mechanical and psychological limitations  in their design, were conducted at the Moore School information Systems Laboratory.  The basic assumption  of the research is that an information retrieval system that provides for man-machine dialogue at a remote  inquiry terminal should provide a searcher with many of the tools which would be available to him were  he actually performing his search at a library or repository of documents.  Factors involved in evaluation  of such a system include ease of use, learning time, and effectiveness of actual retrieval.  Three experiments  and the conclusions resulting from them are detailed.", "authors": "Rubinoff, M. Bergman, S. Franks, W. Rubinoff, E.R.", "words_pool": ["actual", "actual", "assumpt", "basic", "capabl", "conclus", "conduct", "design", "design", "detail", "dialogu", "document", "eas", "effect", "emphasi", "evalu", "evalu", "experiment", "experi", "factor", "includ", "inform", "inquiri", "interact", "involv", "laboratori", "languag", "learn", "librari", "limit", "machin", "man", "mechan", "mechan", "moor", "perform", "provid", "psycholog", "remot", "repositori", "research", "result", "retriev", "school", "search", "searcher", "system", "system", "teletypewrit", "termin", "time", "tool", "rubinoff", "bergman", "frank", "rubinoff"], "word_count": {"actual": 2, "assumpt": 1, "basic": 1, "capabl": 1, "conclus": 1, "conduct": 1, "design": 2, "detail": 1, "dialogu": 1, "document": 1, "eas": 1, "effect": 1, "emphasi": 1, "evalu": 2, "experiment": 1, "experi": 2, "factor": 1, "includ": 1, "inform": 3, "inquiri": 1, "interact": 1, "involv": 1, "laboratori": 1, "languag": 1, "learn": 1, "librari": 1, "limit": 1, "machin": 2, "man": 2, "mechan": 2, "moor": 1, "perform": 1, "provid": 1, "psycholog": 1, "remot": 1, "repositori": 1, "research": 1, "result": 1, "retriev": 3, "school": 1, "search": 1, "searcher": 1, "system": 4, "teletypewrit": 1, "termin": 1, "time": 1, "tool": 1, "rubinoff": 1, "bergman": 1, "frank": 1}}, "1700": {"id": "1700", "title": "PEEKABIT, Computer Offspring of Punched Card PEEKABOO, for Natural Language Searching", "abstract": "The \"peekaboo\" idea from punched card information retrieval methods has been mated with the  idea of superimposed punching to produce a programming technique which cuts computer run time in half  on a test search of 33,000 subject index entries.  A search program using the device has been operational  since late 1963.  As an item is entered in the store, an 18-byte mask is created from the item's meaningful  words using the inclusive OR operation.  If, at search time, the logical product (using the AND operation)  of this mask and a similarly constructed question mask is not equal to the question mask, then one or  more question words are not present in the store item.  An equality is in conclusive; the words of the  store item must be unpacked and compared with question words.  The present store is made up of over 600,000  subject index entries estimated to average 60 characters each.  Longer texts, such as abstracts, could  be handled by multiple masks.", "authors": "Hutton, F. C.", "words_pool": ["abstract", "averag", "byte", "card", "charact", "compar", "comput", "conclus", "construct", "creat", "cut", "devic", "enter", "entri", "equal", "equal", "estim", "half", "handl", "idea", "inclus", "index", "inform", "item", "languag", "late", "logic", "longer", "made", "mask", "mask", "mate", "meaning", "method", "multipl", "natur", "offspr", "oper", "oper", "peekabit", "peekaboo", "present", "produc", "product", "program", "program", "punch", "punch", "question", "retriev", "run", "search", "search", "similarli", "store", "subject", "superimpos", "techniqu", "test", "text", "time", "unpack", "word", "hutton"], "word_count": {"abstract": 1, "averag": 1, "byte": 1, "card": 1, "charact": 1, "compar": 1, "comput": 1, "conclus": 1, "construct": 1, "creat": 1, "cut": 1, "devic": 1, "enter": 1, "entri": 2, "equal": 2, "estim": 1, "half": 1, "handl": 1, "idea": 2, "inclus": 1, "index": 2, "inform": 1, "item": 4, "languag": 1, "late": 1, "logic": 1, "longer": 1, "made": 1, "mask": 5, "mate": 1, "meaning": 1, "method": 1, "multipl": 1, "natur": 1, "offspr": 1, "oper": 3, "peekabit": 1, "peekaboo": 1, "present": 2, "produc": 1, "product": 1, "program": 2, "punch": 2, "question": 4, "retriev": 1, "run": 1, "search": 3, "similarli": 1, "store": 4, "subject": 2, "superimpos": 1, "techniqu": 1, "test": 1, "text": 1, "time": 2, "unpack": 1, "word": 4, "hutton": 1}}, "1701": {"id": "1701", "title": "Synchronous Signaling Rates for Data Transmission* (Proposed USA STandard)", "words_pool": ["data", "propos", "rate", "signal", "standard", "synchron", "transmiss", "usa"], "word_count": {"data": 1, "propos": 1, "rate": 1, "signal": 1, "standard": 1, "synchron": 1, "transmiss": 1, "usa": 1}}, "1702": {"id": "1702", "title": "Commentary on Mr. Mooers' Paper", "authors": "Steel Jr., T. B.", "words_pool": ["commentari", "mooer", "mr", "paper", "steel", "jr"], "word_count": {"commentari": 1, "mooer": 1, "mr": 1, "paper": 1, "steel": 1, "jr": 1}}, "1703": {"id": "1703", "title": "Accommodating Standards and Identification of Programming Languages", "abstract": "The user public wants standardization and reliable identification of programming languages  and related services.  One way of achieving these goals illustrated by the methods adopted for TRAC T-64  interactive language, and its related family of languages.  Oppressive rigidity usually associated with  standardization is avoided by a new accommodation technique accessible to the user to allow local variations  with the language.  Explicit standardization of the language is undertaken at the organizational source  of the language.  Use of the organizational trademark (TRAC) on the published standards, and services  relying upon them, provides a reliable public identification.  These methods can be usefully applied  to other programming languages and computer services.", "authors": "Mooers, C. N.", "words_pool": ["access", "accommod", "accommod", "achiev", "adopt", "allow", "appli", "avoid", "comput", "explicit", "famili", "goal", "identif", "illustr", "interact", "languag", "languag", "local", "method", "oppress", "organiz", "program", "public", "publish", "relat", "reliabl", "reli", "rigid", "servic", "sourc", "standard", "standard", "techniqu", "trac", "trademark", "undertaken", "use", "user", "variat", "want", "mooer"], "word_count": {"access": 1, "accommod": 1, "achiev": 1, "adopt": 1, "allow": 1, "appli": 1, "avoid": 1, "comput": 1, "explicit": 1, "famili": 1, "goal": 1, "identif": 2, "illustr": 1, "interact": 1, "languag": 7, "local": 1, "method": 2, "oppress": 1, "organiz": 2, "program": 2, "public": 2, "publish": 1, "relat": 2, "reliabl": 2, "reli": 1, "rigid": 1, "servic": 3, "sourc": 1, "standard": 4, "techniqu": 1, "trac": 2, "trademark": 1, "undertaken": 1, "use": 1, "user": 2, "variat": 1, "want": 1, "mooer": 1}}, "1704": {"id": "1704", "title": "Minimum Excess Cost Curve (ALgorithm 217 [H])", "authors": "Muth, J. F.", "words_pool": ["algorithm", "cost", "curv", "excess", "minimum", "muth"], "word_count": {"algorithm": 1, "cost": 1, "curv": 1, "excess": 1, "minimum": 1, "muth": 1}}, "1705": {"id": "1705", "title": "A Set of Basic Input-Output Procedures (Algorithm 335 [15])", "abstract": "By means of the primitives in symbol, outsymbol and length, as requested by this journal's  Algorithms Policy [Comm. ACM 10 (Nov. 67), 729] a basic set of input-output procedures is defined aiming  at quality and flexibility.  Outreal, for instance, is written as a derived procedure; it outputs using  the fixed point or the floating point representation, and rounds properly.  Variants can easily be written  because of the explicit call of the procedures decompose integer and decompose real.  The highly recommended  practice of echoing input is made easy with one subset of derived procedures (ioi, ior, iob, ioa).  The  documentation of output in the form of equivalent ALGOL statements is also provided when use is made  of the subset oti, otr, otb, ota.  The Berkeley style of providing information on the form of output  using prior calls of procedures such as real format is defined.  A use of the parameter outchannel to  provide information for simultaneous output to several channels is suggested.  Interrelationship between  the declared procedures is furnished in tabular form.", "authors": "De Vogelaere, R.", "words_pool": ["acm", "aim", "algol", "algorithm", "algorithm", "basic", "berkeley", "call", "call", "channel", "comm", "declar", "decompos", "defin", "deriv", "document", "easili", "easi", "echo", "equival", "explicit", "fix", "flexibl", "float", "form", "format", "furnish", "highli", "inform", "input", "instanc", "integ", "interrelationship", "ioa", "iob", "ioi", "ior", "journal", "length", "made", "mean", "nov", "ota", "otb", "oti", "otr", "outchannel", "output", "output", "outreal", "outsymbol", "paramet", "point", "polici", "practic", "primit", "prior", "procedur", "procedur", "properli", "provid", "provid", "provid", "qualiti", "real", "recommend", "represent", "request", "round", "set", "simultan", "statement", "style", "subset", "suggest", "symbol", "tabular", "variant", "written", "de", "vogelaer"], "word_count": {"acm": 1, "aim": 1, "algol": 1, "algorithm": 1, "basic": 1, "berkeley": 1, "call": 2, "channel": 1, "comm": 1, "declar": 1, "decompos": 2, "defin": 2, "deriv": 2, "document": 1, "easili": 1, "easi": 1, "echo": 1, "equival": 1, "explicit": 1, "fix": 1, "flexibl": 1, "float": 1, "form": 3, "format": 1, "furnish": 1, "highli": 1, "inform": 2, "input": 2, "instanc": 1, "integ": 1, "interrelationship": 1, "ioa": 1, "iob": 1, "ioi": 1, "ior": 1, "journal": 1, "length": 1, "made": 2, "mean": 1, "nov": 1, "ota": 1, "otb": 1, "oti": 1, "otr": 1, "outchannel": 1, "output": 5, "outreal": 1, "outsymbol": 1, "paramet": 1, "point": 2, "polici": 1, "practic": 1, "primit": 1, "prior": 1, "procedur": 6, "properli": 1, "provid": 3, "qualiti": 1, "real": 2, "recommend": 1, "represent": 1, "request": 1, "round": 1, "set": 1, "simultan": 1, "statement": 1, "style": 1, "subset": 2, "suggest": 1, "symbol": 1, "tabular": 1, "variant": 1, "written": 2, "de": 1, "vogelaer": 1}}, "1706": {"id": "1706", "title": "CHAMP-Character Manipulation Procedures", "abstract": "A new programming language facility for symbol manipulation is described.  String procedures  may be declared and called in a standard ALGOL context.  ALGOL procedures can in turn be called by string  procedures so that numeric and symbolic processes may conveniently be programmed together.  Concatenation  and a variant of SNOBOL's pattern matching make up a set of primitive commands.  These are assembled  together into conditional expressions which are to be used to provide alternative computational patterns.   Arrays of strings are processed using quantifiers.  The class of things which may be assigned to an  identifier can be restricted by a procedure expressed in the notation.  The language facilities have  been implemented in the ALGOL compiler for the Burroughs B5500.", "authors": "Storm, E. F.", "words_pool": ["algol", "altern", "array", "assembl", "assign", "b5500", "burrough", "call", "champ", "charact", "class", "command", "compil", "comput", "concaten", "condit", "context", "conveni", "declar", "express", "express", "facil", "facil", "identifi", "implement", "languag", "make", "manipul", "match", "notat", "numer", "pattern", "pattern", "primit", "procedur", "procedur", "process", "process", "program", "program", "provid", "quantifi", "restrict", "set", "snobol", "standard", "string", "string", "symbol", "symbol", "thing", "turn", "variant", "storm"], "word_count": {"algol": 3, "altern": 1, "array": 1, "assembl": 1, "assign": 1, "b5500": 1, "burrough": 1, "call": 2, "champ": 1, "charact": 1, "class": 1, "command": 1, "compil": 1, "comput": 1, "concaten": 1, "condit": 1, "context": 1, "conveni": 1, "declar": 1, "express": 2, "facil": 2, "identifi": 1, "implement": 1, "languag": 2, "make": 1, "manipul": 1, "match": 1, "notat": 1, "numer": 1, "pattern": 2, "primit": 1, "procedur": 4, "process": 2, "program": 2, "provid": 1, "quantifi": 1, "restrict": 1, "set": 1, "snobol": 1, "standard": 1, "string": 3, "symbol": 2, "thing": 1, "turn": 1, "variant": 1, "storm": 1}}, "1707": {"id": "1707", "title": "Generation of Positive Test Matrices with Known Positive Spectra", "abstract": "Sufficient conditions are given for a real matrix to be similar to a positive matrix.  This  result is used to construct a similarity transformation which, when applied to a particular upper triangular  matrix, yields a positive matrix with a preassigned positive spectrum.", "authors": "Hall, C. A. Porsching, T. A.", "words_pool": ["appli", "condit", "construct", "gener", "known", "matric", "matrix", "posit", "preassign", "real", "result", "similar", "similar", "spectra", "spectrum", "suffici", "test", "transform", "triangular", "upper", "yield", "hall", "porsch"], "word_count": {"appli": 1, "condit": 1, "construct": 1, "gener": 1, "known": 1, "matric": 1, "matrix": 4, "posit": 3, "preassign": 1, "real": 1, "result": 1, "similar": 2, "spectra": 1, "spectrum": 1, "suffici": 1, "test": 1, "transform": 1, "triangular": 1, "upper": 1, "yield": 1, "hall": 1, "porsch": 1}}, "1708": {"id": "1708", "title": "A Note on the Efficiency of a LISP Computation in a Paged Machine", "abstract": "The problem of the use of two levels of storage for programs is explored in the context of  a LISP system which uses core memory as a buffer for a large virtual memory stored on a drum.  Details  of timing are given for one particular problem.", "authors": "Borrow, D. G. Murphy, D. L.", "words_pool": ["buffer", "comput", "context", "core", "detail", "drum", "effici", "explor", "larg", "level", "lisp", "machin", "memori", "note", "page", "problem", "program", "storag", "store", "system", "time", "virtual", "borrow", "murphi"], "word_count": {"buffer": 1, "comput": 1, "context": 1, "core": 1, "detail": 1, "drum": 1, "effici": 1, "explor": 1, "larg": 1, "level": 1, "lisp": 1, "machin": 1, "memori": 2, "note": 1, "page": 1, "problem": 2, "program": 1, "storag": 1, "store": 1, "system": 1, "time": 1, "virtual": 1, "borrow": 1, "murphi": 1}}, "1709": {"id": "1709", "title": "A Modification of Efroymson's Technique for Stepwise Regression Analysis", "abstract": "The computational technique conventionally used for stepwise multiple linear regression requires  the storage of an n X n matrix of data.  When the number of variables, n, is large, this requirement  taxes the storage capacity of presently used machinery.  The near symmetry of the matrices involved permits  a modification requiring only half the storage and computations of the conventional algorithm and this  additional storage allows the analysis of problems containing more variables.  Alternatively, it permits  the analysis of problems containing the same number of variables but with all computations performed  in double precision.", "authors": "Breaux, H. J.", "words_pool": ["addit", "algorithm", "altern", "analysi", "capac", "comput", "comput", "convent", "convent", "data", "doubl", "efroymson", "half", "involv", "larg", "linear", "machineri", "matric", "matrix", "modif", "multipl", "number", "perform", "permit", "precis", "present", "problem", "regress", "requir", "requir", "requir", "stepwis", "storag", "symmetri", "tax", "techniqu", "variabl", "breaux"], "word_count": {"addit": 1, "algorithm": 1, "altern": 1, "analysi": 2, "capac": 1, "comput": 3, "convent": 2, "data": 1, "doubl": 1, "efroymson": 1, "half": 1, "involv": 1, "larg": 1, "linear": 1, "machineri": 1, "matric": 1, "matrix": 1, "modif": 1, "multipl": 1, "number": 2, "perform": 1, "permit": 2, "precis": 1, "present": 1, "problem": 2, "regress": 1, "requir": 3, "stepwis": 1, "storag": 4, "symmetri": 1, "tax": 1, "techniqu": 1, "variabl": 3, "breaux": 1}}, "1710": {"id": "1710", "title": "ASP-A Ring Implemented Associative Structure Package", "abstract": "ASP is a general purpose Associative Data Structure Package in which an arbitrary number of  data items and an arbitrary number of the relationships between these data items may be represented.   A special picture language is described which has proved very useful for drawing ASP structures on paper.   ASP structures are built and manipulated by means of a series of macro calls, which are outlined in  the Appendix.  Emphasis is on the philosophy of the system rather than a particular implementation, though  sufficient information is included to enable the reader to produce his own implementation of ASP.", "authors": "Lang, C. A. Gray, J. C.", "words_pool": ["appendix", "arbitrari", "asp", "associ", "built", "call", "data", "draw", "emphasi", "enabl", "gener", "implement", "implement", "includ", "inform", "item", "languag", "macro", "manipul", "mean", "number", "outlin", "packag", "paper", "philosophi", "pictur", "produc", "prove", "purpos", "reader", "relationship", "repres", "ring", "seri", "special", "structur", "structur", "suffici", "system", "lang", "gray"], "word_count": {"appendix": 1, "arbitrari": 2, "asp": 4, "associ": 1, "built": 1, "call": 1, "data": 3, "draw": 1, "emphasi": 1, "enabl": 1, "gener": 1, "implement": 2, "includ": 1, "inform": 1, "item": 2, "languag": 1, "macro": 1, "manipul": 1, "mean": 1, "number": 2, "outlin": 1, "packag": 1, "paper": 1, "philosophi": 1, "pictur": 1, "produc": 1, "prove": 1, "purpos": 1, "reader": 1, "relationship": 1, "repres": 1, "ring": 1, "seri": 1, "special": 1, "structur": 3, "suffici": 1, "system": 1, "lang": 1, "gray": 1}}, "1711": {"id": "1711", "title": "When Your Computer Needs a Lawyer", "abstract": "Possible liability for negligence, for other torts (such as slander of credit) and for liability  under theories of express or implied warranty (guarantees) are discussed, and legal complications are  explained, so that users, operators, owners, and leasors of computers may be alerted to potential legal  problems. Focus is also on trouble spots in contracting for data processing services, in automating record  keeping operations, in deciding whether or not to automate certain operations, and in complying with  statutes and regulation relating to record keeping.  Information is given on patents, copyrights and  trade secret protection for programs, and the problem of using copyrighted material in information storage  and retrieval systems, including the pending copyright and patent revision bills.", "authors": "Banzhaf III, J. F.", "words_pool": ["alert", "autom", "autom", "bill", "complic", "compli", "comput", "comput", "contract", "copyright", "copyright", "copyright", "credit", "data", "decid", "discuss", "explain", "express", "focu", "guarante", "impli", "includ", "inform", "keep", "lawyer", "leasor", "legal", "liabil", "materi", "need", "neglig", "oper", "oper", "owner", "patent", "patent", "pend", "potenti", "problem", "problem", "process", "program", "protect", "record", "regul", "relat", "retriev", "revis", "secret", "servic", "slander", "spot", "statut", "storag", "system", "theori", "tort", "trade", "troubl", "user", "warranti", "banzhaf", "iii"], "word_count": {"alert": 1, "autom": 2, "bill": 1, "complic": 1, "compli": 1, "comput": 1, "contract": 1, "copyright": 3, "credit": 1, "data": 1, "decid": 1, "discuss": 1, "explain": 1, "express": 1, "focu": 1, "guarante": 1, "impli": 1, "includ": 1, "inform": 2, "keep": 2, "lawyer": 1, "leasor": 1, "legal": 2, "liabil": 2, "materi": 1, "need": 1, "neglig": 1, "oper": 3, "owner": 1, "patent": 2, "pend": 1, "potenti": 1, "problem": 2, "process": 1, "program": 1, "protect": 1, "record": 2, "regul": 1, "relat": 1, "retriev": 1, "revis": 1, "secret": 1, "servic": 1, "slander": 1, "spot": 1, "statut": 1, "storag": 1, "system": 1, "theori": 1, "tort": 1, "trade": 1, "troubl": 1, "user": 1, "warranti": 1, "banzhaf": 1, "iii": 1}}, "1712": {"id": "1712", "title": "Recovery of Disk Contents After System Failure", "abstract": "A method is discussed by which, after a system malfunction, the contents of disk files can  be restored to their status at the time of the failure.", "authors": "Lockemann, P. C. Knutsen, W. D.", "words_pool": ["content", "discuss", "disk", "failur", "malfunct", "method", "recoveri", "restor", "statu", "system", "time", "lockemann", "knutsen"], "word_count": {"content": 1, "discuss": 1, "disk": 1, "failur": 1, "malfunct": 1, "method": 1, "recoveri": 1, "restor": 1, "statu": 1, "system": 1, "time": 1, "lockemann": 1, "knutsen": 1}}, "1713": {"id": "1713", "title": "On Overcoming High-Priority Paralysis in Multiprogramming Systems: A Case His tory", "abstract": "High-priority paralysis is the degradation that can occur in multiprogramming systems when  scheduling is based primarily on preassigned priorities.  It can be alleviated by modifying the scheduling  algorithm to maximize the number of programs active at one time.  The case his tory given in this paper  indicates two general methods by which simultaneity can be increased.  Possible refinements in the scheduling  algorithm for future improvements are considered briefly.", "authors": "Stevens, D. F.", "words_pool": ["activ", "algorithm", "allevi", "base", "briefli", "case", "consid", "degrad", "futur", "gener", "high", "improv", "increas", "maxim", "method", "modifi", "multiprogram", "number", "occur", "overcom", "paper", "paralysi", "preassign", "primarili", "prioriti", "prioriti", "program", "refin", "schedul", "simultan", "system", "time", "tori", "steven"], "word_count": {"activ": 1, "algorithm": 2, "allevi": 1, "base": 1, "briefli": 1, "case": 1, "consid": 1, "degrad": 1, "futur": 1, "gener": 1, "high": 1, "improv": 1, "increas": 1, "maxim": 1, "method": 1, "modifi": 1, "multiprogram": 1, "number": 1, "occur": 1, "overcom": 1, "paper": 1, "paralysi": 1, "preassign": 1, "primarili": 1, "prioriti": 2, "program": 1, "refin": 1, "schedul": 3, "simultan": 1, "system": 1, "time": 1, "tori": 1, "steven": 1}}, "1714": {"id": "1714", "title": "Procedure for the Normal Distribution (Algorithm 272 [S15])", "authors": "MacLaren, M. D.", "words_pool": ["algorithm", "distribut", "normal", "procedur", "s15", "maclaren"], "word_count": {"algorithm": 1, "distribut": 1, "normal": 1, "procedur": 1, "s15": 1, "maclaren": 1}}, "1715": {"id": "1715", "title": "Direct Search (Algorithm 178 [E4])", "authors": "De Vogelaere, R.", "words_pool": ["algorithm", "direct", "e4", "search", "de", "vogelaer"], "word_count": {"algorithm": 1, "direct": 1, "e4": 1, "search": 1, "de": 1, "vogelaer": 1}}, "1716": {"id": "1716", "title": "Normal Random Deviates (Algorithm 334 [G5])", "authors": "Bell, J. R.", "words_pool": ["algorithm", "deviat", "g5", "normal", "random", "bell"], "word_count": {"algorithm": 1, "deviat": 1, "g5": 1, "normal": 1, "random": 1, "bell": 1}}, "1717": {"id": "1717", "title": "Generating Prime Implicants Via Ternary Encoding and Decimal Arithmetic", "abstract": "Decimal arithmetic, ternary encoding of cubes, and topological considerations are used in an  algorithm to obtain the extremals and prime implicants of Boolean functions. The algorithm, which has  been programmed in the FORTRAN language, generally requires less memory than other minimization procedures,  and treats DON'T CARE terms in an efficient manner.", "authors": "Dietmeyer, D. L. Duley, J. R.", "words_pool": ["algorithm", "arithmet", "boolean", "care", "consider", "cube", "decim", "don", "effici", "encod", "extrem", "fortran", "function", "gener", "gener", "implic", "languag", "manner", "memori", "minim", "obtain", "prime", "procedur", "program", "requir", "term", "ternari", "topolog", "treat", "dietmey", "duley"], "word_count": {"algorithm": 2, "arithmet": 1, "boolean": 1, "care": 1, "consider": 1, "cube": 1, "decim": 1, "don": 1, "effici": 1, "encod": 1, "extrem": 1, "fortran": 1, "function": 1, "gener": 1, "implic": 1, "languag": 1, "manner": 1, "memori": 1, "minim": 1, "obtain": 1, "prime": 1, "procedur": 1, "program": 1, "requir": 1, "term": 1, "ternari": 1, "topolog": 1, "treat": 1, "dietmey": 1, "duley": 1}}, "1718": {"id": "1718", "title": "\"Logical\" Arithmetic on Computers with Two's Complement Binary Arithmetic", "abstract": "Algorithms are presented for multiplication and division of unsigned integer operands in which  the digits normally reserved for signs participate as significant arithmetic digits with positive weight.", "authors": "Ehrman, J. R.", "words_pool": ["algorithm", "arithmet", "binari", "complement", "comput", "digit", "divis", "integ", "logic", "multipl", "operand", "particip", "posit", "present", "reserv", "signific", "sign", "unsign", "weight", "ehrman"], "word_count": {"algorithm": 1, "arithmet": 1, "binari": 1, "complement": 1, "comput": 1, "digit": 2, "divis": 1, "integ": 1, "logic": 1, "multipl": 1, "operand": 1, "particip": 1, "posit": 1, "present": 1, "reserv": 1, "signific": 1, "sign": 1, "unsign": 1, "weight": 1, "ehrman": 1}}, "1719": {"id": "1719", "title": "A Methodology for Calculating and Optimizing Real-Time System Performance", "abstract": "The continually increasing size, complexity, number of types, and cost of data processing systems  are causing serious re-examination within government and industry of the criteria for and methods of  calculating and optimizing data processing system cost and performance.  Real-time data processing systems  as typified by the automated airline reservation system are discussed in this paper.  Criteria for evaluating  performance are described; a methodology for calculating and optimizing is outlined; and the method is  illustrated by carrying out a portion of the performance calculation and the optimization of a drum-oriented  message switching system.", "authors": "Stimler, S. Brons, K. A.", "words_pool": ["airlin", "autom", "calcul", "calcul", "carri", "caus", "complex", "continu", "cost", "criteria", "data", "discuss", "drum", "evalu", "examin", "govern", "illustr", "increas", "industri", "messag", "method", "methodolog", "method", "number", "optim", "optim", "orient", "outlin", "paper", "perform", "portion", "process", "re", "real", "reserv", "size", "switch", "system", "system", "time", "type", "typifi", "stimler", "bron"], "word_count": {"airlin": 1, "autom": 1, "calcul": 3, "carri": 1, "caus": 1, "complex": 1, "continu": 1, "cost": 2, "criteria": 2, "data": 3, "discuss": 1, "drum": 1, "evalu": 1, "examin": 1, "govern": 1, "illustr": 1, "increas": 1, "industri": 1, "messag": 1, "method": 2, "methodolog": 1, "number": 1, "optim": 3, "orient": 1, "outlin": 1, "paper": 1, "perform": 3, "portion": 1, "process": 3, "re": 1, "real": 1, "reserv": 1, "size": 1, "switch": 1, "system": 5, "time": 1, "type": 1, "typifi": 1, "stimler": 1, "bron": 1}}, "1720": {"id": "1720", "title": "Master's Level Computer Science Curricula", "abstract": "The results of a survey of the course work done by master's degree candidates at 25 US universities  are presented, and some general comments concerning the emphasis of these programs are given.", "authors": "Elliott, R. W.", "words_pool": ["candid", "comment", "comput", "concern", "cours", "curricula", "degre", "emphasi", "gener", "level", "master", "present", "program", "result", "scienc", "survey", "univers", "work", "elliott"], "word_count": {"candid": 1, "comment": 1, "comput": 1, "concern": 1, "cours": 1, "curricula": 1, "degre": 1, "emphasi": 1, "gener": 1, "level": 1, "master": 1, "present": 1, "program": 1, "result": 1, "scienc": 1, "survey": 1, "univers": 1, "work": 1, "elliott": 1}}, "1721": {"id": "1721", "title": "Determination of the Intersection Points of Two Plane Curves by Means of Differential Equations", "abstract": "A new method is proposed to calculate the intersection points of two plane curves.  The theory  of singular points off a system of two differential equations is used in developing the method. The intersection  point to be determined is identified with such a singular point and appropriate modifications are applied  to the system to ensure that the singular point be stable, i.e. all integrals which start in the neighborhood  of the singular point will always approach this point if the integral parameter tends to infinity.  In  addition a method is described for systematically searching for all intersection points in a prescribed  rectangular area.", "authors": "Kuiken, H. K.", "words_pool": ["addit", "appli", "approach", "area", "calcul", "curv", "determin", "determin", "develop", "differenti", "ensur", "equat", "identifi", "infin", "integr", "integr", "intersect", "mean", "method", "modif", "neighborhood", "paramet", "plane", "point", "point", "prescrib", "propos", "rectangular", "search", "singular", "stabl", "start", "system", "systemat", "tend", "theori", "kuiken"], "word_count": {"addit": 1, "appli": 1, "approach": 1, "area": 1, "calcul": 1, "curv": 1, "determin": 1, "develop": 1, "differenti": 1, "ensur": 1, "equat": 1, "identifi": 1, "infin": 1, "integr": 2, "intersect": 3, "mean": 1, "method": 3, "modif": 1, "neighborhood": 1, "paramet": 1, "plane": 1, "point": 8, "prescrib": 1, "propos": 1, "rectangular": 1, "search": 1, "singular": 4, "stabl": 1, "start": 1, "system": 2, "systemat": 1, "tend": 1, "theori": 1, "kuiken": 1}}, "1722": {"id": "1722", "title": "Methods of Convergence Improvement for Some Improper Integrals", "abstract": "In the numerical integration of an improper integral of the first kind, it is customary to  truncate the integral when the change yielded by the last iteration is less than some predetermined constant.  The efficiency of such integration schemes can often be improved by use of recent advances in the theory  of nonlinear transformations; however, for several important integrals, e.g. integrals whose integrands  are rational polynomials, these transformations fail to yield much improvement.  In this paper, several  methods of convergence improvement are developed which greatly improve convergence of some improper integrals,  including the integrals of rational polynomials.", "authors": "McWilliams, G. V. Thompson, R. W.", "words_pool": ["advanc", "chang", "constant", "converg", "customari", "develop", "effici", "fail", "greatli", "import", "improp", "improv", "improv", "improv", "includ", "integr", "integr", "integrand", "integr", "iter", "kind", "method", "nonlinear", "numer", "paper", "polynomi", "predetermin", "ration", "recent", "scheme", "theori", "transform", "truncat", "yield", "yield", "mcwilliam", "thompson"], "word_count": {"advanc": 1, "chang": 1, "constant": 1, "converg": 2, "customari": 1, "develop": 1, "effici": 1, "fail": 1, "greatli": 1, "import": 1, "improp": 2, "improv": 4, "includ": 1, "integr": 8, "integrand": 1, "iter": 1, "kind": 1, "method": 1, "nonlinear": 1, "numer": 1, "paper": 1, "polynomi": 2, "predetermin": 1, "ration": 2, "recent": 1, "scheme": 1, "theori": 1, "transform": 2, "truncat": 1, "yield": 2, "mcwilliam": 1, "thompson": 1}}, "1723": {"id": "1723", "title": "Computer Construction of Project Networks", "abstract": "Project networks are used in PERT and CPM.  An algorithm is given for constructing project  networks directly from the project precedence relations.  The algorithm creates \"dummy\" activities and  topologically orders the arcs and nodes.  The number of nodes created is minimal for the given precedence  relations.  It has been experimentally programmed in FORTRAN II for the IBM 7094.", "authors": "Fisher, A. C. Liebman, J. S. Nemhauser, G. L.", "words_pool": ["activ", "algorithm", "arc", "comput", "construct", "construct", "cpm", "creat", "creat", "directli", "dummi", "experiment", "fortran", "ibm", "ii", "minim", "network", "node", "number", "order", "pert", "preced", "program", "project", "relat", "topolog", "fisher", "liebman", "nemhaus"], "word_count": {"activ": 1, "algorithm": 2, "arc": 1, "comput": 1, "construct": 1, "cpm": 1, "creat": 2, "directli": 1, "dummi": 1, "experiment": 1, "fortran": 1, "ibm": 1, "ii": 1, "minim": 1, "network": 2, "node": 2, "number": 1, "order": 1, "pert": 1, "preced": 2, "program": 1, "project": 3, "relat": 2, "topolog": 1, "fisher": 1, "liebman": 1, "nemhaus": 1}}, "1724": {"id": "1724", "title": "A Generalized Partial Pass Block Sort", "abstract": "The design of a partial pass block sort with arbitrary range of key and number of work files  is described. The design is a generalization of the Partial Pass Column Sort by Ashenhurst and the Amphisbaenic  Sort by Nagler. The power of the sort is tabulated for various sizes of input file and number of work  files. consideration is given to the problem of combining a block sort with internal sorts, and to the  best use of direct access storage devices.", "authors": "Bayes, A.", "words_pool": ["access", "amphisbaen", "arbitrari", "ashenhurst", "block", "column", "combin", "consider", "design", "devic", "direct", "gener", "gener", "input", "intern", "key", "nagler", "number", "partial", "pass", "power", "problem", "rang", "size", "sort", "sort", "storag", "tabul", "work", "bay"], "word_count": {"access": 1, "amphisbaen": 1, "arbitrari": 1, "ashenhurst": 1, "block": 2, "column": 1, "combin": 1, "consider": 1, "design": 2, "devic": 1, "direct": 1, "gener": 1, "input": 1, "intern": 1, "key": 1, "nagler": 1, "number": 2, "partial": 2, "pass": 2, "power": 1, "problem": 1, "rang": 1, "size": 1, "sort": 6, "storag": 1, "tabul": 1, "work": 2, "bay": 1}}, "1725": {"id": "1725", "title": "A Simple Proof of Lewin's Ordered-Retrieval Theorem for Associative Memories", "abstract": "An efficient method of ordered retrieval of binary words from an associative memory, as described by Lewin, is based on the use of special readout circuits which indicate the digit values present in  the individual digit columns of the memory.  Thus the circuits indicate whether the individual digit  columns contain digits of both values, or of only one value, or contain no digits at all (i.e. that the  memory is empty).  The use of these circuits, which in this paper are termed column value indicators,  reduces considerably the number of memory accesses necessary to retrieve in order a number of distinct  words from the memory.  Lewin proves that, for the readout by the described method of m distinct binary  words, 2m - 1 memory accesses are necessary.  (Thus he proves that the number of necessary memory accesses  of his method, unlike those of other methods, is independent of the word length.)  In this paper a very  simple proof of this theorem derived from some elementary aspects of the structure of sets of binary  numbers is presented.", "authors": "Wolinsky, A.", "words_pool": ["2m", "access", "aspect", "associ", "base", "binari", "circuit", "column", "column", "consider", "deriv", "digit", "digit", "distinct", "effici", "elementari", "empti", "independ", "indic", "individu", "length", "lewin", "memori", "memori", "method", "method", "number", "number", "order", "order", "paper", "present", "present", "proof", "prove", "readout", "reduc", "retriev", "retriev", "set", "simpl", "special", "structur", "term", "theorem", "unlik", "valu", "word", "word", "wolinski"], "word_count": {"2m": 1, "access": 3, "aspect": 1, "associ": 1, "base": 1, "binari": 3, "circuit": 3, "column": 3, "consider": 1, "deriv": 1, "digit": 5, "distinct": 2, "effici": 1, "elementari": 1, "empti": 1, "independ": 1, "indic": 1, "individu": 2, "length": 1, "lewin": 2, "memori": 7, "method": 4, "number": 4, "order": 2, "paper": 2, "present": 2, "proof": 1, "prove": 2, "readout": 2, "reduc": 1, "retriev": 2, "set": 1, "simpl": 1, "special": 1, "structur": 1, "term": 1, "theorem": 1, "unlik": 1, "valu": 2, "word": 4, "wolinski": 1}}, "1726": {"id": "1726", "title": "Preliminary Investigation of Techniques for Automated Reading of Unformatted Text", "abstract": "Methods for converting unstructured printed material into computer code are experimentally  investigated.  An operator-controlled mode, depending on human demarcation of the various regions of  the page for guiding the scanner, is implemented by means of a joystick and a CRT display.  This mode,  for which some performance figures are obtained, is thought to be suitable for processing very complicated  material, such as technical journals.  For simpler material, for instance the \"claims\" sections of patents,  and in applications where the utmost accuracy is not necessary, an unsupervised mode is advocated.  Here,  the textual portions of the page are located during a rapid prescan by a rudimentary form of frequency  analysis.  These areas are then rescanned at a higher resolution suitable for character recognition.   Error rates of the order of 0.1 percent are obtained in a simple problem involving photographs of telephone  company meter boards.  Other matters related to the design of a general purpose page reader, such as  the segmentation of printed text, the possibility of time-sharing the scanner, interactive man-machine  operation, and the facsimile reproduction of illustrations, are discussed.", "authors": "Nagy, G.", "words_pool": ["accuraci", "advoc", "analysi", "applic", "area", "autom", "board", "charact", "claim", "code", "compani", "complic", "comput", "control", "convert", "crt", "demarc", "depend", "design", "discuss", "display", "error", "experiment", "facsimil", "figur", "form", "frequenc", "gener", "guid", "higher", "human", "illustr", "implement", "instanc", "interact", "investig", "investig", "involv", "journal", "joystick", "locat", "machin", "man", "materi", "matter", "mean", "meter", "method", "mode", "obtain", "oper", "oper", "order", "page", "patent", "percent", "perform", "photograph", "portion", "possibl", "preliminari", "prescan", "print", "problem", "process", "purpos", "rapid", "rate", "reader", "read", "recognit", "region", "relat", "reproduct", "rescan", "resolut", "rudimentari", "scanner", "section", "segment", "share", "simpl", "simpler", "suitabl", "technic", "techniqu", "telephon", "text", "textual", "thought", "time", "unformat", "unstructur", "unsupervis", "utmost", "nagi"], "word_count": {"accuraci": 1, "advoc": 1, "analysi": 1, "applic": 1, "area": 1, "autom": 1, "board": 1, "charact": 1, "claim": 1, "code": 1, "compani": 1, "complic": 1, "comput": 1, "control": 1, "convert": 1, "crt": 1, "demarc": 1, "depend": 1, "design": 1, "discuss": 1, "display": 1, "error": 1, "experiment": 1, "facsimil": 1, "figur": 1, "form": 1, "frequenc": 1, "gener": 1, "guid": 1, "higher": 1, "human": 1, "illustr": 1, "implement": 1, "instanc": 1, "interact": 1, "investig": 1, "involv": 1, "journal": 1, "joystick": 1, "locat": 1, "machin": 1, "man": 1, "materi": 3, "matter": 1, "mean": 1, "meter": 1, "method": 1, "mode": 3, "obtain": 2, "oper": 2, "order": 1, "page": 3, "patent": 1, "percent": 1, "perform": 1, "photograph": 1, "portion": 1, "possibl": 1, "preliminari": 1, "prescan": 1, "print": 2, "problem": 1, "process": 1, "purpos": 1, "rapid": 1, "rate": 1, "reader": 1, "read": 1, "recognit": 1, "region": 1, "relat": 1, "reproduct": 1, "rescan": 1, "resolut": 1, "rudimentari": 1, "scanner": 2, "section": 1, "segment": 1, "share": 1, "simpl": 1, "simpler": 1, "suitabl": 2, "technic": 1, "techniqu": 1, "telephon": 1, "text": 1, "textual": 1, "thought": 1, "time": 1, "unformat": 1, "unstructur": 1, "unsupervis": 1, "utmost": 1, "nagi": 1}}, "1727": {"id": "1727", "title": "One Way of Estimating Frequencies of Jumps in a Program", "abstract": "For the segmentation of a program it is useful to have a reasonable estimation of the values  of S(ij), where S(ij) is the mean value of the number of jumps from the i-th instruction on to the j-th  instruction in the run time.  In the cases where the S(ij) are estimated directly, the structure of the  whole program must be generally taken into account; therefore it is very difficult for the programmer  and/or the translator to obtain a good estimation of the S(ij).  It is easier to estimate not S(ij) but  the quantities P(ij)=S(ij)*C(i)/SUM[S(ij), j=1,N], where C(i) is an arbitrary positive constant for each  i.  Although the P(ij) are, for each i, proportional to S(ij), the estimation of P(ij) is easier, because  we must estimate only the \"probabilities\" of events where instruction i is executed after instruction  I(i).  This estimation can often be done without considering the structure of the whole program.  In  the first part of the paper, using the theory of the Markov chains, an algorithm for the computation  of the S(ij) from the P(ij) is found, and some ways of obtaining estimates of the P(ij) are given.  In  the second part a variant of this algorithm is derived, avoiding the necessity of computation involving  large matrices.", "authors": "Kral, J.", "words_pool": ["account", "algorithm", "arbitrari", "avoid", "case", "chain", "comput", "consid", "constant", "deriv", "difficult", "directli", "easier", "estim", "estim", "estim", "estim", "estim", "event", "execut", "found", "frequenc", "gener", "good", "ij", "instruct", "involv", "jump", "larg", "markov", "matric", "mean", "necess", "number", "obtain", "obtain", "paper", "part", "posit", "probabl", "program", "programm", "proport", "quantiti", "reason", "run", "segment", "structur", "sum", "th", "theori", "time", "translat", "valu", "variant", "way", "kral"], "word_count": {"account": 1, "algorithm": 2, "arbitrari": 1, "avoid": 1, "case": 1, "chain": 1, "comput": 2, "consid": 1, "constant": 1, "deriv": 1, "difficult": 1, "directli": 1, "easier": 2, "estim": 8, "event": 1, "execut": 1, "found": 1, "frequenc": 1, "gener": 1, "good": 1, "ij": 14, "instruct": 4, "involv": 1, "jump": 1, "larg": 1, "markov": 1, "matric": 1, "mean": 1, "necess": 1, "number": 1, "obtain": 2, "paper": 1, "part": 2, "posit": 1, "probabl": 1, "program": 3, "programm": 1, "proport": 1, "quantiti": 1, "reason": 1, "run": 1, "segment": 1, "structur": 2, "sum": 1, "th": 2, "theori": 1, "time": 1, "translat": 1, "valu": 1, "variant": 1, "way": 1, "kral": 1}}, "1728": {"id": "1728", "title": "Further Experimental Data on the Behavior of Programs in a Paging Environment", "abstract": "Results are summarized from an empirical study directed at the measurement of program operating  behavior in those multiprogramming systems in which programs are organized into fixed length pages.   The data collected from the interpretive execution of a number of paged programs are used to describe  the frequency of page faults, i.e. the frequency of those instants at which an executing program requires  a page of data or instructions not in main (core) memory.  These data are used also for the evaluation  of page replacement algorithms and for assessing the effects on performance of changes in the amount  of storage allocated to executing programs.", "authors": "Coffman, E. G. Varian, L. C.", "words_pool": ["algorithm", "alloc", "amount", "assess", "behavior", "collect", "core", "data", "describ", "direct", "effect", "empir", "environ", "evalu", "execut", "execut", "experiment", "fault", "fix", "frequenc", "instant", "instruct", "interpret", "length", "main", "measur", "memori", "multiprogram", "number", "oper", "organ", "page", "page", "page", "page", "perform", "program", "program", "replac", "requir", "result", "storag", "studi", "summar", "system", "coffman", "varian"], "word_count": {"algorithm": 1, "alloc": 1, "amount": 1, "assess": 1, "behavior": 1, "collect": 1, "core": 1, "data": 3, "describ": 1, "direct": 1, "effect": 1, "empir": 1, "environ": 1, "evalu": 1, "execut": 3, "experiment": 1, "fault": 1, "fix": 1, "frequenc": 2, "instant": 1, "instruct": 1, "interpret": 1, "length": 1, "main": 1, "measur": 1, "memori": 1, "multiprogram": 1, "number": 1, "oper": 1, "organ": 1, "page": 5, "perform": 1, "program": 5, "replac": 1, "requir": 1, "result": 1, "storag": 1, "studi": 1, "summar": 1, "system": 1, "coffman": 1, "varian": 1}}, "1729": {"id": "1729", "title": "Minit Algorithm for Linear Programming (Algorithm 333 [H])", "authors": "Salazar, R. C. Sen, S", "words_pool": ["algorithm", "linear", "minit", "program", "salazar", "sen"], "word_count": {"algorithm": 2, "linear": 1, "minit": 1, "program": 1, "salazar": 1, "sen": 1}}, "1730": {"id": "1730", "title": "Jacobi Polynomials (Algorithm 332 [S22])", "authors": "Witte, B. F. W.", "words_pool": ["algorithm", "jacobi", "polynomi", "s22", "witt"], "word_count": {"algorithm": 1, "jacobi": 1, "polynomi": 1, "s22": 1, "witt": 1}}, "1731": {"id": "1731", "title": "Gaussian Quadrature Formulas (Algorithm 331 [D1])", "authors": "Gautschi, W.", "words_pool": ["algorithm", "d1", "formula", "gaussian", "quadratur", "gautschi"], "word_count": {"algorithm": 1, "d1": 1, "formula": 1, "gaussian": 1, "quadratur": 1, "gautschi": 1}}, "1732": {"id": "1732", "title": "Factorial Analysis of Variance (Algorithm 330 [G1])", "authors": "Oliver,I.", "words_pool": ["algorithm", "analysi", "factori", "g1", "varianc", "oliv"], "word_count": {"algorithm": 1, "analysi": 1, "factori": 1, "g1": 1, "varianc": 1, "oliv": 1}}, "1733": {"id": "1733", "title": "Distribution of Indistinguishable Objects into Distinguishable slots (Algorithm [G6])", "authors": "Fenichel, R. R.", "words_pool": ["algorithm", "distinguish", "distribut", "g6", "indistinguish", "object", "slot", "fenichel"], "word_count": {"algorithm": 1, "distinguish": 1, "distribut": 1, "g6": 1, "indistinguish": 1, "object": 1, "slot": 1, "fenichel": 1}}, "1734": {"id": "1734", "title": "Chebyshev Solution to an Overdetermined Linear System (Algorithm 328 [F4])", "authors": "Bartels, R. H. Goulub, H. G.", "words_pool": ["algorithm", "chebyshev", "f4", "linear", "overdetermin", "solut", "system", "bartel", "goulub"], "word_count": {"algorithm": 1, "chebyshev": 1, "f4": 1, "linear": 1, "overdetermin": 1, "solut": 1, "system": 1, "bartel": 1, "goulub": 1}}, "1735": {"id": "1735", "title": "A Futures Market in Computer time", "abstract": "An auction method is described for allocating computer time that allows the price of computer  time to fluctuate with the demand and the relative priority of users to be controlled so that more important  projects get better access.  This auction is free of the periodic fluctuation in computer use often associated  with monthly time allocation schemes.", "authors": "Sutherland, I. E.", "words_pool": ["access", "alloc", "alloc", "auction", "comput", "control", "demand", "fluctuat", "fluctuat", "free", "futur", "import", "market", "method", "monthli", "period", "price", "prioriti", "project", "rel", "scheme", "time", "user", "sutherland"], "word_count": {"access": 1, "alloc": 2, "auction": 2, "comput": 3, "control": 1, "demand": 1, "fluctuat": 2, "free": 1, "futur": 1, "import": 1, "market": 1, "method": 1, "monthli": 1, "period": 1, "price": 1, "prioriti": 1, "project": 1, "rel": 1, "scheme": 1, "time": 3, "user": 1, "sutherland": 1}}, "1736": {"id": "1736", "title": "Heading Format for Data Transmission (A USAAI Tutorial -- Standards)", "words_pool": ["data", "format", "head", "standard", "transmiss", "tutori", "usaai"], "word_count": {"data": 1, "format": 1, "head": 1, "standard": 1, "transmiss": 1, "tutori": 1, "usaai": 1}}, "1737": {"id": "1737", "title": "A Global Parser for Context-Free Phrase Structure Grammars", "authors": "Unger, S. H.", "words_pool": ["context", "free", "global", "grammar", "parser", "phrase", "structur", "unger"], "word_count": {"context": 1, "free": 1, "global": 1, "grammar": 1, "parser": 1, "phrase": 1, "structur": 1, "unger": 1}}, "1738": {"id": "1738", "title": "Writing an Outline Debugging Program for the Experienced User", "abstract": "Presently available online debugging routines are often unsatisfactory for the experienced  user because they require unnecessarily rigid and complicated typing formats, make it difficult for the  user to correct typing errors, and consume excessive memory with intricate features.  In a debugging  program it is of prime importance that the program be simple, flexible, and highly efficient to use.   Communication between the user and the debugging program can be improved by using certain techniques  applicable to most online debugging programs.  These techniques are presented and are illustrated by  their use in OPAK (octal package), a debugging program coded for the PDP-5/8 and the SDS-930.  The compromise  between economy of utility program core storage and incorporation of elegant debugging features is discussed.", "authors": "Brady, P. T.", "words_pool": ["applic", "code", "commun", "complic", "compromis", "consum", "core", "correct", "debug", "difficult", "discuss", "economi", "effici", "eleg", "error", "excess", "experienc", "featur", "flexibl", "format", "highli", "illustr", "import", "improv", "incorpor", "intric", "make", "memori", "octal", "onlin", "opak", "outlin", "packag", "pdp", "present", "present", "prime", "program", "program", "requir", "rigid", "routin", "sd", "simpl", "storag", "techniqu", "type", "unnecessarili", "unsatisfactori", "user", "util", "write", "bradi"], "word_count": {"applic": 1, "code": 1, "commun": 1, "complic": 1, "compromis": 1, "consum": 1, "core": 1, "correct": 1, "debug": 6, "difficult": 1, "discuss": 1, "economi": 1, "effici": 1, "eleg": 1, "error": 1, "excess": 1, "experienc": 1, "featur": 2, "flexibl": 1, "format": 1, "highli": 1, "illustr": 1, "import": 1, "improv": 1, "incorpor": 1, "intric": 1, "make": 1, "memori": 1, "octal": 1, "onlin": 2, "opak": 1, "outlin": 1, "packag": 1, "pdp": 1, "present": 2, "prime": 1, "program": 6, "requir": 1, "rigid": 1, "routin": 1, "sd": 1, "simpl": 1, "storag": 1, "techniqu": 2, "type": 2, "unnecessarili": 1, "unsatisfactori": 1, "user": 3, "util": 1, "write": 1, "bradi": 1}}, "1739": {"id": "1739", "title": "Regular Expression Search Algorithm", "abstract": "A method for locating specific character strings embedded in character text is described and  an implementation of this method in the form of a compiler is discussed.  The compiler accepts a regular  expression as source language and produces an IBM 7094 program as object language.  The object program  then accepts the text to be searched as input and produces a signal every time an embedded string in  the text matches the given regular expression.  Examples, problems, and solution are also presented.", "authors": "Thompson, K.", "words_pool": ["accept", "algorithm", "charact", "compil", "discuss", "embed", "exampl", "express", "form", "ibm", "implement", "input", "languag", "locat", "match", "method", "object", "present", "problem", "produc", "program", "regular", "search", "search", "signal", "solut", "sourc", "specif", "string", "string", "text", "time", "thompson"], "word_count": {"accept": 2, "algorithm": 1, "charact": 2, "compil": 2, "discuss": 1, "embed": 2, "exampl": 1, "express": 2, "form": 1, "ibm": 1, "implement": 1, "input": 1, "languag": 2, "locat": 1, "match": 1, "method": 2, "object": 2, "present": 1, "problem": 1, "produc": 2, "program": 2, "regular": 2, "search": 1, "signal": 1, "solut": 1, "sourc": 1, "specif": 1, "string": 2, "text": 3, "time": 1, "thompson": 1}}, "1740": {"id": "1740", "title": "An Inexpensive Braille Terminal Device", "abstract": "The active use of time-shared facilities for blind programmers requires a braille terminal  system.  Details are given for the construction of a brailler from a model 33 teletype by modifying the  print head and increasing the resiliency of the platen.  A description of the programming needed to drive  the brailler is presented.", "authors": "Anderson, G. B. Rogers, D. W.", "words_pool": ["activ", "blind", "braill", "brailler", "construct", "descript", "detail", "devic", "drive", "facil", "head", "increas", "inexpens", "model", "modifi", "need", "platen", "present", "print", "programm", "program", "requir", "resili", "share", "system", "teletyp", "termin", "time", "anderson", "roger"], "word_count": {"activ": 1, "blind": 1, "braill": 1, "brailler": 2, "construct": 1, "descript": 1, "detail": 1, "devic": 1, "drive": 1, "facil": 1, "head": 1, "increas": 1, "inexpens": 1, "model": 1, "modifi": 1, "need": 1, "platen": 1, "present": 1, "print": 1, "programm": 1, "program": 1, "requir": 1, "resili": 1, "share": 1, "system": 1, "teletyp": 1, "termin": 1, "time": 1, "anderson": 1, "roger": 1}}, "1741": {"id": "1741", "title": "BRAD: The Brookhaven Raster Display", "abstract": "A multiconsole computer display system has been designed that provides very rich displays at  low unit cost.  Each BRAD (Brookhaven Raster Display) console can plot tens of thousands of points, or  up to 4000 characters at 30 frames per second.  After an initial display system investment of $50,000  each display, with teletype, costs less than $3,000.  The technique employed is that of programmatically  generating a binary image of the desired display in a computer.  The image is written on a rotating drum  memory.  Independent read heads continuously display the picture, which is generated by swept horizontal  lines.  A standard TV monitor serves as the display device.  The technique has two drawbacks.  A computer  must compute any image to be displayed.  Also, the \"pointing\" interaction is more difficult.  This is  because the pointing function gives only the coordinates of the point on the screen.  The inverse of  the map generation process is required to calculate the coordinates of the point on the screen.  The  inverse of the map generation process is required to calculate the coordinates at the selected point  in the input space.", "authors": "Ophir, D. Rankowitz, S. Shepherd, B. J. Spinrad, R. J.", "words_pool": ["binari", "brad", "brookhaven", "calcul", "charact", "comput", "comput", "consol", "continu", "coordin", "cost", "cost", "design", "desir", "devic", "difficult", "display", "display", "display", "drawback", "drum", "employ", "frame", "function", "gener", "gener", "gener", "head", "horizont", "imag", "independ", "initi", "input", "interact", "invers", "invest", "line", "low", "map", "memori", "monitor", "multiconsol", "pictur", "plot", "point", "point", "point", "process", "programmat", "raster", "read", "requir", "rich", "rotat", "screen", "select", "serv", "space", "standard", "swept", "system", "techniqu", "teletyp", "ten", "thousand", "tv", "unit", "written", "ophir", "rankowitz", "shepherd", "spinrad"], "word_count": {"binari": 1, "brad": 1, "brookhaven": 1, "calcul": 2, "charact": 1, "comput": 4, "consol": 1, "continu": 1, "coordin": 3, "cost": 2, "design": 1, "desir": 1, "devic": 1, "difficult": 1, "display": 9, "drawback": 1, "drum": 1, "employ": 1, "frame": 1, "function": 1, "gener": 4, "head": 1, "horizont": 1, "imag": 3, "independ": 1, "initi": 1, "input": 1, "interact": 1, "invers": 2, "invest": 1, "line": 1, "low": 1, "map": 2, "memori": 1, "monitor": 1, "multiconsol": 1, "pictur": 1, "plot": 1, "point": 6, "process": 2, "programmat": 1, "raster": 1, "read": 1, "requir": 2, "rich": 1, "rotat": 1, "screen": 2, "select": 1, "serv": 1, "space": 1, "standard": 1, "swept": 1, "system": 2, "techniqu": 2, "teletyp": 1, "ten": 1, "thousand": 1, "tv": 1, "unit": 1, "written": 1, "ophir": 1, "rankowitz": 1, "shepherd": 1, "spinrad": 1}}, "1742": {"id": "1742", "title": "On the Design of Display Processors", "abstract": "The flexibility and power needed in the data channel for a computer display are considered.   To work efficiently, such a channel must have a sufficient number of instructions that it is best understood  as a small processor rather than a powerful channel.  As it was found that successive improvements to  the display processor design lie on a circular path, by making improvements one can return to the original  simple design plus one new general purpose computer for each trip around.  The degree of physical separation  between display and parent computer is a key factor in display processor design.", "authors": "Myer, T. H.", "words_pool": ["channel", "circular", "comput", "consid", "data", "degre", "design", "display", "effici", "factor", "flexibl", "found", "gener", "improv", "instruct", "key", "lie", "make", "need", "number", "origin", "parent", "path", "physic", "power", "power", "processor", "processor", "purpos", "separ", "simpl", "small", "success", "suffici", "trip", "understood", "work", "myer"], "word_count": {"channel": 3, "circular": 1, "comput": 3, "consid": 1, "data": 1, "degre": 1, "design": 3, "display": 4, "effici": 1, "factor": 1, "flexibl": 1, "found": 1, "gener": 1, "improv": 2, "instruct": 1, "key": 1, "lie": 1, "make": 1, "need": 1, "number": 1, "origin": 1, "parent": 1, "path": 1, "physic": 1, "power": 2, "processor": 3, "purpos": 1, "separ": 1, "simpl": 1, "small": 1, "success": 1, "suffici": 1, "trip": 1, "understood": 1, "work": 1, "myer": 1}}, "1743": {"id": "1743", "title": "Reliable Full-Duplex file Transmission over Half-Duplex Telephone Lines", "abstract": "A field-proven scheme for achieving reliable duplex transmission over a half-duplex communication  line is presented, and to demonstrate the difficulty of the problem, another similar scheme, which is  only slightly unreliable, is also presented.  A flowchart for the reliable scheme and some interesting  examples are given.", "authors": "Lynch, W. C.", "words_pool": ["achiev", "commun", "demonstr", "difficulti", "duplex", "exampl", "field", "flowchart", "full", "half", "interest", "line", "line", "present", "problem", "proven", "reliabl", "scheme", "similar", "slightli", "telephon", "transmiss", "unreli", "lynch"], "word_count": {"achiev": 1, "commun": 1, "demonstr": 1, "difficulti": 1, "duplex": 2, "exampl": 1, "field": 1, "flowchart": 1, "full": 1, "half": 1, "interest": 1, "line": 1, "present": 2, "problem": 1, "proven": 1, "reliabl": 2, "scheme": 3, "similar": 1, "slightli": 1, "telephon": 1, "transmiss": 1, "unreli": 1, "lynch": 1}}, "1744": {"id": "1744", "title": "Stable Numerical Methods for Obtaining the Chebyshev Solution to an Overdetermined System of  Equations", "abstract": "An implementation of Stiefel's exchange algorithm for determining a Chebyshev solution to an  overdetermined system of linear equations is presented, that uses Gaussian LU decomposition with row  interchanges.  The implementation is computationally more stable than those usually given in the literature.   A generalization of Stiefel's algorithm is developed which permits the occasional exchange of two equations  simultaneously.", "authors": "Bartels, R. H. Golub, G. H.", "words_pool": ["algorithm", "chebyshev", "comput", "decomposit", "determin", "develop", "equat", "exchang", "gaussian", "gener", "implement", "interchang", "linear", "literatur", "lu", "method", "numer", "obtain", "occasion", "overdetermin", "permit", "present", "row", "simultan", "solut", "stabl", "stiefel", "system", "bartel", "golub"], "word_count": {"algorithm": 2, "chebyshev": 1, "comput": 1, "decomposit": 1, "determin": 1, "develop": 1, "equat": 2, "exchang": 2, "gaussian": 1, "gener": 1, "implement": 2, "interchang": 1, "linear": 1, "literatur": 1, "lu": 1, "method": 1, "numer": 1, "obtain": 1, "occasion": 1, "overdetermin": 1, "permit": 1, "present": 1, "row": 1, "simultan": 1, "solut": 1, "stabl": 1, "stiefel": 2, "system": 1, "bartel": 1, "golub": 1}}, "1745": {"id": "1745", "title": "A Position Paper on Computing and Communications", "abstract": "The effective operation of free enterprise in creating the envisioned information service industry  is dependent upon three accomplishments: (1) the restructuring of our information processing industry  so that a clear division of costs is made among computing, communications, and the development of information  services; (2) the wide use of multiaccess system concepts so that information services may share in the  use of computer installations and so that the cost of their construction is reasonable; and (3) the development  of public, message-switched communications services so that adequate provisions are made for information  security.", "authors": "Dennis, J. B.", "words_pool": ["accomplish", "adequ", "clear", "commun", "comput", "comput", "concept", "construct", "cost", "cost", "creat", "depend", "develop", "divis", "effect", "enterpris", "envis", "free", "industri", "inform", "instal", "made", "messag", "multiaccess", "oper", "paper", "posit", "process", "provis", "public", "reason", "restructur", "secur", "servic", "servic", "share", "switch", "system", "wide", "denni"], "word_count": {"accomplish": 1, "adequ": 1, "clear": 1, "commun": 2, "comput": 2, "concept": 1, "construct": 1, "cost": 2, "creat": 1, "depend": 1, "develop": 2, "divis": 1, "effect": 1, "enterpris": 1, "envis": 1, "free": 1, "industri": 2, "inform": 5, "instal": 1, "made": 2, "messag": 1, "multiaccess": 1, "oper": 1, "paper": 1, "posit": 1, "process": 1, "provis": 1, "public": 1, "reason": 1, "restructur": 1, "secur": 1, "servic": 4, "share": 1, "switch": 1, "system": 1, "wide": 1, "denni": 1}}, "1746": {"id": "1746", "title": "Protection in an Information Processing Utility", "abstract": "One of the critical problems in the design of an information processing utility that permits  flexible sharing of user information is privacy.  One solution for this problem is discussed.", "authors": "Graham, R.M.", "words_pool": ["critic", "design", "discuss", "flexibl", "inform", "permit", "privaci", "problem", "problem", "process", "protect", "share", "solut", "user", "util", "graham"], "word_count": {"critic": 1, "design": 1, "discuss": 1, "flexibl": 1, "inform": 2, "permit": 1, "privaci": 1, "problem": 2, "process": 1, "protect": 1, "share": 1, "solut": 1, "user": 1, "util": 1, "graham": 1}}, "1747": {"id": "1747", "title": "Three Criteria for Designing Computing Systems to Facilitate Debugging", "abstract": "The designer of a computing system should adopt explicit criteria for accepting or rejecting  proposed system features.  Three possible criteria of this kind are input recordability, input specifiability,  and asynchronous reproducibility of output.  These criteria imply that a user can, if he desires, either  know or control all the influences affecting the content and extent of his computer's output.  To define  the scope of the criteria, the notion of an abstract machine of a programming language and the notion  of a virtual computer are explained.  Examples of applications of the criteria concern the reading of  a time-of-day clock,  the synchronization of parallel processes, protection in multiprogrammed systems,  and the assignment of capability indexes.", "authors": "Van Horn, E. C.", "words_pool": ["abstract", "accept", "adopt", "affect", "applic", "assign", "asynchron", "capabl", "clock", "comput", "comput", "concern", "content", "control", "criteria", "day", "debug", "defin", "design", "design", "desir", "exampl", "explain", "explicit", "extent", "facilit", "featur", "impli", "index", "influenc", "input", "kind", "know", "languag", "machin", "multiprogram", "notion", "output", "parallel", "process", "program", "propos", "protect", "read", "record", "reject", "reproduc", "scope", "specifi", "synchron", "system", "system", "time", "user", "virtual", "van", "horn"], "word_count": {"abstract": 1, "accept": 1, "adopt": 1, "affect": 1, "applic": 1, "assign": 1, "asynchron": 1, "capabl": 1, "clock": 1, "comput": 3, "concern": 1, "content": 1, "control": 1, "criteria": 5, "day": 1, "debug": 1, "defin": 1, "design": 1, "desir": 1, "exampl": 1, "explain": 1, "explicit": 1, "extent": 1, "facilit": 1, "featur": 1, "impli": 1, "index": 1, "influenc": 1, "input": 2, "kind": 1, "know": 1, "languag": 1, "machin": 1, "multiprogram": 1, "notion": 2, "output": 2, "parallel": 1, "process": 1, "program": 1, "propos": 1, "protect": 1, "read": 1, "record": 1, "reject": 1, "reproduc": 1, "scope": 1, "specifi": 1, "synchron": 1, "system": 3, "time": 1, "user": 1, "virtual": 1, "van": 1, "horn": 1}}, "1748": {"id": "1748", "title": "A Scheduling Philosophy for Multiprocessing Systems", "abstract": "A collection of basic ideas is presented, which have been evolved by various workers over the  past four years to provide a suitable framework for the design and analysis of multiprocessing systems.   The notions of process and state vector are discussed, and the nature of basic operations on processes  is considered.  Some of the connections between processes and protection are analyzed.  A very general  approach to priority-oriented scheduling is described, and its relationship to conventional interrupt  systems is explained.  Some aspects of time-oriented scheduling are considered. The implementation of  the scheduling mechanism is analyzed in detail and the feasibility of embodying it in hardware established.   Finally, several methods for interlocking the execution of independent processes are presented and compared.", "authors": "Lampson, B. W.", "words_pool": ["analysi", "analyz", "approach", "aspect", "basic", "collect", "compar", "connect", "consid", "convent", "design", "detail", "discuss", "embodi", "establish", "evolv", "execut", "explain", "feasibl", "final", "framework", "gener", "hardwar", "idea", "implement", "independ", "interlock", "interrupt", "mechan", "method", "multiprocess", "natur", "notion", "oper", "orient", "past", "philosophi", "present", "prioriti", "process", "process", "protect", "provid", "relationship", "schedul", "state", "suitabl", "system", "time", "vector", "worker", "year", "lampson"], "word_count": {"analysi": 1, "analyz": 2, "approach": 1, "aspect": 1, "basic": 2, "collect": 1, "compar": 1, "connect": 1, "consid": 2, "convent": 1, "design": 1, "detail": 1, "discuss": 1, "embodi": 1, "establish": 1, "evolv": 1, "execut": 1, "explain": 1, "feasibl": 1, "final": 1, "framework": 1, "gener": 1, "hardwar": 1, "idea": 1, "implement": 1, "independ": 1, "interlock": 1, "interrupt": 1, "mechan": 1, "method": 1, "multiprocess": 1, "natur": 1, "notion": 1, "oper": 1, "orient": 2, "past": 1, "philosophi": 1, "present": 2, "prioriti": 1, "process": 4, "protect": 1, "provid": 1, "relationship": 1, "schedul": 3, "state": 1, "suitabl": 1, "system": 2, "time": 1, "vector": 1, "worker": 1, "year": 1, "lampson": 1}}, "1749": {"id": "1749", "title": "The Structure of the \"THE\"-Multiprogramming System", "abstract": "A multiprogramming system is described in which all activities are divided over a number of  sequential processes.  These sequential processes are placed at various hierarchical levels, in each  of which one or more independent abstractions have been implemented.  The hierarchical structure proved  to be vital for the verification of the logical soundness of the design and the correctness of its implementation.", "authors": "Dijkstra, E. W.", "words_pool": ["abstract", "activ", "correct", "design", "divid", "hierarch", "implement", "implement", "independ", "level", "logic", "multiprogram", "number", "process", "prove", "sequenti", "sound", "structur", "system", "verif", "vital", "dijkstra"], "word_count": {"abstract": 1, "activ": 1, "correct": 1, "design": 1, "divid": 1, "hierarch": 2, "implement": 2, "independ": 1, "level": 1, "logic": 1, "multiprogram": 1, "number": 1, "process": 2, "prove": 1, "sequenti": 2, "sound": 1, "structur": 1, "system": 1, "verif": 1, "vital": 1, "dijkstra": 1}}, "1750": {"id": "1750", "title": "Considerations in the Design of a Multiple Computer System with Extended Core Storage", "abstract": "The use of large quantities of addressable (but not executable) fast random access memory to  heighten the multiprogramming performance of a multicomputer system is discussed.  The general design  of the hardware arrangement and the software components and functions of such a system are based on a  planned configuration of dual CDC 6600's that share one million words of extended core storage.  In the  generalization of such a design, special emphasis is placed on estimating expected gains when compared  with the traditional configuration of separate and independent computers without extended core storage.   An observation is made on the use of conventional, slower speed, random access storage devices in place  of the faster memory.", "authors": "Fuchel, K. Heller, S.", "words_pool": ["access", "address", "arrang", "base", "cdc", "compar", "compon", "comput", "comput", "configur", "consider", "convent", "core", "design", "devic", "discuss", "dual", "emphasi", "estim", "execut", "expect", "extend", "fast", "faster", "function", "gain", "gener", "gener", "hardwar", "heighten", "independ", "larg", "made", "memori", "million", "multicomput", "multipl", "multiprogram", "observ", "perform", "place", "plan", "quantiti", "random", "separ", "share", "slower", "softwar", "special", "speed", "storag", "system", "tradit", "word", "fuchel", "heller"], "word_count": {"access": 2, "address": 1, "arrang": 1, "base": 1, "cdc": 1, "compar": 1, "compon": 1, "comput": 1, "configur": 2, "consider": 1, "convent": 1, "core": 2, "design": 2, "devic": 1, "discuss": 1, "dual": 1, "emphasi": 1, "estim": 1, "execut": 1, "expect": 1, "extend": 2, "fast": 1, "faster": 1, "function": 1, "gain": 1, "gener": 2, "hardwar": 1, "heighten": 1, "independ": 1, "larg": 1, "made": 1, "memori": 2, "million": 1, "multicomput": 1, "multipl": 1, "multiprogram": 1, "observ": 1, "perform": 1, "place": 1, "plan": 1, "quantiti": 1, "random": 2, "separ": 1, "share": 1, "slower": 1, "softwar": 1, "special": 1, "speed": 1, "storag": 3, "system": 2, "tradit": 1, "word": 1, "fuchel": 1, "heller": 1}}, "1751": {"id": "1751", "title": "The Working Set Model for Program Behavior", "abstract": "Probably the most basic reason behind the absence of a general treatment of resource allocation  in modern computer systems is an adequate model for program behavior.  In this paper a new model, the  \"working set model,\" is developed. The working set of pages associated with a process, defined to be  the collection of its most recently used pages, provides knowledge vital to the dynamic management of  paged memories.  \"Process\" and \"working set\" are shown to be manifestations of the same ongoing computational  activity; then \"processor demand\" and \"memory demand\" are defined; and resource allocation is formulated  as the problem of balancing demands against available equipment.", "authors": "Denning, P. J.", "words_pool": ["absenc", "activ", "adequ", "alloc", "balanc", "basic", "behavior", "collect", "comput", "comput", "defin", "demand", "demand", "develop", "dynam", "equip", "formul", "gener", "knowledg", "manag", "manifest", "memori", "memori", "model", "modern", "ongo", "page", "page", "paper", "problem", "process", "processor", "program", "reason", "recent", "resourc", "set", "shown", "system", "treatment", "vital", "work", "den"], "word_count": {"absenc": 1, "activ": 1, "adequ": 1, "alloc": 2, "balanc": 1, "basic": 1, "behavior": 1, "collect": 1, "comput": 2, "defin": 2, "demand": 3, "develop": 1, "dynam": 1, "equip": 1, "formul": 1, "gener": 1, "knowledg": 1, "manag": 1, "manifest": 1, "memori": 2, "model": 3, "modern": 1, "ongo": 1, "page": 3, "paper": 1, "problem": 1, "process": 2, "processor": 1, "program": 1, "reason": 1, "recent": 1, "resourc": 2, "set": 3, "shown": 1, "system": 1, "treatment": 1, "vital": 1, "work": 3, "den": 1}}, "1752": {"id": "1752", "title": "Resource Management for a Medium Scale Time-Sharing Operating system", "abstract": "Task scheduling and resource balancing for a medium size virtual memory paging machine are  discussed in relation to a combined batch processing and time-sharing environment.  A synopsis is given  of the task scheduling and paging algorithms that were implemented, and the results of comparative simulation  are given by tracing the development of the algorithms through six predecessor versions.  Throughout  the discussion particular emphasis is placed on balancing the system performance relative to the characteristics  of all the system resources.  Simulation results relative to alternate hardware characteristics and the  effects of program mix and loading variations are also presented.", "authors": "Oppenheimer, G. Weizer, N.", "words_pool": ["algorithm", "altern", "balanc", "batch", "characterist", "combin", "compar", "develop", "discuss", "discuss", "effect", "emphasi", "environ", "hardwar", "implement", "load", "machin", "manag", "medium", "memori", "mix", "oper", "page", "perform", "predecessor", "present", "process", "program", "relat", "rel", "resourc", "resourc", "result", "scale", "schedul", "share", "simul", "size", "synopsi", "system", "task", "time", "trace", "variat", "version", "virtual", "oppenheim", "weizer"], "word_count": {"algorithm": 2, "altern": 1, "balanc": 2, "batch": 1, "characterist": 2, "combin": 1, "compar": 1, "develop": 1, "discuss": 2, "effect": 1, "emphasi": 1, "environ": 1, "hardwar": 1, "implement": 1, "load": 1, "machin": 1, "manag": 1, "medium": 1, "memori": 1, "mix": 1, "oper": 1, "page": 2, "perform": 1, "predecessor": 1, "present": 1, "process": 1, "program": 1, "relat": 1, "rel": 2, "resourc": 2, "result": 2, "scale": 1, "schedul": 2, "share": 1, "simul": 2, "size": 1, "synopsi": 1, "system": 2, "task": 2, "time": 1, "trace": 1, "variat": 1, "version": 1, "virtual": 1, "oppenheim": 1, "weizer": 1}}, "1753": {"id": "1753", "title": "Virtual Memory, Processes, and Sharing in MULTICS", "abstract": "Some basic concepts involved in the design of the MULTICS operating system are introduced.   MULTICS concepts of processes, address space, and virtual memory are defined and the use of paging and  segmentation is explained.  The means by which users may share procedures and data is discussed and the  mechanism by which symbolic references are dynamically transformed into virtual machine addresses is  described in detail.", "authors": "Daley, R. C. Dennis, J. B.", "words_pool": ["address", "address", "basic", "concept", "data", "defin", "design", "detail", "discuss", "dynam", "explain", "introduc", "involv", "machin", "mean", "mechan", "memori", "multic", "oper", "page", "procedur", "process", "refer", "segment", "share", "share", "space", "symbol", "system", "transform", "user", "virtual", "daley", "denni"], "word_count": {"address": 2, "basic": 1, "concept": 2, "data": 1, "defin": 1, "design": 1, "detail": 1, "discuss": 1, "dynam": 1, "explain": 1, "introduc": 1, "involv": 1, "machin": 1, "mean": 1, "mechan": 1, "memori": 1, "multic": 2, "oper": 1, "page": 1, "procedur": 1, "process": 1, "refer": 1, "segment": 1, "share": 1, "space": 1, "symbol": 1, "system": 1, "transform": 1, "user": 1, "virtual": 2, "daley": 1, "denni": 1}}, "1754": {"id": "1754", "title": "Dynamic Storage Allocation Systems", "abstract": "In many recent computer system designs, hardware facilities have been provided for easing the  problems of storage allocation.  A method of characterizing dynamic storage allocation systems-according  to the functional capabilities provided and the underlying techniques used-is presented.  The basic purpose  of the paper is to provide a useful perspective from which the utility of various hardware facilities  may be assessed.  A brief survey of storage allocation facilities in several representative computer  systems is included as an appendix.", "authors": "Randell, B. Kuehner, C. J.", "words_pool": ["accord", "alloc", "appendix", "assess", "basic", "capabl", "character", "comput", "design", "dynam", "eas", "facil", "function", "hardwar", "includ", "method", "paper", "perspect", "present", "problem", "provid", "provid", "purpos", "recent", "repres", "storag", "survey", "system", "system", "techniqu", "underli", "util", "randel", "kuehner"], "word_count": {"accord": 1, "alloc": 3, "appendix": 1, "assess": 1, "basic": 1, "capabl": 1, "character": 1, "comput": 2, "design": 1, "dynam": 1, "eas": 1, "facil": 3, "function": 1, "hardwar": 2, "includ": 1, "method": 1, "paper": 1, "perspect": 1, "present": 1, "problem": 1, "provid": 3, "purpos": 1, "recent": 1, "repres": 1, "storag": 3, "survey": 1, "system": 3, "techniqu": 1, "underli": 1, "util": 1, "randel": 1, "kuehner": 1}}, "1755": {"id": "1755", "title": "Proceedings of the ACM Symposium on Operating system Principles", "authors": "ACM Special Interest Committee", "words_pool": ["acm", "oper", "principl", "proceed", "symposium", "system", "acm", "special", "interest", "committe"], "word_count": {"acm": 1, "oper": 1, "principl": 1, "proceed": 1, "symposium": 1, "system": 1, "special": 1, "interest": 1, "committe": 1}}, "1756": {"id": "1756", "title": "Hollerith Punched Card Code* (Proposed USA Standard)", "words_pool": ["card", "code", "hollerith", "propos", "punch", "standard", "usa"], "word_count": {"card": 1, "code": 1, "hollerith": 1, "propos": 1, "punch": 1, "standard": 1, "usa": 1}}, "1757": {"id": "1757", "title": "Data Code for Calendar Date for Machine-to-Machine Data Interchange* (Proposed USA Standard)", "words_pool": ["calendar", "code", "data", "date", "interchang", "machin", "propos", "standard", "usa"], "word_count": {"calendar": 1, "code": 1, "data": 2, "date": 1, "interchang": 1, "machin": 2, "propos": 1, "standard": 1, "usa": 1}}, "1758": {"id": "1758", "title": "Symmetric Polynomials, (Algorithm 305 [C1])", "authors": "McKay, S.", "words_pool": ["algorithm", "c1", "polynomi", "symmetr", "mckay"], "word_count": {"algorithm": 1, "c1": 1, "polynomi": 1, "symmetr": 1, "mckay": 1}}, "1759": {"id": "1759", "title": "Transportation Problem (Algorithm 293 [H])", "authors": "Bayer, G.", "words_pool": ["algorithm", "problem", "transport", "bayer"], "word_count": {"algorithm": 1, "problem": 1, "transport": 1, "bayer": 1}}, "1760": {"id": "1760", "title": "Normal Curve Integral (Algorithm 304 [S15])", "authors": "Bergson, A.", "words_pool": ["algorithm", "curv", "integr", "normal", "s15", "bergson"], "word_count": {"algorithm": 1, "curv": 1, "integr": 1, "normal": 1, "s15": 1, "bergson": 1}}, "1761": {"id": "1761", "title": "Chi-Squared Integral (Algorithm 299 [S15])", "authors": "O'Brien, W. M. Wood, J.", "words_pool": ["algorithm", "chi", "integr", "s15", "squar", "brien", "wood"], "word_count": {"algorithm": 1, "chi": 1, "integr": 1, "s15": 1, "squar": 1, "brien": 1, "wood": 1}}, "1762": {"id": "1762", "title": "Dilogarithm (Algorithm 327 [S22])", "authors": "Kolbig, K. S.", "words_pool": ["algorithm", "dilogarithm", "s22", "kolbig"], "word_count": {"algorithm": 1, "dilogarithm": 1, "s22": 1, "kolbig": 1}}, "1763": {"id": "1763", "title": "Roots of Low-Order Polynomial Equations (Algorithm 326 [C2])", "authors": "Nonweiler, T. F.", "words_pool": ["algorithm", "c2", "equat", "low", "order", "polynomi", "root", "nonweil"], "word_count": {"algorithm": 1, "c2": 1, "equat": 1, "low": 1, "order": 1, "polynomi": 1, "root": 1, "nonweil": 1}}, "1764": {"id": "1764", "title": "Panel Discussion on Computer Appreciation", "abstract": "Session 19 of the ACM 20 th Anniversary Conference on August 31, 1967, was entitled Education,  Design Experiments, and Computer Appreciation.  Its second half consisted of a panel discussion on computer  appreciation, organized and chaired by Elliot I. Organick.  The four panelists were Charles H. Davidson,  Bernard A. Galler, Richard, W. Hamming, and Alan J. Perlis.  After making prepared statements, the panelists  were joined in discussion by Andries van Dam and Arthur B", "authors": "Organick, E. I.", "words_pool": ["acm", "alan", "andri", "anniversari", "appreci", "arthur", "august", "bernard", "chair", "charl", "comput", "confer", "consist", "dam", "davidson", "design", "discuss", "educ", "elliot", "entitl", "experi", "galler", "half", "ham", "join", "make", "organick", "organ", "panel", "panelist", "perli", "prepar", "richard", "session", "statement", "th", "van", "organick"], "word_count": {"acm": 1, "alan": 1, "andri": 1, "anniversari": 1, "appreci": 2, "arthur": 1, "august": 1, "bernard": 1, "chair": 1, "charl": 1, "comput": 2, "confer": 1, "consist": 1, "dam": 1, "davidson": 1, "design": 1, "discuss": 2, "educ": 1, "elliot": 1, "entitl": 1, "experi": 1, "galler": 1, "half": 1, "ham": 1, "join": 1, "make": 1, "organick": 1, "organ": 1, "panel": 1, "panelist": 2, "perli": 1, "prepar": 1, "richard": 1, "session": 1, "statement": 1, "th": 1, "van": 1}}, "1765": {"id": "1765", "title": "Expenditures, Sources of Funds, and Utilization of Digital Computers for Research and Instruction  in Higher Education: 1964-65 with Projections for 1968-69", "abstract": "The Southern Regional Education Board published a complete report on a survey it conducted  to determine the funding and characterize the utilization of computers used for research and instruction  in institutions of higher education in the United States. The sampling survey is described and the estimates  for this total population are presented.", "authors": "Hamblen, J. W.", "words_pool": ["board", "character", "complet", "comput", "conduct", "determin", "digit", "educ", "estim", "expenditur", "fund", "fund", "higher", "institut", "instruct", "popul", "present", "project", "publish", "region", "report", "research", "sampl", "sourc", "southern", "state", "survey", "total", "unit", "util", "hamblen"], "word_count": {"board": 1, "character": 1, "complet": 1, "comput": 1, "conduct": 1, "determin": 1, "digit": 1, "educ": 2, "estim": 1, "expenditur": 1, "fund": 1, "higher": 1, "institut": 1, "instruct": 1, "popul": 1, "present": 1, "project": 1, "publish": 1, "region": 1, "report": 1, "research": 1, "sampl": 1, "sourc": 1, "southern": 1, "state": 1, "survey": 2, "total": 1, "unit": 1, "util": 1, "hamblen": 1}}, "1766": {"id": "1766", "title": "Quasilinearization and the Estimation of Differential Operators from Eigenvalues", "abstract": "Given a linear ordinary differential operator containing several unknown constants and a number  of its eigenvalues, the values of the unknown constants are estimated.  A precise formulation is provided,  and an effective numerical procedure for solution is indicated.   The results of some computational experiments  are given.", "authors": "Bellman, R. E. Kagiwada, H. H. Kalaba, R. E. Vasudenvan, R.", "words_pool": ["comput", "constant", "differenti", "effect", "eigenvalu", "estim", "estim", "experi", "formul", "linear", "number", "numer", "oper", "oper", "ordinari", "precis", "procedur", "provid", "quasilinear", "result", "solut", "unknown", "valu", "bellman", "kagiwada", "kalaba", "vasudenvan"], "word_count": {"comput": 1, "constant": 2, "differenti": 1, "effect": 1, "eigenvalu": 1, "estim": 1, "experi": 1, "formul": 1, "linear": 1, "number": 1, "numer": 1, "oper": 1, "ordinari": 1, "precis": 1, "procedur": 1, "provid": 1, "quasilinear": 1, "result": 1, "solut": 1, "unknown": 2, "valu": 1, "bellman": 1, "kagiwada": 1, "kalaba": 1, "vasudenvan": 1}}, "1767": {"id": "1767", "title": "A General Purpose Graphic Language", "abstract": "Interactive use of computers with graphic terminals will permit many new problems to be solved  using machines.  In order to handle a variety of applications, it is expedient to develop a general purpose  graphic language that is useful on a number of graphic devices.  A system has been designed to produce  such a language quickly and cheaply.  A model graphic language which has been developed with the system  is presented.", "authors": "Kulsrud, H. E.", "words_pool": ["applic", "cheapli", "comput", "design", "develop", "develop", "devic", "expedi", "gener", "graphic", "handl", "interact", "languag", "machin", "model", "number", "order", "permit", "present", "problem", "produc", "purpos", "quickli", "solv", "system", "termin", "varieti", "kulsrud"], "word_count": {"applic": 1, "cheapli": 1, "comput": 1, "design": 1, "develop": 2, "devic": 1, "expedi": 1, "gener": 1, "graphic": 4, "handl": 1, "interact": 1, "languag": 3, "machin": 1, "model": 1, "number": 1, "order": 1, "permit": 1, "present": 1, "problem": 1, "produc": 1, "purpos": 1, "quickli": 1, "solv": 1, "system": 2, "termin": 1, "varieti": 1, "kulsrud": 1}}, "1768": {"id": "1768", "title": "A Global Parser for Context-Free Phrase Structure Grammars", "abstract": "An algorithm for analyzing any context-free phrase structure grammar and for generating a program  which can then parse any sentence in the language (or indicate that the given sentence is invalid) is  described. The parser is of the \"top-to-bottom\" type and is recursive . A number of heuristic procedures  whose purpose is to shorten the basic algorithm by quickly ascertaining that certain substrings of the  input sentence cannot correspond to the target nonterminal symbols are included.  Both the generating  algorithm and the parser have been implemented in RCA SNOBOL and have been tested successfully on a number  of artificial grammars and on a subset of ALGOL.  A number of the routines for extracting data about  a grammar, such as minimum lengths of N-derivable strings and possible prefixes, are given and may be  of interest apart from their application in this particular context.", "authors": "Unger, S. H.", "words_pool": ["algol", "algorithm", "analyz", "applic", "artifici", "ascertain", "basic", "bottom", "context", "correspond", "data", "deriv", "extract", "free", "gener", "global", "grammar", "grammar", "heurist", "implement", "includ", "input", "interest", "invalid", "languag", "length", "minimum", "nontermin", "number", "pars", "parser", "phrase", "prefix", "procedur", "program", "purpos", "quickli", "rca", "recurs", "routin", "sentenc", "shorten", "snobol", "string", "structur", "subset", "substr", "success", "symbol", "target", "test", "top", "type", "unger"], "word_count": {"algol": 1, "algorithm": 3, "analyz": 1, "applic": 1, "artifici": 1, "ascertain": 1, "basic": 1, "bottom": 1, "context": 2, "correspond": 1, "data": 1, "deriv": 1, "extract": 1, "free": 1, "gener": 2, "global": 1, "grammar": 3, "heurist": 1, "implement": 1, "includ": 1, "input": 1, "interest": 1, "invalid": 1, "languag": 1, "length": 1, "minimum": 1, "nontermin": 1, "number": 3, "pars": 1, "parser": 2, "phrase": 1, "prefix": 1, "procedur": 1, "program": 1, "purpos": 1, "quickli": 1, "rca": 1, "recurs": 1, "routin": 1, "sentenc": 3, "shorten": 1, "snobol": 1, "string": 1, "structur": 1, "subset": 1, "substr": 1, "success": 1, "symbol": 1, "target": 1, "test": 1, "top": 1, "type": 1, "unger": 1}}, "1769": {"id": "1769", "title": "The Expanding World of Computers", "abstract": "The onward sweep of automatic processing of information is impeded by nine principal barriers:  geography, cost, problem complexity, man-machine communication, inadequate sensors, lack of understanding,  distance, time, and size.  The main incentive for breaching these barriers is the universal need for  processing information, ever more urgent as the greater part of human work activity changes from production  to service.  Computer developments in hardware, programming, time-sharing, education, data communication,  and displays are judged by how effectively they remove these barriers, and their barrier-smashing potentialities  indicate continued rapid expansion.  Problem-oriented languages are particularly effective over the entire  front.  Online computers and time-sharing also rate high by this measure.  Education and increased understanding  are basic to all progress with the computer.  This complex but powerful tool is the most important one  available to governments and scientists to use in studying the problems being created by the population  explosion, and in analyzing possible solutions.", "authors": "Harder, E. L.", "words_pool": ["activ", "analyz", "automat", "barrier", "barrier", "basic", "breach", "commun", "complex", "complex", "comput", "comput", "continu", "cost", "creat", "data", "develop", "display", "distanc", "educ", "effect", "effect", "entir", "expand", "expans", "explos", "front", "geographi", "govern", "greater", "hardwar", "high", "human", "imped", "import", "inadequ", "incent", "increas", "inform", "judg", "lack", "languag", "machin", "main", "man", "measur", "need", "onlin", "onward", "orient", "part", "popul", "potenti", "power", "princip", "problem", "problem", "process", "product", "program", "progress", "rapid", "rate", "remov", "scientist", "sensor", "servic", "share", "size", "smash", "solut", "studi", "sweep", "time", "tool", "understand", "univers", "urgent", "work", "world", "harder"], "word_count": {"activ": 1, "analyz": 1, "automat": 1, "barrier": 4, "basic": 1, "breach": 1, "commun": 2, "complex": 2, "comput": 3, "continu": 1, "cost": 1, "creat": 1, "data": 1, "develop": 1, "display": 1, "distanc": 1, "educ": 2, "effect": 2, "entir": 1, "expand": 1, "expans": 1, "explos": 1, "front": 1, "geographi": 1, "govern": 1, "greater": 1, "hardwar": 1, "high": 1, "human": 1, "imped": 1, "import": 1, "inadequ": 1, "incent": 1, "increas": 1, "inform": 2, "judg": 1, "lack": 1, "languag": 1, "machin": 1, "main": 1, "man": 1, "measur": 1, "need": 1, "onlin": 1, "onward": 1, "orient": 1, "part": 1, "popul": 1, "potenti": 1, "power": 1, "princip": 1, "problem": 3, "process": 2, "product": 1, "program": 1, "progress": 1, "rapid": 1, "rate": 1, "remov": 1, "scientist": 1, "sensor": 1, "servic": 1, "share": 2, "size": 1, "smash": 1, "solut": 1, "studi": 1, "sweep": 1, "time": 3, "tool": 1, "understand": 2, "univers": 1, "urgent": 1, "work": 1, "world": 1, "harder": 1}}, "1770": {"id": "1770", "title": "Rules of Ethics in Information Processing", "abstract": "The background and motivation for the adoption by the ACM Council on November 11, 1966, of  a set of Guidelines for Professional Conduct in Information Processing are described.  A brief his tory  is given of ethical codes in other professions.  Some reasons for and against adoption of ethical rules  are considered, and several sections of the ACM Guidelines are analyzed.  The purpose is to inform about  this important aspect of our profession, as well as to stimulate thought and interest.", "authors": "Parker, D. B.", "words_pool": ["acm", "adopt", "analyz", "aspect", "background", "code", "conduct", "consid", "council", "ethic", "ethic", "guidelin", "import", "inform", "inform", "interest", "motiv", "novemb", "process", "profess", "profession", "profess", "purpos", "reason", "rule", "section", "set", "stimul", "thought", "tori", "parker"], "word_count": {"acm": 2, "adopt": 2, "analyz": 1, "aspect": 1, "background": 1, "code": 1, "conduct": 1, "consid": 1, "council": 1, "ethic": 2, "guidelin": 2, "import": 1, "inform": 2, "interest": 1, "motiv": 1, "novemb": 1, "process": 1, "profess": 2, "profession": 1, "purpos": 1, "reason": 1, "rule": 1, "section": 1, "set": 1, "stimul": 1, "thought": 1, "tori": 1, "parker": 1}}, "1771": {"id": "1771", "title": "CURRICULUM 68 -- Recommendations for Academic Programs in Computer Science -- A Report of the  ACM Curriculum Committee on Computer science", "abstract": "This report contains recommendations on academic programs in computer science which were developed  by the ACM Curriculum Committee on Computer Science.  A classification of the subject areas contained  in computer science is presented and twenty-two courses in these areas are described.  Prerequisites,  catalog descriptions, detailed outlines, and annotated bibliographies for these courses are included.   Specific recommendations which have evolved from the Committee's 1965 Preliminary Recommendations are  given for undergraduate programs.  Graduate programs in computer science are discussed and some recommendations  are presented for the development of master's degree programs.  Ways of developing guidelines for doctoral  programs are discussed, but no specific recommendations are made. The importance of service courses,  minors, and continuing education in computer science is emphasized.  Attention is given to the organization,  staff requirements, computer resources, and other facilities needed to implement computer science educational  programs.", "words_pool": ["academ", "acm", "annot", "area", "attent", "bibliographi", "catalog", "classif", "committe", "comput", "contain", "continu", "cours", "curriculum", "degre", "descript", "detail", "develop", "develop", "develop", "discuss", "doctor", "educ", "educ", "emphas", "evolv", "facil", "graduat", "guidelin", "implement", "import", "includ", "made", "master", "minor", "need", "organ", "outlin", "preliminari", "prerequisit", "present", "program", "recommend", "report", "requir", "resourc", "scienc", "servic", "specif", "staff", "subject", "twenti", "undergradu", "way"], "word_count": {"academ": 1, "acm": 1, "annot": 1, "area": 2, "attent": 1, "bibliographi": 1, "catalog": 1, "classif": 1, "committe": 2, "comput": 7, "contain": 1, "continu": 1, "cours": 3, "curriculum": 1, "degre": 1, "descript": 1, "detail": 1, "develop": 3, "discuss": 2, "doctor": 1, "educ": 2, "emphas": 1, "evolv": 1, "facil": 1, "graduat": 1, "guidelin": 1, "implement": 1, "import": 1, "includ": 1, "made": 1, "master": 1, "minor": 1, "need": 1, "organ": 1, "outlin": 1, "preliminari": 1, "prerequisit": 1, "present": 2, "program": 6, "recommend": 5, "report": 1, "requir": 1, "resourc": 1, "scienc": 6, "servic": 1, "specif": 2, "staff": 1, "subject": 1, "twenti": 1, "undergradu": 1, "way": 1}}, "1772": {"id": "1772", "title": "USASCSOCR Dual Case Keyboard Arrangement* (Proposed USA Standard)", "words_pool": ["arrang", "case", "dual", "keyboard", "propos", "standard", "usa", "usascsocr"], "word_count": {"arrang": 1, "case": 1, "dual": 1, "keyboard": 1, "propos": 1, "standard": 1, "usa": 1, "usascsocr": 1}}, "1773": {"id": "1773", "title": "General Purpose Alphanumeric Keyboard Arrangement for Information Interchange* (Proposed USA  Standard)", "words_pool": ["alphanumer", "arrang", "gener", "inform", "interchang", "keyboard", "propos", "purpos", "standard", "usa"], "word_count": {"alphanumer": 1, "arrang": 1, "gener": 1, "inform": 1, "interchang": 1, "keyboard": 1, "propos": 1, "purpos": 1, "standard": 1, "usa": 1}}, "1774": {"id": "1774", "title": "Program Overlay Techniques", "abstract": "The general features of program overlay systems are described.  Three main types -- automatic,  semiautomatic and nonautomatic -- are classified, and the programming techniques are explained as a function  of machine hardware and other system features.  The implementation of semiautomatic overlay facility  in a multiprogrammed system on the CDC 6600 is described in detail, with special reference to real time  applications.", "authors": "Pankhurst, R. J.", "words_pool": ["applic", "automat", "cdc", "classifi", "detail", "explain", "facil", "featur", "function", "gener", "hardwar", "implement", "machin", "main", "multiprogram", "nonautomat", "overlay", "program", "program", "real", "refer", "semiautomat", "special", "system", "system", "techniqu", "time", "type", "pankhurst"], "word_count": {"applic": 1, "automat": 1, "cdc": 1, "classifi": 1, "detail": 1, "explain": 1, "facil": 1, "featur": 2, "function": 1, "gener": 1, "hardwar": 1, "implement": 1, "machin": 1, "main": 1, "multiprogram": 1, "nonautomat": 1, "overlay": 2, "program": 2, "real": 1, "refer": 1, "semiautomat": 2, "special": 1, "system": 3, "techniqu": 1, "time": 1, "type": 1, "pankhurst": 1}}, "1775": {"id": "1775", "title": "Adjustment of the Inverse of a Symmetric Matrix when Two Symmetric Elements are Changed (Algorithm  325 [F1])", "authors": "Zielke, G.", "words_pool": ["adjust", "algorithm", "chang", "element", "f1", "invers", "matrix", "symmetr", "zielk"], "word_count": {"adjust": 1, "algorithm": 1, "chang": 1, "element": 1, "f1": 1, "invers": 1, "matrix": 1, "symmetr": 2, "zielk": 1}}, "1776": {"id": "1776", "title": "Maxflow (Algorithm 324 [H])", "authors": "Bayer, G.", "words_pool": ["algorithm", "maxflow", "bayer"], "word_count": {"algorithm": 1, "maxflow": 1, "bayer": 1}}, "1777": {"id": "1777", "title": "Generation of Permutations in Lexicographic Order (Algorithm 323 [G6])", "authors": "Ord-Smith, R. J.", "words_pool": ["algorithm", "g6", "gener", "lexicograph", "order", "permut", "ord", "smith"], "word_count": {"algorithm": 1, "g6": 1, "gener": 1, "lexicograph": 1, "order": 1, "permut": 1, "ord": 1, "smith": 1}}, "1778": {"id": "1778", "title": "F-Distribution (Algorithm 322 [S14])", "authors": "Dorrer, E.", "words_pool": ["algorithm", "distribut", "s14", "dorrer"], "word_count": {"algorithm": 1, "distribut": 1, "s14": 1, "dorrer": 1}}, "1779": {"id": "1779", "title": "t-Test Probabilities (Algorithm [S14])", "authors": "Morris, J.", "words_pool": ["algorithm", "probabl", "s14", "test", "morri"], "word_count": {"algorithm": 1, "probabl": 1, "s14": 1, "test": 1, "morri": 1}}, "1780": {"id": "1780", "title": "Harmonic Analysis for Symmetrically Distributed Data (Algorithm 320 [C6])", "authors": "Hunter, D. B.", "words_pool": ["algorithm", "analysi", "c6", "data", "distribut", "harmon", "symmetr", "hunter"], "word_count": {"algorithm": 1, "analysi": 1, "c6": 1, "data": 1, "distribut": 1, "harmon": 1, "symmetr": 1, "hunter": 1}}, "1781": {"id": "1781", "title": "Translator Writing systems", "abstract": "A critical review of recent efforts to automate the writing of translators of programming languages  is presented.  The formal study of syntax and its application to translator writing are discussed in  Section II.  Various approaches to automating the post syntactic (semantic) aspects of translator writing  are discussed in Section III, and several related topics in Section IV.", "authors": "Feldman, J. Gries, D.", "words_pool": ["applic", "approach", "aspect", "autom", "autom", "critic", "discuss", "effort", "formal", "ii", "iii", "iv", "languag", "post", "present", "program", "recent", "relat", "review", "section", "semant", "studi", "syntact", "syntax", "system", "topic", "translat", "translat", "write", "feldman", "gri"], "word_count": {"applic": 1, "approach": 1, "aspect": 1, "autom": 2, "critic": 1, "discuss": 2, "effort": 1, "formal": 1, "ii": 1, "iii": 1, "iv": 1, "languag": 1, "post": 1, "present": 1, "program": 1, "recent": 1, "relat": 1, "review": 1, "section": 3, "semant": 1, "studi": 1, "syntact": 1, "syntax": 1, "system": 1, "topic": 1, "translat": 3, "write": 3, "feldman": 1, "gri": 1}}, "1782": {"id": "1782", "title": "A Numerical Integration Formula Useful in Fourier Analysis", "abstract": "A numerical integration formula is presented which uses unequal sampling intervals.  The intervals  are equally spaced on a log scale.  Such a formulation is useful in Fourier analysis to improve accuracy  and ease of usage.  A complete set of formulas for numerical Fourier analysis is given.", "authors": "Meisel, W. S.", "words_pool": ["accuraci", "analysi", "complet", "eas", "equal", "formula", "formula", "formul", "fourier", "improv", "integr", "interv", "log", "numer", "present", "sampl", "scale", "set", "space", "unequ", "usag", "meisel"], "word_count": {"accuraci": 1, "analysi": 2, "complet": 1, "eas": 1, "equal": 1, "formula": 2, "formul": 1, "fourier": 2, "improv": 1, "integr": 1, "interv": 2, "log": 1, "numer": 2, "present": 1, "sampl": 1, "scale": 1, "set": 1, "space": 1, "unequ": 1, "usag": 1, "meisel": 1}}, "1783": {"id": "1783", "title": "In-and-Out Conversions", "abstract": "Byan in-and-out conversion we mean that a floating-point number in one base is converted into  a floating-point number in another base and then converted back to a floating-point number in the original  base.  For all combinations of rounding and truncation conversions the question is considered of how  many significant digits are needed in the intermediate base to allow such in-and-out conversions to return  the original number (when possible), or at least significant digit.", "authors": "Matula, D. W.", "words_pool": ["allow", "back", "base", "byan", "combin", "consid", "convers", "convers", "convert", "digit", "digit", "float", "intermedi", "mean", "need", "number", "origin", "point", "question", "round", "signific", "truncat", "matula"], "word_count": {"allow": 1, "back": 1, "base": 4, "byan": 1, "combin": 1, "consid": 1, "convers": 3, "convert": 2, "digit": 2, "float": 3, "intermedi": 1, "mean": 1, "need": 1, "number": 4, "origin": 2, "point": 3, "question": 1, "round": 1, "signific": 2, "truncat": 1, "matula": 1}}, "1784": {"id": "1784", "title": "Practical Error Coefficients for Estimating Quadrature Errors for Analytic Functions", "abstract": "All published error coefficients for estimating quadrature errors for analytic functions were  computed on the assumption that the quadrature rule was exact for polynomials up to a given degree.   Since these rules use rounded values for the abscissas and weights and since the true values of the integrals  of some of the polynomials in question have an infinite binary expression, the quadrature rule is not  exact.  Hence these errors must be taken into consideration in computing practical error coefficients.", "authors": "Rabinowitz, P.", "words_pool": ["abscissa", "analyt", "assumpt", "binari", "coeffici", "comput", "comput", "consider", "degre", "error", "error", "estim", "exact", "express", "function", "infinit", "integr", "polynomi", "practic", "publish", "quadratur", "question", "round", "rule", "rule", "true", "valu", "weight", "rabinowitz"], "word_count": {"abscissa": 1, "analyt": 1, "assumpt": 1, "binari": 1, "coeffici": 2, "comput": 2, "consider": 1, "degre": 1, "error": 4, "estim": 1, "exact": 2, "express": 1, "function": 1, "infinit": 1, "integr": 1, "polynomi": 2, "practic": 1, "publish": 1, "quadratur": 3, "question": 1, "round": 1, "rule": 3, "true": 1, "valu": 2, "weight": 1, "rabinowitz": 1}}, "1785": {"id": "1785", "title": "Scatter Storage Techniques", "abstract": "Scatter storage techniques as a method for implementing the symbol tables of assemblers and  compilers are reviewed and a number of ways of using them more effectively are presented.  Many of the  most useful variants of the techniques are documented.", "authors": "Morris, R.", "words_pool": ["assembl", "compil", "document", "effect", "implement", "method", "number", "present", "review", "scatter", "storag", "symbol", "tabl", "techniqu", "variant", "way", "morri"], "word_count": {"assembl": 1, "compil": 1, "document": 1, "effect": 1, "implement": 1, "method": 1, "number": 1, "present": 1, "review": 1, "scatter": 1, "storag": 1, "symbol": 1, "tabl": 1, "techniqu": 2, "variant": 1, "way": 1, "morri": 1}}, "1786": {"id": "1786", "title": "An Improved Hash Code for Scatter Storage", "abstract": "Introduced is a hash coding method based on fixed-point division rather than multiplication  or logical operations.  This new method allows the hash table to have almost any length.  Also a new  method of handling collisions is discussed.  Known as quadratic search, this method is faster than random  search and free from the \"clusters\" that build up with a linear search.", "authors": "Maurer, W. D.", "words_pool": ["base", "build", "cluster", "code", "code", "collis", "discuss", "divis", "faster", "fix", "free", "handl", "hash", "improv", "introduc", "known", "length", "linear", "logic", "method", "multipl", "oper", "point", "quadrat", "random", "scatter", "search", "storag", "tabl", "maurer"], "word_count": {"base": 1, "build": 1, "cluster": 1, "code": 1, "collis": 1, "discuss": 1, "divis": 1, "faster": 1, "fix": 1, "free": 1, "handl": 1, "hash": 2, "improv": 1, "introduc": 1, "known": 1, "length": 1, "linear": 1, "logic": 1, "method": 4, "multipl": 1, "oper": 1, "point": 1, "quadrat": 1, "random": 1, "scatter": 1, "search": 3, "storag": 1, "tabl": 1, "maurer": 1}}, "1787": {"id": "1787", "title": "Use of Transition Matrices in Compiling", "abstract": "An algorithms is described which constructs from a suitable BNF grammar an efficient left-right  recognizer for sentences of the corresponding language.  The type of recognizer, used in a number of  compilers, operates with a pushdown stack and with a transition matrix.  Two examples illustrate how  such recognizers may be used effectively for other purposes besides the usual syntax checking.", "authors": "Gries, D.", "words_pool": ["algorithm", "bnf", "check", "compil", "compil", "construct", "effect", "effici", "exampl", "grammar", "illustr", "languag", "left", "matric", "matrix", "number", "oper", "purpos", "pushdown", "recogn", "recogn", "sentenc", "stack", "suitabl", "syntax", "transit", "type", "usual", "gri"], "word_count": {"algorithm": 1, "bnf": 1, "check": 1, "compil": 1, "construct": 1, "effect": 1, "effici": 1, "exampl": 1, "grammar": 1, "illustr": 1, "languag": 1, "left": 1, "matric": 1, "matrix": 1, "number": 1, "oper": 1, "purpos": 1, "pushdown": 1, "recogn": 3, "sentenc": 1, "stack": 1, "suitabl": 1, "syntax": 1, "transit": 1, "type": 1, "usual": 1, "gri": 1}}, "1788": {"id": "1788", "title": "Toward a General Processor for Programming Languages", "abstract": "Many efforts have been made to develop a better way of implementing a higher level programming  language than by the construction of a whole new compiler, but so far none has proved generally satisfactory.   In this paper, it is contended that a programming language is best described functionally as a body  of macro instructions, and that the macro call constitutes a canonical form in terms of which a programming  notation may be described.  A supporting discussion of the logical and his torical role of the macro instruction  is presented.  Also discussed are the conflict between machine independence and object program efficiency,  and the question of where the greatest difficulties lie in compiler construction.", "authors": "Halpern, M. J.", "words_pool": ["bodi", "call", "canon", "compil", "conflict", "constitut", "construct", "contend", "develop", "difficulti", "discuss", "discuss", "effici", "effort", "form", "function", "gener", "gener", "greatest", "higher", "implement", "independ", "instruct", "instruct", "languag", "languag", "level", "lie", "logic", "machin", "macro", "made", "notat", "object", "paper", "present", "processor", "program", "program", "prove", "question", "role", "satisfactori", "support", "term", "toric", "halpern"], "word_count": {"bodi": 1, "call": 1, "canon": 1, "compil": 2, "conflict": 1, "constitut": 1, "construct": 2, "contend": 1, "develop": 1, "difficulti": 1, "discuss": 2, "effici": 1, "effort": 1, "form": 1, "function": 1, "gener": 1, "greatest": 1, "higher": 1, "implement": 1, "independ": 1, "instruct": 2, "languag": 2, "level": 1, "lie": 1, "logic": 1, "machin": 1, "macro": 3, "made": 1, "notat": 1, "object": 1, "paper": 1, "present": 1, "processor": 1, "program": 4, "prove": 1, "question": 1, "role": 1, "satisfactori": 1, "support": 1, "term": 1, "toric": 1, "halpern": 1}}, "1789": {"id": "1789", "title": "Logarithm of Gamma Function (Algorithm 291 [S14])", "authors": "Hoare, M. R.", "words_pool": ["algorithm", "function", "gamma", "logarithm", "s14", "hoar"], "word_count": {"algorithm": 1, "function": 1, "gamma": 1, "logarithm": 1, "s14": 1, "hoar": 1}}, "1790": {"id": "1790", "title": "Muller's Method for Finding roots of an Arbitrary Function  (Algorithm 196 [C5])", "authors": "Whitley, V. W.", "words_pool": ["algorithm", "arbitrari", "c5", "find", "function", "method", "muller", "root", "whitley"], "word_count": {"algorithm": 1, "arbitrari": 1, "c5": 1, "find": 1, "function": 1, "method": 1, "muller": 1, "root": 1, "whitley": 1}}, "1791": {"id": "1791", "title": "Triangular Factors of Modified Matrices (Algorithm 319 [F1])", "authors": "Green, D. R.", "words_pool": ["algorithm", "f1", "factor", "matric", "modifi", "triangular", "green"], "word_count": {"algorithm": 1, "f1": 1, "factor": 1, "matric": 1, "modifi": 1, "triangular": 1, "green": 1}}, "1792": {"id": "1792", "title": "Exploratory Experimental Studies Comparing Online and Off line Programming Performance", "abstract": "Two exploratory experiments were conducted at System Development Corporation to compare debugging  performance of programmers working under conditions of on-line and off line access to a computer.  These  are the first known studies that measure programmers' performance under controlled conditions for standard  tasks.  Statistically significant results of both experiments indicated faster debugging under online  conditions, but perhaps the most important practical finding involves the striking individual differences  in programmer performance.  Methodological problems encountered in designing and conducting these experiments  are described; limitations of the findings are pointed out; hypotheses are presented to account for results;  and suggestions are made for further research.", "authors": "Sackman, H. Erikson, W. J. Grant, E. E.", "words_pool": ["access", "account", "compar", "compar", "comput", "condit", "conduct", "conduct", "control", "corpor", "debug", "design", "develop", "differ", "encount", "experiment", "experi", "exploratori", "faster", "find", "find", "hypothes", "import", "individu", "involv", "known", "limit", "line", "made", "measur", "methodolog", "onlin", "perform", "point", "practic", "present", "problem", "programm", "programm", "program", "research", "result", "signific", "standard", "statist", "strike", "studi", "suggest", "system", "task", "work", "sackman", "erikson", "grant"], "word_count": {"access": 1, "account": 1, "compar": 1, "comput": 1, "condit": 3, "conduct": 2, "control": 1, "corpor": 1, "debug": 2, "design": 1, "develop": 1, "differ": 1, "encount": 1, "experiment": 1, "experi": 3, "exploratori": 1, "faster": 1, "find": 2, "hypothes": 1, "import": 1, "individu": 1, "involv": 1, "known": 1, "limit": 1, "line": 2, "made": 1, "measur": 1, "methodolog": 1, "onlin": 1, "perform": 3, "point": 1, "practic": 1, "present": 1, "problem": 1, "programm": 3, "program": 1, "research": 1, "result": 2, "signific": 1, "standard": 1, "statist": 1, "strike": 1, "studi": 1, "suggest": 1, "system": 1, "task": 1, "work": 1, "sackman": 1, "erikson": 1, "grant": 1}}, "1793": {"id": "1793", "title": "Presentation of Alphameric Characters for Information Processing* (Proposed American National  Standard)", "words_pool": ["alphamer", "american", "charact", "inform", "nation", "present", "process", "propos", "standard"], "word_count": {"alphamer": 1, "american": 1, "charact": 1, "inform": 1, "nation": 1, "present": 1, "process": 1, "propos": 1, "standard": 1}}, "1794": {"id": "1794", "title": "A Fast Random Number Generator for IBM 360", "authors": "Seraphin, D. S.", "words_pool": ["fast", "gener", "ibm", "number", "random", "seraphin"], "word_count": {"fast": 1, "gener": 1, "ibm": 1, "number": 1, "random": 1, "seraphin": 1}}, "1795": {"id": "1795", "title": "Optimal Code for Serial and Parallel Computation", "authors": "Fateman, R. J.", "words_pool": ["code", "comput", "optim", "parallel", "serial", "fateman"], "word_count": {"code": 1, "comput": 1, "optim": 1, "parallel": 1, "serial": 1, "fateman": 1}}, "1796": {"id": "1796", "title": "Index by Subject to Algorithms, 1969", "words_pool": ["algorithm", "index", "subject"], "word_count": {"algorithm": 1, "index": 1, "subject": 1}}, "1797": {"id": "1797", "title": "Solution of Linear programs in 0-1 (Algorithm 341 [H])", "authors": "Proll, L. G.", "words_pool": ["algorithm", "linear", "program", "solut", "proll"], "word_count": {"algorithm": 1, "linear": 1, "program": 1, "solut": 1, "proll": 1}}, "1798": {"id": "1798", "title": "Coulomb Wave Functions (Algorithm 300 [S22])", "authors": "Kolbig, K. S.", "words_pool": ["algorithm", "coulomb", "function", "s22", "wave", "kolbig"], "word_count": {"algorithm": 1, "coulomb": 1, "function": 1, "s22": 1, "wave": 1, "kolbig": 1}}, "1799": {"id": "1799", "title": "Elementary Functions by Continued Fractions (Algorithm 229 [B1])", "authors": "Bray, T. A.", "words_pool": ["algorithm", "b1", "continu", "elementari", "fraction", "function", "bray"], "word_count": {"algorithm": 1, "b1": 1, "continu": 1, "elementari": 1, "fraction": 1, "function": 1, "bray": 1}}, "1800": {"id": "1800", "title": "PSIF (Algorithm 147 [S14])", "authors": "Parsons, R. G.", "words_pool": ["algorithm", "psif", "s14", "parson"], "word_count": {"algorithm": 1, "psif": 1, "s14": 1, "parson": 1}}, "1801": {"id": "1801", "title": "Analysis of Variance for Balanced Experiments (Algorithm 367 [G2])", "authors": "Claringbold, P. J.", "words_pool": ["algorithm", "analysi", "balanc", "experi", "g2", "varianc", "claringbold"], "word_count": {"algorithm": 1, "analysi": 1, "balanc": 1, "experi": 1, "g2": 1, "varianc": 1, "claringbold": 1}}, "1802": {"id": "1802", "title": "Regression Using Certain Direct Product Matrices (Algorithm 366 [G2])", "authors": "Claringbold, P. J.", "words_pool": ["algorithm", "direct", "g2", "matric", "product", "regress", "claringbold"], "word_count": {"algorithm": 1, "direct": 1, "g2": 1, "matric": 1, "product": 1, "regress": 1, "claringbold": 1}}, "1803": {"id": "1803", "title": "Complex Root Finding (Algorithm 365 [C5])", "authors": "Bach, H.", "words_pool": ["algorithm", "c5", "complex", "find", "root", "bach"], "word_count": {"algorithm": 1, "c5": 1, "complex": 1, "find": 1, "root": 1, "bach": 1}}, "1804": {"id": "1804", "title": "Coloring Polygonal Regions (Algorithm 364 [Z])", "authors": "Herriot, R. G.", "words_pool": ["algorithm", "color", "polygon", "region", "herriot"], "word_count": {"algorithm": 1, "color": 1, "polygon": 1, "region": 1, "herriot": 1}}, "1805": {"id": "1805", "title": "Productivity of Multiprogrammed Computers-Progress in Developing an Analytic Prediction Method", "abstract": "Multiprogramming as it is discussed here is a mode of computer operation in which two or more programs are concurrently in processor memory and proceeding, each using the same central processor unit  (CPU) and input-output (I/O) channels.  These programs are actually proceeding intermittently and singly,  according to eligibility (readiness to proceed) and priority.  It is useful to be able to represent them  as proceeding continuously and simultaneously, each at an effective rate, which may be a fraction of  that which it would enjoy in the absence of the other programs.  The effective progress rate of each  program is sensitive to many detailed characteristics of itself and its co-residents and simulation has  been the best available method of predicting it.  This paper presents the results of progress in developing  an alternative to simulation, a simulation-tested iterative computation of these rates under certain  situations.  The algorithm is sensitive to most of the factors that control the phenomenon, including  nonquantitative or topological features of the programs' structures.", "authors": "Lasser, D. J.", "words_pool": ["abl", "absenc", "accord", "actual", "algorithm", "altern", "analyt", "central", "channel", "characterist", "comput", "comput", "comput", "concurr", "continu", "control", "cpu", "detail", "develop", "discuss", "effect", "elig", "enjoy", "factor", "featur", "fraction", "includ", "input", "intermitt", "iter", "memori", "method", "mode", "multiprogram", "multiprogram", "nonquantit", "oper", "output", "paper", "phenomenon", "predict", "predict", "present", "prioriti", "proceed", "proceed", "processor", "product", "program", "program", "progress", "rate", "rate", "readi", "repres", "resid", "result", "sensit", "simul", "simultan", "singli", "situat", "structur", "test", "topolog", "unit", "lasser"], "word_count": {"abl": 1, "absenc": 1, "accord": 1, "actual": 1, "algorithm": 1, "altern": 1, "analyt": 1, "central": 1, "channel": 1, "characterist": 1, "comput": 2, "concurr": 1, "continu": 1, "control": 1, "cpu": 1, "detail": 1, "develop": 1, "discuss": 1, "effect": 2, "elig": 1, "enjoy": 1, "factor": 1, "featur": 1, "fraction": 1, "includ": 1, "input": 1, "intermitt": 1, "iter": 1, "memori": 1, "method": 1, "mode": 1, "multiprogram": 1, "nonquantit": 1, "oper": 1, "output": 1, "paper": 1, "phenomenon": 1, "predict": 1, "present": 1, "prioriti": 1, "proceed": 4, "processor": 2, "product": 1, "program": 5, "progress": 2, "rate": 3, "readi": 1, "repres": 1, "resid": 1, "result": 1, "sensit": 2, "simul": 3, "simultan": 1, "singli": 1, "situat": 1, "structur": 1, "test": 1, "topolog": 1, "unit": 1, "lasser": 1}}, "1806": {"id": "1806", "title": "On the Downhill Method", "abstract": "The downhill method is a numerical method for solving complex equations f(z) = 0 on which the  only restriction is that the function w = f(z) must be analytical.  An introduction to this method is  given and a critical review of relating literature is presented.  Although in theory the method always  converges, it is shown that a fundamental dilemma exists which may cause a breakdown in practical applications.   To avoid this difficulty and to improve the rate of convergence toward a root, some modifications of  the original method are proposed and a program (FORTRAN) based on the modified method is given in Algorithm  365.  Some numerical examples are included.", "authors": "Bach, H.", "words_pool": ["algorithm", "analyt", "applic", "avoid", "base", "breakdown", "complex", "converg", "converg", "critic", "difficulti", "dilemma", "downhil", "equat", "exampl", "exist", "fortran", "function", "fundament", "improv", "includ", "introduct", "literatur", "method", "modif", "modifi", "numer", "origin", "practic", "present", "program", "propos", "rate", "relat", "restrict", "review", "root", "shown", "solv", "theori", "bach"], "word_count": {"algorithm": 1, "analyt": 1, "applic": 1, "avoid": 1, "base": 1, "breakdown": 1, "complex": 1, "converg": 2, "critic": 1, "difficulti": 1, "dilemma": 1, "downhil": 1, "equat": 1, "exampl": 1, "exist": 1, "fortran": 1, "function": 1, "fundament": 1, "improv": 1, "includ": 1, "introduct": 1, "literatur": 1, "method": 6, "modif": 1, "modifi": 1, "numer": 2, "origin": 1, "practic": 1, "present": 1, "program": 1, "propos": 1, "rate": 1, "relat": 1, "restrict": 1, "review": 1, "root": 1, "shown": 1, "solv": 1, "theori": 1, "bach": 1}}, "1807": {"id": "1807", "title": "Optimization of Expressions in Fortran", "abstract": "A method of optimizing the computation of arithmetic and indexing expressions of a Fortran  program is presented.  The method is based on a linear analysis of the definition points of the variables  and the branching and DO loop structure of the program.  The objectives of the processing are (1) to  eliminate redundant calculations when references are made to common subexpression values, (2) to remove  invariant calculations from DO loops, (3) to efficiently compute subscripts containing DO iteration variables,  and (4) to provide efficient index register usage.  The method presented requires at least a three-pass  compiler, the second of which is scanned backward.  It has been used in the development of several FORTRAN  compilers that have proved to produce excellent object code without significantly reducing the compilation  speed.", "authors": "Busam, V. A. England, D. E.", "words_pool": ["analysi", "arithmet", "backward", "base", "branch", "calcul", "code", "common", "compil", "compil", "compil", "comput", "comput", "definit", "develop", "effici", "effici", "elimin", "excel", "express", "fortran", "index", "index", "invari", "iter", "linear", "loop", "loop", "made", "method", "object", "object", "optim", "optim", "pass", "point", "present", "process", "produc", "program", "prove", "provid", "reduc", "redund", "refer", "regist", "remov", "requir", "scan", "significantli", "speed", "structur", "subexpress", "subscript", "usag", "valu", "variabl", "busam", "england"], "word_count": {"analysi": 1, "arithmet": 1, "backward": 1, "base": 1, "branch": 1, "calcul": 2, "code": 1, "common": 1, "compil": 3, "comput": 2, "definit": 1, "develop": 1, "effici": 2, "elimin": 1, "excel": 1, "express": 1, "fortran": 2, "index": 2, "invari": 1, "iter": 1, "linear": 1, "loop": 2, "made": 1, "method": 3, "object": 2, "optim": 1, "pass": 1, "point": 1, "present": 2, "process": 1, "produc": 1, "program": 2, "prove": 1, "provid": 1, "reduc": 1, "redund": 1, "refer": 1, "regist": 1, "remov": 1, "requir": 1, "scan": 1, "significantli": 1, "speed": 1, "structur": 1, "subexpress": 1, "subscript": 1, "usag": 1, "valu": 1, "variabl": 2, "busam": 1, "england": 1}}, "1808": {"id": "1808", "title": "Advanced Cryptographic Techniques for Computers", "abstract": "Cryptographic techniques which can be used to maintain the confidentiality of information processed  by computers are dealt with.  Special emphasis is paid to the unique characteristics of computer files  that make many cryptographic methods of little use.  Relative security, costs, and preferred methods  are included in this paper.", "authors": "Van Tassel, D.", "words_pool": ["advanc", "characterist", "comput", "comput", "confidenti", "cost", "cryptograph", "dealt", "emphasi", "includ", "inform", "maintain", "make", "method", "paid", "paper", "prefer", "process", "rel", "secur", "special", "techniqu", "uniqu", "van", "tassel"], "word_count": {"advanc": 1, "characterist": 1, "comput": 2, "confidenti": 1, "cost": 1, "cryptograph": 2, "dealt": 1, "emphasi": 1, "includ": 1, "inform": 1, "maintain": 1, "make": 1, "method": 2, "paid": 1, "paper": 1, "prefer": 1, "process": 1, "rel": 1, "secur": 1, "special": 1, "techniqu": 1, "uniqu": 1, "van": 1, "tassel": 1}}, "1809": {"id": "1809", "title": "Numerical Analysis in a Ph.D. Computer Science Program", "abstract": "Numerical Analysis is the study of methods and procedures used to obtain \"approximate solutions\"  to mathematical problems.  Much of the emphasis is on scientific calculation.  The difficulties of education  in such a broad area center around the question of background and emphasis.  The Numerical Analysis program  in the Computer Science Department should emphasize an awareness of the problems of computer implementation  and experimental procedures.  Nevertheless, there is a need for a solid background in applied mathematics.", "authors": "Parter, S. V.", "words_pool": ["analysi", "appli", "approxim", "area", "awar", "background", "broad", "calcul", "center", "comput", "depart", "difficulti", "educ", "emphasi", "emphas", "experiment", "implement", "mathemat", "mathemat", "method", "need", "numer", "obtain", "ph", "problem", "procedur", "program", "question", "scienc", "scientif", "solid", "solut", "studi", "parter"], "word_count": {"analysi": 2, "appli": 1, "approxim": 1, "area": 1, "awar": 1, "background": 2, "broad": 1, "calcul": 1, "center": 1, "comput": 2, "depart": 1, "difficulti": 1, "educ": 1, "emphasi": 2, "emphas": 1, "experiment": 1, "implement": 1, "mathemat": 2, "method": 1, "need": 1, "numer": 2, "obtain": 1, "ph": 1, "problem": 2, "procedur": 2, "program": 1, "question": 1, "scienc": 1, "scientif": 1, "solid": 1, "solut": 1, "studi": 1, "parter": 1}}, "1810": {"id": "1810", "title": "Is Automatic \"Folding\" of Programs Efficient Enough To Displace Manual?", "abstract": "The operation of \"folding\" a program into the available memory is discussed.  Measurements  by Brown et al. and by Nelson on an automatic folding mechanism of simple design, a demand paging unit  built at the IBM Research Center by Belady, Nelson, O'Neil, and others, permitting its quality to be  compared with that of manual folding, are discussed, and it is shown that given some care in use the  unit performs satisfactorily under the conditions tested, even though it is operating across a memory-to-storage  interface with a very large speed difference.  The disadvantages of prefolding, which is required when  the folding is manual, are examined, and a number of the important troubles which beset computing today  are shown to arise from, or be aggravated by, this source.  It is concluded that a folding mechanism  will probably become a normal part of most computing systems.", "authors": "Sayre, D.", "words_pool": ["aggrav", "al", "aris", "automat", "beladi", "beset", "brown", "built", "care", "center", "compar", "comput", "conclud", "condit", "demand", "design", "differ", "disadvantag", "discuss", "displac", "effici", "examin", "fold", "ibm", "import", "interfac", "larg", "measur", "mechan", "memori", "neil", "nelson", "normal", "number", "oper", "oper", "page", "part", "perform", "permit", "prefold", "program", "program", "qualiti", "requir", "research", "satisfactorili", "shown", "simpl", "sourc", "speed", "storag", "system", "test", "today", "troubl", "unit", "sayr"], "word_count": {"aggrav": 1, "al": 1, "aris": 1, "automat": 1, "beladi": 1, "beset": 1, "brown": 1, "built": 1, "care": 1, "center": 1, "compar": 1, "comput": 2, "conclud": 1, "condit": 1, "demand": 1, "design": 1, "differ": 1, "disadvantag": 1, "discuss": 2, "displac": 1, "effici": 1, "examin": 1, "fold": 5, "ibm": 1, "import": 1, "interfac": 1, "larg": 1, "measur": 1, "mechan": 2, "memori": 2, "neil": 1, "nelson": 2, "normal": 1, "number": 1, "oper": 2, "page": 1, "part": 1, "perform": 1, "permit": 1, "prefold": 1, "program": 1, "qualiti": 1, "requir": 1, "research": 1, "satisfactorili": 1, "shown": 2, "simpl": 1, "sourc": 1, "speed": 1, "storag": 1, "system": 1, "test": 1, "today": 1, "troubl": 1, "unit": 2, "sayr": 1}}, "1811": {"id": "1811", "title": "A Case Study in Programming for Parallel-Processors", "abstract": "An affirmative partial answer is provided to the question of whether it is possible to program  parallel-processor computing systems to efficiently decrease execution time for useful problems.  Parallel-processor  systems are multiprocessor systems in which several of the processors can simultaneously execute separate  tasks of a single job, thus cooperating to decrease the solution time of a computational problem. The  processors have independent instruction counters, meaning that each processor executes its own task program  relatively independently of the other processors.  Communication between cooperating processors is by  means of data in storage shared by all processors.  A program for the determination of the distribution  of current in an electrical network was written for a parallel-processor computing system, and execution  of this program was simulated.  The data gathered from simulation runs demonstrate the efficient solution  of this problem, typical of a large class of important problems.  It is shown that, with proper programming,  solution time when N processors are applied approaches 1/N times the solution time for a single processor,  while improper programming can actually lead to an increase of solution time with the number of processors.   Stability of the method of solution was also investigated.", "authors": "Rosenfeld, J. L.", "words_pool": ["actual", "affirm", "answer", "appli", "approach", "case", "class", "commun", "comput", "comput", "cooper", "counter", "data", "decreas", "demonstr", "determin", "distribut", "effici", "effici", "electr", "execut", "execut", "execut", "gather", "import", "improp", "increas", "independ", "independ", "instruct", "investig", "job", "larg", "lead", "mean", "mean", "method", "multiprocessor", "network", "number", "parallel", "partial", "problem", "problem", "processor", "processor", "program", "program", "proper", "provid", "question", "run", "separ", "share", "shown", "simul", "simul", "simultan", "singl", "solut", "stabil", "storag", "studi", "system", "system", "task", "task", "time", "time", "typic", "written", "rosenfeld"], "word_count": {"actual": 1, "affirm": 1, "answer": 1, "appli": 1, "approach": 1, "case": 1, "class": 1, "commun": 1, "comput": 3, "cooper": 2, "counter": 1, "data": 2, "decreas": 2, "demonstr": 1, "determin": 1, "distribut": 1, "effici": 2, "electr": 1, "execut": 4, "gather": 1, "import": 1, "improp": 1, "increas": 1, "independ": 2, "instruct": 1, "investig": 1, "job": 1, "larg": 1, "lead": 1, "mean": 2, "method": 1, "multiprocessor": 1, "network": 1, "number": 1, "parallel": 3, "partial": 1, "problem": 4, "processor": 12, "program": 6, "proper": 1, "provid": 1, "question": 1, "run": 1, "separ": 1, "share": 1, "shown": 1, "simul": 2, "simultan": 1, "singl": 2, "solut": 6, "stabil": 1, "storag": 1, "studi": 1, "system": 4, "task": 2, "time": 6, "typic": 1, "written": 1, "rosenfeld": 1}}, "1812": {"id": "1812", "title": "More on Fortran Random Number Generators", "authors": "Grosenbaugh, L. R.", "words_pool": ["fortran", "gener", "number", "random", "grosenbaugh"], "word_count": {"fortran": 1, "gener": 1, "number": 1, "random": 1, "grosenbaugh": 1}}, "1813": {"id": "1813", "title": "Generation of Permutations in Pseudo-Lexicographic Order (Algorithm 308 [G6])", "authors": "Ord-Smith, R. J.", "words_pool": ["algorithm", "g6", "gener", "lexicograph", "order", "permut", "pseudo", "ord", "smith"], "word_count": {"algorithm": 1, "g6": 1, "gener": 1, "lexicograph": 1, "order": 1, "permut": 1, "pseudo": 1, "ord": 1, "smith": 1}}, "1814": {"id": "1814", "title": "Direct Search (Algorithm 178 [E4])", "authors": "Smith, L. B.", "words_pool": ["algorithm", "direct", "e4", "search", "smith"], "word_count": {"algorithm": 1, "direct": 1, "e4": 1, "search": 1, "smith": 1}}, "1815": {"id": "1815", "title": "Direct Search (Algorithm 178 [E4])", "authors": "Tomlin, F. K. Smith, L. B.", "words_pool": ["algorithm", "direct", "e4", "search", "tomlin", "smith"], "word_count": {"algorithm": 1, "direct": 1, "e4": 1, "search": 1, "tomlin": 1, "smith": 1}}, "1816": {"id": "1816", "title": "Generalized Least Squares Fit By Orthogonal Polynomials (Algorithm 296 [E2])", "authors": "Watson, W. T.", "words_pool": ["algorithm", "e2", "fit", "gener", "orthogon", "polynomi", "squar", "watson"], "word_count": {"algorithm": 1, "e2": 1, "fit": 1, "gener": 1, "orthogon": 1, "polynomi": 1, "squar": 1, "watson": 1}}, "1817": {"id": "1817", "title": "Computation of Fourier Coefficients (Algorithm 255 [C6])", "authors": "Hall, G. Ray, V. A.", "words_pool": ["algorithm", "c6", "coeffici", "comput", "fourier", "hall", "ray"], "word_count": {"algorithm": 1, "c6": 1, "coeffici": 1, "comput": 1, "fourier": 1, "hall": 1, "ray": 1}}, "1818": {"id": "1818", "title": "Associated Legendre Functions of the First Kind for Real or Imaginary Arguments (Algorithm 47  [S16])", "authors": "Cobb, S. M.", "words_pool": ["algorithm", "argument", "function", "imaginari", "kind", "legendr", "real", "s16", "cobb"], "word_count": {"algorithm": 1, "argument": 1, "function": 1, "imaginari": 1, "kind": 1, "legendr": 1, "real": 1, "s16": 1, "cobb": 1}}, "1819": {"id": "1819", "title": "Complex Error Function (Algorithm 363 [S15])", "authors": "Gautschi, W.", "words_pool": ["algorithm", "complex", "error", "function", "s15", "gautschi"], "word_count": {"algorithm": 1, "complex": 1, "error": 1, "function": 1, "s15": 1, "gautschi": 1}}, "1820": {"id": "1820", "title": "Generation of Random Permutations (Algorithm 362 [G6])", "authors": "Robson, J. M.", "words_pool": ["algorithm", "g6", "gener", "permut", "random", "robson"], "word_count": {"algorithm": 1, "g6": 1, "gener": 1, "permut": 1, "random": 1, "robson": 1}}, "1821": {"id": "1821", "title": "Permanent Function of a Square Matrix I and II (Algorithm 361 [G6])", "authors": "Shriver, B. Eberlein, P. J. Dixon, R. D.", "words_pool": ["algorithm", "function", "g6", "ii", "matrix", "perman", "squar", "shriver", "eberlein", "dixon"], "word_count": {"algorithm": 1, "function": 1, "g6": 1, "ii": 1, "matrix": 1, "perman": 1, "squar": 1, "shriver": 1, "eberlein": 1, "dixon": 1}}, "1822": {"id": "1822", "title": "Shortest-Path Forest with Topological Ordering (Algorithm [H])", "authors": "Dial, R. B.", "words_pool": ["algorithm", "forest", "order", "path", "shortest", "topolog", "dial"], "word_count": {"algorithm": 1, "forest": 1, "order": 1, "path": 1, "shortest": 1, "topolog": 1, "dial": 1}}, "1823": {"id": "1823", "title": "Factorial Analysis of Variance (Algorithm [G1])", "authors": "Howell, J. R.", "words_pool": ["algorithm", "analysi", "factori", "g1", "varianc", "howel"], "word_count": {"algorithm": 1, "analysi": 1, "factori": 1, "g1": 1, "varianc": 1, "howel": 1}}, "1824": {"id": "1824", "title": "APAREL-A Parse-Request Language", "abstract": "APAREL is described: this language is an extension to an algorithmic language (PL/I) that provides  the pattern-matching capabilities normally found only in special purpose languages such as SNOBOL4 and  TMG.  This capability is provided through parse-requests stated in a BNF-like format.  These parse-requests  form their own programming language with special sequencing rules.  Upon successfully completing a parse-request,  an associated piece of PL/I code is executed.  This code has available for use, as normal PL/I strings  the various pieces (at all levels) of the parse.  It also has available as normal PL/I variables, the information concerning which of the various alternatives were successful.  Convenient facilities for  multiple input-output streams, the initiation of sequences of parse-requests as a subroutine, and parse-time  semantic checks are also included.  APAREL has proven convenient  in building a powerful SYNTAX and FUNCTION  macro system, an algebraic language preprocessor debugging system, an on-line command parser, a translator  for Dataless Programming, and as a general string manipulator.", "authors": "Balzer, R. M. Farber, D. J.", "words_pool": ["algebra", "algorithm", "altern", "aparel", "bnf", "build", "capabl", "capabl", "check", "code", "command", "complet", "concern", "conveni", "dataless", "debug", "execut", "extens", "facil", "form", "format", "found", "function", "gener", "includ", "inform", "initi", "input", "languag", "languag", "level", "line", "macro", "manipul", "match", "multipl", "normal", "output", "pars", "parser", "pattern", "piec", "piec", "pl", "power", "preprocessor", "program", "proven", "provid", "purpos", "request", "request", "rule", "semant", "sequenc", "sequenc", "snobol4", "special", "state", "stream", "string", "string", "subroutin", "success", "success", "syntax", "system", "time", "tmg", "translat", "variabl", "balzer", "farber"], "word_count": {"algebra": 1, "algorithm": 1, "altern": 1, "aparel": 2, "bnf": 1, "build": 1, "capabl": 2, "check": 1, "code": 2, "command": 1, "complet": 1, "concern": 1, "conveni": 2, "dataless": 1, "debug": 1, "execut": 1, "extens": 1, "facil": 1, "form": 1, "format": 1, "found": 1, "function": 1, "gener": 1, "includ": 1, "inform": 1, "initi": 1, "input": 1, "languag": 5, "level": 1, "line": 1, "macro": 1, "manipul": 1, "match": 1, "multipl": 1, "normal": 2, "output": 1, "pars": 6, "parser": 1, "pattern": 1, "piec": 2, "pl": 4, "power": 1, "preprocessor": 1, "program": 2, "proven": 1, "provid": 1, "purpos": 1, "request": 4, "rule": 1, "semant": 1, "sequenc": 2, "snobol4": 1, "special": 2, "state": 1, "stream": 1, "string": 2, "subroutin": 1, "success": 2, "syntax": 1, "system": 2, "time": 1, "tmg": 1, "translat": 1, "variabl": 1, "balzer": 1, "farber": 1}}, "1825": {"id": "1825", "title": "A Practical Method for Constructing LR(k) Processors", "abstract": "A practical method for constructing LR(k) processors is developed.  These processors are capable  of recognizing and parsing an input during a single no-backup scan in a number of steps equal to the  length of the input plus the number of steps in its derivation.  The technique presented here is based  on the original method described by Knuth, but decreases both the effort required to construct the processor  and the size of the processor produced.  This procedure involves partitioning the given grammar into  a number of smaller parts.  If an LR(k) processor can be constructed for each part (using Knuth's algorithm)  and if certain conditions relating these individual processors are satisfied, then an LR(k) processor  for the entire grammar can be constructed for them.  Using this procedure, an LR(1) parser for ALGOL  has been obtained.", "authors": "Korenjak, A. J.", "words_pool": ["algol", "algorithm", "backup", "base", "capabl", "condit", "construct", "construct", "construct", "decreas", "deriv", "develop", "effort", "entir", "equal", "grammar", "individu", "input", "involv", "knuth", "length", "lr", "method", "number", "obtain", "origin", "parser", "pars", "part", "partit", "part", "practic", "present", "procedur", "processor", "processor", "produc", "recogn", "relat", "requir", "satisfi", "scan", "singl", "size", "smaller", "step", "techniqu", "korenjak"], "word_count": {"algol": 1, "algorithm": 1, "backup": 1, "base": 1, "capabl": 1, "condit": 1, "construct": 4, "decreas": 1, "deriv": 1, "develop": 1, "effort": 1, "entir": 1, "equal": 1, "grammar": 2, "individu": 1, "input": 2, "involv": 1, "knuth": 2, "length": 1, "lr": 4, "method": 2, "number": 3, "obtain": 1, "origin": 1, "parser": 1, "pars": 1, "part": 2, "partit": 1, "practic": 1, "present": 1, "procedur": 2, "processor": 7, "produc": 1, "recogn": 1, "relat": 1, "requir": 1, "satisfi": 1, "scan": 1, "singl": 1, "size": 1, "smaller": 1, "step": 2, "techniqu": 1, "korenjak": 1}}, "1826": {"id": "1826", "title": "A LISP Garbage-Collector for Virtual-Memory Computer Systems", "abstract": "In this paper a garbage-collection algorithm for list-processing systems which operate within  very large virtual memories is described.  The object of the algorithm is more the compaction of active  storage than the discovery of free storage.  Because free storage is never really exhausted, the decision  to garbage collect is not easily made; therefore, various criteria of this decision are discussed.", "authors": "Fenichel, R. R. Yochelson, J. C.", "words_pool": ["activ", "algorithm", "collect", "collect", "collector", "compact", "comput", "criteria", "decis", "discoveri", "discuss", "easili", "exhaust", "free", "garbag", "larg", "lisp", "list", "made", "memori", "memori", "object", "oper", "paper", "process", "storag", "system", "virtual", "fenichel", "yochelson"], "word_count": {"activ": 1, "algorithm": 2, "collect": 2, "collector": 1, "compact": 1, "comput": 1, "criteria": 1, "decis": 2, "discoveri": 1, "discuss": 1, "easili": 1, "exhaust": 1, "free": 2, "garbag": 2, "larg": 1, "lisp": 1, "list": 1, "made": 1, "memori": 1, "object": 1, "oper": 1, "paper": 1, "process": 1, "storag": 3, "system": 1, "virtual": 1, "fenichel": 1, "yochelson": 1}}, "1827": {"id": "1827", "title": "Performance Monitoring in a Time-Sharing System", "abstract": "A software measurement facility which is part of a general purpose time-sharing system is described.   The Date Collection Facility (DCF) has been implemented in the Michigan Terminal System (MTS) for the  System/360 model 67.  It exists for the purpose of monitoring operating system and user program behavior  and performance.  The overall structure of MTS is outlined in order to explain the implementation of  the DCF.  Events in the system are identified and recorded from within the supervisor, and dumped to  magnetic tape by an auxiliary program for off-line processing.  Events in user programs which are unrelated  to system actions are recorded with a supervisor call.  The time of occurrence of each event is accurately  recorded, and data items are further identified by job and type.  The overhead associated with data collection  and its interference with normal jobs is carefully analyzed, and both are shown to be minimal.  Several  examples are given of information obtained with the facility and of applications in which it has been  useful.  Some general guidelines are offered for the construction of future monitoring programs.", "authors": "Pinkerton, T. B.", "words_pool": ["accur", "action", "analyz", "applic", "auxiliari", "behavior", "call", "care", "collect", "construct", "data", "date", "dcf", "dump", "event", "event", "exampl", "exist", "explain", "facil", "futur", "gener", "guidelin", "identifi", "implement", "implement", "inform", "interfer", "item", "job", "job", "line", "magnet", "measur", "michigan", "minim", "model", "monitor", "mt", "normal", "obtain", "occurr", "offer", "oper", "order", "outlin", "overhead", "part", "perform", "process", "program", "program", "purpos", "record", "share", "shown", "softwar", "structur", "supervisor", "system", "tape", "termin", "time", "type", "unrel", "user", "pinkerton"], "word_count": {"accur": 1, "action": 1, "analyz": 1, "applic": 1, "auxiliari": 1, "behavior": 1, "call": 1, "care": 1, "collect": 2, "construct": 1, "data": 2, "date": 1, "dcf": 2, "dump": 1, "event": 3, "exampl": 1, "exist": 1, "explain": 1, "facil": 3, "futur": 1, "gener": 2, "guidelin": 1, "identifi": 2, "implement": 2, "inform": 1, "interfer": 1, "item": 1, "job": 2, "line": 1, "magnet": 1, "measur": 1, "michigan": 1, "minim": 1, "model": 1, "monitor": 2, "mt": 2, "normal": 1, "obtain": 1, "occurr": 1, "offer": 1, "oper": 1, "order": 1, "outlin": 1, "overhead": 1, "part": 1, "perform": 1, "process": 1, "program": 4, "purpos": 2, "record": 3, "share": 1, "shown": 1, "softwar": 1, "structur": 1, "supervisor": 2, "system": 6, "tape": 1, "termin": 1, "time": 2, "type": 1, "unrel": 1, "user": 2, "pinkerton": 1}}, "1828": {"id": "1828", "title": "Synchronization in a Parallel-Accessed Data Base", "abstract": "The following problem is considered:  Given a data base which can be manipulated simultaneously  by more than one process, what are the rules for synchronization which will maximize the amount of parallel  activity allowed.  It is assumed that the data base can be represented as a graph.  An example of such  a data base is a hierarchy of directories for an on-line file system.  Methods for synchronization of  processes are examined; their validity is discussed and their performance compared.", "authors": "Shoshani, A. Bernstein, A. J.", "words_pool": ["access", "activ", "allow", "amount", "assum", "base", "compar", "consid", "data", "directori", "discuss", "examin", "graph", "hierarchi", "line", "manipul", "maxim", "method", "parallel", "perform", "problem", "process", "process", "repres", "rule", "simultan", "synchron", "system", "valid", "shoshani", "bernstein"], "word_count": {"access": 1, "activ": 1, "allow": 1, "amount": 1, "assum": 1, "base": 3, "compar": 1, "consid": 1, "data": 3, "directori": 1, "discuss": 1, "examin": 1, "graph": 1, "hierarchi": 1, "line": 1, "manipul": 1, "maxim": 1, "method": 1, "parallel": 1, "perform": 1, "problem": 1, "process": 2, "repres": 1, "rule": 1, "simultan": 1, "synchron": 2, "system": 1, "valid": 1, "shoshani": 1, "bernstein": 1}}, "1829": {"id": "1829", "title": "An Interactive Graphical Display Monitor in a Batch-Processing Environment with Remote Entry", "abstract": "A graphic monitor program is described.  It was developed at Carnegie-Mellon University for  the CDC G21 computer, which is a general purpose, batch-processing system with remote entry.  The existing  G21 system and the graphics hardware are described.  The graphic monitor is a resident auxiliary monitor  which provides comprehensive managerial capability over the graphical system in response to commands  from the human user.  It also will respond to commands from a user program through a similar interface,  where routine calls take the place of manual actions.  Thus the human and program can interact on a symmetrical  and equal basis through the medium of the graphic monitor.  The choice made in designing the graphic  monitor, given the constraints of the existing hardware and computer system, are discussed.  The structure  of the monitor program and the human and program interfaces are described.  There is also a transient  swapping version with a small resident part, and provision for swapped used submonitors.", "authors": "Bond, A. H. Rightnour, J.", "words_pool": ["action", "auxiliari", "basi", "batch", "call", "capabl", "carnegi", "cdc", "choic", "command", "comprehens", "comput", "constraint", "design", "develop", "discuss", "display", "entri", "environ", "equal", "exist", "g21", "gener", "graphic", "graphic", "graphic", "hardwar", "human", "interact", "interact", "interfac", "interfac", "made", "manageri", "medium", "mellon", "monitor", "part", "place", "process", "program", "provis", "purpos", "remot", "resid", "respond", "respons", "routin", "similar", "small", "structur", "submonitor", "swap", "swap", "symmetr", "system", "take", "transient", "univers", "user", "version", "bond", "rightnour"], "word_count": {"action": 1, "auxiliari": 1, "basi": 1, "batch": 1, "call": 1, "capabl": 1, "carnegi": 1, "cdc": 1, "choic": 1, "command": 2, "comprehens": 1, "comput": 2, "constraint": 1, "design": 1, "develop": 1, "discuss": 1, "display": 1, "entri": 1, "environ": 1, "equal": 1, "exist": 2, "g21": 2, "gener": 1, "graphic": 6, "hardwar": 2, "human": 3, "interact": 1, "interfac": 2, "made": 1, "manageri": 1, "medium": 1, "mellon": 1, "monitor": 6, "part": 1, "place": 1, "process": 1, "program": 5, "provis": 1, "purpos": 1, "remot": 1, "resid": 2, "respond": 1, "respons": 1, "routin": 1, "similar": 1, "small": 1, "structur": 1, "submonitor": 1, "swap": 2, "symmetr": 1, "system": 4, "take": 1, "transient": 1, "univers": 1, "user": 2, "version": 1, "bond": 1, "rightnour": 1}}, "1830": {"id": "1830", "title": "Retrieval Times for a Packed Direct Access Inverted File", "authors": "Bayes, A. J.", "words_pool": ["access", "direct", "invert", "pack", "retriev", "time", "bay"], "word_count": {"access": 1, "direct": 1, "invert": 1, "pack": 1, "retriev": 1, "time": 1, "bay": 1}}, "1831": {"id": "1831", "title": "A Comment on Optimal Tree Structures", "authors": "Stanfel, L. E.", "words_pool": ["comment", "optim", "structur", "tree", "stanfel"], "word_count": {"comment": 1, "optim": 1, "structur": 1, "tree": 1, "stanfel": 1}}, "1832": {"id": "1832", "title": "Minimax Logarithmic Error", "authors": "Dunham, C. B.", "words_pool": ["error", "logarithm", "minimax", "dunham"], "word_count": {"error": 1, "logarithm": 1, "minimax": 1, "dunham": 1}}, "1833": {"id": "1833", "title": "An Ambiguity in the Description of ALGOL 60", "authors": "Herriot, J. G.", "words_pool": ["algol", "ambigu", "descript", "herriot"], "word_count": {"algol": 1, "ambigu": 1, "descript": 1, "herriot": 1}}, "1834": {"id": "1834", "title": "An Axiomatic Basis for Computer Programming", "abstract": "In this paper an attempt is made to explore the logical foundations of computer programming  by use of techniques which were first applied in the study of geometry and have later been extended to  other branches of mathematics.  This involves the elucidation of sets of axioms and rules of inference  which can be used in proofs of the properties of computer programs.  Examples are given of such axioms  and rules, and a formal proof of a simple theorem is displayed.  Finally, it is argued that important  advantages, both theoretical and practical, may follow from a pursuance of these topics.", "authors": "Hoare, C. A. R.", "words_pool": ["advantag", "appli", "argu", "attempt", "axiomat", "axiom", "basi", "branch", "comput", "display", "elucid", "exampl", "explor", "extend", "final", "follow", "formal", "foundat", "geometri", "import", "infer", "involv", "later", "logic", "made", "mathemat", "paper", "practic", "program", "program", "proof", "proof", "properti", "pursuanc", "rule", "set", "simpl", "studi", "techniqu", "theorem", "theoret", "topic", "hoar"], "word_count": {"advantag": 1, "appli": 1, "argu": 1, "attempt": 1, "axiomat": 1, "axiom": 2, "basi": 1, "branch": 1, "comput": 2, "display": 1, "elucid": 1, "exampl": 1, "explor": 1, "extend": 1, "final": 1, "follow": 1, "formal": 1, "foundat": 1, "geometri": 1, "import": 1, "infer": 1, "involv": 1, "later": 1, "logic": 1, "made": 1, "mathemat": 1, "paper": 1, "practic": 1, "program": 2, "proof": 2, "properti": 1, "pursuanc": 1, "rule": 2, "set": 1, "simpl": 1, "studi": 1, "techniqu": 1, "theorem": 1, "theoret": 1, "topic": 1, "hoar": 1}}, "1835": {"id": "1835", "title": "The IITRAN Programming Language", "abstract": "The IITRAN language, developed to be used by students, and its important important features  are described. IITRAN is a procedure-oriented language with a one-level block structure and a variety  of data types.  Several novel and powerful features are included.  A discussion of design principles  to be followed in a student language is given.", "authors": "Dewar, R. B. K. Hochsprung, R. R.", "words_pool": ["block", "data", "design", "develop", "discuss", "featur", "iitran", "import", "includ", "languag", "level", "orient", "power", "principl", "procedur", "program", "structur", "student", "student", "type", "varieti", "dewar", "hochsprung"], "word_count": {"block": 1, "data": 1, "design": 1, "develop": 1, "discuss": 1, "featur": 2, "iitran": 2, "import": 2, "includ": 1, "languag": 3, "level": 1, "orient": 1, "power": 1, "principl": 1, "procedur": 1, "program": 1, "structur": 1, "student": 2, "type": 1, "varieti": 1, "dewar": 1, "hochsprung": 1}}, "1836": {"id": "1836", "title": "A New Method for Determining Linear Precedence Functions for Precedence Grammars", "abstract": "The precedence relations of a precedence grammar can be precisely described by a two-dimensional  precedence matrix.  Often the information in the matrix can be represented more concisely by a pair of  vectors, called linear precedence functions.  A new algorithm is presented for obtaining the linear precedence functions when given the precedence matrix; this algorithm is shown to possess several computational  advantages.", "authors": "Bell, J. R.", "words_pool": ["advantag", "algorithm", "call", "comput", "concis", "determin", "dimension", "function", "grammar", "grammar", "inform", "linear", "matrix", "method", "obtain", "pair", "possess", "preced", "precis", "present", "relat", "repres", "shown", "vector", "bell"], "word_count": {"advantag": 1, "algorithm": 2, "call": 1, "comput": 1, "concis": 1, "determin": 1, "dimension": 1, "function": 2, "grammar": 1, "inform": 1, "linear": 2, "matrix": 3, "method": 1, "obtain": 1, "pair": 1, "possess": 1, "preced": 6, "precis": 1, "present": 1, "relat": 1, "repres": 1, "shown": 1, "vector": 1, "bell": 1}}, "1837": {"id": "1837", "title": "An Algol Convolution Procedure Based on the Fast Fourier Transform (Algorithm 345 [C6])", "authors": "Singleton, R. C.", "words_pool": ["algol", "algorithm", "base", "c6", "convolut", "fast", "fourier", "procedur", "transform", "singleton"], "word_count": {"algol": 1, "algorithm": 1, "base": 1, "c6": 1, "convolut": 1, "fast": 1, "fourier": 1, "procedur": 1, "transform": 1, "singleton": 1}}, "1838": {"id": "1838", "title": "Normal Curve Integral (Algorithm 304 [S15])", "authors": "Adams, A. G.", "words_pool": ["algorithm", "curv", "integr", "normal", "s15", "adam"], "word_count": {"algorithm": 1, "curv": 1, "integr": 1, "normal": 1, "s15": 1, "adam": 1}}, "1839": {"id": "1839", "title": "Singular Value Decomposition of a Complex Matrix (Algorithm 358 [F1, 4,5])", "authors": "Businger, P. A. Goulub, G. H.", "words_pool": ["algorithm", "complex", "decomposit", "f1", "matrix", "singular", "busing", "goulub"], "word_count": {"algorithm": 1, "complex": 1, "decomposit": 1, "f1": 1, "matrix": 1, "singular": 1, "busing": 1, "goulub": 1}}, "1840": {"id": "1840", "title": "An Efficient Prime Number Generator (Algorithm 357 [A1])", "authors": "Singleton, R. C.", "words_pool": ["a1", "algorithm", "effici", "gener", "number", "prime", "singleton"], "word_count": {"a1": 1, "algorithm": 1, "effici": 1, "gener": 1, "number": 1, "prime": 1, "singleton": 1}}, "1841": {"id": "1841", "title": "A Prime Number Generator Using The Treesort Principle (Algorithm 356 [A1])", "authors": "Singleton, R. C.", "words_pool": ["a1", "algorithm", "gener", "number", "prime", "principl", "treesort", "singleton"], "word_count": {"a1": 1, "algorithm": 1, "gener": 1, "number": 1, "prime": 1, "principl": 1, "treesort": 1, "singleton": 1}}, "1842": {"id": "1842", "title": "An Algorithm for Generating Ising Configurations (Algorithm 355 [Z])", "authors": "Simoes, J. M. S.", "words_pool": ["algorithm", "configur", "gener", "ise", "simo"], "word_count": {"algorithm": 2, "configur": 1, "gener": 1, "ise": 1, "simo": 1}}, "1843": {"id": "1843", "title": "The Choice of Base", "abstract": "A digital computer is considered, whose memory words are composed on N r-state devices plus  two sign bits (two state devices).  The choice of base B for the internal representation of floating-point  numbers on such a computer is discussed.  It is shown that in a certain sense B= r is best.", "authors": "Brown, W. S. Richman, P. L.", "words_pool": ["base", "bit", "choic", "compos", "comput", "consid", "devic", "digit", "discuss", "float", "intern", "memori", "number", "point", "represent", "sens", "shown", "sign", "state", "word", "brown", "richman"], "word_count": {"base": 1, "bit": 1, "choic": 1, "compos": 1, "comput": 2, "consid": 1, "devic": 2, "digit": 1, "discuss": 1, "float": 1, "intern": 1, "memori": 1, "number": 1, "point": 1, "represent": 1, "sens": 1, "shown": 1, "sign": 1, "state": 2, "word": 1, "brown": 1, "richman": 1}}, "1844": {"id": "1844", "title": "A Modular Computer Sharing System", "abstract": "An alternative approach to the design and organization of a general purpose interactive multiterminal  computing system is presented.  The system organization described is a conceptually simple arrangement  of a bank of interchangeable computers, each of which is a memory/processor pair, that are assigned to  process terminal jobs as they arrive.  One of the computers serves as the master or control computer  and supervises the collection and distribution of messages from and to the remote terminals.  In the  simplest form there is a disk drive for each connected terminal.  A crosspoint switching network allows  any such disk drive to be connected to any computer.  Thus, while each active terminal user \"occupies\"  a dedicated disk drive, he may share the computer with many other terminal users in a simple manner.   The ratio of users to computers is dependent on both the size and power of the machines used and the  computation requirements of the particular mix of users.  This system organization is inherently a simpler  and therefore more reliable approach to time-sharing computers and has the potential of a highly available  system at relatively low cost.  Economic configurations are possible for a range of systems sizes that  span at least one order of magnitude.  Finally, problem programs developed by remote terminal users can  be run on a dedicated batch system if compatible computers are used.", "authors": "Baskin, H. B. Horowitz, E. B. Tennison, R. D. Rittenhouse, L. E.", "words_pool": ["activ", "altern", "approach", "arrang", "arriv", "assign", "bank", "batch", "collect", "compat", "comput", "comput", "comput", "comput", "conceptu", "configur", "connect", "control", "cost", "crosspoint", "dedic", "depend", "design", "develop", "disk", "distribut", "drive", "econom", "final", "form", "gener", "highli", "inher", "interact", "interchang", "job", "low", "machin", "magnitud", "manner", "master", "memori", "messag", "mix", "modular", "multitermin", "network", "occupi", "order", "organ", "pair", "potenti", "power", "present", "problem", "process", "processor", "program", "purpos", "rang", "ratio", "reliabl", "remot", "requir", "run", "serv", "share", "share", "simpl", "simpler", "simplest", "size", "size", "span", "supervis", "switch", "system", "system", "termin", "termin", "time", "user", "user", "baskin", "horowitz", "tennison", "rittenhous"], "word_count": {"activ": 1, "altern": 1, "approach": 2, "arrang": 1, "arriv": 1, "assign": 1, "bank": 1, "batch": 1, "collect": 1, "compat": 1, "comput": 10, "conceptu": 1, "configur": 1, "connect": 2, "control": 1, "cost": 1, "crosspoint": 1, "dedic": 2, "depend": 1, "design": 1, "develop": 1, "disk": 3, "distribut": 1, "drive": 3, "econom": 1, "final": 1, "form": 1, "gener": 1, "highli": 1, "inher": 1, "interact": 1, "interchang": 1, "job": 1, "low": 1, "machin": 1, "magnitud": 1, "manner": 1, "master": 1, "memori": 1, "messag": 1, "mix": 1, "modular": 1, "multitermin": 1, "network": 1, "occupi": 1, "order": 1, "organ": 3, "pair": 1, "potenti": 1, "power": 1, "present": 1, "problem": 1, "process": 1, "processor": 1, "program": 1, "purpos": 1, "rang": 1, "ratio": 1, "reliabl": 1, "remot": 2, "requir": 1, "run": 1, "serv": 1, "share": 2, "simpl": 2, "simpler": 1, "simplest": 1, "size": 2, "span": 1, "supervis": 1, "switch": 1, "system": 6, "termin": 6, "time": 1, "user": 5, "baskin": 1, "horowitz": 1, "tennison": 1, "rittenhous": 1}}, "1845": {"id": "1845", "title": "Loader Standardization for Overlay Programs", "abstract": "The overlay capability is described for four of the third generation computer systems: CDC-6000,  GE-635, IBM-360, and UNIVAC-1108.  A critique of the first three systems is based on actual experience  with a large overlaid trajectory simulation program; a short history and description of this program  is presented.  A standardization of minimum capabilities for loaders is recommended so that programs  which must operate under more than one computer system may be easily converted and maintained.  A proposal  that overlay software incorporates a memory occupation specification concept instead of the conditional  tree structure is delineated.  This concept provides more efficient and cost-effective utilization of  the memory as well as increased flexibility in program structure.", "authors": "Lanzano, B. C.", "words_pool": ["actual", "base", "capabl", "capabl", "cdc", "comput", "concept", "condit", "convert", "cost", "critiqu", "delin", "descript", "easili", "effect", "effici", "experi", "flexibl", "ge", "gener", "histori", "ibm", "incorpor", "increas", "larg", "loader", "loader", "maintain", "memori", "minimum", "occup", "oper", "overlaid", "overlay", "present", "program", "program", "propos", "recommend", "short", "simul", "softwar", "specif", "standard", "structur", "system", "system", "trajectori", "tree", "univac", "util", "lanzano"], "word_count": {"actual": 1, "base": 1, "capabl": 2, "cdc": 1, "comput": 2, "concept": 2, "condit": 1, "convert": 1, "cost": 1, "critiqu": 1, "delin": 1, "descript": 1, "easili": 1, "effect": 1, "effici": 1, "experi": 1, "flexibl": 1, "ge": 1, "gener": 1, "histori": 1, "ibm": 1, "incorpor": 1, "increas": 1, "larg": 1, "loader": 1, "maintain": 1, "memori": 2, "minimum": 1, "occup": 1, "oper": 1, "overlaid": 1, "overlay": 2, "present": 1, "program": 4, "propos": 1, "recommend": 1, "short": 1, "simul": 1, "softwar": 1, "specif": 1, "standard": 1, "structur": 2, "system": 3, "trajectori": 1, "tree": 1, "univac": 1, "util": 1, "lanzano": 1}}, "1846": {"id": "1846", "title": "On Simulating Networks of Parallel Processes in Which Simultaneous Events May Occur", "abstract": "Some of the problems of simulating discrete event systems, particularly computer systems, on  a conventional digital computer are dealt with.  The systems are assumed to be described as a network  of interconnected sequential processes.  Briefly reviewed are the common techniques used to handle such  simulations when simultaneous events do not occur, can be ignored, or can be handled by simple priority  rules.  Following this, the problem of dealing with simultaneous events in separate processes is introduced.   An abstraction of this problem is developed which admits solution for a majority of commonly encountered problems.  The technique will either find a method of simulating the parallel events or report that none  can be found.  In some of the latter cases it is shown to be possible to find a solution by extending  the information available to the solution technique, but in many cases the technique becomes computationally  unfeasible when the additional information is provided.", "authors": "Parnas, D. L.", "words_pool": ["abstract", "addit", "admit", "assum", "briefli", "case", "common", "commonli", "comput", "comput", "convent", "deal", "dealt", "develop", "digit", "discret", "encount", "event", "event", "extend", "find", "found", "handl", "handl", "inform", "interconnect", "introduc", "major", "method", "network", "network", "occur", "parallel", "prioriti", "problem", "problem", "process", "provid", "report", "review", "rule", "separ", "sequenti", "shown", "simpl", "simul", "simul", "simultan", "solut", "system", "techniqu", "techniqu", "unfeas", "parna"], "word_count": {"abstract": 1, "addit": 1, "admit": 1, "assum": 1, "briefli": 1, "case": 2, "common": 1, "commonli": 1, "comput": 3, "convent": 1, "deal": 1, "dealt": 1, "develop": 1, "digit": 1, "discret": 1, "encount": 1, "event": 4, "extend": 1, "find": 2, "found": 1, "handl": 2, "inform": 2, "interconnect": 1, "introduc": 1, "major": 1, "method": 1, "network": 1, "occur": 1, "parallel": 1, "prioriti": 1, "problem": 4, "process": 2, "provid": 1, "report": 1, "review": 1, "rule": 1, "separ": 1, "sequenti": 1, "shown": 1, "simpl": 1, "simul": 3, "simultan": 2, "solut": 3, "system": 3, "techniqu": 4, "unfeas": 1, "parna": 1}}, "1847": {"id": "1847", "title": "An Algorithm for Finding a Fundamental Set of Cycles of a Graph", "abstract": "A fast method is presented for finding a fundamental set of cycles for an undirected finite  graph.  A spanning tree is grown and the vertices examined in turn, unexamined vertices being stored  in a pushdown list to await examination.  One stage in the process is to take the top element v of the  pushdown list and examine it, i.e. inspect all those edges (v,z) of the graph for which z has not yet  been examined.  If z is already in the tree, a fundamental cycle is added; if not, the edge (v,z) is  placed in the tree.  There is exactly one such stage for each of the n vertices of the graph.  For large  n, the store required in creases as n^2 and the time as n^g where g depends on the type of graph involved.   g is bounded below by 2 and above by 3, and it is shown that both bounds are attained.  In terms of  storage our algorithm is similar to that of Gotlieb and Corneil and superior to that of Welch; in terms  of speed it is similar to that of Welch and superior to that of Gotlieb and Corneil.  Testsshow our  algorithm to be remarkably efficient (g=2) on random graphs.", "authors": "Paton, K.", "words_pool": ["ad", "algorithm", "attain", "await", "bound", "bound", "corneil", "creas", "cycl", "cycl", "depend", "edg", "edg", "effici", "element", "exactli", "examin", "examin", "examin", "fast", "find", "finit", "fundament", "gotlieb", "graph", "graph", "grown", "inspect", "involv", "larg", "list", "method", "present", "process", "pushdown", "random", "remark", "requir", "set", "shown", "similar", "span", "speed", "stage", "storag", "store", "store", "superior", "take", "term", "testsshow", "time", "top", "tree", "turn", "type", "undirect", "unexamin", "vertic", "welch", "paton"], "word_count": {"ad": 1, "algorithm": 2, "attain": 1, "await": 1, "bound": 2, "corneil": 2, "creas": 1, "cycl": 2, "depend": 1, "edg": 2, "effici": 1, "element": 1, "exactli": 1, "examin": 4, "fast": 1, "find": 1, "finit": 1, "fundament": 2, "gotlieb": 2, "graph": 5, "grown": 1, "inspect": 1, "involv": 1, "larg": 1, "list": 2, "method": 1, "present": 1, "process": 1, "pushdown": 2, "random": 1, "remark": 1, "requir": 1, "set": 1, "shown": 1, "similar": 2, "span": 1, "speed": 1, "stage": 2, "storag": 1, "store": 2, "superior": 2, "take": 1, "term": 2, "testsshow": 1, "time": 1, "top": 1, "tree": 3, "turn": 1, "type": 1, "undirect": 1, "unexamin": 1, "vertic": 3, "welch": 2, "paton": 1}}, "1848": {"id": "1848", "title": "The Damped Taylor's Series Method for Minimizing a Sum of Squares and for Solving Systems of  Nonlinear Equations (Algorithm 315 [E4, C5])", "authors": "Silverman, G.", "words_pool": ["algorithm", "c5", "damp", "e4", "equat", "method", "minim", "nonlinear", "seri", "solv", "squar", "sum", "system", "taylor", "silverman"], "word_count": {"algorithm": 1, "c5": 1, "damp": 1, "e4": 1, "equat": 1, "method": 1, "minim": 1, "nonlinear": 1, "seri": 1, "solv": 1, "squar": 1, "sum": 1, "system": 1, "taylor": 1, "silverman": 1}}, "1849": {"id": "1849", "title": "Function Minimization (Algorithm 251 [E4])", "authors": "Hamilton, P. A. Boothroyd, J.", "words_pool": ["algorithm", "e4", "function", "minim", "hamilton", "boothroyd"], "word_count": {"algorithm": 1, "e4": 1, "function": 1, "minim": 1, "hamilton": 1, "boothroyd": 1}}, "1850": {"id": "1850", "title": "Generation of Permutations in Lexicographic Order (Algorithm 323 [G6])", "authors": "Leitch, I. M.", "words_pool": ["algorithm", "g6", "gener", "lexicograph", "order", "permut", "leitch"], "word_count": {"algorithm": 1, "g6": 1, "gener": 1, "lexicograph": 1, "order": 1, "permut": 1, "leitch": 1}}, "1851": {"id": "1851", "title": "Generator of Spanning Trees (Algorithms 354 [H])", "authors": "McIlroy, M. D.", "words_pool": ["algorithm", "gener", "span", "tree", "mcilroy"], "word_count": {"algorithm": 1, "gener": 1, "span": 1, "tree": 1, "mcilroy": 1}}, "1852": {"id": "1852", "title": "A Base for a Mobile Programming System", "abstract": "An algorithm for a macro processor which has been used as the base of an implementation, by  bootstrapping, of processors for programming languages is described.  This algorithm can be easily implemented  on contemporary computing machines.  Experience with programming languages whose implementation is based on this algorithm indicates that such a language can be transferred to a new machine in less than one  man-week without using the old machine.", "authors": "Orgass, R. J. Waite, W. M.", "words_pool": ["algorithm", "base", "base", "bootstrap", "comput", "contemporari", "easili", "experi", "implement", "implement", "languag", "languag", "machin", "machin", "macro", "man", "mobil", "processor", "processor", "program", "system", "transfer", "week", "orgass", "wait"], "word_count": {"algorithm": 3, "base": 2, "bootstrap": 1, "comput": 1, "contemporari": 1, "easili": 1, "experi": 1, "implement": 3, "languag": 3, "machin": 3, "macro": 1, "man": 1, "mobil": 1, "processor": 2, "program": 2, "system": 1, "transfer": 1, "week": 1, "orgass": 1, "wait": 1}}, "1853": {"id": "1853", "title": "Compact List Representation: Definition, Garbage Collection, and System Implementation", "abstract": "Compact lists are stored sequentially in memory, rather than chained with pointers.  Since  this is not always convenient, the Swym system permits a list to be chained, compact, or any combination  of the two.  A description is given of that list representation and the operators implemented (most are  similar to those of LISP 1.5).  The system garbage collector attempts to make all lists compact; it relocates  and rearranges all of list storage using temporary storage.  This unique list-compacting garbage collection  algorithm is presented in detail.  Several classes of the macros used to implement the system are described.   Finally, consideration is given to those design factors essential to the success of a plex processing  system implementation.", "authors": "Hansen, W. J.", "words_pool": ["algorithm", "attempt", "chain", "class", "collect", "collector", "combin", "compact", "compact", "consider", "conveni", "definit", "descript", "design", "detail", "essenti", "factor", "final", "garbag", "implement", "implement", "implement", "lisp", "list", "list", "macro", "make", "memori", "oper", "permit", "plex", "pointer", "present", "process", "rearrang", "reloc", "represent", "sequenti", "similar", "storag", "store", "success", "swym", "system", "temporari", "uniqu", "hansen"], "word_count": {"algorithm": 1, "attempt": 1, "chain": 2, "class": 1, "collect": 1, "collector": 1, "combin": 1, "compact": 4, "consider": 1, "conveni": 1, "definit": 1, "descript": 1, "design": 1, "detail": 1, "essenti": 1, "factor": 1, "final": 1, "garbag": 2, "implement": 3, "lisp": 1, "list": 6, "macro": 1, "make": 1, "memori": 1, "oper": 1, "permit": 1, "plex": 1, "pointer": 1, "present": 1, "process": 1, "rearrang": 1, "reloc": 1, "represent": 1, "sequenti": 1, "similar": 1, "storag": 2, "store": 1, "success": 1, "swym": 1, "system": 4, "temporari": 1, "uniqu": 1, "hansen": 1}}, "1854": {"id": "1854", "title": "On Multiprogramming, Machine Coding, and Computer Organization", "abstract": "The author feels that the interrupt feature which is available in most modern computers is  a potent source of programming pitfalls and errors, and that it therefore may heavily contribute to the  unreliability of programs making use of it.  A programming scheme is presented which avoids the concept  of the interrupt and permits the specification of concurrent (or pseudoconcurrent) activities in a supposedly  more perspicuous manner.  It is intended to serve as a basis for the construction of operating systems,  which are prime examples of programs with concurrent activities.  The scheme includes a set of basic  instructions for the generation, termination, and synchronization of parallel processes.  A set of routines  representing these instructions and thereby simulating a hypothetical machine organization has been implemented  and test on the IBM System/360.  Two programs using these instructions, written in PL360, are presented.", "authors": "Wirth, N.", "words_pool": ["activ", "author", "avoid", "basic", "basi", "code", "comput", "comput", "concept", "concurr", "construct", "contribut", "error", "exampl", "featur", "feel", "gener", "heavili", "hypothet", "ibm", "implement", "includ", "instruct", "intend", "interrupt", "machin", "make", "manner", "modern", "multiprogram", "oper", "organ", "parallel", "permit", "perspicu", "pitfal", "pl360", "potent", "present", "prime", "process", "program", "program", "pseudoconcurr", "repres", "routin", "scheme", "serv", "set", "simul", "sourc", "specif", "supposedli", "synchron", "system", "system", "termin", "test", "unreli", "written", "wirth"], "word_count": {"activ": 2, "author": 1, "avoid": 1, "basic": 1, "basi": 1, "code": 1, "comput": 1, "concept": 1, "concurr": 2, "construct": 1, "contribut": 1, "error": 1, "exampl": 1, "featur": 1, "feel": 1, "gener": 1, "heavili": 1, "hypothet": 1, "ibm": 1, "implement": 1, "includ": 1, "instruct": 3, "intend": 1, "interrupt": 2, "machin": 1, "make": 1, "manner": 1, "modern": 1, "multiprogram": 1, "oper": 1, "organ": 1, "parallel": 1, "permit": 1, "perspicu": 1, "pitfal": 1, "pl360": 1, "potent": 1, "present": 2, "prime": 1, "process": 1, "program": 5, "pseudoconcurr": 1, "repres": 1, "routin": 1, "scheme": 2, "serv": 1, "set": 2, "simul": 1, "sourc": 1, "specif": 1, "supposedli": 1, "synchron": 1, "system": 2, "termin": 1, "test": 1, "unreli": 1, "written": 1, "wirth": 1}}, "1855": {"id": "1855", "title": "A Program for the Syntactic Analysis of English Sentences", "abstract": "A program is described which produces syntactic analyses of English sentences with respect  to a transformational grammar.  The main features of the analyzer are that it uses only a limited dictionary  of English words and that it pursues all analysis paths simultaneously while processing the sentence  from left to right.  The form of representation used for the dictionary and the grammar is indicated  and an outline account is given of the analysis procedure.  Techniques for keeping the size of the analysis  record within reasonable limits and for avoiding the need for dynamic application of certain transformational  rules are described.   A number of examples of output produced by the program are given.  The output  includes timing information.", "authors": "Dewar, H. Bratley, P.", "words_pool": ["account", "analys", "analysi", "analyz", "applic", "avoid", "dictionari", "dynam", "english", "exampl", "featur", "form", "grammar", "includ", "inform", "keep", "left", "limit", "limit", "main", "need", "number", "outlin", "output", "path", "procedur", "process", "produc", "produc", "program", "pursu", "reason", "record", "represent", "respect", "rule", "sentenc", "sentenc", "simultan", "size", "syntact", "techniqu", "time", "transform", "word", "dewar", "bratley"], "word_count": {"account": 1, "analys": 1, "analysi": 3, "analyz": 1, "applic": 1, "avoid": 1, "dictionari": 2, "dynam": 1, "english": 2, "exampl": 1, "featur": 1, "form": 1, "grammar": 2, "includ": 1, "inform": 1, "keep": 1, "left": 1, "limit": 2, "main": 1, "need": 1, "number": 1, "outlin": 1, "output": 2, "path": 1, "procedur": 1, "process": 1, "produc": 2, "program": 2, "pursu": 1, "reason": 1, "record": 1, "represent": 1, "respect": 1, "rule": 1, "sentenc": 2, "simultan": 1, "size": 1, "syntact": 1, "techniqu": 1, "time": 1, "transform": 2, "word": 1, "dewar": 1, "bratley": 1}}, "1856": {"id": "1856", "title": "The Teachable Language Comprehender:  A Simulation Program and Theory of Language", "abstract": "The Teachable Language Comprehender (TLC) is a program designed to be capable of being taught  to \"comprehend\" English text.  When text which the program has not seen before is input to it, it comprehends  that text by correctly relating each (explicit or implicit) assertion of the new text to a large memory.   This memory is a \"semantic network\" representing factual assertions about the world.  The program also  creates copies of the parts of its memory which have been found to relate to the new text, adapting and  combining these copies to represent the meaning of the new text.  By this means, the meaning of all text  the program successfully comprehends is encoded into the same format as that of the memory.  In this  form it can be added into the memory.  Both factual assertions for the memory and the capabilities for  correctly relating text to the memory's prior content are to be taught to the program as they are needed.   TLC presently contains a relatively small number of examples of such assertions and capabilities, but  within the system, notations for expressing either of these are provided.  Thus the program now corresponds  to a general process for comprehending language, and it provides a methodology for adding the additional  information this process requires to actually comprehend text of any particular kind.  The memory structure  and comprehension process of TLC allow new factual assertions and capabilities for relating text to such  stored assertions to generalize automatically.  That is, once such an assertion or capability is put  into the system, it becomes available to help comprehend a great many other sentences in the future.   Thus the addition of a single factual assertion or linguistic capability will often provide a large  increment in TLC's effective knowledge of the world and in its overall ability to comprehend text.  The  program's strategy is presented as a general theory of language comprehension.", "authors": "Quillian, M. R.", "words_pool": ["abil", "actual", "adapt", "ad", "ad", "addit", "addit", "allow", "assert", "assert", "capabl", "capabl", "capabl", "combin", "comprehend", "comprehend", "comprehend", "comprehend", "comprehens", "content", "copi", "correctli", "correspond", "creat", "design", "effect", "encod", "english", "exampl", "explicit", "express", "factual", "form", "format", "found", "futur", "gener", "gener", "great", "help", "implicit", "increment", "inform", "input", "kind", "knowledg", "languag", "larg", "linguist", "mean", "mean", "memori", "methodolog", "need", "network", "notat", "number", "part", "present", "present", "prior", "process", "program", "provid", "provid", "put", "relat", "relat", "repres", "repres", "requir", "seen", "semant", "sentenc", "simul", "singl", "small", "store", "strategi", "structur", "success", "system", "taught", "teachabl", "text", "theori", "tlc", "world", "quillian"], "word_count": {"abil": 1, "actual": 1, "adapt": 1, "ad": 2, "addit": 2, "allow": 1, "assert": 8, "capabl": 6, "combin": 1, "comprehend": 8, "comprehens": 2, "content": 1, "copi": 2, "correctli": 2, "correspond": 1, "creat": 1, "design": 1, "effect": 1, "encod": 1, "english": 1, "exampl": 1, "explicit": 1, "express": 1, "factual": 4, "form": 1, "format": 1, "found": 1, "futur": 1, "gener": 3, "great": 1, "help": 1, "implicit": 1, "increment": 1, "inform": 1, "input": 1, "kind": 1, "knowledg": 1, "languag": 3, "larg": 2, "linguist": 1, "mean": 3, "memori": 8, "methodolog": 1, "need": 1, "network": 1, "notat": 1, "number": 1, "part": 1, "present": 2, "prior": 1, "process": 3, "program": 7, "provid": 2, "put": 1, "relat": 4, "repres": 2, "requir": 1, "seen": 1, "semant": 1, "sentenc": 1, "simul": 1, "singl": 1, "small": 1, "store": 1, "strategi": 1, "structur": 1, "success": 1, "system": 2, "taught": 2, "teachabl": 1, "text": 11, "theori": 1, "tlc": 4, "world": 2, "quillian": 1}}, "1857": {"id": "1857", "title": "Filon Quadrature (Algorithm [D1])", "authors": "Chase, S. M. Fosdick, L. D.", "words_pool": ["algorithm", "d1", "filon", "quadratur", "chase", "fosdick"], "word_count": {"algorithm": 1, "d1": 1, "filon": 1, "quadratur": 1, "chase": 1, "fosdick": 1}}, "1858": {"id": "1858", "title": "An Algorithm for Filon Quadrature", "abstract": "An algorithm for Filon quadrature is described.  Considerable attention has been devoted to  an analysis of the round-off and truncation errors.  The algorithm includes an automatic error control  feature.", "authors": "Chase, S. M. Fosdick, L. D.", "words_pool": ["algorithm", "analysi", "attent", "automat", "consider", "control", "devot", "error", "error", "featur", "filon", "includ", "quadratur", "round", "truncat", "chase", "fosdick"], "word_count": {"algorithm": 2, "analysi": 1, "attent": 1, "automat": 1, "consider": 1, "control": 1, "devot": 1, "error": 2, "featur": 1, "filon": 1, "includ": 1, "quadratur": 1, "round": 1, "truncat": 1, "chase": 1, "fosdick": 1}}, "1859": {"id": "1859", "title": "Error Bounds for Periodic Quintic Splines", "abstract": "Explicit error bounds for periodic quintic spline interpolation are developed.  The first (third)  derivative of the periodic spline is shown to be a sixth (fourth) order approximation at the mesh points  to the first (third) derivative of the function being interpolated.", "authors": "Hall, C. A.", "words_pool": ["approxim", "bound", "deriv", "develop", "error", "explicit", "fourth", "function", "interpol", "interpol", "mesh", "order", "period", "point", "quintic", "shown", "sixth", "spline", "spline", "hall"], "word_count": {"approxim": 1, "bound": 1, "deriv": 2, "develop": 1, "error": 1, "explicit": 1, "fourth": 1, "function": 1, "interpol": 2, "mesh": 1, "order": 1, "period": 2, "point": 1, "quintic": 1, "shown": 1, "sixth": 1, "spline": 2, "hall": 1}}, "1860": {"id": "1860", "title": "An Algol-Based Associative Language", "abstract": "A high level programming language for large, complex associative structures has been designed  and implemented.  The underlying data structure has been implemented using a hash-coding technique.   The discussion includes a comparison with other work and examples of applications of the language.", "authors": "Feldman, J. A.", "words_pool": ["algol", "applic", "associ", "base", "code", "comparison", "complex", "data", "design", "discuss", "exampl", "hash", "high", "implement", "includ", "languag", "larg", "level", "program", "structur", "structur", "techniqu", "underli", "work", "feldman"], "word_count": {"algol": 1, "applic": 1, "associ": 1, "base": 1, "code": 1, "comparison": 1, "complex": 1, "data": 1, "design": 1, "discuss": 1, "exampl": 1, "hash": 1, "high": 1, "implement": 2, "includ": 1, "languag": 2, "larg": 1, "level": 1, "program": 1, "structur": 2, "techniqu": 1, "underli": 1, "work": 1, "feldman": 1}}, "1861": {"id": "1861", "title": "The MAD Definition Facility", "abstract": "One of the first definition facilities for higher level languages is described.  Users of the  language can define new operators and/or data types into the MAD language, so that their use appears  as if they were predefined.  Information is given on how one writes definitions, as well as on much of  the motivation behind the form in which definitions are written. Some conclusions are drawn about future  definitional facilities.", "authors": "Arden, B. W. Galler, B. A. Graham, R. M.", "words_pool": ["appear", "conclus", "data", "defin", "definit", "definit", "definit", "drawn", "facil", "facil", "form", "futur", "higher", "inform", "languag", "languag", "level", "mad", "motiv", "oper", "predefin", "type", "user", "write", "written", "arden", "galler", "graham"], "word_count": {"appear": 1, "conclus": 1, "data": 1, "defin": 1, "definit": 4, "drawn": 1, "facil": 2, "form": 1, "futur": 1, "higher": 1, "inform": 1, "languag": 3, "level": 1, "mad": 1, "motiv": 1, "oper": 1, "predefin": 1, "type": 1, "user": 1, "write": 1, "written": 1, "arden": 1, "galler": 1, "graham": 1}}, "1862": {"id": "1862", "title": "Computing Capabilities at Argentine and Chilean Universities", "abstract": "The author reports on a trip to universities in Argentina and Chile during November 1968, describing  university conditions and computing activities.  As elsewhere, these universities are experiencing student  discontent with the status quo and the solutions they are attempting contrast: Argentina is excluding  students from participating in university government; Chile is allowing such participation.  University  computing service and academic activities are limited.  The number of computers is small and so is the  capacity, none larger than an IBM 360/40; with some exception, computing science academic programs are  rare. This situation is by no means attributable to those responsible for computing developments, who  strive for excellence; rather the \"system\" is hard to over-come.  Universities, especially those with  strong European traditions, adapt slowly to new academic resources and disciplines; superimposed are  the severe technological and economic constraints of the developing nation.  Consequently, in the absence  of conscious government emphasis on strengthening computing capabilities, future progress may be retarded.", "authors": "Finerman, A.", "words_pool": ["absenc", "academ", "activ", "adapt", "allow", "argentina", "argentin", "attempt", "attribut", "author", "capabl", "capac", "chile", "chilean", "come", "comput", "comput", "condit", "consciou", "constraint", "contrast", "describ", "develop", "develop", "disciplin", "discont", "econom", "emphasi", "especi", "european", "excel", "except", "exclud", "experienc", "futur", "govern", "hard", "ibm", "larger", "limit", "mean", "nation", "novemb", "number", "particip", "particip", "program", "progress", "quo", "rare", "report", "resourc", "respons", "retard", "scienc", "servic", "sever", "situat", "slowli", "small", "solut", "statu", "strengthen", "strive", "strong", "student", "student", "superimpos", "system", "technolog", "tradit", "trip", "univers", "univers", "finerman"], "word_count": {"absenc": 1, "academ": 3, "activ": 2, "adapt": 1, "allow": 1, "argentina": 2, "argentin": 1, "attempt": 1, "attribut": 1, "author": 1, "capabl": 1, "capac": 1, "chile": 2, "chilean": 1, "come": 1, "comput": 6, "condit": 1, "consciou": 1, "constraint": 1, "contrast": 1, "describ": 1, "develop": 2, "disciplin": 1, "discont": 1, "econom": 1, "emphasi": 1, "especi": 1, "european": 1, "excel": 1, "except": 1, "exclud": 1, "experienc": 1, "futur": 1, "govern": 2, "hard": 1, "ibm": 1, "larger": 1, "limit": 1, "mean": 1, "nation": 1, "novemb": 1, "number": 1, "particip": 2, "program": 1, "progress": 1, "quo": 1, "rare": 1, "report": 1, "resourc": 1, "respons": 1, "retard": 1, "scienc": 1, "servic": 1, "sever": 1, "situat": 1, "slowli": 1, "small": 1, "solut": 1, "statu": 1, "strengthen": 1, "strive": 1, "strong": 1, "student": 2, "superimpos": 1, "system": 1, "technolog": 1, "tradit": 1, "trip": 1, "univers": 6, "finerman": 1}}, "1863": {"id": "1863", "title": "Minit Algorithm for Linear Programming (Algorithm 333 [H])", "authors": "Messham, D. K.", "words_pool": ["algorithm", "linear", "minit", "program", "messham"], "word_count": {"algorithm": 2, "linear": 1, "minit": 1, "program": 1, "messham": 1}}, "1864": {"id": "1864", "title": "Generation of Hilbert Derived Test Matrix (Algorithm 274 [F1])", "authors": "Boothroyd, J.", "words_pool": ["algorithm", "deriv", "f1", "gener", "hilbert", "matrix", "test", "boothroyd"], "word_count": {"algorithm": 1, "deriv": 1, "f1": 1, "gener": 1, "hilbert": 1, "matrix": 1, "test": 1, "boothroyd": 1}}, "1865": {"id": "1865", "title": "Algol 60 Reference Language Editor (Algorithm 268 [R2])", "authors": "Sauer, G.", "words_pool": ["algol", "algorithm", "editor", "languag", "r2", "refer", "sauer"], "word_count": {"algol": 1, "algorithm": 1, "editor": 1, "languag": 1, "r2": 1, "refer": 1, "sauer": 1}}, "1866": {"id": "1866", "title": "Characteristic Values and Associated Solutions of Mathieu's Differential Equation (Algorithm  352 [S22])", "authors": "Clemm, D. S.", "words_pool": ["algorithm", "characterist", "differenti", "equat", "mathieu", "s22", "solut", "valu", "clemm"], "word_count": {"algorithm": 1, "characterist": 1, "differenti": 1, "equat": 1, "mathieu": 1, "s22": 1, "solut": 1, "valu": 1, "clemm": 1}}, "1867": {"id": "1867", "title": "On the Expected Lengths of Sequences Generated in Sorting by Replacement Selecting", "abstract": "In the replacement-selecting technique of sorting, one is interested in the ratio L(j) of the  expected length of the j-th sequence generated by the technique to the number of memory cells used.   Using complex-variable theory, it is shown that L(j) -> 2 and that, asymptotically, the average interval  between sign changes of L(j)-2 is 2.6662.", "authors": "Hooker, W. W.", "words_pool": ["asymptot", "averag", "cell", "complex", "expect", "gener", "interest", "interv", "length", "length", "memori", "number", "ratio", "replac", "select", "sequenc", "sequenc", "shown", "sign", "sort", "techniqu", "th", "theori", "variabl", "hooker"], "word_count": {"asymptot": 1, "averag": 1, "cell": 1, "complex": 1, "expect": 1, "gener": 1, "interest": 1, "interv": 1, "length": 1, "memori": 1, "number": 1, "ratio": 1, "replac": 1, "select": 1, "sequenc": 1, "shown": 1, "sign": 1, "sort": 1, "techniqu": 2, "th": 1, "theori": 1, "variabl": 1, "hooker": 1}}, "1868": {"id": "1868", "title": "On Obtaining Correct Input:A New Approach", "abstract": "Most information put into machine readable form, whether from scientific or business origins,  is still keypunched.  This paper is addressed toward the difficulty of obtaining correctly keypunched  and key verified data and an alternative method is suggested in which the computer itself is used to rule  out the possibility of errors in input.  This technique is explained and illustrated by reference to  a working program which involves essentially two phases: in the first phase errors are detected by the  machine, and subsequently, in the second phase, they are corrected by it.", "authors": "Kennedy, M.", "words_pool": ["address", "altern", "approach", "busi", "comput", "correct", "correct", "correctli", "data", "detect", "difficulti", "error", "essenti", "explain", "form", "illustr", "inform", "input", "involv", "key", "keypunch", "machin", "method", "obtain", "origin", "paper", "phase", "phase", "possibl", "program", "put", "readabl", "refer", "rule", "scientif", "subsequ", "suggest", "techniqu", "verifi", "work", "kennedi"], "word_count": {"address": 1, "altern": 1, "approach": 1, "busi": 1, "comput": 1, "correct": 1, "correctli": 1, "data": 1, "detect": 1, "difficulti": 1, "error": 2, "essenti": 1, "explain": 1, "form": 1, "illustr": 1, "inform": 1, "input": 1, "involv": 1, "key": 1, "keypunch": 2, "machin": 2, "method": 1, "obtain": 1, "origin": 1, "paper": 1, "phase": 3, "possibl": 1, "program": 1, "put": 1, "readabl": 1, "refer": 1, "rule": 1, "scientif": 1, "subsequ": 1, "suggest": 1, "techniqu": 1, "verifi": 1, "work": 1, "kennedi": 1}}, "1869": {"id": "1869", "title": "Block Structures, Indirect Addressing, and Garbage Collection", "abstract": "Programming languages have included explicit or implicit block structures to provide a naming  convenience for the programmer.  However, when indirect addressing is used, as in SNOBOL, naming constraints  may be introduced.  Two modifications to SNOBOL are described, resulting in two desirable consequences:  (1) naming constraints disappear even when there is indirect addressing within function definitions;  and (2) there is a significant saving in the number of calls to the garbage collector, because some garbage  is collected, at little expense, each time a function returns to its calling program.  These modifications  have been implemented as an extension to a SNOBOL dialect.", "authors": "Kain, R. Y.", "words_pool": ["address", "block", "call", "call", "collect", "collect", "collector", "consequ", "constraint", "conveni", "definit", "desir", "dialect", "disappear", "expens", "explicit", "extens", "function", "garbag", "implement", "implicit", "includ", "indirect", "introduc", "languag", "modif", "name", "number", "program", "programm", "program", "provid", "result", "save", "signific", "snobol", "structur", "time", "kain"], "word_count": {"address": 2, "block": 1, "call": 2, "collect": 1, "collector": 1, "consequ": 1, "constraint": 2, "conveni": 1, "definit": 1, "desir": 1, "dialect": 1, "disappear": 1, "expens": 1, "explicit": 1, "extens": 1, "function": 2, "garbag": 2, "implement": 1, "implicit": 1, "includ": 1, "indirect": 2, "introduc": 1, "languag": 1, "modif": 2, "name": 3, "number": 1, "program": 2, "programm": 1, "provid": 1, "result": 1, "save": 1, "signific": 1, "snobol": 3, "structur": 1, "time": 1, "kain": 1}}, "1870": {"id": "1870", "title": "Some Techniques for Using Pseudorandom Numbers in Computer Simulation", "abstract": "An algorithm is described by which uniform pseudorandom integers may be used to construct binary  \"numbers\" in which the probability that each bit in the word is a 1-bit and can assume any desired parameter  value.  Techniques for making use of such \"numbers\" in simulation programming are described.", "authors": "Donnelly, T.", "words_pool": ["algorithm", "assum", "binari", "bit", "comput", "construct", "desir", "integ", "make", "number", "paramet", "probabl", "program", "pseudorandom", "simul", "techniqu", "uniform", "word", "donnelli"], "word_count": {"algorithm": 1, "assum": 1, "binari": 1, "bit": 2, "comput": 1, "construct": 1, "desir": 1, "integ": 1, "make": 1, "number": 2, "paramet": 1, "probabl": 1, "program": 1, "pseudorandom": 1, "simul": 1, "techniqu": 1, "uniform": 1, "word": 1, "donnelli": 1}}, "1871": {"id": "1871", "title": "Automatic Contour Map", "abstract": "Some methods for contour mapping by means of a digital plotter are discussed, and a new method  is presented that is simple enough to be implemented by programs with a rather small number of instructions  (about 120 FORTRAN IV instructions are required).  Comparisons with some methods proposed by other authors  are also performed,  A FORTRAN IV program implementing the proposed method is available at the Istituto  di Elettrotecnica ed Elettronica, Politencnico di Milano.", "authors": "Cottafava, G. LeMoli, G.", "words_pool": ["author", "automat", "comparison", "contour", "di", "digit", "discuss", "ed", "elettronica", "elettrotecnica", "fortran", "implement", "implement", "instruct", "istituto", "iv", "map", "map", "mean", "method", "method", "milano", "number", "perform", "plotter", "politencnico", "present", "program", "program", "propos", "requir", "simpl", "small", "cottafava", "lemoli"], "word_count": {"author": 1, "automat": 1, "comparison": 1, "contour": 1, "di": 2, "digit": 1, "discuss": 1, "ed": 1, "elettronica": 1, "elettrotecnica": 1, "fortran": 2, "implement": 2, "instruct": 2, "istituto": 1, "iv": 2, "map": 1, "mean": 1, "method": 4, "milano": 1, "number": 1, "perform": 1, "plotter": 1, "politencnico": 1, "present": 1, "program": 2, "propos": 2, "requir": 1, "simpl": 1, "small": 1, "cottafava": 1, "lemoli": 1}}, "1872": {"id": "1872", "title": "Chebyshev Interpolation and Quadrature Formulas of Very High Degree (Errata)", "authors": "Salzer, H. E.", "words_pool": ["chebyshev", "degre", "errata", "formula", "high", "interpol", "quadratur", "salzer"], "word_count": {"chebyshev": 1, "degre": 1, "errata": 1, "formula": 1, "high": 1, "interpol": 1, "quadratur": 1, "salzer": 1}}, "1873": {"id": "1873", "title": "Accelerating LP Algorithms", "abstract": "It is shown how a novel method for computing (related) inner products can accelerate the pricing  phase of LP algorithms.  Other LP applications are indicated.", "authors": "Fox, B. L.", "words_pool": ["acceler", "acceler", "algorithm", "applic", "comput", "lp", "method", "phase", "price", "product", "relat", "shown", "fox"], "word_count": {"acceler": 1, "algorithm": 1, "applic": 1, "comput": 1, "lp": 2, "method": 1, "phase": 1, "price": 1, "product": 1, "relat": 1, "shown": 1, "fox": 1}}, "1874": {"id": "1874", "title": "Generating Pseudorandom Numbers on a Two's Complement Machine such as the IBM 360", "abstract": "The familiar multiplicative congruential generator is examined in the context of the type of  two's complement arithmetic used in the IBM 360 series.  Different sequences of residues are considered  and relationships established among them.  It is shown that a sequence of positive and negative residues  may be produced more simply and economically than with the conventional approach and yet have twice the  period of the latter without loss of desirable statistical properties.  Another easily generated sequence  involving absolute values is also shown to have twice the period but with less attractive statistical  properties.  The statistical properties of these sequences are given and related to previously established  criteria.", "authors": "Hemmerle, W. J.", "words_pool": ["absolut", "approach", "arithmet", "attract", "complement", "congruenti", "consid", "context", "convent", "criteria", "desir", "easili", "econom", "establish", "examin", "familiar", "gener", "gener", "gener", "ibm", "involv", "loss", "machin", "multipl", "neg", "number", "period", "posit", "previous", "produc", "properti", "pseudorandom", "relat", "relationship", "residu", "sequenc", "sequenc", "seri", "shown", "simpli", "statist", "type", "valu", "hemmerl"], "word_count": {"absolut": 1, "approach": 1, "arithmet": 1, "attract": 1, "complement": 1, "congruenti": 1, "consid": 1, "context": 1, "convent": 1, "criteria": 1, "desir": 1, "easili": 1, "econom": 1, "establish": 2, "examin": 1, "familiar": 1, "gener": 2, "ibm": 1, "involv": 1, "loss": 1, "machin": 1, "multipl": 1, "neg": 1, "number": 1, "period": 2, "posit": 1, "previous": 1, "produc": 1, "properti": 3, "pseudorandom": 1, "relat": 1, "relationship": 1, "residu": 2, "sequenc": 4, "seri": 1, "shown": 2, "simpli": 1, "statist": 3, "type": 1, "valu": 1, "hemmerl": 1}}, "1875": {"id": "1875", "title": "Polynomial and Spline Approximation by Quadratic Programming", "abstract": "The problem of approximation to a given function, or of fitting a given set of data, where  the approximating function is required to have certain of its derivations of specified sign over the  whole range of approximation, is studied.  Two approaches are presented, in each of which quadratic programming  is used to provide both the constraints on the derivatives and the selection of the function which yields  the best fit.  The first is a modified Bernstein polynomial scheme, and the second is a spline fit.", "authors": "Amos, D. E. Slater, M. L.", "words_pool": ["approach", "approxim", "approxim", "bernstein", "constraint", "data", "deriv", "deriv", "fit", "fit", "function", "modifi", "polynomi", "present", "problem", "program", "provid", "quadrat", "rang", "requir", "scheme", "select", "set", "sign", "spline", "studi", "yield", "amo", "slater"], "word_count": {"approach": 1, "approxim": 3, "bernstein": 1, "constraint": 1, "data": 1, "deriv": 2, "fit": 3, "function": 3, "modifi": 1, "polynomi": 1, "present": 1, "problem": 1, "program": 1, "provid": 1, "quadrat": 1, "rang": 1, "requir": 1, "scheme": 1, "select": 1, "set": 1, "sign": 1, "spline": 1, "studi": 1, "yield": 1, "amo": 1, "slater": 1}}, "1876": {"id": "1876", "title": "Generation of Test Matrices Having Certain Sign Patterns and Prescribed Positive Spectra", "abstract": "A class of orthogonal transformations is presented whose members transform a given positive  diagonal matrix into a matrix having one of four special sign patterns.", "authors": "Schneider, A. J.", "words_pool": ["class", "diagon", "gener", "matric", "matrix", "member", "orthogon", "pattern", "posit", "prescrib", "present", "sign", "special", "spectra", "test", "transform", "transform", "schneider"], "word_count": {"class": 1, "diagon": 1, "gener": 1, "matric": 1, "matrix": 2, "member": 1, "orthogon": 1, "pattern": 1, "posit": 1, "prescrib": 1, "present": 1, "sign": 1, "special": 1, "spectra": 1, "test": 1, "transform": 2, "schneider": 1}}, "1877": {"id": "1877", "title": "Prevention of System Deadlocks", "abstract": "A well-known problem in the design of operating systems is the selection of a resource allocation  policy that will prevent deadlock.  Deadlock is the situation in which resources have been allocated  to various tasks in such a way that none of the tasks can continue.  The various published solutions  have been somewhat restrictive: either they do not handle the problem in sufficient generality or they  suggest policies which will on occasion refuse a request which could have been safely granted.  Algorithms  are presented which examine a request in the light of the current allocation of resources and determine  whether or not the granting of the request will introduce the possibility of a deadlock.  Proofs given  in the appendixes show that the conditions imposed by the algorithms are both necessary and sufficient  to prevent deadlock.  The algorithms have been successfully used in the THE system.", "authors": "Habermann, A. N.", "words_pool": ["algorithm", "alloc", "alloc", "appendix", "condit", "continu", "deadlock", "deadlock", "design", "determin", "examin", "gener", "grant", "grant", "handl", "impos", "introduc", "known", "light", "occas", "oper", "polici", "polici", "possibl", "present", "prevent", "prevent", "problem", "proof", "publish", "refus", "request", "resourc", "resourc", "restrict", "safe", "select", "show", "situat", "solut", "success", "suffici", "suggest", "system", "system", "task", "habermann"], "word_count": {"algorithm": 3, "alloc": 3, "appendix": 1, "condit": 1, "continu": 1, "deadlock": 4, "design": 1, "determin": 1, "examin": 1, "gener": 1, "grant": 2, "handl": 1, "impos": 1, "introduc": 1, "known": 1, "light": 1, "occas": 1, "oper": 1, "polici": 2, "possibl": 1, "present": 1, "prevent": 2, "problem": 2, "proof": 1, "publish": 1, "refus": 1, "request": 3, "resourc": 3, "restrict": 1, "safe": 1, "select": 1, "show": 1, "situat": 1, "solut": 1, "success": 1, "suffici": 2, "suggest": 1, "system": 2, "task": 2, "habermann": 1}}, "1878": {"id": "1878", "title": "Recovery of Reentrant List Structures in SLIP", "abstract": "One consequence of the reference-count-based space-recovery system employed by SLIP is that  reentrant list structures are not recovered even when explicitly erased.  LISP-like garbage-collection  schemes are free of this impediment.  They however, depend on being able to find and mark nodes that  are reachable from program variables.  By tracing all descendants from program variables may then be  identified and collected.  The list-creating function LIST of SLIP may be amended to mark those lists  for which the programmer wishes to assume responsibility.  Given this modification, a LISP-like garbage  collector that recovers abandoned reentrant list structures may then be appended to the SLIP system.", "authors": "Weizenbaum, J.", "words_pool": ["abandon", "abl", "amend", "append", "assum", "base", "collect", "collect", "collector", "consequ", "count", "creat", "depend", "descend", "employ", "eras", "explicitli", "find", "free", "function", "garbag", "identifi", "impedi", "lisp", "list", "list", "mark", "modif", "node", "program", "programm", "reachabl", "recov", "recov", "recoveri", "reentrant", "refer", "respons", "scheme", "slip", "space", "structur", "system", "trace", "variabl", "wish", "weizenbaum"], "word_count": {"abandon": 1, "abl": 1, "amend": 1, "append": 1, "assum": 1, "base": 1, "collect": 2, "collector": 1, "consequ": 1, "count": 1, "creat": 1, "depend": 1, "descend": 1, "employ": 1, "eras": 1, "explicitli": 1, "find": 1, "free": 1, "function": 1, "garbag": 2, "identifi": 1, "impedi": 1, "lisp": 2, "list": 5, "mark": 2, "modif": 1, "node": 1, "program": 2, "programm": 1, "reachabl": 1, "recov": 2, "recoveri": 1, "reentrant": 2, "refer": 1, "respons": 1, "scheme": 1, "slip": 3, "space": 1, "structur": 2, "system": 2, "trace": 1, "variabl": 2, "wish": 1, "weizenbaum": 1}}, "1879": {"id": "1879", "title": "A Note on Storage Fragmentation and Program Segmentation", "abstract": "The main purpose of this paper is the presentation of some of the results of a series of simulation  experiments investigating the phenomenon of storage fragmentation.  Two different types of storage fragmentation  are distinguished: (1) external fragmentation, namely the loss in storage utilization caused by the inability  to make use of all available storage after it has been fragmented into a large number of separate blocks;  and (2) internal fragmentation, the loss of utilization caused by rounding up a request for storage,  rather than allocating only the exact number of words required.  The most striking result is the apparently  general rule that rounding up requests for storage, to reduce the number of different sizes of blocks  coexisting in storage, causes more loss of storage by increased internal fragmentation than is saved  by decreased external fragmentation.  Described also are a method of segment allocation and an accompanying  technique for segment addressing which take advantage of the above result.  Evidence is presented of  possible advantages of the method over conventional paging techniques.", "authors": "Randell, B.", "words_pool": ["accompani", "address", "advantag", "advantag", "alloc", "alloc", "appar", "block", "caus", "coexist", "convent", "decreas", "distinguish", "evid", "exact", "experi", "extern", "fragment", "fragment", "gener", "inabl", "increas", "intern", "investig", "larg", "loss", "main", "make", "method", "note", "number", "page", "paper", "phenomenon", "present", "present", "program", "purpos", "reduc", "request", "request", "requir", "result", "result", "round", "rule", "save", "segment", "segment", "separ", "seri", "simul", "size", "storag", "strike", "take", "techniqu", "techniqu", "type", "util", "word", "randel"], "word_count": {"accompani": 1, "address": 1, "advantag": 2, "alloc": 2, "appar": 1, "block": 2, "caus": 2, "coexist": 1, "convent": 1, "decreas": 1, "distinguish": 1, "evid": 1, "exact": 1, "experi": 1, "extern": 2, "fragment": 7, "gener": 1, "inabl": 1, "increas": 1, "intern": 2, "investig": 1, "larg": 1, "loss": 3, "main": 1, "make": 1, "method": 2, "note": 1, "number": 3, "page": 1, "paper": 1, "phenomenon": 1, "present": 2, "program": 1, "purpos": 1, "reduc": 1, "request": 2, "requir": 1, "result": 3, "round": 2, "rule": 1, "save": 1, "segment": 2, "separ": 1, "seri": 1, "simul": 1, "size": 1, "storag": 8, "strike": 1, "take": 1, "techniqu": 2, "type": 1, "util": 2, "word": 1, "randel": 1}}, "1880": {"id": "1880", "title": "Chebyshev Solution to an Overdetermined Linear System (Algorithm 328 [F4])", "authors": "Golub, G. H.", "words_pool": ["algorithm", "chebyshev", "f4", "linear", "overdetermin", "solut", "system", "golub"], "word_count": {"algorithm": 1, "chebyshev": 1, "f4": 1, "linear": 1, "overdetermin": 1, "solut": 1, "system": 1, "golub": 1}}, "1881": {"id": "1881", "title": "Transpose Vector Stored Array (Algorithm 302 [K2])", "authors": "MacLeod, I. D. G.", "words_pool": ["algorithm", "array", "k2", "store", "transpos", "vector", "macleod"], "word_count": {"algorithm": 1, "array": 1, "k2": 1, "store": 1, "transpos": 1, "vector": 1, "macleod": 1}}, "1882": {"id": "1882", "title": "Determination of the Square Root of a Positive Definite Matrix (Algorithm 298 [F1])", "authors": "Duke, B. J.", "words_pool": ["algorithm", "definit", "determin", "f1", "matrix", "posit", "root", "squar", "duke"], "word_count": {"algorithm": 1, "definit": 1, "determin": 1, "f1": 1, "matrix": 1, "posit": 1, "root": 1, "squar": 1, "duke": 1}}, "1883": {"id": "1883", "title": "Modified Romberg Quadrature(Algorithm [D1])", "authors": "Fair weather, G.", "words_pool": ["algorithm", "d1", "modifi", "quadratur", "romberg", "fair", "weather"], "word_count": {"algorithm": 1, "d1": 1, "modifi": 1, "quadratur": 1, "romberg": 1, "fair": 1, "weather": 1}}, "1884": {"id": "1884", "title": "An Anomaly in Space-Time Characteristics of Certain Programs Running in a Paging Machine", "abstract": "The running time of programs in a paging machine generally increases as the store in which  programs are constrained to run decreases.  Experiments, however, have revealed cases in which the reverse  is true: a decrease in the size of the store is accompanied by a decrease in running time.  An informal  discussion of the anomalous behavior is given, and for the case of the FIFO replacement algorithm a formal  treatment is presented.", "authors": "Belady, L. A. Nelson, R. A. Shedler, G. S.", "words_pool": ["accompani", "algorithm", "anomal", "anomali", "behavior", "case", "case", "characterist", "constrain", "decreas", "decreas", "discuss", "experi", "fifo", "formal", "gener", "increas", "inform", "machin", "page", "present", "program", "replac", "reveal", "revers", "run", "run", "size", "space", "store", "time", "treatment", "true", "beladi", "nelson", "shedler"], "word_count": {"accompani": 1, "algorithm": 1, "anomal": 1, "anomali": 1, "behavior": 1, "case": 2, "characterist": 1, "constrain": 1, "decreas": 3, "discuss": 1, "experi": 1, "fifo": 1, "formal": 1, "gener": 1, "increas": 1, "inform": 1, "machin": 1, "page": 1, "present": 1, "program": 2, "replac": 1, "reveal": 1, "revers": 1, "run": 3, "size": 1, "space": 1, "store": 2, "time": 2, "treatment": 1, "true": 1, "beladi": 1, "nelson": 1, "shedler": 1}}, "1885": {"id": "1885", "title": "A Computer System for Transformational Grammar", "abstract": "A comprehensive system for transformational grammar has been designed and implemented on the  IBM 360/67 computer.  The system deals with the transformational model of syntax, along the lines of  Chomsky's Aspects of the Theory of Syntax. The major innovations include a full,formal description of  the syntax of a transformational grammar, a directed random phrase structure generator, a lexical insertion  algorithm, an extended definition of analysis, and a simple problem-oriented programming language in  which the algorithm for application of transformations can be expressed.  In this paper we present the  system as a whole, first discussing the general attitudes underlying the development of the system, then  outlining the system and discussing its more important special features.  References are given to papers  which consider some particular aspect of the system in detail.", "authors": "Friedman, J.", "words_pool": ["algorithm", "analysi", "applic", "aspect", "aspect", "attitud", "chomski", "comprehens", "comput", "consid", "deal", "definit", "descript", "design", "detail", "develop", "direct", "discuss", "express", "extend", "featur", "formal", "full", "gener", "gener", "grammar", "ibm", "implement", "import", "includ", "innov", "insert", "languag", "lexic", "line", "major", "model", "orient", "outlin", "paper", "paper", "phrase", "present", "problem", "program", "random", "refer", "simpl", "special", "structur", "syntax", "system", "theori", "transform", "transform", "underli", "friedman"], "word_count": {"algorithm": 2, "analysi": 1, "applic": 1, "aspect": 2, "attitud": 1, "chomski": 1, "comprehens": 1, "comput": 1, "consid": 1, "deal": 1, "definit": 1, "descript": 1, "design": 1, "detail": 1, "develop": 1, "direct": 1, "discuss": 2, "express": 1, "extend": 1, "featur": 1, "formal": 1, "full": 1, "gener": 2, "grammar": 2, "ibm": 1, "implement": 1, "import": 1, "includ": 1, "innov": 1, "insert": 1, "languag": 1, "lexic": 1, "line": 1, "major": 1, "model": 1, "orient": 1, "outlin": 1, "paper": 2, "phrase": 1, "present": 1, "problem": 1, "program": 1, "random": 1, "refer": 1, "simpl": 1, "special": 1, "structur": 1, "syntax": 3, "system": 6, "theori": 1, "transform": 4, "underli": 1, "friedman": 1}}, "1886": {"id": "1886", "title": "Generation of Optimal Code for Expressions via Factorization", "abstract": "Given a set of expressions which are to be compiled, methods are presented for increasing the  efficiency of the object code produced by first factoring the expressions, i.e. finding a set of subexpressions  each of which occurs in two or more other expressions or subexpressions.  Once all the factors have been  ascertained, a sequencing procedure is applied which orders the factors and expressions such that all  information is computed in the correct sequence and factors need be retained in memory a minimal amount  of time.  An assignment algorithm is then executed in order to minimize the total number of temporary  storage cells required to hold the results of evaluating the factors.  In order to make these techniques  computationally feasible, heuristic procedures are applied, and hence global optimal results are not  necessarily generated.  The factorization algorithms are also applicable to the problem of factoring  Boolean switching expressions and of factoring polynomials encountered in symbol manipulating systems.", "authors": "Breuer, M. A.", "words_pool": ["algorithm", "algorithm", "amount", "applic", "appli", "ascertain", "assign", "boolean", "cell", "code", "compil", "comput", "comput", "correct", "effici", "encount", "evalu", "execut", "express", "factor", "factor", "factor", "feasibl", "find", "gener", "gener", "global", "heurist", "hold", "increas", "inform", "make", "manipul", "memori", "method", "minim", "minim", "necessarili", "need", "number", "object", "occur", "optim", "order", "order", "polynomi", "present", "problem", "procedur", "procedur", "produc", "requir", "result", "retain", "sequenc", "sequenc", "set", "storag", "subexpress", "switch", "symbol", "system", "techniqu", "temporari", "time", "total", "breuer"], "word_count": {"algorithm": 2, "amount": 1, "applic": 1, "appli": 2, "ascertain": 1, "assign": 1, "boolean": 1, "cell": 1, "code": 1, "compil": 1, "comput": 2, "correct": 1, "effici": 1, "encount": 1, "evalu": 1, "execut": 1, "express": 5, "factor": 8, "feasibl": 1, "find": 1, "gener": 1, "global": 1, "heurist": 1, "hold": 1, "increas": 1, "inform": 1, "make": 1, "manipul": 1, "memori": 1, "method": 1, "minim": 2, "necessarili": 1, "need": 1, "number": 1, "object": 1, "occur": 1, "optim": 1, "order": 3, "polynomi": 1, "present": 1, "problem": 1, "procedur": 2, "produc": 1, "requir": 1, "result": 2, "retain": 1, "sequenc": 2, "set": 2, "storag": 1, "subexpress": 2, "switch": 1, "symbol": 1, "system": 1, "techniqu": 1, "temporari": 1, "time": 1, "total": 1, "breuer": 1}}, "1887": {"id": "1887", "title": "A Recursive Relation for the Determinant of a Pentadiagonal Matrix", "abstract": "A recursive relation, relating leading principal minors, is developed for the determinant of  a pentadiagonal matrix.  A numerical example is included to indicate its use in calculating eigenvalues.", "authors": "Sweet, R. A.", "words_pool": ["calcul", "determin", "develop", "eigenvalu", "includ", "lead", "matrix", "minor", "numer", "pentadiagon", "princip", "recurs", "relat", "relat", "sweet"], "word_count": {"calcul": 1, "determin": 1, "develop": 1, "eigenvalu": 1, "includ": 1, "lead": 1, "matrix": 1, "minor": 1, "numer": 1, "pentadiagon": 1, "princip": 1, "recurs": 1, "relat": 2, "sweet": 1}}, "1888": {"id": "1888", "title": "Spline Function Methods for Nonlinear Boundary-Value Problems", "abstract": "The solution of the nonlinear differential equation Y\"=F(x,Y,Y') with two-point boundary conditions  is approximated by a quintic or cubic spline function y(x).  The method is well suited to nonuniform  mesh size and dynamic mesh size allocation.  For uniform mesh size h, the error in the quintic spline  y(x) is O(h^4), with typical error one-third that from Numerov's method.  Requiring the differential  equation to be satisfied at the mesh points results in a set of difference equations, which are block  tridiagonal and so are easily solved by relaxation or other standard methods.", "authors": "Blue, J. L.", "words_pool": ["alloc", "approxim", "block", "boundari", "condit", "cubic", "differ", "differenti", "dynam", "easili", "equat", "equat", "error", "function", "mesh", "method", "method", "nonlinear", "nonuniform", "numerov", "point", "point", "problem", "quintic", "relax", "requir", "result", "satisfi", "set", "size", "solut", "solv", "spline", "standard", "suit", "tridiagon", "typic", "uniform", "blue"], "word_count": {"alloc": 1, "approxim": 1, "block": 1, "boundari": 1, "condit": 1, "cubic": 1, "differ": 1, "differenti": 2, "dynam": 1, "easili": 1, "equat": 3, "error": 2, "function": 1, "mesh": 4, "method": 3, "nonlinear": 1, "nonuniform": 1, "numerov": 1, "point": 2, "problem": 1, "quintic": 2, "relax": 1, "requir": 1, "result": 1, "satisfi": 1, "set": 1, "size": 3, "solut": 1, "solv": 1, "spline": 2, "standard": 1, "suit": 1, "tridiagon": 1, "typic": 1, "uniform": 1, "blue": 1}}, "1889": {"id": "1889", "title": "Introducing Computing to Smaller Colleges and Universities -- A Progress Report", "abstract": "By technical means that are now routine, computer service for smaller colleges and universities  can be provided by remote terminals of a central facility.  Access, however, is not enough-effective  organizational and educational methodology for introducing computing at such institutions must also be  developed.  The experience of two years with a statewide network involving-41 institutions is discussed.   Lessons include the importance of a separate organization representing the small colleges, the necessity  for on-campus training for the institutions, the need for some special programming and documentation  to support such users,and the development of curriculum by evolutionary means.", "authors": "Parker Jr., L. T. Gallie, T. M. Brooks Jr., F. P. Ferrel, J. K.", "words_pool": ["access", "campu", "central", "colleg", "comput", "comput", "curriculum", "develop", "develop", "discuss", "document", "educ", "effect", "evolutionari", "experi", "facil", "import", "includ", "institut", "introduc", "involv", "lesson", "mean", "methodolog", "necess", "need", "network", "organ", "organiz", "program", "progress", "provid", "remot", "report", "repres", "routin", "separ", "servic", "small", "smaller", "special", "statewid", "support", "technic", "termin", "train", "univers", "user", "year", "parker", "jr", "galli", "brook", "jr", "ferrel"], "word_count": {"access": 1, "campu": 1, "central": 1, "colleg": 2, "comput": 2, "curriculum": 1, "develop": 2, "discuss": 1, "document": 1, "educ": 1, "effect": 1, "evolutionari": 1, "experi": 1, "facil": 1, "import": 1, "includ": 1, "institut": 3, "introduc": 1, "involv": 1, "lesson": 1, "mean": 2, "methodolog": 1, "necess": 1, "need": 1, "network": 1, "organ": 1, "organiz": 1, "program": 1, "progress": 1, "provid": 1, "remot": 1, "report": 1, "repres": 1, "routin": 1, "separ": 1, "servic": 1, "small": 1, "smaller": 1, "special": 1, "statewid": 1, "support": 1, "technic": 1, "termin": 1, "train": 1, "univers": 1, "user": 1, "year": 1, "parker": 1, "jr": 1, "galli": 1, "brook": 1, "ferrel": 1}}, "1890": {"id": "1890", "title": "Simulation of Traffic Flows in a Network", "abstract": "A computer simulation program which deals with traffic flows in the network of a large area  is described.  Each road is segmented into blocks of several ten-meter lengths and is represented by  a bidirectional list in computer memory.  The movement of cars, i.e. the transfer of cars from one block  to the next, is expressed by a proper formula.  This formula is based on the supposition that the speed  of cars in a block is determined only by the density of cars in the block, and this speed-versus-density  curve is empirically given the numerical values.  This simulation scheme has its excellent point in that  it makes it possible to trace the dynamic behavior of traffic flows in a variety of situations, some  examples of which are given for an actual area of the city of Kyoto, Japan.", "authors": "Sakai, T. Nagao, M.", "words_pool": ["actual", "area", "base", "behavior", "bidirect", "block", "block", "car", "citi", "comput", "curv", "deal", "densiti", "determin", "dynam", "empir", "exampl", "excel", "express", "flow", "formula", "japan", "kyoto", "larg", "length", "list", "make", "memori", "meter", "movement", "network", "numer", "point", "program", "proper", "repres", "road", "scheme", "segment", "simul", "situat", "speed", "supposit", "ten", "trace", "traffic", "transfer", "valu", "varieti", "versu", "sakai", "nagao"], "word_count": {"actual": 1, "area": 2, "base": 1, "behavior": 1, "bidirect": 1, "block": 4, "car": 4, "citi": 1, "comput": 2, "curv": 1, "deal": 1, "densiti": 2, "determin": 1, "dynam": 1, "empir": 1, "exampl": 1, "excel": 1, "express": 1, "flow": 2, "formula": 2, "japan": 1, "kyoto": 1, "larg": 1, "length": 1, "list": 1, "make": 1, "memori": 1, "meter": 1, "movement": 1, "network": 1, "numer": 1, "point": 1, "program": 1, "proper": 1, "repres": 1, "road": 1, "scheme": 1, "segment": 1, "simul": 2, "situat": 1, "speed": 2, "supposit": 1, "ten": 1, "trace": 1, "traffic": 2, "transfer": 1, "valu": 1, "varieti": 1, "versu": 1, "sakai": 1, "nagao": 1}}, "1891": {"id": "1891", "title": "Three-Dimensional Computer Display", "abstract": "A stereographic display terminal has been produced using the raster display (BRAD) recently  developed at Brookhaven.  The system uses a rotating refresh memory to feed standard television monitors.   To produce a stereographic display the computer calculates the projected video images of an object,  viewed from two separate points.  The resulting video maps are stored on separate refresh bands of the  rotating memory.  The two output signals are connected to separate color guns of a color television monitor,  thus creating a superimposed image on the screen.  Optical separation is achieved by viewing the image  through color filters.  The display is interactive and can be viewed by a large group of people at the  same time.", "authors": "Ophir, D. Shepherd, B. J. Spinrad, R. J.", "words_pool": ["achiev", "band", "brad", "brookhaven", "calcul", "color", "comput", "connect", "creat", "develop", "dimension", "display", "feed", "filter", "group", "gun", "imag", "imag", "interact", "larg", "map", "memori", "monitor", "monitor", "object", "optic", "output", "peopl", "point", "produc", "produc", "project", "raster", "recent", "refresh", "result", "rotat", "screen", "separ", "separ", "signal", "standard", "stereograph", "store", "superimpos", "system", "televis", "termin", "time", "video", "view", "view", "ophir", "shepherd", "spinrad"], "word_count": {"achiev": 1, "band": 1, "brad": 1, "brookhaven": 1, "calcul": 1, "color": 3, "comput": 1, "connect": 1, "creat": 1, "develop": 1, "dimension": 1, "display": 4, "feed": 1, "filter": 1, "group": 1, "gun": 1, "imag": 3, "interact": 1, "larg": 1, "map": 1, "memori": 2, "monitor": 2, "object": 1, "optic": 1, "output": 1, "peopl": 1, "point": 1, "produc": 2, "project": 1, "raster": 1, "recent": 1, "refresh": 2, "result": 1, "rotat": 2, "screen": 1, "separ": 4, "signal": 1, "standard": 1, "stereograph": 2, "store": 1, "superimpos": 1, "system": 1, "televis": 2, "termin": 1, "time": 1, "video": 2, "view": 3, "ophir": 1, "shepherd": 1, "spinrad": 1}}, "1892": {"id": "1892", "title": "Degree of Multiprogramming in Page-on-Demand Systems", "abstract": "A simple stochastic model is described which offers a base for understanding the relationship  between the number of programs permitted to share memory (the degree of multiprogramming), drum traffic  rates, and central processing unit utilization in page-on-demand, multiprogrammed, time-shared computer  systems.  The model preserves, as a key feature, the property of page-demand statistics which implies  a \"burst\" of page demands at the beginning of any job or quantum execution.  The model, a Markov chain,  is analyzed numerically and the results are presented graphically for a wide range of key environment-descriptive  parameters.  Implications of the results to time-shared system design and programming are discussed,  and a calculation of the optimal degree of multiprogramming for a wide range of parameters is presented  graphically.", "authors": "Wallace, V. L. Mason, D. L.", "words_pool": ["analyz", "base", "begin", "burst", "calcul", "central", "chain", "comput", "degre", "demand", "demand", "descript", "design", "discuss", "drum", "environ", "execut", "featur", "graphic", "implic", "impli", "job", "key", "markov", "memori", "model", "multiprogram", "multiprogram", "number", "numer", "offer", "optim", "page", "paramet", "permit", "present", "preserv", "process", "program", "program", "properti", "quantum", "rang", "rate", "relationship", "result", "share", "share", "simpl", "statist", "stochast", "system", "system", "time", "traffic", "understand", "unit", "util", "wide", "wallac", "mason"], "word_count": {"analyz": 1, "base": 1, "begin": 1, "burst": 1, "calcul": 1, "central": 1, "chain": 1, "comput": 1, "degre": 2, "demand": 3, "descript": 1, "design": 1, "discuss": 1, "drum": 1, "environ": 1, "execut": 1, "featur": 1, "graphic": 2, "implic": 1, "impli": 1, "job": 1, "key": 2, "markov": 1, "memori": 1, "model": 3, "multiprogram": 3, "number": 1, "numer": 1, "offer": 1, "optim": 1, "page": 3, "paramet": 2, "permit": 1, "present": 2, "preserv": 1, "process": 1, "program": 2, "properti": 1, "quantum": 1, "rang": 2, "rate": 1, "relationship": 1, "result": 2, "share": 3, "simpl": 1, "statist": 1, "stochast": 1, "system": 2, "time": 2, "traffic": 1, "understand": 1, "unit": 1, "util": 1, "wide": 2, "wallac": 1, "mason": 1}}, "1893": {"id": "1893", "title": "Roots of Polynomials by a Root-Squaring and Resultant routine (Algorithm 340 [C2])", "authors": "Noltemeier, A.", "words_pool": ["algorithm", "c2", "polynomi", "result", "root", "root", "routin", "squar", "noltemei"], "word_count": {"algorithm": 1, "c2": 1, "polynomi": 1, "result": 1, "root": 2, "routin": 1, "squar": 1, "noltemei": 1}}, "1894": {"id": "1894", "title": "Normal Random Deviates (Algorithm 334 [G5])", "authors": "Knop, R.", "words_pool": ["algorithm", "deviat", "g5", "normal", "random", "knop"], "word_count": {"algorithm": 1, "deviat": 1, "g5": 1, "normal": 1, "random": 1, "knop": 1}}, "1895": {"id": "1895", "title": "Gaussian Quadrature Formulas (Algorithm 331 [D1])", "authors": "Hill, I. D.", "words_pool": ["algorithm", "d1", "formula", "gaussian", "quadratur", "hill"], "word_count": {"algorithm": 1, "d1": 1, "formula": 1, "gaussian": 1, "quadratur": 1, "hill": 1}}, "1896": {"id": "1896", "title": "Regular Coulomb Wave Functions (Algorithm 292 S22])", "authors": "Gautschi, W.", "words_pool": ["algorithm", "coulomb", "function", "regular", "s22", "wave", "gautschi"], "word_count": {"algorithm": 1, "coulomb": 1, "function": 1, "regular": 1, "s22": 1, "wave": 1, "gautschi": 1}}, "1897": {"id": "1897", "title": "Coulomb Wave Functions (Algorithm 300 [S22])", "authors": "Kolbig, K. S.", "words_pool": ["algorithm", "coulomb", "function", "s22", "wave", "kolbig"], "word_count": {"algorithm": 1, "coulomb": 1, "function": 1, "s22": 1, "wave": 1, "kolbig": 1}}, "1898": {"id": "1898", "title": "Regular Coulomb Wave Functions (Algorithm 292 [S22])", "authors": "Kolbig, K. S.", "words_pool": ["algorithm", "coulomb", "function", "regular", "s22", "wave", "kolbig"], "word_count": {"algorithm": 1, "coulomb": 1, "function": 1, "regular": 1, "s22": 1, "wave": 1, "kolbig": 1}}, "1899": {"id": "1899", "title": "Simplex Method Procedure Employing Lu Decomposition (Algorithm 350 [H])", "authors": "Bartels, R. H. Golub, G. H.", "words_pool": ["algorithm", "decomposit", "employ", "lu", "method", "procedur", "simplex", "bartel", "golub"], "word_count": {"algorithm": 1, "decomposit": 1, "employ": 1, "lu": 1, "method": 1, "procedur": 1, "simplex": 1, "bartel": 1, "golub": 1}}, "1900": {"id": "1900", "title": "Clarification of Fortran Standards-Initial Progress", "abstract": "In 1966 after four years of effort, FORTRAN became the first programming language standardized  in the United States.  Since that initial achievement, study and application of the standard specifications  have revealed the need for maintenance of the standards.  As the result of work initiated in 1967, an  initial set of clarifying interpretations has been prepared.  The nature of the maintenance, corrections  to the standard specifications, and completed interpretations are reported.", "words_pool": ["achiev", "applic", "clarif", "clarifi", "complet", "correct", "effort", "fortran", "initi", "initi", "interpret", "languag", "mainten", "natur", "need", "prepar", "program", "progress", "report", "result", "reveal", "set", "specif", "standard", "standard", "standard", "state", "studi", "unit", "work", "year"], "word_count": {"achiev": 1, "applic": 1, "clarif": 1, "clarifi": 1, "complet": 1, "correct": 1, "effort": 1, "fortran": 1, "initi": 3, "interpret": 2, "languag": 1, "mainten": 2, "natur": 1, "need": 1, "prepar": 1, "program": 1, "progress": 1, "report": 1, "result": 1, "reveal": 1, "set": 1, "specif": 2, "standard": 4, "state": 1, "studi": 1, "unit": 1, "work": 1, "year": 1}}, "1901": {"id": "1901", "title": "Dynamic Space-Sharing in Computer Systems", "abstract": "A formalization of relationships between space-shading program behavior, and processor efficiency  in computer systems is presented.  Concepts of value and cost of space allocation per task are defined  and then value and cost are combined to develop a single parameter termed value per unit cost.  The intent  is to illustrate a possible analytic approach to the investigation of the problems of space-sharing and  to demonstrate the method on sample problems.", "authors": "Belady, L. A. Kuehner, C. J.", "words_pool": ["alloc", "analyt", "approach", "behavior", "combin", "comput", "concept", "cost", "defin", "demonstr", "develop", "dynam", "effici", "formal", "illustr", "intent", "investig", "method", "paramet", "present", "problem", "processor", "program", "relationship", "sampl", "shade", "share", "singl", "space", "system", "task", "term", "unit", "beladi", "kuehner"], "word_count": {"alloc": 1, "analyt": 1, "approach": 1, "behavior": 1, "combin": 1, "comput": 1, "concept": 1, "cost": 3, "defin": 1, "demonstr": 1, "develop": 1, "dynam": 1, "effici": 1, "formal": 1, "illustr": 1, "intent": 1, "investig": 1, "method": 1, "paramet": 1, "present": 1, "problem": 2, "processor": 1, "program": 1, "relationship": 1, "sampl": 1, "shade": 1, "share": 1, "singl": 1, "space": 3, "system": 1, "task": 1, "term": 1, "unit": 1, "beladi": 1, "kuehner": 1}}, "1902": {"id": "1902", "title": "An Automatic Grading Scheme for Simple Programming Exercises", "abstract": "A discussion is given of alterations that were made to a typical university operating system  to record the results of programming exercises in three different languages, including assembly language.   In this computer-controlled grading scheme provision is made for testing with programmer-supplied data  and for final runs with system-supplied data.  Exercises run under the scheme may be mixed with other  programs, and no special recognition of exercises by the operators is necessary.", "authors": "Hext, J. B. Winings, J. W.", "words_pool": ["alter", "assembl", "automat", "comput", "control", "data", "discuss", "exercis", "final", "grade", "includ", "languag", "languag", "made", "mix", "oper", "oper", "programm", "program", "program", "provis", "recognit", "record", "result", "run", "run", "scheme", "simpl", "special", "suppli", "system", "test", "typic", "univers", "hext", "wine"], "word_count": {"alter": 1, "assembl": 1, "automat": 1, "comput": 1, "control": 1, "data": 2, "discuss": 1, "exercis": 3, "final": 1, "grade": 1, "includ": 1, "languag": 2, "made": 2, "mix": 1, "oper": 2, "programm": 1, "program": 2, "provis": 1, "recognit": 1, "record": 1, "result": 1, "run": 2, "scheme": 2, "simpl": 1, "special": 1, "suppli": 2, "system": 2, "test": 1, "typic": 1, "univers": 1, "hext": 1, "wine": 1}}, "1903": {"id": "1903", "title": "Chebyshev Interpolation and Quadrature Formulas of Very High Degree", "authors": "Salzer, H. E.", "words_pool": ["chebyshev", "degre", "formula", "high", "interpol", "quadratur", "salzer"], "word_count": {"chebyshev": 1, "degre": 1, "formula": 1, "high": 1, "interpol": 1, "quadratur": 1, "salzer": 1}}, "1904": {"id": "1904", "title": "Rough and Ready Error Estimates in Gaussian Integration of Analytic Functions", "authors": "Rabinowitz, P.", "words_pool": ["analyt", "error", "estim", "function", "gaussian", "integr", "readi", "rough", "rabinowitz"], "word_count": {"analyt": 1, "error": 1, "estim": 1, "function": 1, "gaussian": 1, "integr": 1, "readi": 1, "rough": 1, "rabinowitz": 1}}, "1905": {"id": "1905", "title": "The Simplex Method of Linear Programming Using LU Decomposition", "abstract": "Standard computer implementations of Dantzig's simplex method for linear programming are based  upon forming the inverse of the basic matrix and updating the inverse after every step of the method.   These implementations have bad round-off error properties.  This paper gives the theoretical background  for an implementation which is based upon the LU decomposition, computed with row interchanges, of the  basic matrix.  The implementation is slow, but has good round-off error behavior.  The implementation  appears as CACM Algorithm 350.", "authors": "Bartels, R. H. Goulub, G. H.", "words_pool": ["algorithm", "appear", "background", "bad", "base", "basic", "behavior", "cacm", "comput", "comput", "dantzig", "decomposit", "error", "form", "good", "implement", "implement", "interchang", "invers", "linear", "lu", "matrix", "method", "paper", "program", "properti", "round", "row", "simplex", "slow", "standard", "step", "theoret", "updat", "bartel", "goulub"], "word_count": {"algorithm": 1, "appear": 1, "background": 1, "bad": 1, "base": 2, "basic": 2, "behavior": 1, "cacm": 1, "comput": 2, "dantzig": 1, "decomposit": 1, "error": 2, "form": 1, "good": 1, "implement": 5, "interchang": 1, "invers": 2, "linear": 1, "lu": 1, "matrix": 2, "method": 2, "paper": 1, "program": 1, "properti": 1, "round": 2, "row": 1, "simplex": 1, "slow": 1, "standard": 1, "step": 1, "theoret": 1, "updat": 1, "bartel": 1, "goulub": 1}}, "1906": {"id": "1906", "title": "Automated Printed Circuit Routing with a Stepping Aperture", "abstract": "A computer program for routing interconnections on a two-sided printed circuit board with a  regular pattern of lines, pins (terminals), and vias (feed-through holes) is described.  In this program,  each interconnection is given a planned routing-typically, down from the upper pin, through a via, and  horizontally to the lower pin.  From the top, a virtual aperture (i.e. a long horizontal slit) is stepped  down the board.  The planned routing is the basis for rerouting interconnections within the aperture  to resolve conflicts for lines and vias below the aperture and to maximize the effective line usage.   If a conflict has not been resolved before the aperture arrives at the lower pin,interconnections are  deleted to resolve the conflict.  Extensions of this technique to the control of crosstalk between routed  interconnections and to the problem of obtaining 100 percent interconnect are also discussed.", "authors": "Lass, S.E.", "words_pool": ["apertur", "arriv", "autom", "basi", "board", "circuit", "comput", "conflict", "conflict", "control", "crosstalk", "delet", "discuss", "effect", "extens", "feed", "hole", "horizont", "horizont", "interconnect", "interconnect", "interconnect", "line", "line", "long", "lower", "maxim", "obtain", "pattern", "percent", "pin", "pin", "plan", "print", "problem", "program", "regular", "rerout", "resolv", "resolv", "rout", "rout", "side", "slit", "step", "step", "techniqu", "termin", "top", "typic", "upper", "usag", "via", "virtual", "lass"], "word_count": {"apertur": 4, "arriv": 1, "autom": 1, "basi": 1, "board": 2, "circuit": 1, "comput": 1, "conflict": 3, "control": 1, "crosstalk": 1, "delet": 1, "discuss": 1, "effect": 1, "extens": 1, "feed": 1, "hole": 1, "horizont": 2, "interconnect": 6, "line": 3, "long": 1, "lower": 2, "maxim": 1, "obtain": 1, "pattern": 1, "percent": 1, "pin": 4, "plan": 2, "print": 1, "problem": 1, "program": 2, "regular": 1, "rerout": 1, "resolv": 3, "rout": 4, "side": 1, "slit": 1, "step": 1, "techniqu": 1, "termin": 1, "top": 1, "typic": 1, "upper": 1, "usag": 1, "via": 2, "virtual": 1, "lass": 1}}, "1907": {"id": "1907", "title": "A Note on Reliable Full-Duplex Transmission over Half-Duplex Links", "abstract": "A simple procedure for achieving reliable full-duplex transmission over half-duplex links is  proposed. The scheme is compared with another of the same type, which has recently been described in  the literature.  Finally, some comments are made on another group of related transmission procedures  which have been shown to be unreliable under some circumstances.", "authors": "Bartlett, K. A. Scantlebury, R. A.", "words_pool": ["achiev", "circumst", "comment", "compar", "duplex", "final", "full", "group", "half", "link", "literatur", "made", "note", "procedur", "procedur", "propos", "recent", "relat", "reliabl", "scheme", "shown", "simpl", "transmiss", "type", "unreli", "bartlett", "scantleburi"], "word_count": {"achiev": 1, "circumst": 1, "comment": 1, "compar": 1, "duplex": 2, "final": 1, "full": 1, "group": 1, "half": 1, "link": 1, "literatur": 1, "made": 1, "note": 1, "procedur": 2, "propos": 1, "recent": 1, "relat": 1, "reliabl": 1, "scheme": 1, "shown": 1, "simpl": 1, "transmiss": 2, "type": 1, "unreli": 1, "bartlett": 1, "scantleburi": 1}}, "1908": {"id": "1908", "title": "Time-Sharing and Batch-Processing:  An Experimental Comparison of Their Values in a Problem -  Solving Situation", "abstract": "An experimental comparison of problem-solving using time-sharing and batch-processing computer  systems conducted at MIT is described in this paper.  This study is the first known attempt to evaluate  two such systems for what may well be the predominant user population within the next decade-the professionals  who, as nonprogrammers, are using the computer as an aid in decision-making and problem-solving rather  than as a programming end in itself.  Statistically and logically significant results indicate equal  cost for usage of the two computer systems; however, a much higher level of performance is attained by  time-sharing users.  There are indications that significantly lower costs would have resulted if the  time-sharing users had stopped work when they reached a performance level equal to that of the batch  users.  The users' speed of problem-solving and their attitudes made time-sharing the more favorable  system.", "authors": "Gold, M. M.", "words_pool": ["aid", "attain", "attempt", "attitud", "batch", "comparison", "comput", "conduct", "cost", "cost", "decad", "decis", "end", "equal", "evalu", "experiment", "favor", "higher", "indic", "known", "level", "logic", "lower", "made", "make", "mit", "nonprogramm", "paper", "perform", "popul", "predomin", "problem", "process", "profession", "program", "reach", "result", "result", "share", "signific", "significantli", "situat", "solv", "speed", "statist", "stop", "studi", "system", "system", "time", "usag", "user", "user", "valu", "work", "gold"], "word_count": {"aid": 1, "attain": 1, "attempt": 1, "attitud": 1, "batch": 2, "comparison": 1, "comput": 3, "conduct": 1, "cost": 2, "decad": 1, "decis": 1, "end": 1, "equal": 2, "evalu": 1, "experiment": 1, "favor": 1, "higher": 1, "indic": 1, "known": 1, "level": 2, "logic": 1, "lower": 1, "made": 1, "make": 1, "mit": 1, "nonprogramm": 1, "paper": 1, "perform": 2, "popul": 1, "predomin": 1, "problem": 3, "process": 1, "profession": 1, "program": 1, "reach": 1, "result": 2, "share": 4, "signific": 1, "significantli": 1, "situat": 1, "solv": 3, "speed": 1, "statist": 1, "stop": 1, "studi": 1, "system": 4, "time": 4, "usag": 1, "user": 5, "valu": 1, "work": 1, "gold": 1}}, "1909": {"id": "1909", "title": "Computation of Jn(x) by Numerical Integration", "abstract": "It is shown to be practical to compute Jn(x) by numerical integration of its integral representation  using the trapezoidal rule. The error in this approximation was studied empirically.", "authors": "Stroud, A. H. Kohli, J. P.", "words_pool": ["approxim", "comput", "comput", "empir", "error", "integr", "integr", "jn", "numer", "practic", "represent", "rule", "shown", "studi", "trapezoid", "stroud", "kohli"], "word_count": {"approxim": 1, "comput": 1, "empir": 1, "error": 1, "integr": 2, "jn": 1, "numer": 1, "practic": 1, "represent": 1, "rule": 1, "shown": 1, "studi": 1, "trapezoid": 1, "stroud": 1, "kohli": 1}}, "1910": {"id": "1910", "title": "An Algorithm for Solving a Special Class of Tridiagonal Systems of Linear Equations", "abstract": "An algorithm is presented for solving a system of linear equation Bu=k where B is tridiagonal  and of a special form.  It is shown that this algorithm is almost twice as fast as the Gaussian elimination  method usually suggested for solving such systems.  In addition, explicit formulas for the inverse and  determinant of the matrix B are given.", "authors": "Rose, D. J.", "words_pool": ["addit", "algorithm", "bu", "class", "determin", "elimin", "equat", "equat", "explicit", "fast", "form", "formula", "gaussian", "invers", "linear", "matrix", "method", "present", "shown", "solv", "special", "suggest", "system", "system", "tridiagon", "rose"], "word_count": {"addit": 1, "algorithm": 2, "bu": 1, "class": 1, "determin": 1, "elimin": 1, "equat": 1, "explicit": 1, "fast": 1, "form": 1, "formula": 1, "gaussian": 1, "invers": 1, "linear": 1, "matrix": 1, "method": 1, "present": 1, "shown": 1, "solv": 2, "special": 1, "suggest": 1, "system": 2, "tridiagon": 1, "rose": 1}}, "1911": {"id": "1911", "title": "On Coordination Reduction and Sentence Analysis", "abstract": "A class of coordination phenomena in natural languages is considered within the frame work  of transformational theory.  To account for these phenomena it is proposed that certain machinery be  added to the syntactic component of a transformational grammar. This machinery includes certain rule  schemata, the conditions under which they are to be applied, and conditions determining the sequence  of subtrees on which they are to be performed.  A solution to the syntactic analysis problem for this  class of grammars is outlined.  Precise specification of both the generative procedure of this paper  and its inverse is given in the form of LISP function definitions.", "authors": "Petrick, S. R. Postal, P. M. Rosenbaum, P. S.", "words_pool": ["account", "ad", "analysi", "appli", "class", "compon", "condit", "consid", "coordin", "definit", "determin", "form", "frame", "function", "gener", "grammar", "grammar", "includ", "invers", "languag", "lisp", "machineri", "natur", "outlin", "paper", "perform", "phenomena", "precis", "problem", "procedur", "propos", "reduct", "rule", "schemata", "sentenc", "sequenc", "solut", "specif", "subtre", "syntact", "theori", "transform", "work", "petrick", "postal", "rosenbaum"], "word_count": {"account": 1, "ad": 1, "analysi": 1, "appli": 1, "class": 2, "compon": 1, "condit": 2, "consid": 1, "coordin": 1, "definit": 1, "determin": 1, "form": 1, "frame": 1, "function": 1, "gener": 1, "grammar": 2, "includ": 1, "invers": 1, "languag": 1, "lisp": 1, "machineri": 2, "natur": 1, "outlin": 1, "paper": 1, "perform": 1, "phenomena": 2, "precis": 1, "problem": 1, "procedur": 1, "propos": 1, "reduct": 1, "rule": 1, "schemata": 1, "sentenc": 1, "sequenc": 1, "solut": 1, "specif": 1, "subtre": 1, "syntact": 2, "theori": 1, "transform": 2, "work": 1, "petrick": 1, "postal": 1, "rosenbaum": 1}}, "1912": {"id": "1912", "title": "Simulation of Outpatient Appointment Systems", "abstract": "An experimental computer program is described which simulates appointment systems employed  by outpatient departments of hospitals.  Both major kinds of appointment systems-individual and block-can  be simulated.  The purpose of the Simulator is to enable the user to evaluate the effectiveness of alternative  appointment systems in a given clinical environment.", "authors": "Katz, J. H.", "words_pool": ["altern", "appoint", "block", "clinic", "comput", "depart", "effect", "employ", "enabl", "environ", "evalu", "experiment", "hospit", "individu", "kind", "major", "outpati", "program", "purpos", "simul", "simul", "simul", "simul", "system", "user", "katz"], "word_count": {"altern": 1, "appoint": 3, "block": 1, "clinic": 1, "comput": 1, "depart": 1, "effect": 1, "employ": 1, "enabl": 1, "environ": 1, "evalu": 1, "experiment": 1, "hospit": 1, "individu": 1, "kind": 1, "major": 1, "outpati": 1, "program": 1, "purpos": 1, "simul": 3, "system": 3, "user": 1, "katz": 1}}, "1913": {"id": "1913", "title": "Polygamma Functions with Arbitrary Precision (Algorithm 349 [S14])", "authors": "Schwachheim, G.", "words_pool": ["algorithm", "arbitrari", "function", "polygamma", "precis", "s14", "schwachheim"], "word_count": {"algorithm": 1, "arbitrari": 1, "function": 1, "polygamma": 1, "precis": 1, "s14": 1, "schwachheim": 1}}, "1914": {"id": "1914", "title": "Matrix Scaling by Integer Programming (Algorithm 348 [F1])", "authors": "Klimpel, R. R.", "words_pool": ["algorithm", "f1", "integ", "matrix", "program", "scale", "klimpel"], "word_count": {"algorithm": 1, "f1": 1, "integ": 1, "matrix": 1, "program": 1, "scale": 1, "klimpel": 1}}, "1915": {"id": "1915", "title": "An Algorithm for Hidden Line Elimination", "abstract": "The algorithm presented causes the elimination of hidden lines in the representation of a perspective  view of concave and convex plane-faced objects on the picture plane.  All the edges of the objects are  considered sequentially, and all planes which hide every point of an edge are found.  The computing time  increases roughly as the square of the number of edges.  The algorithm takes advantage of a reduced number  of concave points and automatically recognizes if only one object with no concave points is considered.  In this last case, the result is obtained in a much simpler way.", "authors": "Galimberti, R. Montanari, U.", "words_pool": ["advantag", "algorithm", "case", "comput", "concav", "consid", "convex", "edg", "edg", "elimin", "face", "found", "hidden", "hide", "increas", "line", "line", "number", "object", "object", "obtain", "perspect", "pictur", "plane", "plane", "point", "point", "present", "recogn", "reduc", "represent", "result", "roughli", "sequenti", "simpler", "squar", "take", "time", "view", "galimberti", "montanari"], "word_count": {"advantag": 1, "algorithm": 2, "case": 1, "comput": 1, "concav": 3, "consid": 2, "convex": 1, "edg": 3, "elimin": 1, "face": 1, "found": 1, "hidden": 1, "hide": 1, "increas": 1, "line": 1, "number": 2, "object": 3, "obtain": 1, "perspect": 1, "pictur": 1, "plane": 3, "point": 3, "present": 1, "recogn": 1, "reduc": 1, "represent": 1, "result": 1, "roughli": 1, "sequenti": 1, "simpler": 1, "squar": 1, "take": 1, "time": 1, "view": 1, "galimberti": 1, "montanari": 1}}, "1916": {"id": "1916", "title": "Analysis of Boolean Program Models for Time-Shared, Paged Environments", "abstract": "Directed graphs or their associated matrices are frequently used to represent the logical structure  of sequences of computer instructions.  Such techniques are used and, in addition, data references are  represented in a nondirected model. The complete structural specification of a program is represented  by a combined model.  A transformation of the combined model yields a new model in which additional timing  information is also contained.  Analysis of these models prior to execution yields information valuable  in determining segmentation of instructions and data for a time-shared environment, as well as for initial  page loading; during execution, the analysis may be used for \"look ahead\" control of page turning.", "authors": "Lowe, T. C.", "words_pool": ["addit", "addit", "ahead", "analysi", "boolean", "combin", "complet", "comput", "contain", "control", "data", "determin", "direct", "environ", "environ", "execut", "frequent", "graph", "inform", "initi", "instruct", "load", "logic", "look", "matric", "model", "model", "nondirect", "page", "page", "prior", "program", "refer", "repres", "repres", "segment", "sequenc", "share", "specif", "structur", "structur", "techniqu", "time", "time", "transform", "turn", "valuabl", "yield", "low"], "word_count": {"addit": 2, "ahead": 1, "analysi": 2, "boolean": 1, "combin": 2, "complet": 1, "comput": 1, "contain": 1, "control": 1, "data": 2, "determin": 1, "direct": 1, "environ": 1, "execut": 2, "frequent": 1, "graph": 1, "inform": 2, "initi": 1, "instruct": 2, "load": 1, "logic": 1, "look": 1, "matric": 1, "model": 5, "nondirect": 1, "page": 2, "prior": 1, "program": 1, "refer": 1, "repres": 3, "segment": 1, "sequenc": 1, "share": 1, "specif": 1, "structur": 2, "techniqu": 1, "time": 2, "transform": 1, "turn": 1, "valuabl": 1, "yield": 2, "low": 1}}, "1917": {"id": "1917", "title": "An Algol Procedure for the Fast Fourier Transform with Arbitrary Factors (Algorithm 339 [C6])", "authors": "Singleton, R. C.", "words_pool": ["algol", "algorithm", "arbitrari", "c6", "factor", "fast", "fourier", "procedur", "transform", "singleton"], "word_count": {"algol": 1, "algorithm": 1, "arbitrari": 1, "c6": 1, "factor": 1, "fast": 1, "fourier": 1, "procedur": 1, "transform": 1, "singleton": 1}}, "1918": {"id": "1918", "title": "Distribution of Indistinguishable Objects into Distinguishable Slots (Algorithm 329 [G6])", "authors": "Gray, M.", "words_pool": ["algorithm", "distinguish", "distribut", "g6", "indistinguish", "object", "slot", "gray"], "word_count": {"algorithm": 1, "distinguish": 1, "distribut": 1, "g6": 1, "indistinguish": 1, "object": 1, "slot": 1, "gray": 1}}, "1919": {"id": "1919", "title": "An Efficient Algorithm for Sorting with Minimal Storage (Algorithm 347 [M1])", "authors": "Singleton, R. C.", "words_pool": ["algorithm", "effici", "m1", "minim", "sort", "storag", "singleton"], "word_count": {"algorithm": 2, "effici": 1, "m1": 1, "minim": 1, "sort": 1, "storag": 1, "singleton": 1}}, "1920": {"id": "1920", "title": "F-Test Probabilities (Algorithm 346 [S14])", "authors": "Morris, J.", "words_pool": ["algorithm", "probabl", "s14", "test", "morri"], "word_count": {"algorithm": 1, "probabl": 1, "s14": 1, "test": 1, "morri": 1}}, "1921": {"id": "1921", "title": "An Algol Convolution Procedure Based on the Fast Fourier Transform (Algorithm 345 [C6])", "authors": "Singleton, R. C.", "words_pool": ["algol", "algorithm", "base", "c6", "convolut", "fast", "fourier", "procedur", "transform", "singleton"], "word_count": {"algol": 1, "algorithm": 1, "base": 1, "c6": 1, "convolut": 1, "fast": 1, "fourier": 1, "procedur": 1, "transform": 1, "singleton": 1}}, "1922": {"id": "1922", "title": "Proposed USA Standard (Data Communication Control Procedures for the USA Standarad Code for Information  Interchange)", "words_pool": ["code", "commun", "control", "data", "inform", "interchang", "procedur", "propos", "standarad", "standard", "usa"], "word_count": {"code": 1, "commun": 1, "control": 1, "data": 1, "inform": 1, "interchang": 1, "procedur": 1, "propos": 1, "standarad": 1, "standard": 1, "usa": 2}}, "1923": {"id": "1923", "title": "Pseudofiles", "abstract": "An approach to system interfaces for high level languages using basic input/output support  facilities is described.  It is shown that this technique can provide potentially inexpensive methods  for programs to communicate with deeply embedded facilities such as command language processors.", "authors": "Rosin, R. F.", "words_pool": ["approach", "basic", "command", "commun", "deepli", "embed", "facil", "high", "inexpens", "input", "interfac", "languag", "languag", "level", "method", "output", "potenti", "processor", "program", "provid", "pseudofil", "shown", "support", "system", "techniqu", "rosin"], "word_count": {"approach": 1, "basic": 1, "command": 1, "commun": 1, "deepli": 1, "embed": 1, "facil": 2, "high": 1, "inexpens": 1, "input": 1, "interfac": 1, "languag": 2, "level": 1, "method": 1, "output": 1, "potenti": 1, "processor": 1, "program": 1, "provid": 1, "pseudofil": 1, "shown": 1, "support": 1, "system": 1, "techniqu": 1, "rosin": 1}}, "1924": {"id": "1924", "title": "Organizing Matrices and Matrix Operations for Paged Memory Systems", "abstract": "Matrix representations and operations are examined for the purpose of minimizing the page faulting  occurring in a paged memory system.  It is shown that carefully designed matrix algorithms can lead to  enormous savings in the number of page faults occurring when only a small part of the total matrix can  be in main memory at one time.  Examination of addition, multiplication, and inversion algorithms shows  that a partitioned matrix representation (i.e. one submatrix or partition per page) in most cases induced  fewer page faults than a row-by-row representation.  The number of page-pulls required by these matrix  manipulation algorithms is also studied as a function of the number of pages of main memory available  to the algorithm.", "authors": "McKellar, A. C. Coffman Jr., E. G.", "words_pool": ["addit", "algorithm", "algorithm", "care", "case", "design", "enorm", "examin", "examin", "fault", "fault", "fewer", "function", "induc", "invers", "lead", "main", "manipul", "matric", "matrix", "memori", "minim", "multipl", "number", "occur", "oper", "organ", "page", "page", "page", "part", "partit", "partit", "pull", "purpos", "represent", "represent", "requir", "row", "save", "shown", "show", "small", "studi", "submatrix", "system", "system", "time", "total", "mckellar", "coffman", "jr"], "word_count": {"addit": 1, "algorithm": 4, "care": 1, "case": 1, "design": 1, "enorm": 1, "examin": 2, "fault": 3, "fewer": 1, "function": 1, "induc": 1, "invers": 1, "lead": 1, "main": 2, "manipul": 1, "matric": 1, "matrix": 5, "memori": 3, "minim": 1, "multipl": 1, "number": 3, "occur": 2, "oper": 1, "organ": 1, "page": 7, "part": 1, "partit": 2, "pull": 1, "purpos": 1, "represent": 3, "requir": 1, "row": 2, "save": 1, "shown": 1, "show": 1, "small": 1, "studi": 1, "submatrix": 1, "system": 1, "time": 1, "total": 1, "mckellar": 1, "coffman": 1, "jr": 1}}, "1925": {"id": "1925", "title": "Concepts of Use in Contour Map Processing", "abstract": "Generalized techniques whose use can simplify the solution of problems relating to contour  maps.  One of these techniques makes use of the topological properties of contour maps.  The topology  is represented by a graphical structure in which adjacent contour lines appear as connected nodes.  Another  generalized technique consists of utilizing geometrical properties to determine the characteristics of  straight lines drawn on the contour map.  Both of these techniques have been applied to the problem of  locating the ground track of an aircraft from elevation readings obtained during a flight.", "authors": "Morse, S. P.", "words_pool": ["adjac", "aircraft", "appli", "characterist", "concept", "connect", "consist", "contour", "determin", "drawn", "elev", "flight", "gener", "geometr", "graphic", "ground", "line", "locat", "make", "map", "map", "node", "obtain", "problem", "problem", "process", "properti", "read", "relat", "repres", "simplifi", "solut", "straight", "structur", "techniqu", "techniqu", "topolog", "topolog", "track", "util", "mors"], "word_count": {"adjac": 1, "aircraft": 1, "appli": 1, "characterist": 1, "concept": 1, "connect": 1, "consist": 1, "contour": 4, "determin": 1, "drawn": 1, "elev": 1, "flight": 1, "gener": 2, "geometr": 1, "graphic": 1, "ground": 1, "line": 2, "locat": 1, "make": 1, "map": 3, "node": 1, "obtain": 1, "problem": 2, "process": 1, "properti": 2, "read": 1, "relat": 1, "repres": 1, "simplifi": 1, "solut": 1, "straight": 1, "structur": 1, "techniqu": 4, "topolog": 2, "track": 1, "util": 1, "mors": 1}}, "1926": {"id": "1926", "title": "Description of FORMAT, a Text-Processing Program", "abstract": "FORMAT is a production program which facilitates the editing and printing of \"finished\" documents  directly on the printer of a relatively small (64k) computer system.  It features good performance, totally  free-form input, very flexible formatting capabilities including up to eight columns per page, automatic  capitalization, aids for index construction, and a minimum of nontext items.  It is written entirely  in FORTRAN IV.", "authors": "Berns, G. M.", "words_pool": ["64k", "aid", "automat", "capabl", "capit", "column", "comput", "construct", "descript", "directli", "document", "edit", "entir", "facilit", "featur", "finish", "flexibl", "form", "format", "format", "fortran", "free", "good", "includ", "index", "input", "item", "iv", "minimum", "nontext", "page", "perform", "printer", "print", "process", "product", "program", "small", "system", "text", "total", "written", "bern"], "word_count": {"64k": 1, "aid": 1, "automat": 1, "capabl": 1, "capit": 1, "column": 1, "comput": 1, "construct": 1, "descript": 1, "directli": 1, "document": 1, "edit": 1, "entir": 1, "facilit": 1, "featur": 1, "finish": 1, "flexibl": 1, "form": 1, "format": 2, "fortran": 1, "free": 1, "good": 1, "includ": 1, "index": 1, "input": 1, "item": 1, "iv": 1, "minimum": 1, "nontext": 1, "page": 1, "perform": 1, "printer": 1, "print": 1, "process": 1, "product": 1, "program": 1, "small": 1, "system": 1, "text": 1, "total": 1, "written": 1, "bern": 1}}, "1927": {"id": "1927", "title": "Information Science in a Ph.D. Computer Science Program", "abstract": "This report contains recommendations on a sample course curriculum in the general area of information  organization and information system design in a Ph.D. Computer Science Program.  The subject area is  first briefly described, followed by a listing of some desirable graduate-level courses.  Suitable bibliographies  are appended.", "authors": "Salton, G.", "words_pool": ["append", "area", "bibliographi", "briefli", "comput", "cours", "cours", "curriculum", "design", "desir", "gener", "graduat", "inform", "level", "list", "organ", "ph", "program", "recommend", "report", "sampl", "scienc", "subject", "suitabl", "system", "salton"], "word_count": {"append": 1, "area": 2, "bibliographi": 1, "briefli": 1, "comput": 1, "cours": 2, "curriculum": 1, "design": 1, "desir": 1, "gener": 1, "graduat": 1, "inform": 2, "level": 1, "list": 1, "organ": 1, "ph": 1, "program": 1, "recommend": 1, "report": 1, "sampl": 1, "scienc": 1, "subject": 1, "suitabl": 1, "system": 1, "salton": 1}}, "1928": {"id": "1928", "title": "Exclusive Simulation of Activity in Digital Networks", "abstract": "A technique for simulating the detailed logic networks of large and active digital systems  is described.  Essential objectives sought are improved ease and economy in model generation, economy  in execution time and space, and a facility for handling simultaneous activities.  The main results obtained  are a clear and useful separation of structural and behavioral model description, a reduction of manual  tasks in converting Boolean logic into a structural model, the elimination of manual processes in achieving  exclusive simulation of activity, an event-scheduling technique which does not deteriorate in economy as the event queue grows in length, and a simulation procedure which deals effectively with any mixture  of serial and simultaneous activities.  The passage of time is simulated in a precise, quantitative fashion  and systems to be simulated may be combinations of synchronous and asynchronous logic.  Certain aspects  of the techniques described may be used for the simulation of network structures other than digital networks.", "authors": "Ulrich, E. G.", "words_pool": ["achiev", "activ", "activ", "activ", "aspect", "asynchron", "behavior", "boolean", "clear", "combin", "convert", "deal", "descript", "detail", "deterior", "digit", "eas", "economi", "effect", "elimin", "essenti", "event", "exclus", "execut", "facil", "fashion", "gener", "grow", "handl", "improv", "larg", "length", "logic", "main", "mixtur", "model", "network", "network", "object", "obtain", "passag", "precis", "procedur", "process", "quantit", "queue", "reduct", "result", "schedul", "separ", "serial", "simul", "simul", "simul", "simultan", "sought", "space", "structur", "structur", "synchron", "system", "task", "techniqu", "techniqu", "time", "ulrich"], "word_count": {"achiev": 1, "activ": 4, "aspect": 1, "asynchron": 1, "behavior": 1, "boolean": 1, "clear": 1, "combin": 1, "convert": 1, "deal": 1, "descript": 1, "detail": 1, "deterior": 1, "digit": 2, "eas": 1, "economi": 3, "effect": 1, "elimin": 1, "essenti": 1, "event": 2, "exclus": 1, "execut": 1, "facil": 1, "fashion": 1, "gener": 1, "grow": 1, "handl": 1, "improv": 1, "larg": 1, "length": 1, "logic": 3, "main": 1, "mixtur": 1, "model": 3, "network": 3, "object": 1, "obtain": 1, "passag": 1, "precis": 1, "procedur": 1, "process": 1, "quantit": 1, "queue": 1, "reduct": 1, "result": 1, "schedul": 1, "separ": 1, "serial": 1, "simul": 6, "simultan": 2, "sought": 1, "space": 1, "structur": 3, "synchron": 1, "system": 2, "task": 1, "techniqu": 3, "time": 2, "ulrich": 1}}, "1929": {"id": "1929", "title": "Images from Computers and Microfilm Plotters", "abstract": "Digital computers are widely used for the processing of information and data of all kinds,  including the pictorial information contained in photographs and other graphical representations.  Efficient  conversion facilities for putting graphical information into the computer and retrieving it in graphical  form are therefore much needed.  One of the most commonly employed devices for obtaining permanent graphical  output from digital computers is the microfilm plotter.  Regrettably, present models have no provision  for producing images with a continuous gray scale or \"half tones.\"  In this note several programming techniques  are described for obtaining half tone pictures from a microfilm plotter under the control of a digital  computer.  Illustrative examples of several methods are given.", "authors": "Schroeder, M. R.", "words_pool": ["commonli", "comput", "comput", "contain", "continu", "control", "convers", "data", "devic", "digit", "effici", "employ", "exampl", "facil", "form", "graphic", "gray", "half", "illustr", "imag", "includ", "inform", "kind", "method", "microfilm", "model", "need", "note", "obtain", "output", "perman", "photograph", "pictori", "pictur", "plotter", "plotter", "present", "process", "produc", "program", "provis", "put", "regrett", "represent", "retriev", "scale", "techniqu", "tone", "tone", "wide", "schroeder"], "word_count": {"commonli": 1, "comput": 4, "contain": 1, "continu": 1, "control": 1, "convers": 1, "data": 1, "devic": 1, "digit": 3, "effici": 1, "employ": 1, "exampl": 1, "facil": 1, "form": 1, "graphic": 4, "gray": 1, "half": 2, "illustr": 1, "imag": 1, "includ": 1, "inform": 3, "kind": 1, "method": 1, "microfilm": 2, "model": 1, "need": 1, "note": 1, "obtain": 2, "output": 1, "perman": 1, "photograph": 1, "pictori": 1, "pictur": 1, "plotter": 2, "present": 1, "process": 1, "produc": 1, "program": 1, "provis": 1, "put": 1, "regrett": 1, "represent": 1, "retriev": 1, "scale": 1, "techniqu": 1, "tone": 2, "wide": 1, "schroeder": 1}}, "1930": {"id": "1930", "title": "Extremely Portable Random Number Generator", "abstract": "Extremely portable subroutines are sometimes needed for which moderate quality and efficiency  suffice.  Typically, this occurs for library functions (like random number generation and in core sorting)  which are not entirely universal or are not used in a standardized way.  The literature on random number  generators does not seem to contain an algorithm that meets requirements of this sort.  An extremely  portable 8-line FORTRAN program is provided which based on an important paper by Coveyou and MacPherson  (1967).Using their methods, Fourier analysis is applied to the probability function for the consecutive  n-tuples provided by our generator (with n less than or equal to 4).  While the small modulus which must  be used to maintain portability prevents the quality of the generator from being high, the generator  compares well with the bounds established in the above mentioned paper.", "authors": "Kruskal, J. B.", "words_pool": ["algorithm", "analysi", "appli", "base", "bound", "compar", "consecut", "core", "covey", "effici", "entir", "equal", "establish", "extrem", "fortran", "fourier", "function", "function", "gener", "gener", "gener", "high", "import", "librari", "line", "literatur", "macpherson", "maintain", "meet", "mention", "method", "moder", "modulu", "need", "number", "occur", "paper", "portabl", "portabl", "prevent", "probabl", "program", "provid", "qualiti", "random", "requir", "small", "sort", "sort", "standard", "subroutin", "suffic", "tupl", "typic", "univers", "kruskal"], "word_count": {"algorithm": 1, "analysi": 1, "appli": 1, "base": 1, "bound": 1, "compar": 1, "consecut": 1, "core": 1, "covey": 1, "effici": 1, "entir": 1, "equal": 1, "establish": 1, "extrem": 2, "fortran": 1, "fourier": 1, "function": 2, "gener": 5, "high": 1, "import": 1, "librari": 1, "line": 1, "literatur": 1, "macpherson": 1, "maintain": 1, "meet": 1, "mention": 1, "method": 1, "moder": 1, "modulu": 1, "need": 1, "number": 2, "occur": 1, "paper": 2, "portabl": 3, "prevent": 1, "probabl": 1, "program": 1, "provid": 2, "qualiti": 2, "random": 2, "requir": 1, "small": 1, "sort": 2, "standard": 1, "subroutin": 1, "suffic": 1, "tupl": 1, "typic": 1, "univers": 1, "kruskal": 1}}, "1931": {"id": "1931", "title": "Interval Arithmetic Determinant Evaluation and Its Use in Testing for a Chebyshev System", "abstract": "Two recent papers, one by Hansen and one by Hansen and R. R. Smith, have shown how Interval  Arithmetic (I", "authors": "Smith, L. B.", "words_pool": ["arithmet", "chebyshev", "determin", "evalu", "hansen", "interv", "paper", "recent", "shown", "smith", "system", "test", "smith"], "word_count": {"arithmet": 1, "chebyshev": 1, "determin": 1, "evalu": 1, "hansen": 2, "interv": 1, "paper": 1, "recent": 1, "shown": 1, "smith": 1, "system": 1, "test": 1}}, "1932": {"id": "1932", "title": "The Logarithmic Error and Newton's Method for the Square Root", "abstract": "The problem of obtaining optimal starting values for the calculation of the square root using  Newton's method is considered.  It has been pointed out elsewhere that if relative error is used as the  measure of goodness of fit, optimal results are not obtained when the initial approximation is a best  fit.  It is shown here that if, instead, the so-called logarithmic error is used, then a best initial  fit is optimal for both types of error.  Moreover, use of the logarithmic error appears to simplify the  problem of determining the optimal initial approximation.", "authors": "King, R. F. Phillips, D. L.", "words_pool": ["appear", "approxim", "calcul", "call", "consid", "determin", "error", "fit", "good", "initi", "logarithm", "measur", "method", "newton", "obtain", "obtain", "optim", "point", "problem", "rel", "result", "root", "shown", "simplifi", "squar", "start", "type", "valu", "king", "phillip"], "word_count": {"appear": 1, "approxim": 2, "calcul": 1, "call": 1, "consid": 1, "determin": 1, "error": 4, "fit": 3, "good": 1, "initi": 3, "logarithm": 2, "measur": 1, "method": 1, "newton": 1, "obtain": 2, "optim": 4, "point": 1, "problem": 2, "rel": 1, "result": 1, "root": 1, "shown": 1, "simplifi": 1, "squar": 1, "start": 1, "type": 1, "valu": 1, "king": 1, "phillip": 1}}, "1933": {"id": "1933", "title": "Coding the Lehmer Pseudo-random Number Generator", "abstract": "An algorithm and coding technique is presented for quick evaluation of the Lehmer pseudo-random  number generator modulo 2**31 - 1, a prime Mersenne number with produces 2**31 - 2 numbers, on a p-bit  (greater than 31) computer.  The computation method is extendible to limited problems in modular arithmetic.   Prime factorization for 2**61 - 2 and a primitive root for 2**61 - 1, the next largest prime Mersenne  number, are given for possible construction of a pseudo-random number generator of increased cycle length.", "authors": "Payne, W. H. Rabung, J. R. Bogyo, T. P.", "words_pool": ["algorithm", "arithmet", "bit", "code", "comput", "comput", "construct", "cycl", "evalu", "extend", "factor", "gener", "greater", "increas", "largest", "lehmer", "length", "limit", "mersenn", "method", "modular", "modulo", "number", "number", "present", "prime", "primit", "problem", "produc", "pseudo", "quick", "random", "root", "techniqu", "payn", "rabung", "bogyo"], "word_count": {"algorithm": 1, "arithmet": 1, "bit": 1, "code": 1, "comput": 2, "construct": 1, "cycl": 1, "evalu": 1, "extend": 1, "factor": 1, "gener": 2, "greater": 1, "increas": 1, "largest": 1, "lehmer": 1, "length": 1, "limit": 1, "mersenn": 2, "method": 1, "modular": 1, "modulo": 1, "number": 5, "present": 1, "prime": 3, "primit": 1, "problem": 1, "produc": 1, "pseudo": 2, "quick": 1, "random": 2, "root": 1, "techniqu": 1, "payn": 1, "rabung": 1, "bogyo": 1}}, "1934": {"id": "1934", "title": "On Arithmetic Expressions and Trees", "abstract": "A description is given of how a tree representing the evaluation of an arithmetic expression  can be drawn in such a way that the number of accumulators needed for the computation can be represented  in a straightforward manner.  This representation reduces the choice of the best order of computation  to a specific problem under the theory of graphs.  An algorithm to solve this problem is presented.", "authors": "Redziejowski, R. R.", "words_pool": ["accumul", "algorithm", "arithmet", "choic", "comput", "descript", "drawn", "evalu", "express", "express", "graph", "manner", "need", "number", "order", "present", "problem", "reduc", "represent", "repres", "repres", "solv", "specif", "straightforward", "theori", "tree", "tree", "redziejowski"], "word_count": {"accumul": 1, "algorithm": 1, "arithmet": 1, "choic": 1, "comput": 2, "descript": 1, "drawn": 1, "evalu": 1, "express": 1, "graph": 1, "manner": 1, "need": 1, "number": 1, "order": 1, "present": 1, "problem": 2, "reduc": 1, "represent": 1, "repres": 2, "solv": 1, "specif": 1, "straightforward": 1, "theori": 1, "tree": 1, "redziejowski": 1}}, "1935": {"id": "1935", "title": "Randomized Binary Search Technique", "abstract": "A mathematical model is developed for the mean and variance of the number of trials to recover  a given document in a randomly received list of files.  The search method described is binary in nature  and offers new potential for information retrieval systems.", "authors": "Arora, S. R. Dent, W. T.", "words_pool": ["binari", "develop", "document", "inform", "list", "mathemat", "mean", "method", "model", "natur", "number", "offer", "potenti", "random", "randomli", "receiv", "recov", "retriev", "search", "system", "techniqu", "trial", "varianc", "arora", "dent"], "word_count": {"binari": 1, "develop": 1, "document": 1, "inform": 1, "list": 1, "mathemat": 1, "mean": 1, "method": 1, "model": 1, "natur": 1, "number": 1, "offer": 1, "potenti": 1, "random": 1, "randomli": 1, "receiv": 1, "recov": 1, "retriev": 1, "search": 1, "system": 1, "techniqu": 1, "trial": 1, "varianc": 1, "arora": 1, "dent": 1}}, "1936": {"id": "1936", "title": "Variable Length Tree Structures Having Minimum Average Search Time", "abstract": "Sussenguth suggests in a paper (1963) that a file should be organized as a doubly-chained tree  structure if it is necessary both to search and to update frequently.  Such a structure provides a compromise  between the fast search/slow update characteristics of binary searching and the slow search/fast update  characteristics of serial searching.  His method, however, contains the limiting restriction that all  terminal nodes lie on the same level of the tree.  This paper considers the effect of relaxing this restriction.   First, trees which have the property that a priori the filial set of each node is well defined are studied.   It is proved that coding the nodes within each filial set with respect to the number of terminal nodes  reachable from each is necessary and sufficient to guarantee minimum average search time.  Then the more  general case (that is, where the entire structure of the tree is changeable) is treated.  A procedure  is developed for constructing a tree with a minimum average search time.  A simple closed expression  for this minimum average search time is obtained as a function of the number of terminal nodes.  The  storage capacity required to implement the doubly-chained tree structure on a digital computer is also  determined.  Finally, the total cost of the structure, using Sussenguth's cost criterion, is computed.   It is shown that significant improvements in both the average search time and the total cost can be  obtained by relaxing Sussenguth's restriction that all terminal nodes lie on the same level of the tree.", "authors": "Patt, Y. N.", "words_pool": ["averag", "binari", "capac", "case", "chain", "changeabl", "characterist", "close", "code", "compromis", "comput", "comput", "consid", "construct", "cost", "criterion", "defin", "determin", "develop", "digit", "doubli", "effect", "entir", "express", "fast", "filial", "final", "frequent", "function", "gener", "guarante", "implement", "improv", "length", "level", "lie", "limit", "method", "minimum", "node", "node", "number", "obtain", "organ", "paper", "priori", "procedur", "properti", "prove", "reachabl", "relax", "requir", "respect", "restrict", "search", "search", "serial", "set", "shown", "signific", "simpl", "slow", "storag", "structur", "structur", "studi", "suffici", "suggest", "sussenguth", "termin", "time", "total", "treat", "tree", "tree", "updat", "variabl", "patt"], "word_count": {"averag": 4, "binari": 1, "capac": 1, "case": 1, "chain": 2, "changeabl": 1, "characterist": 2, "close": 1, "code": 1, "compromis": 1, "comput": 2, "consid": 1, "construct": 1, "cost": 3, "criterion": 1, "defin": 1, "determin": 1, "develop": 1, "digit": 1, "doubli": 2, "effect": 1, "entir": 1, "express": 1, "fast": 2, "filial": 2, "final": 1, "frequent": 1, "function": 1, "gener": 1, "guarante": 1, "implement": 1, "improv": 1, "length": 1, "level": 2, "lie": 2, "limit": 1, "method": 1, "minimum": 3, "node": 6, "number": 2, "obtain": 2, "organ": 1, "paper": 2, "priori": 1, "procedur": 1, "properti": 1, "prove": 1, "reachabl": 1, "relax": 2, "requir": 1, "respect": 1, "restrict": 3, "search": 9, "serial": 1, "set": 2, "shown": 1, "signific": 1, "simpl": 1, "slow": 2, "storag": 1, "structur": 5, "studi": 1, "suffici": 1, "suggest": 1, "sussenguth": 3, "termin": 4, "time": 4, "total": 2, "treat": 1, "tree": 7, "updat": 3, "variabl": 1, "patt": 1}}, "1937": {"id": "1937", "title": "CODAS: A Data Display System", "abstract": "CODAS, a Customer Oriented Data System, is a user-oriented data retrieval and display system.   The command language of the system provides the user with an easy means for specifying data retrieval  and display requests.  Data is displayed as tables and graphs produced in a format ready for publication.   In this paper the statements of the request language and the general system design are described.", "authors": "Day, R. H. Mansfield, M. K. Ellis, M. E.", "words_pool": ["coda", "command", "custom", "data", "design", "display", "display", "easi", "format", "gener", "graph", "languag", "mean", "orient", "paper", "produc", "public", "readi", "request", "request", "retriev", "statement", "system", "tabl", "user", "day", "mansfield", "elli"], "word_count": {"coda": 1, "command": 1, "custom": 1, "data": 4, "design": 1, "display": 3, "easi": 1, "format": 1, "gener": 1, "graph": 1, "languag": 2, "mean": 1, "orient": 2, "paper": 1, "produc": 1, "public": 1, "readi": 1, "request": 2, "retriev": 2, "statement": 1, "system": 4, "tabl": 1, "user": 2, "day": 1, "mansfield": 1, "elli": 1}}, "1938": {"id": "1938", "title": "Some Criteria for Time-Sharing System Performance", "abstract": "Time-sharing systems, as defined in this article, are those multiaccess systems which permit  a terminal user to utilize essentially the full resources of the system while sharing its time with other  terminal users.  It is each terminal user's ability to utilize the full resources of the system that  makes quantitative evaluation of time-sharing systems particularly difficult.  Six criteria are described  which have been successfully used to perform first-level quantitative time-sharing system performance  evaluation.", "authors": "Stimler, S.", "words_pool": ["abil", "articl", "criteria", "defin", "difficult", "essenti", "evalu", "full", "level", "make", "multiaccess", "perform", "perform", "permit", "quantit", "resourc", "share", "success", "system", "system", "termin", "time", "user", "user", "util", "stimler"], "word_count": {"abil": 1, "articl": 1, "criteria": 1, "defin": 1, "difficult": 1, "essenti": 1, "evalu": 2, "full": 2, "level": 1, "make": 1, "multiaccess": 1, "perform": 2, "permit": 1, "quantit": 2, "resourc": 2, "share": 4, "success": 1, "system": 6, "termin": 3, "time": 4, "user": 3, "util": 2, "stimler": 1}}, "1939": {"id": "1939", "title": "Directed Random Generation of Sentences", "abstract": "The problem of producing sentences of a transformational grammar by using a random generator  to create phrase structure trees for input to the lexical insertion and transformational phases is discussed.   A purely random generator will produce base trees which will be blocked by the transformations, and  which are frequently too long to be of practical interest.  A solution is offered in the form of a computer  program which allows the user to constrain and direct the generation by the simple but powerful device  of restricted subtrees.  The program is a directed random generator which accepts as input a subtree  with restrictions and produces around it a tree which satisfies the restrictions and is ready for the  next phase of the grammar.  The underlying linguistic model is that at Noam Chomsky, as presented in  Aspects of the Theory of Syntax.  The program is written in FORTRAN IV for the IBM 360/67 and is part of a unified computer system for transformational grammar.  It is currently being used with several partial  grammars of English.", "authors": "Friedman, J.", "words_pool": ["accept", "aspect", "base", "block", "chomski", "comput", "constrain", "creat", "devic", "direct", "direct", "discuss", "english", "form", "fortran", "frequent", "gener", "gener", "grammar", "grammar", "ibm", "input", "insert", "interest", "iv", "lexic", "linguist", "long", "model", "noam", "offer", "part", "partial", "phase", "phase", "phrase", "power", "practic", "present", "problem", "produc", "produc", "produc", "program", "pure", "random", "readi", "restrict", "restrict", "satisfi", "sentenc", "simpl", "solut", "structur", "subtre", "subtre", "syntax", "system", "theori", "transform", "transform", "tree", "tree", "underli", "unifi", "user", "written", "friedman"], "word_count": {"accept": 1, "aspect": 1, "base": 1, "block": 1, "chomski": 1, "comput": 2, "constrain": 1, "creat": 1, "devic": 1, "direct": 2, "discuss": 1, "english": 1, "form": 1, "fortran": 1, "frequent": 1, "gener": 4, "grammar": 4, "ibm": 1, "input": 2, "insert": 1, "interest": 1, "iv": 1, "lexic": 1, "linguist": 1, "long": 1, "model": 1, "noam": 1, "offer": 1, "part": 1, "partial": 1, "phase": 2, "phrase": 1, "power": 1, "practic": 1, "present": 1, "problem": 1, "produc": 3, "program": 3, "pure": 1, "random": 3, "readi": 1, "restrict": 3, "satisfi": 1, "sentenc": 1, "simpl": 1, "solut": 1, "structur": 1, "subtre": 2, "syntax": 1, "system": 1, "theori": 1, "transform": 4, "tree": 3, "underli": 1, "unifi": 1, "user": 1, "written": 1, "friedman": 1}}, "1940": {"id": "1940", "title": "Calculation of a Polynomial and its Derivative Values by Horner Scheme (Algorithm 337 [C1])", "authors": "Smith, O. K.", "words_pool": ["algorithm", "c1", "calcul", "deriv", "horner", "polynomi", "scheme", "valu", "smith"], "word_count": {"algorithm": 1, "c1": 1, "calcul": 1, "deriv": 1, "horner": 1, "polynomi": 1, "scheme": 1, "valu": 1, "smith": 1}}, "1941": {"id": "1941", "title": "F-Distribution (Algorithm 322 [S14])", "authors": "Field, J. B. F.", "words_pool": ["algorithm", "distribut", "s14", "field"], "word_count": {"algorithm": 1, "distribut": 1, "s14": 1, "field": 1}}, "1942": {"id": "1942", "title": "Finding a Solution of N Functional Equations in N Unknowns (Algorithm 314 [C5])", "authors": "Vandergraft, J. Mesztenyi, C.", "words_pool": ["algorithm", "c5", "equat", "find", "function", "solut", "unknown", "vandergraft", "mesztenyi"], "word_count": {"algorithm": 1, "c5": 1, "equat": 1, "find": 1, "function": 1, "solut": 1, "unknown": 1, "vandergraft": 1, "mesztenyi": 1}}, "1943": {"id": "1943", "title": "Complete Elliptic Integrals (Algorithm 165 [S21])", "authors": "Farkas, I.", "words_pool": ["algorithm", "complet", "ellipt", "integr", "s21", "farka"], "word_count": {"algorithm": 1, "complet": 1, "ellipt": 1, "integr": 1, "s21": 1, "farka": 1}}, "1944": {"id": "1944", "title": "Student's t-Distribution (Algorithm 344 [S14])", "authors": "Levine, D. A.", "words_pool": ["algorithm", "distribut", "s14", "student", "levin"], "word_count": {"algorithm": 1, "distribut": 1, "s14": 1, "student": 1, "levin": 1}}, "1945": {"id": "1945", "title": "The Role of Programming in a Ph.D. Computer Science Program", "abstract": "In this general paper the role of programming in advanced graduate training is discussed.   Subject matter related to programming as well as programming per se is considered.  The  importance and  application of formalism are considered and also the need for good empirical experimentation.  A brief  outline for a sequence of courses is included, and subject headings that have been obtained from an extensive  bibliography are given.  A bibliography of programming references is included.", "authors": "Arden, B. W.", "words_pool": ["advanc", "applic", "bibliographi", "comput", "consid", "cours", "discuss", "empir", "experiment", "extens", "formal", "gener", "good", "graduat", "head", "import", "includ", "matter", "need", "obtain", "outlin", "paper", "ph", "program", "program", "refer", "relat", "role", "scienc", "se", "sequenc", "subject", "train", "arden"], "word_count": {"advanc": 1, "applic": 1, "bibliographi": 2, "comput": 1, "consid": 2, "cours": 1, "discuss": 1, "empir": 1, "experiment": 1, "extens": 1, "formal": 1, "gener": 1, "good": 1, "graduat": 1, "head": 1, "import": 1, "includ": 2, "matter": 1, "need": 1, "obtain": 1, "outlin": 1, "paper": 1, "ph": 1, "program": 4, "refer": 1, "relat": 1, "role": 1, "scienc": 1, "se": 1, "sequenc": 1, "subject": 2, "train": 1, "arden": 1}}, "1946": {"id": "1946", "title": "Computing Polynomial Resultants: Bezout's Determinant vs. Collins' Reduced P.R.S. Algorithm", "abstract": "Algorithms for computing the resultant of two polynomials in several variables, a key repetitive  step of computation in solving systems of polynomial equations by elimination, are studied.  Determining  the best algorithm for computer implementation depends upon the extent to which extraneous factors are  introduced, the extent of propagation of errors caused by truncation of real coefficients, memory requirements,  and computing speed.  Preliminary considerations narrow the choice of the best algorithm to Bezout's  determinant and Collins' reduced polynomial remainder sequence (p.r.s.) algorithm.  Detailed tests performed  on sample problems conclusively show that Bezout's determinant is superior in all respects except for  univariate polynomials, in which case Collins' reduced p.r.s. algorithm is somewhat faster.  In particular  Bezout's determinant proves to be strikingly superior in numerical accuracy, displaying excellent stability  with regard to round-off errors. Results of tests are reported in detail.", "authors": "Ku, S. Y. Adler, R. J.", "words_pool": ["accuraci", "algorithm", "algorithm", "bezout", "case", "caus", "choic", "coeffici", "collin", "comput", "comput", "comput", "conclus", "consider", "depend", "detail", "detail", "determin", "determin", "display", "elimin", "equat", "error", "excel", "extent", "extran", "factor", "faster", "implement", "introduc", "key", "memori", "narrow", "numer", "perform", "polynomi", "polynomi", "preliminari", "problem", "propag", "prove", "real", "reduc", "regard", "remaind", "repetit", "report", "requir", "respect", "result", "result", "result", "round", "sampl", "sequenc", "show", "solv", "speed", "stabil", "step", "strikingli", "studi", "superior", "system", "test", "truncat", "univari", "variabl", "ku", "adler"], "word_count": {"accuraci": 1, "algorithm": 5, "bezout": 3, "case": 1, "caus": 1, "choic": 1, "coeffici": 1, "collin": 2, "comput": 4, "conclus": 1, "consider": 1, "depend": 1, "detail": 2, "determin": 4, "display": 1, "elimin": 1, "equat": 1, "error": 2, "excel": 1, "extent": 2, "extran": 1, "factor": 1, "faster": 1, "implement": 1, "introduc": 1, "key": 1, "memori": 1, "narrow": 1, "numer": 1, "perform": 1, "polynomi": 4, "preliminari": 1, "problem": 1, "propag": 1, "prove": 1, "real": 1, "reduc": 2, "regard": 1, "remaind": 1, "repetit": 1, "report": 1, "requir": 1, "respect": 1, "result": 2, "round": 1, "sampl": 1, "sequenc": 1, "show": 1, "solv": 1, "speed": 1, "stabil": 1, "step": 1, "strikingli": 1, "studi": 1, "superior": 2, "system": 1, "test": 2, "truncat": 1, "univari": 1, "variabl": 1, "ku": 1, "adler": 1}}, "1947": {"id": "1947", "title": "Object code Optimization", "abstract": "Methods of analyzing the control flow and data flow of programs during compilation are applied  to transforming the program to improve object time efficiency.  Dominance relationships, indicating which  statements are necessarily executed before others, are used to do global common expression elimination  and loop identification.  Implementation of these and other optimizations in OS/360 FORTRAN H are described.", "authors": "Lowry, E. S. Medlock, C. W.", "words_pool": ["analyz", "appli", "code", "common", "compil", "control", "data", "domin", "effici", "elimin", "execut", "express", "flow", "fortran", "global", "identif", "implement", "improv", "indic", "loop", "method", "necessarili", "object", "optim", "optim", "os", "program", "program", "relationship", "statement", "time", "transform", "lowri", "medlock"], "word_count": {"analyz": 1, "appli": 1, "code": 1, "common": 1, "compil": 1, "control": 1, "data": 1, "domin": 1, "effici": 1, "elimin": 1, "execut": 1, "express": 1, "flow": 2, "fortran": 1, "global": 1, "identif": 1, "implement": 1, "improv": 1, "indic": 1, "loop": 1, "method": 1, "necessarili": 1, "object": 1, "optim": 1, "os": 1, "program": 2, "relationship": 1, "statement": 1, "time": 1, "transform": 1, "lowri": 1, "medlock": 1}}, "1948": {"id": "1948", "title": "Computers in Group Theory: a Survey", "abstract": "Computers are being applied to an increasingly diverse range of problems in group theory.   The most important areas of application at present are coset enumeration, subgroup lattices, automorphism  groups of finite groups, character tables, and commutator calculus.  Group theory programs range from  simple combinatorial or numerical programs to large symbol manipulation systems.  In this survey the  more important algorithms in use are described and contrasted, and results which have been obtained using  existing programs are indicated.  An extensive bibliography is included.", "authors": "Cannon, J. J.", "words_pool": ["algorithm", "applic", "appli", "area", "automorph", "bibliographi", "calculu", "charact", "combinatori", "commut", "comput", "contrast", "coset", "divers", "enumer", "exist", "extens", "finit", "group", "group", "import", "includ", "increasingli", "larg", "lattic", "manipul", "numer", "obtain", "present", "problem", "program", "rang", "result", "simpl", "subgroup", "survey", "symbol", "system", "tabl", "theori", "cannon"], "word_count": {"algorithm": 1, "applic": 1, "appli": 1, "area": 1, "automorph": 1, "bibliographi": 1, "calculu": 1, "charact": 1, "combinatori": 1, "commut": 1, "comput": 1, "contrast": 1, "coset": 1, "divers": 1, "enumer": 1, "exist": 1, "extens": 1, "finit": 1, "group": 4, "import": 2, "includ": 1, "increasingli": 1, "larg": 1, "lattic": 1, "manipul": 1, "numer": 1, "obtain": 1, "present": 1, "problem": 1, "program": 3, "rang": 2, "result": 1, "simpl": 1, "subgroup": 1, "survey": 1, "symbol": 1, "system": 1, "tabl": 1, "theori": 2, "cannon": 1}}, "1949": {"id": "1949", "title": "Finiteness Assumptions and Intellectual Isolation of Computer Scientists", "authors": "Wagner, R. A.", "words_pool": ["assumpt", "comput", "finit", "intellectu", "isol", "scientist", "wagner"], "word_count": {"assumpt": 1, "comput": 1, "finit": 1, "intellectu": 1, "isol": 1, "scientist": 1, "wagner": 1}}, "1950": {"id": "1950", "title": "Efficient Handling of Binary Data", "authors": "Raduchel, W. J.", "words_pool": ["binari", "data", "effici", "handl", "raduchel"], "word_count": {"binari": 1, "data": 1, "effici": 1, "handl": 1, "raduchel": 1}}, "1951": {"id": "1951", "title": "Estimates of Distributions of Random Variables for Certain Computer Communications Traffic Models", "abstract": "A study of multiaccess computer communications has characterized the distributions underlying an elementary  model of the user-computer interactive process.  The model used is elementary in the sense that many of the random variables that generally are of interest in computer communications studies can be decomposed into the elements of this model.  Data were examined from four operational multiaccess systems, and the model is shown to be robust; that is each of the variables of the model has the same distribution independent of which of the four systems is being examined.  It is shown that the gamma distribution can be used to describe the discrete variables.  Approximations to the gamma distribution by the exponential distribution are discussed for the systems studied.", "authors": "Fuchs, E. Jackson, P. E.", "words_pool": ["approxim", "character", "commun", "comput", "data", "decompos", "describ", "discret", "discuss", "distribut", "distribut", "elementari", "element", "estim", "examin", "exponenti", "gamma", "gener", "independ", "interact", "interest", "model", "model", "multiaccess", "oper", "process", "random", "robust", "sens", "shown", "studi", "studi", "studi", "system", "traffic", "underli", "user", "variabl", "fuch", "jackson"], "word_count": {"approxim": 1, "character": 1, "commun": 2, "comput": 3, "data": 1, "decompos": 1, "describ": 1, "discret": 1, "discuss": 1, "distribut": 5, "elementari": 2, "element": 1, "estim": 1, "examin": 2, "exponenti": 1, "gamma": 2, "gener": 1, "independ": 1, "interact": 1, "interest": 1, "model": 5, "multiaccess": 2, "oper": 1, "process": 1, "random": 1, "robust": 1, "sens": 1, "shown": 2, "studi": 3, "system": 3, "traffic": 1, "underli": 1, "user": 1, "variabl": 3, "fuch": 1, "jackson": 1}}, "1952": {"id": "1952", "title": "Index by Subject to Algorithms, 1970", "words_pool": ["algorithm", "index", "subject"], "word_count": {"algorithm": 1, "index": 1, "subject": 1}}, "1953": {"id": "1953", "title": "Exponential Integral Ei(x) (Algorithms 385 $S13))", "authors": "Redish, K. A.", "words_pool": ["algorithm", "ei", "exponenti", "integr", "s13", "redish"], "word_count": {"algorithm": 1, "ei": 1, "exponenti": 1, "integr": 1, "s13": 1, "redish": 1}}, "1954": {"id": "1954", "title": "Eigenvalues and Eigenvectors of a Real Symmetric Matrix (Algorithm 384 $F2))", "authors": "Stewart, G. W.", "words_pool": ["algorithm", "eigenvalu", "eigenvector", "f2", "matrix", "real", "symmetr", "stewart"], "word_count": {"algorithm": 1, "eigenvalu": 1, "eigenvector": 1, "f2": 1, "matrix": 1, "real": 1, "symmetr": 1, "stewart": 1}}, "1955": {"id": "1955", "title": "Characteristic Values and Associated Solutions of Mathieu's Differential Equation (Algorithm 352 $S22))", "authors": "Sale, A. H. J.", "words_pool": ["algorithm", "characterist", "differenti", "equat", "mathieu", "s22", "solut", "valu", "sale"], "word_count": {"algorithm": 1, "characterist": 1, "differenti": 1, "equat": 1, "mathieu": 1, "s22": 1, "solut": 1, "valu": 1, "sale": 1}}, "1956": {"id": "1956", "title": "Optimum Merging from Mass Storage", "abstract": "An algorithm is displayed which yields the merge orders such that the total read time, defined to be the sum of seek time plus data-transfer time, is minimized for a sort using mass storage. The analysis is parameterized in terms of the ratio of seek time to the time it takes to fill available core with records, and the file size in units of core lengths; and thus it can be applied to any conventional CPU/mass storage combination.  An explicit formula for total read time is derived, in terms of the parameters, which correlates very well with the total read time calculated using the optimum merge orders yielded by the algorithm.  The formula involves the roots of a simple  transcendental equation.  A short table of these roots is included.  Numerical results are graphically displayed for a wide range of the parameters.  It is found that the normalized read time for optimum merging on a given hardware configuration is proportional to the file length times the logarithm of the file length.", "authors": "Black, N. A.", "words_pool": ["algorithm", "analysi", "appli", "calcul", "combin", "configur", "convent", "core", "correl", "cpu", "data", "defin", "deriv", "display", "equat", "explicit", "fill", "formula", "found", "graphic", "hardwar", "includ", "involv", "length", "length", "logarithm", "mass", "merg", "merg", "minim", "normal", "numer", "optimum", "order", "parameter", "paramet", "proport", "rang", "ratio", "read", "record", "result", "root", "seek", "short", "simpl", "size", "sort", "storag", "sum", "tabl", "take", "term", "time", "time", "total", "transcendent", "transfer", "unit", "wide", "yield", "yield", "black"], "word_count": {"algorithm": 2, "analysi": 1, "appli": 1, "calcul": 1, "combin": 1, "configur": 1, "convent": 1, "core": 2, "correl": 1, "cpu": 1, "data": 1, "defin": 1, "deriv": 1, "display": 2, "equat": 1, "explicit": 1, "fill": 1, "formula": 2, "found": 1, "graphic": 1, "hardwar": 1, "includ": 1, "involv": 1, "length": 3, "logarithm": 1, "mass": 2, "merg": 3, "minim": 1, "normal": 1, "numer": 1, "optimum": 2, "order": 2, "parameter": 1, "paramet": 2, "proport": 1, "rang": 1, "ratio": 1, "read": 4, "record": 1, "result": 1, "root": 2, "seek": 2, "short": 1, "simpl": 1, "size": 1, "sort": 1, "storag": 2, "sum": 1, "tabl": 1, "take": 1, "term": 2, "time": 9, "total": 3, "transcendent": 1, "transfer": 1, "unit": 1, "wide": 1, "yield": 2, "black": 1}}, "1957": {"id": "1957", "title": "The List Set Generator: A Construct for Evaluating Set Expressions", "abstract": "The list set generator is defined and algorithms for its use are given.  The list set generator is a construct which may be added to a list processing system or any system that handles sets.  It efficiently generates the set which results from any expression involving sets and set operators.  The efficiency derives from evaluating the expression as a whole and in parallel, rather than evaluating subexpressions and then using those sets to arrive at the final result.", "authors": "Shapiro, S. C.", "words_pool": ["ad", "algorithm", "arriv", "construct", "defin", "deriv", "effici", "effici", "evalu", "express", "express", "final", "gener", "gener", "handl", "involv", "list", "oper", "parallel", "process", "result", "result", "set", "set", "subexpress", "system", "shapiro"], "word_count": {"ad": 1, "algorithm": 1, "arriv": 1, "construct": 1, "defin": 1, "deriv": 1, "effici": 2, "evalu": 2, "express": 2, "final": 1, "gener": 3, "handl": 1, "involv": 1, "list": 3, "oper": 1, "parallel": 1, "process": 1, "result": 2, "set": 7, "subexpress": 1, "system": 2, "shapiro": 1}}, "1958": {"id": "1958", "title": "Improving Round-off in Runge-Kutta Computations with Gill's Method", "abstract": "A Runge-Kutta-Gill scheme in common use is based on an incomplete adaptation for floating point operations of Gill's method.  An improved version reduces round-off error significantly.  In this note the heart of the scheme is presented in Fortran language.  It is then shown how an improved version of the method can be obtained with the addition of two Fortran statements.  The two version is a significant improvement.  A numerical example comparing the two is included.", "authors": "Thompson, R. J.", "words_pool": ["adapt", "addit", "base", "common", "compar", "comput", "error", "float", "fortran", "gill", "heart", "improv", "improv", "improv", "includ", "incomplet", "kutta", "languag", "method", "note", "numer", "obtain", "oper", "point", "present", "reduc", "round", "rung", "scheme", "shown", "signific", "significantli", "statement", "version", "thompson"], "word_count": {"adapt": 1, "addit": 1, "base": 1, "common": 1, "compar": 1, "comput": 1, "error": 1, "float": 1, "fortran": 2, "gill": 2, "heart": 1, "improv": 3, "includ": 1, "incomplet": 1, "kutta": 1, "languag": 1, "method": 2, "note": 1, "numer": 1, "obtain": 1, "oper": 1, "point": 1, "present": 1, "reduc": 1, "round": 1, "rung": 1, "scheme": 2, "shown": 1, "signific": 1, "significantli": 1, "statement": 1, "version": 3, "thompson": 1}}, "1959": {"id": "1959", "title": "An Interrupt Based Organization for Management Information Systems", "abstract": "A programming structure, language constructs, and a supervisory system  organization are proposed for the design and coding of large shared data base systems.  The bases for this organization are a generalized interrupt structure and the newly introduced concept of \"file tagging,\" which is the process of associating program structures and interrupt generating conditions with items in the data base.  An algorithm for resolving conflicts which arise in scheduling the interrupt processing routines is presented.  DPL, a programming language and supervisory system in which these concepts are implemented, is used to illustrated the new organization which is proposed for management information systems.", "authors": "Morgan, H. L.", "words_pool": ["algorithm", "aris", "associ", "base", "base", "base", "code", "concept", "concept", "condit", "conflict", "construct", "data", "design", "dpl", "gener", "gener", "illustr", "implement", "inform", "interrupt", "introduc", "item", "languag", "larg", "manag", "newli", "organ", "present", "process", "process", "program", "program", "propos", "resolv", "routin", "schedul", "share", "structur", "structur", "supervisori", "system", "system", "tag", "morgan"], "word_count": {"algorithm": 1, "aris": 1, "associ": 1, "base": 3, "code": 1, "concept": 2, "condit": 1, "conflict": 1, "construct": 1, "data": 2, "design": 1, "dpl": 1, "gener": 2, "illustr": 1, "implement": 1, "inform": 1, "interrupt": 3, "introduc": 1, "item": 1, "languag": 2, "larg": 1, "manag": 1, "newli": 1, "organ": 3, "present": 1, "process": 2, "program": 3, "propos": 2, "resolv": 1, "routin": 1, "schedul": 1, "share": 1, "structur": 3, "supervisori": 2, "system": 4, "tag": 1, "morgan": 1}}, "1960": {"id": "1960", "title": "Process Management and Resource Sharing in the Multiaccess System ESOPE", "abstract": "The main design principles of the multiaccess system ESOPE are described. Emphasis is placed on basic ideas underlying the design rather than on implementation details.  The main features of the system include the ability given to any user to schedule his own parallel processes using system primitive operations, the file-memory relationship, and the allocation-scheduling policy, which dynamically takes into account recent information about user behavior.", "authors": "Betourne, C. Boulenger, J. Ferrie, J. Kaiser, C. Krakowiak, S. Mossiere, J.", "words_pool": ["abil", "account", "alloc", "basic", "behavior", "design", "detail", "dynam", "emphasi", "esop", "featur", "idea", "implement", "includ", "inform", "main", "manag", "memori", "multiaccess", "oper", "parallel", "polici", "primit", "principl", "process", "process", "recent", "relationship", "resourc", "schedul", "schedul", "share", "system", "take", "underli", "user", "betourn", "bouleng", "ferri", "kaiser", "krakowiak", "mossier"], "word_count": {"abil": 1, "account": 1, "alloc": 1, "basic": 1, "behavior": 1, "design": 2, "detail": 1, "dynam": 1, "emphasi": 1, "esop": 1, "featur": 1, "idea": 1, "implement": 1, "includ": 1, "inform": 1, "main": 2, "manag": 1, "memori": 1, "multiaccess": 1, "oper": 1, "parallel": 1, "polici": 1, "primit": 1, "principl": 1, "process": 1, "recent": 1, "relationship": 1, "resourc": 1, "schedul": 2, "share": 1, "system": 3, "take": 1, "underli": 1, "user": 2, "betourn": 1, "bouleng": 1, "ferri": 1, "kaiser": 1, "krakowiak": 1, "mossier": 1}}, "1961": {"id": "1961", "title": "An Efficient Search Algorithm to Find the Elementary Circuits of a Graph", "abstract": "A theoretically most efficient search algorithm is presented which uses an exhaustive search to find all of the elementary circuits of a graph.  The algorithm can be easily modified to find all of the elementary circuits with a particular attribute such as length.  A rigorous proof of the algorithm is given as well as an example of its application.  Empirical bounds are presented relating the speed of the algorithm to the number of vertices and the number of arcs.  The speed is also related to the number of circuits in the graph to give a relation between speed and complexity. Extensions to undirected and s-graphs are discussed.", "authors": "Tiernan, J. C.", "words_pool": ["algorithm", "applic", "arc", "attribut", "bound", "circuit", "complex", "discuss", "easili", "effici", "elementari", "empir", "exhaust", "extens", "find", "give", "graph", "graph", "length", "modifi", "number", "present", "proof", "relat", "relat", "relat", "rigor", "search", "speed", "theoret", "undirect", "vertic", "tiernan"], "word_count": {"algorithm": 4, "applic": 1, "arc": 1, "attribut": 1, "bound": 1, "circuit": 3, "complex": 1, "discuss": 1, "easili": 1, "effici": 1, "elementari": 2, "empir": 1, "exhaust": 1, "extens": 1, "find": 2, "give": 1, "graph": 3, "length": 1, "modifi": 1, "number": 3, "present": 2, "proof": 1, "relat": 3, "rigor": 1, "search": 2, "speed": 3, "theoret": 1, "undirect": 1, "vertic": 1, "tiernan": 1}}, "1962": {"id": "1962", "title": "GROOVE-A Program to Compose, Store, and Edit Functions of Time", "abstract": "A program which makes possible creating, storing, reproducing, and editing functions of time is described.  The functions are typical of those generated by human beings.  Multiple functions (up to 14) are produced for long periods of time (up to several hours) at sufficiently high sampling rates to describe fast human reactions (up to 200 samples per second).  The functions can be used for a variety of purposes such as the control of machine tools or sound synthesizers or anything a person normally controls.  The program operates on a small computer (DDP-224).  Functions are stored on a disk file.  Functions may be created by real-time human inputs to the computer which can interact with already stored functions and computed functions.  Real-time feedback from the process being controlled is an important link in the system.  The environment for effective man-machine interaction has been carefully nurtured.", "authors": "Mathews, M. V. Moore, F. R.", "words_pool": ["be", "care", "compos", "comput", "comput", "control", "control", "control", "creat", "creat", "ddp", "describ", "disk", "edit", "edit", "effect", "environ", "fast", "feedback", "function", "gener", "groov", "high", "hour", "human", "import", "input", "interact", "interact", "link", "long", "machin", "make", "man", "multipl", "nurtur", "oper", "period", "person", "process", "produc", "program", "purpos", "rate", "reaction", "real", "reproduc", "sampl", "sampl", "small", "sound", "store", "store", "store", "suffici", "synthes", "system", "time", "tool", "typic", "varieti", "mathew", "moor"], "word_count": {"be": 1, "care": 1, "compos": 1, "comput": 3, "control": 3, "creat": 2, "ddp": 1, "describ": 1, "disk": 1, "edit": 1, "effect": 1, "environ": 1, "fast": 1, "feedback": 1, "function": 8, "gener": 1, "groov": 1, "high": 1, "hour": 1, "human": 3, "import": 1, "input": 1, "interact": 2, "link": 1, "long": 1, "machin": 2, "make": 1, "man": 1, "multipl": 1, "nurtur": 1, "oper": 1, "period": 1, "person": 1, "process": 1, "produc": 1, "program": 2, "purpos": 1, "rate": 1, "reaction": 1, "real": 2, "reproduc": 1, "sampl": 2, "small": 1, "sound": 1, "store": 3, "suffici": 1, "synthes": 1, "system": 1, "time": 4, "tool": 1, "typic": 1, "varieti": 1, "mathew": 1, "moor": 1}}, "1963": {"id": "1963", "title": "Condition Numbers of PEI Matrices", "authors": "Rokne, J.", "words_pool": ["condit", "matric", "number", "pei", "rokn"], "word_count": {"condit": 1, "matric": 1, "number": 1, "pei": 1, "rokn": 1}}, "1964": {"id": "1964", "title": "Comment on the Working Set Model for Program Behavior", "authors": "Bernstein, A.", "words_pool": ["behavior", "comment", "model", "program", "set", "work", "bernstein"], "word_count": {"behavior": 1, "comment": 1, "model": 1, "program": 1, "set": 1, "work": 1, "bernstein": 1}}, "1965": {"id": "1965", "title": "Correction to \"Logical\" Arithmetic on Computers with Two's Complement Binary Arithmetic", "authors": "Ehrman, J. R.", "words_pool": ["arithmet", "binari", "complement", "comput", "correct", "logic", "ehrman"], "word_count": {"arithmet": 2, "binari": 1, "complement": 1, "comput": 1, "correct": 1, "logic": 1, "ehrman": 1}}, "1966": {"id": "1966", "title": "A Generalized Method for Generating Argument/Function Values", "authors": "Wilson, W. J.", "words_pool": ["argument", "function", "gener", "gener", "method", "valu", "wilson"], "word_count": {"argument": 1, "function": 1, "gener": 2, "method": 1, "valu": 1, "wilson": 1}}, "1967": {"id": "1967", "title": "An Improved Algorithm to Produce Complex Primes (Algorithm 401 $A1))", "authors": "Bratley, P.", "words_pool": ["a1", "algorithm", "complex", "improv", "prime", "produc", "bratley"], "word_count": {"a1": 1, "algorithm": 2, "complex": 1, "improv": 1, "prime": 1, "produc": 1, "bratley": 1}}, "1968": {"id": "1968", "title": "Eigenvalues and Eigenvectors of a Real General Matrix (Algorithm 343 $F1))", "authors": "Knight, W. Mersereau, W.", "words_pool": ["algorithm", "eigenvalu", "eigenvector", "f1", "gener", "matrix", "real", "knight", "mersereau"], "word_count": {"algorithm": 1, "eigenvalu": 1, "eigenvector": 1, "f1": 1, "gener": 1, "matrix": 1, "real": 1, "knight": 1, "mersereau": 1}}, "1969": {"id": "1969", "title": "Increasing the Efficiency of Quicksort (Algorithm 402 $M1))", "authors": "Van Emden, M. H.", "words_pool": ["algorithm", "effici", "increas", "m1", "quicksort", "van", "emden"], "word_count": {"algorithm": 1, "effici": 1, "increas": 1, "m1": 1, "quicksort": 1, "van": 1, "emden": 1}}, "1970": {"id": "1970", "title": "Unrecorded Magnetic Tape for Information Interchange (9 Track-200 and 800 CPI, NRZI and 1600 CPI, PE)* (Proposed American National Standard)", "words_pool": ["american", "cpi", "inform", "interchang", "magnet", "nation", "nrzi", "pe", "propos", "standard", "tape", "track", "unrecord"], "word_count": {"american": 1, "cpi": 2, "inform": 1, "interchang": 1, "magnet": 1, "nation": 1, "nrzi": 1, "pe": 1, "propos": 1, "standard": 1, "tape": 1, "track": 1, "unrecord": 1}}, "1971": {"id": "1971", "title": "Recorded Magnetic Tape for Information Interchange (1600 CPI, Phase Encoded)* (Proposed American National Standard)", "words_pool": ["american", "cpi", "encod", "inform", "interchang", "magnet", "nation", "phase", "propos", "record", "standard", "tape"], "word_count": {"american": 1, "cpi": 1, "encod": 1, "inform": 1, "interchang": 1, "magnet": 1, "nation": 1, "phase": 1, "propos": 1, "record": 1, "standard": 1, "tape": 1}}, "1972": {"id": "1972", "title": "A  Nonrecursive List Compacting Algorithm", "abstract": "A simple nonrecursive list structure compacting scheme or garbage  collector suitable for both compact and LISP-like list structures is presented. The algorithm avoids the need for recursion by using the partial structure as  it is built up to keep track of those lists that have been copied.", "authors": "Cheney, C. J.", "words_pool": ["algorithm", "avoid", "built", "collector", "compact", "compact", "copi", "garbag", "lisp", "list", "list", "need", "nonrecurs", "partial", "present", "recurs", "scheme", "simpl", "structur", "structur", "suitabl", "track", "cheney"], "word_count": {"algorithm": 1, "avoid": 1, "built": 1, "collector": 1, "compact": 2, "copi": 1, "garbag": 1, "lisp": 1, "list": 3, "need": 1, "nonrecurs": 1, "partial": 1, "present": 1, "recurs": 1, "scheme": 1, "simpl": 1, "structur": 3, "suitabl": 1, "track": 1, "cheney": 1}}, "1973": {"id": "1973", "title": "The Linear Quotient Hash Code", "abstract": "A new method of hash coding is presented and is shown to possess desirable attributes.  Specifically, the algorithm is simple, efficient, and exhaustive, while needing little time per probe and using few probes per lookup.  Performance data and implementation hints are also given.", "authors": "Bell, J. R. Kaman, C. H.", "words_pool": ["algorithm", "attribut", "code", "code", "data", "desir", "effici", "exhaust", "hash", "hint", "implement", "linear", "lookup", "method", "need", "perform", "possess", "present", "probe", "probe", "quotient", "shown", "simpl", "specif", "time", "bell", "kaman"], "word_count": {"algorithm": 1, "attribut": 1, "code": 1, "data": 1, "desir": 1, "effici": 1, "exhaust": 1, "hash": 1, "hint": 1, "implement": 1, "linear": 1, "lookup": 1, "method": 1, "need": 1, "perform": 1, "possess": 1, "present": 1, "probe": 2, "quotient": 1, "shown": 1, "simpl": 1, "specif": 1, "time": 1, "bell": 1, "kaman": 1}}, "1974": {"id": "1974", "title": "NEATER2: A PL/I Source Statement Reformatter", "abstract": "NEATER2 accepts a PL/I source program and operates on it to produce a reformatted version.  When in the LOGICAL mode, NEATER2 indicates the logical structure of the source program in the indentation pattern of its output.  Logic errors discovered through NEATER2 logical analysis are discovered much more economically than is possible through compilation and trial runs.  A number of options are available to give the user full control over the output format and to maximize the utility of NEATER2 as an aid during the early stages of development of a PL/I source deck.  One option, USAGE, causes NEATER2 to insert into each logical unit of coding a statement which will case the number of times each one is executed to be recorded during execution.  This feature is expected to provide a major aid in optimization of PL/I programs.", "authors": "Conrow, K. Smith, R. G.", "words_pool": ["accept", "aid", "analysi", "case", "code", "compil", "control", "deck", "develop", "discov", "earli", "econom", "error", "execut", "execut", "expect", "featur", "format", "full", "give", "indent", "insert", "logic", "logic", "major", "maxim", "mode", "neater2", "number", "oper", "optim", "option", "option", "output", "pattern", "pl", "produc", "program", "program", "provid", "record", "reformat", "reformatt", "run", "sourc", "stage", "statement", "structur", "time", "trial", "unit", "usag", "user", "util", "version", "conrow", "smith"], "word_count": {"accept": 1, "aid": 2, "analysi": 1, "case": 1, "code": 1, "compil": 1, "control": 1, "deck": 1, "develop": 1, "discov": 2, "earli": 1, "econom": 1, "error": 1, "execut": 2, "expect": 1, "featur": 1, "format": 1, "full": 1, "give": 1, "indent": 1, "insert": 1, "logic": 5, "major": 1, "maxim": 1, "mode": 1, "neater2": 5, "number": 2, "oper": 1, "optim": 1, "option": 2, "output": 2, "pattern": 1, "pl": 3, "produc": 1, "program": 3, "provid": 1, "record": 1, "reformat": 1, "reformatt": 1, "run": 1, "sourc": 3, "stage": 1, "statement": 1, "structur": 1, "time": 1, "trial": 1, "unit": 1, "usag": 1, "user": 1, "util": 1, "version": 1, "conrow": 1, "smith": 1}}, "1975": {"id": "1975", "title": "A Multiple-Precision Division Algorithm", "abstract": "A generalized division algorithm for use with positive integral operands is  presented.  Depending upon the algebraic relationship of the first two ciphers of the divisor, one or at most two adjustments to the original  divisor and dividend must be performed before the division operation can be  initiated. The uniqueness of this method will cause each trial cipher in the  quotient to be either equal to or one greater than its final replacement.", "authors": "Mifsud, C. J.", "words_pool": ["adjust", "algebra", "algorithm", "cipher", "cipher", "depend", "dividend", "divis", "divisor", "equal", "final", "gener", "greater", "initi", "integr", "method", "multipl", "operand", "oper", "origin", "perform", "posit", "precis", "present", "quotient", "relationship", "replac", "trial", "uniqu", "mifsud"], "word_count": {"adjust": 1, "algebra": 1, "algorithm": 1, "cipher": 2, "depend": 1, "dividend": 1, "divis": 2, "divisor": 2, "equal": 1, "final": 1, "gener": 1, "greater": 1, "initi": 1, "integr": 1, "method": 1, "multipl": 1, "operand": 1, "oper": 1, "origin": 1, "perform": 1, "posit": 1, "precis": 1, "present": 1, "quotient": 1, "relationship": 1, "replac": 1, "trial": 1, "uniqu": 1, "mifsud": 1}}, "1976": {"id": "1976", "title": "Multi-attribute Retrieval with Combined Indexes", "abstract": "In this paper a file organization scheme designed to replace the use of the popular secondary index filing scheme (or inverted files on secondary key fields) is described. Through the use of redundancy and storing  keys (or access numbers of the records) that satisfy different combinations of secondary index values in \"buckets,\" it is possible to retrieve all keys satisfying any input query derived from a subset of fields by a single access to an index file, although each bucket may be used for many combinations of values and a combination of buckets may be required for a given query.  The method which, in its degenerate case, becomes the conventional secondary index filing scheme works similarly but has the following advantages: (1) the elimination of multiple accesses in many cases; (2) the elimination of false drops; (3) the elimination of computer time to perform intersection of key sets each qualified for one secondary index field only; and (4) the avoidance of long strings of keys when an index field appearing in a query has very few possible values.  Redundancy, in some  cases, is the same as the secondary indexing method. In the general case,  trade-off between the number of accesses for query and redundancy exists.", "authors": "Lum, V. Y.", "words_pool": ["access", "access", "advantag", "appear", "attribut", "avoid", "bucket", "bucket", "case", "case", "combin", "combin", "combin", "comput", "convent", "degener", "deriv", "design", "drop", "elimin", "exist", "fals", "field", "field", "file", "gener", "index", "index", "index", "input", "intersect", "invert", "key", "key", "long", "method", "multi", "multipl", "number", "number", "organ", "paper", "perform", "popular", "qualifi", "queri", "record", "redund", "replac", "requir", "retriev", "retriev", "satisfi", "satisfi", "scheme", "secondari", "set", "similarli", "singl", "store", "string", "subset", "time", "trade", "valu", "work", "lum"], "word_count": {"access": 4, "advantag": 1, "appear": 1, "attribut": 1, "avoid": 1, "bucket": 3, "case": 4, "combin": 3, "comput": 1, "convent": 1, "degener": 1, "deriv": 1, "design": 1, "drop": 1, "elimin": 3, "exist": 1, "fals": 1, "field": 4, "file": 2, "gener": 1, "index": 7, "input": 1, "intersect": 1, "invert": 1, "key": 5, "long": 1, "method": 2, "multi": 1, "multipl": 1, "number": 2, "organ": 1, "paper": 1, "perform": 1, "popular": 1, "qualifi": 1, "queri": 4, "record": 1, "redund": 3, "replac": 1, "requir": 1, "retriev": 1, "satisfi": 2, "scheme": 3, "secondari": 6, "set": 1, "similarli": 1, "singl": 1, "store": 1, "string": 1, "subset": 1, "time": 1, "trade": 1, "valu": 3, "work": 1, "lum": 1}}, "1977": {"id": "1977", "title": "An Interactive Display for Approximation by Linear Programming", "abstract": "An interactive program with a graphical display has been developed for the approximation of data by means of a linear combination of functions (including splines) selected by the user.  The coefficients of the approximation are determined by linear programming so as to minimize the error in either the L1 or L-infinity norm.  Auxiliary conditions such as monotonicity or convexity of the approximation can also be imposed. This interactive system is described and several examples of its use are given.", "authors": "LaFata, P. Rosen, J. B.", "words_pool": ["approxim", "auxiliari", "coeffici", "combin", "condit", "convex", "data", "determin", "develop", "display", "error", "exampl", "function", "graphic", "impos", "includ", "infin", "interact", "l1", "linear", "mean", "minim", "monoton", "norm", "program", "program", "select", "spline", "system", "user", "lafata", "rosen"], "word_count": {"approxim": 3, "auxiliari": 1, "coeffici": 1, "combin": 1, "condit": 1, "convex": 1, "data": 1, "determin": 1, "develop": 1, "display": 1, "error": 1, "exampl": 1, "function": 1, "graphic": 1, "impos": 1, "includ": 1, "infin": 1, "interact": 2, "l1": 1, "linear": 2, "mean": 1, "minim": 1, "monoton": 1, "norm": 1, "program": 2, "select": 1, "spline": 1, "system": 1, "user": 1, "lafata": 1, "rosen": 1}}, "1978": {"id": "1978", "title": "The Use of Interactive Graphics To Solve Numerical Problems", "abstract": "With the advent of on-line (time-sharing) computer systems and graphic terminals, we have available a new dimension in numerical problem solving capabilities.  Rather than simply use the new power to achieve fast turnaround, we can develop interactive routines which are easy to use and also take advantage of the insight and visual capabilities of the human problem solver.  Several on-line systems for general purpose mathematical problem solving have already been implemented as well as some special purpose systems for solving problems in a particular area such as ordinary differential equations.  The advantage of restricting the problem area is that the interface with a user can be greatly simplified. In this paper we discuss some of the advantages accrued by such systems and design considerations for interactive routines.  Furthermore, an implementation of an on-line least squares data-fitting program, PEG, is presented with results obtained from empirical data.  In conclusion, area for future work in this field are discussed.", "authors": "Smith, L. B.", "words_pool": ["accru", "achiev", "advantag", "advantag", "advent", "area", "capabl", "comput", "conclus", "consider", "data", "design", "develop", "differenti", "dimens", "discuss", "discuss", "easi", "empir", "equat", "fast", "field", "fit", "futur", "gener", "graphic", "graphic", "greatli", "human", "implement", "implement", "insight", "interact", "interfac", "line", "mathemat", "numer", "obtain", "ordinari", "paper", "peg", "power", "present", "problem", "problem", "program", "purpos", "restrict", "result", "routin", "share", "simplifi", "simpli", "solv", "solver", "solv", "special", "squar", "system", "take", "termin", "time", "turnaround", "user", "visual", "work", "smith"], "word_count": {"accru": 1, "achiev": 1, "advantag": 3, "advent": 1, "area": 3, "capabl": 2, "comput": 1, "conclus": 1, "consider": 1, "data": 2, "design": 1, "develop": 1, "differenti": 1, "dimens": 1, "discuss": 2, "easi": 1, "empir": 1, "equat": 1, "fast": 1, "field": 1, "fit": 1, "futur": 1, "gener": 1, "graphic": 1, "greatli": 1, "human": 1, "implement": 2, "insight": 1, "interact": 2, "interfac": 1, "line": 3, "mathemat": 1, "numer": 1, "obtain": 1, "ordinari": 1, "paper": 1, "peg": 1, "power": 1, "present": 1, "problem": 5, "program": 1, "purpos": 2, "restrict": 1, "result": 1, "routin": 2, "share": 1, "simplifi": 1, "simpli": 1, "solv": 3, "solver": 1, "special": 1, "squar": 1, "system": 4, "take": 1, "termin": 1, "time": 1, "turnaround": 1, "user": 1, "visual": 1, "work": 1, "smith": 1}}, "1979": {"id": "1979", "title": "Numerical Inversion of Laplace Transforms (Algorithm 368 $D5))", "authors": "Stehfest, H.", "words_pool": ["algorithm", "d5", "invers", "laplac", "numer", "transform", "stehfest"], "word_count": {"algorithm": 1, "d5": 1, "invers": 1, "laplac": 1, "numer": 1, "transform": 1, "stehfest": 1}}, "1980": {"id": "1980", "title": "An Efficient Algorithm for Sorting with Minimal Storage (Algorithm 347 $M1))", "authors": "Peto, R.", "words_pool": ["algorithm", "effici", "m1", "minim", "sort", "storag", "peto"], "word_count": {"algorithm": 2, "effici": 1, "m1": 1, "minim": 1, "sort": 1, "storag": 1, "peto": 1}}, "1981": {"id": "1981", "title": "Normal Curve Integral (Algorithm 304 $S15))", "authors": "Holmgren, B.", "words_pool": ["algorithm", "curv", "integr", "normal", "s15", "holmgren"], "word_count": {"algorithm": 1, "curv": 1, "integr": 1, "normal": 1, "s15": 1, "holmgren": 1}}, "1982": {"id": "1982", "title": "Modified Havie Integration (Algorithm 400 $D1))", "authors": "Wallick, G. C.", "words_pool": ["algorithm", "d1", "havi", "integr", "modifi", "wallick"], "word_count": {"algorithm": 1, "d1": 1, "havi": 1, "integr": 1, "modifi": 1, "wallick": 1}}, "1983": {"id": "1983", "title": "Spanning Tree $H) (Algorithm 399)", "authors": "Seppanen, J. J.", "words_pool": ["algorithm", "span", "tree", "seppanen"], "word_count": {"algorithm": 1, "span": 1, "tree": 1, "seppanen": 1}}, "1984": {"id": "1984", "title": "Tableless Date Conversion $Z) (Algorithm 398)", "authors": "Stone, R. A.", "words_pool": ["algorithm", "convers", "date", "tableless", "stone"], "word_count": {"algorithm": 1, "convers": 1, "date": 1, "tableless": 1, "stone": 1}}, "1985": {"id": "1985", "title": "An Integer Programming Problem $H) (Algorithm 397)", "authors": "Chang, S. K. Gill, A.", "words_pool": ["algorithm", "integ", "problem", "program", "chang", "gill"], "word_count": {"algorithm": 1, "integ": 1, "problem": 1, "program": 1, "chang": 1, "gill": 1}}, "1986": {"id": "1986", "title": "Student's t-Quantiles $S14) (Algorithm 396)", "authors": "Hill, G. W.", "words_pool": ["algorithm", "quantil", "s14", "student", "hill"], "word_count": {"algorithm": 1, "quantil": 1, "s14": 1, "student": 1, "hill": 1}}, "1987": {"id": "1987", "title": "Student's t-Distribution $S14) (Algorithm 395)", "authors": "Hill, G. W.", "words_pool": ["algorithm", "distribut", "s14", "student", "hill"], "word_count": {"algorithm": 1, "distribut": 1, "s14": 1, "student": 1, "hill": 1}}, "1988": {"id": "1988", "title": "A Formalism for Translator Interactions", "abstract": "A formalism is presented for describing the actions of processors for programming languages-compilers, interpreters, assemblers-and their interactions in complex systems such as compiler-compilers or extendible languages. The formalism here might be used to define and answer such a question as \"Can one do bootstrapping using a meta-compiler  whose metaphase is interpretive?\"  In addition an algorithm is presented for deciding whether or not a given system can be produced from a given set of component processors.", "authors": "Earley, J.", "words_pool": ["action", "addit", "algorithm", "answer", "assembl", "bootstrap", "compil", "compil", "complex", "compon", "decid", "defin", "describ", "extend", "formal", "interact", "interpret", "interpret", "languag", "meta", "metaphas", "present", "processor", "produc", "program", "question", "set", "system", "system", "translat", "earley"], "word_count": {"action": 1, "addit": 1, "algorithm": 1, "answer": 1, "assembl": 1, "bootstrap": 1, "compil": 4, "complex": 1, "compon": 1, "decid": 1, "defin": 1, "describ": 1, "extend": 1, "formal": 2, "interact": 1, "interpret": 2, "languag": 2, "meta": 1, "metaphas": 1, "present": 2, "processor": 2, "produc": 1, "program": 1, "question": 1, "set": 1, "system": 2, "translat": 1, "earley": 1}}, "1989": {"id": "1989", "title": "Transition Network Grammars for Natural Language Analysis", "abstract": "The use of augmented transition network grammars for the analysis of natural language sentences is described.  Structure-building actions associated with the arcs of the grammar network allow for the reordering, restructuring, and copying of constituents necessary to produce deep-structure representations of the type normally obtained from a transformational analysis, and conditions on the arcs allow for a powerful selectivity which can rule out meaningless analyses and take advantage of semantic information to guide the parsing.  The advantage of this model for natural language analysis are discussed in detail and illustrated by examples.  An implementation of an experimental parsing system for transition network grammars is briefly  described.", "authors": "Woods, W. A.", "words_pool": ["action", "advantag", "allow", "analys", "analysi", "arc", "augment", "briefli", "build", "condit", "constitu", "copi", "deep", "detail", "discuss", "exampl", "experiment", "grammar", "grammar", "guid", "illustr", "implement", "inform", "languag", "meaningless", "model", "natur", "network", "obtain", "pars", "power", "produc", "reorder", "represent", "restructur", "rule", "select", "semant", "sentenc", "structur", "system", "take", "transform", "transit", "type", "wood"], "word_count": {"action": 1, "advantag": 2, "allow": 2, "analys": 1, "analysi": 3, "arc": 2, "augment": 1, "briefli": 1, "build": 1, "condit": 1, "constitu": 1, "copi": 1, "deep": 1, "detail": 1, "discuss": 1, "exampl": 1, "experiment": 1, "grammar": 3, "guid": 1, "illustr": 1, "implement": 1, "inform": 1, "languag": 2, "meaningless": 1, "model": 1, "natur": 2, "network": 3, "obtain": 1, "pars": 2, "power": 1, "produc": 1, "reorder": 1, "represent": 1, "restructur": 1, "rule": 1, "select": 1, "semant": 1, "sentenc": 1, "structur": 2, "system": 1, "take": 1, "transform": 1, "transit": 2, "type": 1, "wood": 1}}, "1990": {"id": "1990", "title": "Numerical Constants (Algorithm)", "authors": "Dunham, C. B.", "words_pool": ["algorithm", "constant", "numer", "dunham"], "word_count": {"algorithm": 1, "constant": 1, "numer": 1, "dunham": 1}}, "1991": {"id": "1991", "title": "On the Number of Automorphisms of a Singly Generated Automaton", "authors": "Bavel, Z.", "words_pool": ["automaton", "automorph", "gener", "number", "singli", "bavel"], "word_count": {"automaton": 1, "automorph": 1, "gener": 1, "number": 1, "singli": 1, "bavel": 1}}, "1992": {"id": "1992", "title": "Comment on Bell's Quadratic Quotient Method for Hash Code Searching", "authors": "Lamport, L.", "words_pool": ["bell", "code", "comment", "hash", "method", "quadrat", "quotient", "search", "lamport"], "word_count": {"bell": 1, "code": 1, "comment": 1, "hash": 1, "method": 1, "quadrat": 1, "quotient": 1, "search": 1, "lamport": 1}}, "1993": {"id": "1993", "title": "Regular Coulomb Wave Functions (Algorithm 292 $S22))", "authors": "Cody, W. J. Paciorek, K. A.", "words_pool": ["algorithm", "coulomb", "function", "regular", "s22", "wave", "codi", "paciorek"], "word_count": {"algorithm": 1, "coulomb": 1, "function": 1, "regular": 1, "s22": 1, "wave": 1, "codi": 1, "paciorek": 1}}, "1994": {"id": "1994", "title": "Decision Table Translation $H) (Algorithm 394)", "authors": "Dial, R. B.", "words_pool": ["algorithm", "decis", "tabl", "translat", "dial"], "word_count": {"algorithm": 1, "decis": 1, "tabl": 1, "translat": 1, "dial": 1}}, "1995": {"id": "1995", "title": "Special Series Summation with Arbitrary Precision $C6) (Algorithm 393)", "authors": "Abdali, S. K.", "words_pool": ["algorithm", "arbitrari", "c6", "precis", "seri", "special", "summat", "abdali"], "word_count": {"algorithm": 1, "arbitrari": 1, "c6": 1, "precis": 1, "seri": 1, "special": 1, "summat": 1, "abdali": 1}}, "1996": {"id": "1996", "title": "Systems of Hyperbolic PDE $D3) (Algorithm 392)", "authors": "Smith, R. R. McCall, D.", "words_pool": ["algorithm", "d3", "hyperbol", "pde", "system", "smith", "mccall"], "word_count": {"algorithm": 1, "d3": 1, "hyperbol": 1, "pde": 1, "system": 1, "smith": 1, "mccall": 1}}, "1997": {"id": "1997", "title": "Increasing the Efficiency of Quicksort", "abstract": "A method is presented for the analysis of various generalizations of quicksort.  The average asymptotic number of comparisons needed is shown  to be an log^2(n).  A formula is derived expressing a in terms of the probability distribution of the \"bound\" of a partition.  This  formula assumes a particularly simple form for a generalization already considered by Hoare, namely, choice of the bound as median of a random sample. The main contribution of this paper is another generalization of quicksort, which uses a bounding interval instead of a single element as bound.  This generalization turns out to be easy to implement in a computer program.  A numerical approximation shows that a = 1.140 for this version of quicksort compared with 1.386 for the original.  This implies a decrease in number of comparisons of  18 percent; actual tests showed about 15 percent saving in computing time.", "authors": "van Emden, M. H.", "words_pool": ["actual", "analysi", "approxim", "assum", "asymptot", "averag", "bound", "bound", "choic", "compar", "comparison", "comput", "comput", "consid", "contribut", "decreas", "deriv", "distribut", "easi", "effici", "element", "express", "form", "formula", "gener", "gener", "hoar", "implement", "impli", "increas", "interv", "log", "main", "median", "method", "need", "number", "numer", "origin", "paper", "partit", "percent", "present", "probabl", "program", "quicksort", "random", "sampl", "save", "show", "shown", "show", "simpl", "singl", "term", "test", "time", "turn", "version", "van", "emden"], "word_count": {"actual": 1, "analysi": 1, "approxim": 1, "assum": 1, "asymptot": 1, "averag": 1, "bound": 4, "choic": 1, "compar": 1, "comparison": 2, "comput": 2, "consid": 1, "contribut": 1, "decreas": 1, "deriv": 1, "distribut": 1, "easi": 1, "effici": 1, "element": 1, "express": 1, "form": 1, "formula": 2, "gener": 4, "hoar": 1, "implement": 1, "impli": 1, "increas": 1, "interv": 1, "log": 1, "main": 1, "median": 1, "method": 1, "need": 1, "number": 2, "numer": 1, "origin": 1, "paper": 1, "partit": 1, "percent": 2, "present": 1, "probabl": 1, "program": 1, "quicksort": 3, "random": 1, "sampl": 1, "save": 1, "show": 2, "shown": 1, "simpl": 1, "singl": 1, "term": 1, "test": 1, "time": 1, "turn": 1, "version": 1, "van": 1, "emden": 1}}, "1998": {"id": "1998", "title": "Complex Matrix Inversion Versus Real", "abstract": "A comparison of complex matrix with real matrix inversion is made.  It is shown that the complex inversion can be up to  twice as fast as the real inversion.  Further, the rounding error bound for complex inversion is about one-eighth that of real, for Gaussian elimination.  Using extended inner product accumulation the bound is half of the real system.", "authors": "Ehrlich, L. W.", "words_pool": ["accumul", "bound", "comparison", "complex", "eighth", "elimin", "error", "extend", "fast", "gaussian", "half", "invers", "made", "matrix", "product", "real", "round", "shown", "system", "versu", "ehrlich"], "word_count": {"accumul": 1, "bound": 2, "comparison": 1, "complex": 3, "eighth": 1, "elimin": 1, "error": 1, "extend": 1, "fast": 1, "gaussian": 1, "half": 1, "invers": 4, "made": 1, "matrix": 2, "product": 1, "real": 4, "round": 1, "shown": 1, "system": 1, "versu": 1, "ehrlich": 1}}, "1999": {"id": "1999", "title": "Optimal Starting Approximations for Generating Square Root for Slow or No Divide", "abstract": "On machine with slow or no division, it is preferable to use an iterative scheme for the square root different from the classical Heron scheme.  The problem of optimal initial  approximants is considered, and some optimal polynomial initial  approximations are tabulated.", "authors": "Wilson, M. W.", "words_pool": ["approxim", "approxim", "classic", "consid", "divid", "divis", "gener", "heron", "initi", "iter", "machin", "optim", "polynomi", "prefer", "problem", "root", "scheme", "slow", "squar", "start", "tabul", "wilson"], "word_count": {"approxim": 2, "classic": 1, "consid": 1, "divid": 1, "divis": 1, "gener": 1, "heron": 1, "initi": 2, "iter": 1, "machin": 1, "optim": 2, "polynomi": 1, "prefer": 1, "problem": 1, "root": 1, "scheme": 2, "slow": 1, "squar": 1, "start": 1, "tabul": 1, "wilson": 1}}, "2000": {"id": "2000", "title": "A Variation of the Goodman-Lance Method for the Solution of Two-Point Boundary Value Problems", "abstract": "A recently published method for the interpolative solution of nonlinear equations is improved, and applied to give a significant variation of the Goodman-Lance method for the solution of two-point boundary value problems.  The resulting method applies in particular to the numerical solution of optimal control problems in the Euler-Lagrange formulation. Quantitative estimates are presented which indicate that the variation is nearly twice as fast on some problems in the latter context.", "authors": "Kimble, G. W.", "words_pool": ["appli", "appli", "boundari", "context", "control", "equat", "estim", "euler", "fast", "formul", "give", "goodman", "improv", "interpol", "lagrang", "lanc", "method", "nearli", "nonlinear", "numer", "optim", "point", "present", "problem", "publish", "quantit", "recent", "result", "signific", "solut", "variat", "kimbl"], "word_count": {"appli": 2, "boundari": 1, "context": 1, "control": 1, "equat": 1, "estim": 1, "euler": 1, "fast": 1, "formul": 1, "give": 1, "goodman": 1, "improv": 1, "interpol": 1, "lagrang": 1, "lanc": 1, "method": 3, "nearli": 1, "nonlinear": 1, "numer": 1, "optim": 1, "point": 1, "present": 1, "problem": 3, "publish": 1, "quantit": 1, "recent": 1, "result": 1, "signific": 1, "solut": 3, "variat": 2, "kimbl": 1}}, "2001": {"id": "2001", "title": "Integrating Square Roots", "abstract": "Differential equation of the (y')^2 = f(y) are difficult to integrate  numerically because of the singularity at points where f(y) vanishes.  A  simple trick removes the singularity.", "authors": "Moler, C. B. Solomon, L. P.", "words_pool": ["differenti", "difficult", "equat", "integr", "integr", "numer", "point", "remov", "root", "simpl", "singular", "squar", "trick", "vanish", "moler", "solomon"], "word_count": {"differenti": 1, "difficult": 1, "equat": 1, "integr": 1, "numer": 1, "point": 1, "remov": 1, "root": 1, "simpl": 1, "singular": 2, "squar": 1, "trick": 1, "vanish": 1, "moler": 1, "solomon": 1}}, "2002": {"id": "2002", "title": "AMESPLOT-A Higher Level Data Plotting Software System", "abstract": "AMESPLOT is an extensible software system designed to make the display of  data as simple, painless, and neat as possible.  The system described is  hardware-independent and has been implemented on a variety of installations, of different manufacturers, having diverse configurations.  The elements  common to all types of data plots are outlined and the way in which these  elements may be combined into a system based on simple modules is demonstrated. These modules are specified independently and are independent of the axis systems or other attributes of the plot.  This enables plots of any complexity to be constructed by adding or replacing modules.  The basic syntax of AMESPLOT is outlined, and a brief description is given of its current utility software, consisting of \"macros\" to produce self-scaled plots, formal tablets of text-interspersed with subplots, map coastlines, and 3-D plots.  The system was formulate d in a way such that the user could supply the minimum of information, and it should be fully integrable with user's program written in most conventional higher languages.  The functions of positioning, locating, and scaling (in the layout of multiple subplots) of axes, labels, and all other elements of the plot are handled automatically by the software system unless the user specifies otherwise.  The structuring  of plots from multiple, independent, self-contained subplots is described. Transformation, projection, scaling, rotation, or shifting of entire plots or  subplots by the action of one or more simple modules is possible.  The user  may interact freely with AMESPLOT at three levels, enabling him to construct  his own data markers, alphabetic characters, and transformations, and to produce a variety of artistic and other effects.", "authors": "Hirschsoln, I.", "words_pool": ["action", "ad", "alphabet", "amesplot", "artist", "attribut", "axe", "axi", "base", "basic", "charact", "coastlin", "combin", "common", "complex", "configur", "consist", "construct", "construct", "contain", "convent", "data", "demonstr", "descript", "design", "display", "divers", "effect", "element", "enabl", "enabl", "entir", "extens", "formal", "formul", "freeli", "fulli", "function", "handl", "hardwar", "higher", "implement", "independ", "independ", "inform", "instal", "integr", "interact", "interspers", "label", "languag", "layout", "level", "level", "locat", "macro", "make", "manufactur", "map", "marker", "minimum", "modul", "multipl", "neat", "outlin", "painless", "plot", "plot", "plot", "posit", "produc", "program", "project", "replac", "rotat", "scale", "scale", "shift", "simpl", "softwar", "specifi", "structur", "subplot", "suppli", "syntax", "system", "system", "tablet", "text", "transform", "transform", "type", "user", "util", "varieti", "written", "hirschsoln"], "word_count": {"action": 1, "ad": 1, "alphabet": 1, "amesplot": 3, "artist": 1, "attribut": 1, "axe": 1, "axi": 1, "base": 1, "basic": 1, "charact": 1, "coastlin": 1, "combin": 1, "common": 1, "complex": 1, "configur": 1, "consist": 1, "construct": 2, "contain": 1, "convent": 1, "data": 3, "demonstr": 1, "descript": 1, "design": 1, "display": 1, "divers": 1, "effect": 1, "element": 3, "enabl": 2, "entir": 1, "extens": 1, "formal": 1, "formul": 1, "freeli": 1, "fulli": 1, "function": 1, "handl": 1, "hardwar": 1, "higher": 1, "implement": 1, "independ": 4, "inform": 1, "instal": 1, "integr": 1, "interact": 1, "interspers": 1, "label": 1, "languag": 1, "layout": 1, "level": 1, "locat": 1, "macro": 1, "make": 1, "manufactur": 1, "map": 1, "marker": 1, "minimum": 1, "modul": 4, "multipl": 2, "neat": 1, "outlin": 2, "painless": 1, "plot": 8, "posit": 1, "produc": 2, "program": 1, "project": 1, "replac": 1, "rotat": 1, "scale": 3, "shift": 1, "simpl": 3, "softwar": 3, "specifi": 1, "structur": 1, "subplot": 4, "suppli": 1, "syntax": 1, "system": 6, "tablet": 1, "text": 1, "transform": 2, "type": 1, "user": 4, "util": 1, "varieti": 2, "written": 1, "hirschsoln": 1}}, "2003": {"id": "2003", "title": "An Interactive Software System for Computers-Aided Design:  An Application to Circuit Project", "abstract": "The characteristics of an interactive software system, intended to constitute  an interface between designer and computer during various steps of the design process, are presented.  The main emphasis is given to the description of the features of the two high level user oriented languages, operating at different levels, on which the interaction is based.  The first one is IMOL, an interactive monitor language, which is designed to perform the overall and control functions of the software system; its design criteria provide the user with commands which are both simple and efficient in order to perform all the functions needed in computer-aided circuit design.  The second one is  COIF, a circuit oriented graphic language, which is designed to describe, generate, and manipulate graphic problem specifications;  it is an  extension of Fortran with graphic-type variables, so that the designer who is familiar with Fortran need not learn a new  language.  The application to computer-aided circuit design is in particular examined; on the other hand, the adopted design criteria provide sufficient generality to extend the use of the two languages  to different computer-assisted applications.", "authors": "Bracchi, G. Somalvico, M.", "words_pool": ["adopt", "aid", "applic", "applic", "assist", "base", "characterist", "circuit", "coif", "command", "comput", "comput", "constitut", "control", "criteria", "describ", "descript", "design", "design", "design", "effici", "emphasi", "examin", "extend", "extens", "familiar", "featur", "fortran", "function", "gener", "gener", "graphic", "hand", "high", "imol", "intend", "interact", "interact", "interfac", "languag", "languag", "learn", "level", "level", "main", "manipul", "monitor", "need", "need", "oper", "order", "orient", "perform", "present", "problem", "process", "project", "provid", "simpl", "softwar", "specif", "step", "suffici", "system", "type", "user", "variabl", "bracchi", "somalvico"], "word_count": {"adopt": 1, "aid": 2, "applic": 2, "assist": 1, "base": 1, "characterist": 1, "circuit": 3, "coif": 1, "command": 1, "comput": 4, "constitut": 1, "control": 1, "criteria": 2, "describ": 1, "descript": 1, "design": 9, "effici": 1, "emphasi": 1, "examin": 1, "extend": 1, "extens": 1, "familiar": 1, "featur": 1, "fortran": 2, "function": 2, "gener": 2, "graphic": 3, "hand": 1, "high": 1, "imol": 1, "intend": 1, "interact": 3, "interfac": 1, "languag": 5, "learn": 1, "level": 2, "main": 1, "manipul": 1, "monitor": 1, "need": 2, "oper": 1, "order": 1, "orient": 2, "perform": 2, "present": 1, "problem": 1, "process": 1, "project": 1, "provid": 2, "simpl": 1, "softwar": 2, "specif": 1, "step": 1, "suffici": 1, "system": 2, "type": 1, "user": 2, "variabl": 1, "bracchi": 1, "somalvico": 1}}, "2004": {"id": "2004", "title": "A Procedure for Generation of Three-dimensional Half-toned Computer Graphics Presentations", "abstract": "A description is given of an algorithm for producing computer generated  half-tone presentations of three-dimensional polygonal surface structures.   This algorithm achieves a significant increase in speed of computation over  the Warnock algorithm developed at the University of Utah and implemented also on the Coordinated Science Laboratory CDC 1604 computer system at the University of Illinois.  The history leading to the algorithm development and then the algorithm itself are described. Results are presented and are compared with computer runs achieved by the Warnock approach.  An extension of the procedure to variable position illumination sources is also given.", "authors": "Bouknight, W. J.", "words_pool": ["achiev", "achiev", "algorithm", "approach", "cdc", "compar", "comput", "comput", "coordin", "descript", "develop", "develop", "dimension", "extens", "gener", "gener", "graphic", "half", "histori", "illinoi", "illumin", "implement", "increas", "laboratori", "lead", "polygon", "posit", "present", "present", "procedur", "produc", "result", "run", "scienc", "signific", "sourc", "speed", "structur", "surfac", "system", "tone", "tone", "univers", "utah", "variabl", "warnock", "bouknight"], "word_count": {"achiev": 2, "algorithm": 5, "approach": 1, "cdc": 1, "compar": 1, "comput": 4, "coordin": 1, "descript": 1, "develop": 2, "dimension": 1, "extens": 1, "gener": 1, "graphic": 1, "half": 1, "histori": 1, "illinoi": 1, "illumin": 1, "implement": 1, "increas": 1, "laboratori": 1, "lead": 1, "polygon": 1, "posit": 1, "present": 2, "procedur": 1, "produc": 1, "result": 1, "run": 1, "scienc": 1, "signific": 1, "sourc": 1, "speed": 1, "structur": 1, "surfac": 1, "system": 1, "tone": 1, "univers": 2, "utah": 1, "variabl": 1, "warnock": 2, "bouknight": 1}}, "2005": {"id": "2005", "title": "Proposed Revision of American National Standard X3.21-1967, \"Rectangular Holes in Twelve-Row Punched Cards\"*", "words_pool": ["american", "card", "hole", "nation", "propos", "punch", "rectangular", "revis", "row", "standard", "twelv", "x3"], "word_count": {"american": 1, "card": 1, "hole": 1, "nation": 1, "propos": 1, "punch": 1, "rectangular": 1, "revis": 1, "row": 1, "standard": 1, "twelv": 1, "x3": 1}}, "2006": {"id": "2006", "title": "Proposed American National Standard", "authors": "Kerpelman, C.", "words_pool": ["american", "nation", "propos", "standard", "kerpelman"], "word_count": {"american": 1, "nation": 1, "propos": 1, "standard": 1, "kerpelman": 1}}, "2007": {"id": "2007", "title": "Algorithms Policy/Revised August 1970", "words_pool": ["algorithm", "august", "polici", "revis"], "word_count": {"algorithm": 1, "august": 1, "polici": 1, "revis": 1}}, "2008": {"id": "2008", "title": "Gaussian Quadrature Formulas (Algorithm 331 $D1))", "authors": "Wise Jr., W. R.", "words_pool": ["algorithm", "d1", "formula", "gaussian", "quadratur", "wise", "jr"], "word_count": {"algorithm": 1, "d1": 1, "formula": 1, "gaussian": 1, "quadratur": 1, "wise": 1, "jr": 1}}, "2009": {"id": "2009", "title": "Simpson's Rule for Multiple Integration (Algorithm 233 $D1))", "authors": "Proll, L. G.", "words_pool": ["algorithm", "d1", "integr", "multipl", "rule", "simpson", "proll"], "word_count": {"algorithm": 1, "d1": 1, "integr": 1, "multipl": 1, "rule": 1, "simpson": 1, "proll": 1}}, "2010": {"id": "2010", "title": "Unitary Symmetric Polynomials $Z) (Algorithm 391)", "authors": "McKay, J.", "words_pool": ["algorithm", "polynomi", "symmetr", "unitari", "mckay"], "word_count": {"algorithm": 1, "polynomi": 1, "symmetr": 1, "unitari": 1, "mckay": 1}}, "2011": {"id": "2011", "title": "Sequency Ordered Walsh Functions $S22) (Algorithm 390)", "authors": "Hubner, H.", "words_pool": ["algorithm", "function", "order", "s22", "sequenc", "walsh", "hubner"], "word_count": {"algorithm": 1, "function": 1, "order": 1, "s22": 1, "sequenc": 1, "walsh": 1, "hubner": 1}}, "2012": {"id": "2012", "title": "Binary Ordered Walsh Functions $S22) (Algorithm 389)", "authors": "Hubner, H.", "words_pool": ["algorithm", "binari", "function", "order", "s22", "walsh", "hubner"], "word_count": {"algorithm": 1, "binari": 1, "function": 1, "order": 1, "s22": 1, "walsh": 1, "hubner": 1}}, "2013": {"id": "2013", "title": "Rademacher Function $S22) (Algorithm 388)", "authors": "Hubner, H.", "words_pool": ["algorithm", "function", "rademach", "s22", "hubner"], "word_count": {"algorithm": 1, "function": 1, "rademach": 1, "s22": 1, "hubner": 1}}, "2014": {"id": "2014", "title": "Function Minimization and Linear Search $E4) (Algorithm 387)", "authors": "Fielding, K.", "words_pool": ["algorithm", "e4", "function", "linear", "minim", "search", "field"], "word_count": {"algorithm": 1, "e4": 1, "function": 1, "linear": 1, "minim": 1, "search": 1, "field": 1}}, "2015": {"id": "2015", "title": "A Technique for Generating Almost Optimal Floyd-Evans Productions for Precedence Grammars", "abstract": "A technique is developed for generating almost optimal Floyd-Evans productions  given a precedence grammar. A graph formulation is used for the problem of  merging productions.  The productions generated correspond to the minimum cost  inverse-arborescence of that graph.  The validity of the technique is demonstrated for weak precedence grammars defined here, but the productions mechanically generated for any precedence grammar can often be modified in  such a way that correct, almost optimal parsers are obtained.", "authors": "Ichbiah, J. D. Morse, S. P.", "words_pool": ["arboresc", "correct", "correspond", "cost", "defin", "demonstr", "develop", "evan", "floyd", "formul", "gener", "gener", "grammar", "grammar", "graph", "invers", "mechan", "merg", "minimum", "modifi", "obtain", "optim", "parser", "preced", "problem", "product", "techniqu", "valid", "weak", "ichbiah", "mors"], "word_count": {"arboresc": 1, "correct": 1, "correspond": 1, "cost": 1, "defin": 1, "demonstr": 1, "develop": 1, "evan": 1, "floyd": 1, "formul": 1, "gener": 3, "grammar": 3, "graph": 2, "invers": 1, "mechan": 1, "merg": 1, "minimum": 1, "modifi": 1, "obtain": 1, "optim": 2, "parser": 1, "preced": 3, "problem": 1, "product": 4, "techniqu": 2, "valid": 1, "weak": 1, "ichbiah": 1, "mors": 1}}, "2016": {"id": "2016", "title": "The Instrumentation of Multics", "abstract": "An array of measuring tools devised to aid in the implementation of a prototype computer utility is discussed.  These tools include special hardware clocks and data channels, general purpose programmed probing and recording tools, and specialized measurement facilities.  Some particular measurements of interest in a system which combines demand  paging with multiprogramming are described in detail.  Where appropriate,  insight into effectiveness (or lack there of) of individual tools is provided.", "authors": "Gintell, J. W. Saltzer, J. H.", "words_pool": ["aid", "array", "channel", "clock", "combin", "comput", "data", "demand", "detail", "devis", "discuss", "effect", "facil", "gener", "hardwar", "implement", "includ", "individu", "insight", "instrument", "interest", "lack", "measur", "measur", "measur", "multic", "multiprogram", "page", "probe", "program", "prototyp", "provid", "purpos", "record", "special", "special", "system", "tool", "util", "gintel", "saltzer"], "word_count": {"aid": 1, "array": 1, "channel": 1, "clock": 1, "combin": 1, "comput": 1, "data": 1, "demand": 1, "detail": 1, "devis": 1, "discuss": 1, "effect": 1, "facil": 1, "gener": 1, "hardwar": 1, "implement": 1, "includ": 1, "individu": 1, "insight": 1, "instrument": 1, "interest": 1, "lack": 1, "measur": 3, "multic": 1, "multiprogram": 1, "page": 1, "probe": 1, "program": 1, "prototyp": 1, "provid": 1, "purpos": 1, "record": 1, "special": 2, "system": 1, "tool": 4, "util": 1, "gintel": 1, "saltzer": 1}}, "2017": {"id": "2017", "title": "Sorting in a Paging Environment", "abstract": "This sorting study was part of an extensive measurement project undertaken on the M44/44X, an experimental paging system which was conceived and implemented at IBM Research in order to explore the virtual machine concept.  The study was concerned with the implementation  of sorting procedures in the context of the dynamic paging environment characteristic of virtual memory machines.  Descriptions of  the experimental sort programs and analysis of the performance measurement results obtained for them are presented. The insight gained  from the experimental effort is used to arrive at a set of broad guidelines for writing sort programs for a paging environment.", "authors": "Brawn, B. S. Gustavson, G. Mankin, E. S.", "words_pool": ["44x", "analysi", "arriv", "broad", "characterist", "conceiv", "concept", "concern", "context", "descript", "dynam", "effort", "environ", "experiment", "explor", "extens", "gain", "guidelin", "ibm", "implement", "implement", "insight", "m44", "machin", "machin", "measur", "memori", "obtain", "order", "page", "part", "perform", "present", "procedur", "program", "project", "research", "result", "set", "sort", "sort", "studi", "system", "undertaken", "virtual", "write", "brawn", "gustavson", "mankin"], "word_count": {"44x": 1, "analysi": 1, "arriv": 1, "broad": 1, "characterist": 1, "conceiv": 1, "concept": 1, "concern": 1, "context": 1, "descript": 1, "dynam": 1, "effort": 1, "environ": 2, "experiment": 3, "explor": 1, "extens": 1, "gain": 1, "guidelin": 1, "ibm": 1, "implement": 2, "insight": 1, "m44": 1, "machin": 2, "measur": 2, "memori": 1, "obtain": 1, "order": 1, "page": 3, "part": 1, "perform": 1, "present": 1, "procedur": 1, "program": 2, "project": 1, "research": 1, "result": 1, "set": 1, "sort": 4, "studi": 2, "system": 1, "undertaken": 1, "virtual": 2, "write": 1, "brawn": 1, "gustavson": 1, "mankin": 1}}, "2018": {"id": "2018", "title": "Full Table Quadratic Searching for Scatter Storage", "abstract": "The quadratic residue search method for hash tables avoids much of the clustering experienced with a linear search method.  The simple quadratic search only accesses half the table.  It has been shown that when the length of the table is a prime of the form 4n+3, where n  is an integer, the whole table may be accessed by two quadratic searches plus a separate access for the original entry point. A search  method is presented which is computationally simple, has all the advantages  of the quadratic search, and yet accesses all the table in one sweep.", "authors": "Day, A. C.", "words_pool": ["4n", "access", "access", "access", "advantag", "avoid", "cluster", "comput", "entri", "experienc", "form", "full", "half", "hash", "integ", "length", "linear", "method", "origin", "point", "present", "prime", "quadrat", "residu", "scatter", "search", "search", "search", "separ", "shown", "simpl", "storag", "sweep", "tabl", "tabl", "day"], "word_count": {"4n": 1, "access": 4, "advantag": 1, "avoid": 1, "cluster": 1, "comput": 1, "entri": 1, "experienc": 1, "form": 1, "full": 1, "half": 1, "hash": 1, "integ": 1, "length": 1, "linear": 1, "method": 3, "origin": 1, "point": 1, "present": 1, "prime": 1, "quadrat": 4, "residu": 1, "scatter": 1, "search": 6, "separ": 1, "shown": 1, "simpl": 2, "storag": 1, "sweep": 1, "tabl": 5, "day": 1}}, "2019": {"id": "2019", "title": "Normalization Techniques for Hand printed Numerals", "abstract": "Family of pattern standardization techniques based on geometrical projection is applied to a file of digitized hand printed numerals obtained from sales clerks. The principle involves transforming a quadrilateral specified in terms of the convex hull of each pattern into a square. The amount of overlap within each class of characters versus the amount between classes is used to evaluate the degree of normalization achieved with respect to other  published methods including size and shear normalization through moments.", "authors": "Nagy, G. Tuong, N.", "words_pool": ["achiev", "amount", "appli", "base", "charact", "class", "class", "clerk", "convex", "degre", "digit", "evalu", "famili", "geometr", "hand", "hull", "includ", "involv", "method", "moment", "normal", "numer", "obtain", "overlap", "pattern", "principl", "print", "project", "publish", "quadrilater", "respect", "sale", "shear", "size", "squar", "standard", "techniqu", "term", "transform", "versu", "nagi", "tuong"], "word_count": {"achiev": 1, "amount": 2, "appli": 1, "base": 1, "charact": 1, "class": 2, "clerk": 1, "convex": 1, "degre": 1, "digit": 1, "evalu": 1, "famili": 1, "geometr": 1, "hand": 1, "hull": 1, "includ": 1, "involv": 1, "method": 1, "moment": 1, "normal": 2, "numer": 1, "obtain": 1, "overlap": 1, "pattern": 2, "principl": 1, "print": 1, "project": 1, "publish": 1, "quadrilater": 1, "respect": 1, "sale": 1, "shear": 1, "size": 1, "squar": 1, "standard": 1, "techniqu": 1, "term": 1, "transform": 1, "versu": 1, "nagi": 1, "tuong": 1}}, "2020": {"id": "2020", "title": "The Allocation of Computer Resources-Is Pricing the Answer?", "abstract": "The widespread use of complex third generation computing systems has led to a  much broader concern about the means by which the resources of these systems are allocated among the user community.  One means that is suggested more and more frequently is a pricing procedure.  In this paper the manner in which one would like to allocate computing resources is considered, and then the extent to which a pricing mechanism fits this mold  is discussed.  Inasmuch as pricing must serve as a rationing mechanism at  times, consideration is given to the means by which prices can be adjusted  flexibly in order to make a dynamic allocation of resources.  Consideration is  also given to the means by which users can be insulated from the harmful  effects of frequent price fluctuations.  Although the subject of pricing has been given a lot of attention recently, a number of misconceptions persist about its purpose and its operation.  An attempt is made to clarify  some of these misunderstandings and to highlight the advantages and  disadvantages and to highlight the advantages and disadvantages of pricing. Two illustrative pricing systems are also discussed in order to demonstrate the  applicability of pricing in quite different environments.", "authors": "Nielsen, N. R.", "words_pool": ["adjust", "advantag", "alloc", "alloc", "alloc", "answer", "applic", "attempt", "attent", "broader", "clarifi", "commun", "complex", "comput", "comput", "concern", "consider", "consid", "demonstr", "disadvantag", "discuss", "dynam", "effect", "environ", "extent", "fit", "flexibl", "fluctuat", "frequent", "frequent", "gener", "harm", "highlight", "illustr", "insul", "led", "lot", "made", "make", "manner", "mean", "mechan", "misconcept", "misunderstand", "mold", "number", "oper", "order", "paper", "persist", "price", "price", "price", "procedur", "purpos", "ration", "recent", "resourc", "serv", "subject", "suggest", "system", "time", "user", "user", "widespread", "nielsen"], "word_count": {"adjust": 1, "advantag": 2, "alloc": 3, "answer": 1, "applic": 1, "attempt": 1, "attent": 1, "broader": 1, "clarifi": 1, "commun": 1, "complex": 1, "comput": 2, "concern": 1, "consider": 2, "consid": 1, "demonstr": 1, "disadvantag": 2, "discuss": 2, "dynam": 1, "effect": 1, "environ": 1, "extent": 1, "fit": 1, "flexibl": 1, "fluctuat": 1, "frequent": 2, "gener": 1, "harm": 1, "highlight": 2, "illustr": 1, "insul": 1, "led": 1, "lot": 1, "made": 1, "make": 1, "manner": 1, "mean": 4, "mechan": 2, "misconcept": 1, "misunderstand": 1, "mold": 1, "number": 1, "oper": 1, "order": 2, "paper": 1, "persist": 1, "price": 9, "procedur": 1, "purpos": 1, "ration": 1, "recent": 1, "resourc": 3, "serv": 1, "subject": 1, "suggest": 1, "system": 3, "time": 1, "user": 2, "widespread": 1, "nielsen": 1}}, "2021": {"id": "2021", "title": "A Comment on Axiomatic Approaches to Programming", "authors": "Hunt, B.R.", "words_pool": ["approach", "axiomat", "comment", "program", "hunt"], "word_count": {"approach": 1, "axiomat": 1, "comment": 1, "program": 1, "hunt": 1}}, "2022": {"id": "2022", "title": "Note on an Anomaly in Paging", "authors": "Pomeranz,J. E.", "words_pool": ["anomali", "note", "page", "pomeranz"], "word_count": {"anomali": 1, "note": 1, "page": 1, "pomeranz": 1}}, "2023": {"id": "2023", "title": "A Note on Data Base Deadlocks", "authors": "Baecker, H. D.", "words_pool": ["base", "data", "deadlock", "note", "baecker"], "word_count": {"base": 1, "data": 1, "deadlock": 1, "note": 1, "baecker": 1}}, "2024": {"id": "2024", "title": "Comments on a Paper by Lowe", "authors": "Sattley, K. Millstein, R.", "words_pool": ["comment", "low", "paper", "sattley", "millstein"], "word_count": {"comment": 1, "low": 1, "paper": 1, "sattley": 1, "millstein": 1}}, "2025": {"id": "2025", "title": "Student's t-Distribution; Jacobi Polynomials; Modified Romberg Quadrature; Factorial Analysis of Variance; (Algorithms 332,344,351,359)", "authors": "Sale, A. H. J.", "words_pool": ["algorithm", "analysi", "distribut", "factori", "jacobi", "modifi", "polynomi", "quadratur", "romberg", "student", "varianc", "sale"], "word_count": {"algorithm": 1, "analysi": 1, "distribut": 1, "factori": 1, "jacobi": 1, "modifi": 1, "polynomi": 1, "quadratur": 1, "romberg": 1, "student": 1, "varianc": 1, "sale": 1}}, "2026": {"id": "2026", "title": "Exponential Integral (Algorithm 385 $S13))", "authors": "Ng, E. W.", "words_pool": ["algorithm", "exponenti", "integr", "s13", "ng"], "word_count": {"algorithm": 1, "exponenti": 1, "integr": 1, "s13": 1, "ng": 1}}, "2027": {"id": "2027", "title": "Ricatti-Bessel Functions of First and Second Kind (Algorithm 22 $S17))", "authors": "Bray, T.", "words_pool": ["algorithm", "bessel", "function", "kind", "ricatti", "s17", "bray"], "word_count": {"algorithm": 1, "bessel": 1, "function": 1, "kind": 1, "ricatti": 1, "s17": 1, "bray": 1}}, "2028": {"id": "2028", "title": "Greatest Common Divisor of n Integers and Multipliers $A1) (Algorithm 386)", "authors": "Bradley, G. H.", "words_pool": ["a1", "algorithm", "common", "divisor", "greatest", "integ", "multipli", "bradley"], "word_count": {"a1": 1, "algorithm": 1, "common": 1, "divisor": 1, "greatest": 1, "integ": 1, "multipli": 1, "bradley": 1}}, "2029": {"id": "2029", "title": "Exponential Integral $S13) (Algorithm 385)", "authors": "Paciorek, K. A.", "words_pool": ["algorithm", "exponenti", "integr", "s13", "paciorek"], "word_count": {"algorithm": 1, "exponenti": 1, "integr": 1, "s13": 1, "paciorek": 1}}, "2030": {"id": "2030", "title": "Context-Sensitive Parsing", "abstract": "This paper presents a canonical form for context-sensitive derivations and a parsing algorithm which finds each context-sensitive analysis once and only once.  The amount of memory required by the algorithm is essentially no more than the required to  store a single complete derivation.  In addition, a modified version of the basic algorithm is presented which blocks infinite analyses  for grammars which contain loops.  The algorithm is also compared with several previous parsers for context-sensitive grammars and general rewriting systems, and the difference between the two types of analyses is discussed.  The algorithm appears to be complementary to an algorithm by S. Kuno in several respects, including  the space-time trade-off and the degree of context dependence involved.", "authors": "Woods, W. A.", "words_pool": ["addit", "algorithm", "amount", "analys", "analysi", "appear", "basic", "block", "canon", "compar", "complementari", "complet", "context", "degre", "depend", "deriv", "deriv", "differ", "discuss", "essenti", "find", "form", "gener", "grammar", "includ", "infinit", "involv", "kuno", "loop", "memori", "modifi", "paper", "parser", "pars", "present", "present", "previou", "requir", "respect", "rewrit", "sensit", "singl", "space", "store", "system", "time", "trade", "type", "version", "wood"], "word_count": {"addit": 1, "algorithm": 6, "amount": 1, "analys": 2, "analysi": 1, "appear": 1, "basic": 1, "block": 1, "canon": 1, "compar": 1, "complementari": 1, "complet": 1, "context": 4, "degre": 1, "depend": 1, "deriv": 2, "differ": 1, "discuss": 1, "essenti": 1, "find": 1, "form": 1, "gener": 1, "grammar": 2, "includ": 1, "infinit": 1, "involv": 1, "kuno": 1, "loop": 1, "memori": 1, "modifi": 1, "paper": 1, "parser": 1, "pars": 1, "present": 2, "previou": 1, "requir": 2, "respect": 1, "rewrit": 1, "sensit": 3, "singl": 1, "space": 1, "store": 1, "system": 1, "time": 1, "trade": 1, "type": 1, "version": 1, "wood": 1}}, "2031": {"id": "2031", "title": "Algorithm and Bound for the Greatest Common Divisor of n Integers", "abstract": "A new version of the Euclidean algorithm for finding the greatest common divisor of n integers a(i) and multipliers x(i) such that gcd = x(1)a(1) + ... + x(n)a(n) is presented.  The number of arithmetic operations and the number of storage locations are linear in n.  A theorem of Lame that gives a bound  for the number of iterations of the Euclidean algorithm for two integers  is extended to the case of n integers.  An algorithm to construct a minimal  set of multipliers is presented.  A Fortran program for the algorithm appears  as Comm. ACM Algorithm 386.", "authors": "Bradley, G. H.", "words_pool": ["acm", "algorithm", "appear", "arithmet", "bound", "case", "comm", "common", "construct", "divisor", "euclidean", "extend", "find", "fortran", "gcd", "greatest", "integ", "iter", "lame", "linear", "locat", "minim", "multipli", "number", "oper", "present", "program", "set", "storag", "theorem", "version", "bradley"], "word_count": {"acm": 1, "algorithm": 5, "appear": 1, "arithmet": 1, "bound": 1, "case": 1, "comm": 1, "common": 1, "construct": 1, "divisor": 1, "euclidean": 2, "extend": 1, "find": 1, "fortran": 1, "gcd": 1, "greatest": 1, "integ": 3, "iter": 1, "lame": 1, "linear": 1, "locat": 1, "minim": 1, "multipli": 2, "number": 3, "oper": 1, "present": 2, "program": 1, "set": 1, "storag": 1, "theorem": 1, "version": 1, "bradley": 1}}, "2032": {"id": "2032", "title": "File Structures Using Hashing Functions", "abstract": "A general method of file structuring is proposed which uses a hashing function to define tree structure.  Two types of such trees are examined,  and their relation to trees studied in the past is explained.Results for the  probability distributions of path lengths are derived and illustrated.", "authors": "Coffman Jr., E. G. Eve, J.", "words_pool": ["defin", "deriv", "distribut", "examin", "explain", "function", "function", "gener", "hash", "illustr", "length", "method", "past", "path", "probabl", "propos", "relat", "result", "structur", "structur", "structur", "studi", "tree", "tree", "type", "coffman", "jr", "eve"], "word_count": {"defin": 1, "deriv": 1, "distribut": 1, "examin": 1, "explain": 1, "function": 1, "gener": 1, "hash": 1, "illustr": 1, "length": 1, "method": 1, "past": 1, "path": 1, "probabl": 1, "propos": 1, "relat": 1, "result": 1, "structur": 2, "studi": 1, "tree": 3, "type": 1, "coffman": 1, "jr": 1, "eve": 1}}, "2033": {"id": "2033", "title": "Space/Time Trade-offs in Hash Coding with Allowable Errors", "abstract": "In this paper trade-offs among certain computational factors a given set of messages.  Two new hash-coding methods are examined and compared with a particular conventional hash-coding method. The computational factors considered are the size of the hash area (space), the time required to identify a message as a nonmember of the  given set (reject time), and an allowable error frequency.  The new methods  are intended to reduce the amount of space required to contain the hash-coded  information from that associated with conventional methods.  The reduction in  space is accomplished by exploiting the possibility that a small fraction of  errors of commission may be tolerable in some applications, in particular,  applications in which a large amount of data is involved and a core resident hash area is consequently not feasible using conventional methods.  In such  applications, it is envisaged that overall performance could be improved by using a smaller core resident hash area in conjunction with the new methods and, when necessary, by using some secondary and perhaps time-consuming test to \"catch\" the small fraction of errors associated with new methods.  An example is discussed which illustrates possible areas of application for the new methods.  Analysis of the paradigm problem demonstrates that allowing a small number of test messages to be falsely identified as members of the given set will permit a much smaller hash area to be used without increasing reject time.", "authors": "Bloom, B. H.", "words_pool": ["accomplish", "allow", "allow", "amount", "analysi", "applic", "applic", "area", "area", "catch", "code", "code", "commiss", "compar", "comput", "conjunct", "consid", "consum", "convent", "core", "data", "demonstr", "discuss", "envisag", "error", "error", "examin", "exploit", "factor", "fals", "feasibl", "fraction", "frequenc", "hash", "identifi", "identifi", "illustr", "improv", "increas", "inform", "intend", "involv", "larg", "member", "messag", "messag", "method", "method", "nonmemb", "number", "off", "paper", "paradigm", "perform", "permit", "possibl", "problem", "reduc", "reduct", "reject", "requir", "resid", "secondari", "set", "size", "small", "smaller", "space", "test", "time", "toler", "trade", "bloom"], "word_count": {"accomplish": 1, "allow": 2, "amount": 2, "analysi": 1, "applic": 4, "area": 5, "catch": 1, "code": 3, "commiss": 1, "compar": 1, "comput": 2, "conjunct": 1, "consid": 1, "consum": 1, "convent": 3, "core": 2, "data": 1, "demonstr": 1, "discuss": 1, "envisag": 1, "error": 3, "examin": 1, "exploit": 1, "factor": 2, "fals": 1, "feasibl": 1, "fraction": 2, "frequenc": 1, "hash": 7, "identifi": 2, "illustr": 1, "improv": 1, "increas": 1, "inform": 1, "intend": 1, "involv": 1, "larg": 1, "member": 1, "messag": 3, "method": 8, "nonmemb": 1, "number": 1, "off": 1, "paper": 1, "paradigm": 1, "perform": 1, "permit": 1, "possibl": 1, "problem": 1, "reduc": 1, "reduct": 1, "reject": 2, "requir": 2, "resid": 2, "secondari": 1, "set": 3, "size": 1, "small": 3, "smaller": 2, "space": 3, "test": 2, "time": 4, "toler": 1, "trade": 1, "bloom": 1}}, "2034": {"id": "2034", "title": "The Mobile Programming System: STAGE2", "abstract": "STAGE2 is the second level of a bootstrap sequence which is easily implemented on any computer.  It is a flexible, provided by STAGE2 are summarized, and the implementation techniques which have made it possible to have STAGE2 running on a new machine with less than one man-week of effort are discussed.  The approach has been successful on over 15 machines of widely varying characteristics.", "authors": "Waite, W. M.", "words_pool": ["approach", "bootstrap", "characterist", "comput", "discuss", "easili", "effort", "flexibl", "implement", "implement", "level", "machin", "machin", "made", "man", "mobil", "program", "provid", "run", "sequenc", "stage2", "success", "summar", "system", "techniqu", "vari", "week", "wide", "wait"], "word_count": {"approach": 1, "bootstrap": 1, "characterist": 1, "comput": 1, "discuss": 1, "easili": 1, "effort": 1, "flexibl": 1, "implement": 2, "level": 1, "machin": 2, "made": 1, "man": 1, "mobil": 1, "program": 1, "provid": 1, "run": 1, "sequenc": 1, "stage2": 3, "success": 1, "summar": 1, "system": 1, "techniqu": 1, "vari": 1, "week": 1, "wide": 1, "wait": 1}}, "2035": {"id": "2035", "title": "Conversational Access to a 2048-Word Machine", "abstract": "LAP6 is an on-line system running on a 2048-word LINC which provides full  facilities for text editing, automatic filing and file maintenance, and  program preparation and assembly.  It focuses on the preparation and editing  of continuously displayed 23,040-character text strings (manuscripts) which can be positioned anywhere by the user and edited by simply adding and deleting lines as though working directly on an elastic scroll. Other features are available through a uniform command set which itself can  be augmented by the user.  The machine, although small, aids program design by providing display scope and premarked randomly addressable LINC tapes as standard items, in an environment similar to that of a sophisticated terminal.  The tapes are logically  similar to a disk.  Priority was given to the design of efficient tape algorithms to minimize the limitations of the small memory.  Techniques  developed for handling scroll editing, filing, and the layered system  structure are outlined.  LAP6 is used by about 2000 people in 11 countries.   Its design was strongly influenced by performance criteria established in  interviews held with LINC users themselves during the specification period.", "authors": "Wilkes, M. A.", "words_pool": ["access", "ad", "address", "aid", "algorithm", "assembl", "augment", "automat", "charact", "command", "continu", "convers", "countri", "criteria", "delet", "design", "develop", "directli", "disk", "display", "display", "edit", "edit", "effici", "elast", "environ", "establish", "facil", "featur", "file", "focus", "full", "handl", "held", "influenc", "interview", "item", "lap6", "layer", "limit", "linc", "line", "line", "logic", "machin", "mainten", "manuscript", "memori", "minim", "outlin", "peopl", "perform", "period", "posit", "premark", "prepar", "prioriti", "program", "provid", "randomli", "run", "scope", "scroll", "set", "similar", "simpli", "small", "sophist", "specif", "standard", "string", "strongli", "structur", "system", "tape", "tape", "techniqu", "termin", "text", "uniform", "user", "user", "word", "work", "wilk"], "word_count": {"access": 1, "ad": 1, "address": 1, "aid": 1, "algorithm": 1, "assembl": 1, "augment": 1, "automat": 1, "charact": 1, "command": 1, "continu": 1, "convers": 1, "countri": 1, "criteria": 1, "delet": 1, "design": 3, "develop": 1, "directli": 1, "disk": 1, "display": 2, "edit": 4, "effici": 1, "elast": 1, "environ": 1, "establish": 1, "facil": 1, "featur": 1, "file": 2, "focus": 1, "full": 1, "handl": 1, "held": 1, "influenc": 1, "interview": 1, "item": 1, "lap6": 2, "layer": 1, "limit": 1, "linc": 3, "line": 2, "logic": 1, "machin": 1, "mainten": 1, "manuscript": 1, "memori": 1, "minim": 1, "outlin": 1, "peopl": 1, "perform": 1, "period": 1, "posit": 1, "premark": 1, "prepar": 2, "prioriti": 1, "program": 2, "provid": 1, "randomli": 1, "run": 1, "scope": 1, "scroll": 2, "set": 1, "similar": 2, "simpli": 1, "small": 2, "sophist": 1, "specif": 1, "standard": 1, "string": 1, "strongli": 1, "structur": 1, "system": 2, "tape": 3, "techniqu": 1, "termin": 1, "text": 2, "uniform": 1, "user": 3, "word": 1, "work": 1, "wilk": 1}}, "2036": {"id": "2036", "title": "An Interactive Command Generating Facility", "abstract": "A facility to permit conversationally controlled tasks to be executed in a noninteractive environment is proposed. A means by which programs can generate interactive time-sharing commands and receive the corresponding output response is presented.  The commands  will be invoked as if they had been typed at a console keyboard.  It is  argued that this facility will help overcome some of the current limitations  in man-computer communication. A set of functions to accomplish the above  which could be embedded into any string processing language is suggested,  and necessary information pertinent to implementation of the facility on  existing time-sharing systems is given.", "authors": "Grant, C. A.", "words_pool": ["accomplish", "argu", "command", "command", "commun", "comput", "consol", "control", "convers", "embed", "environ", "execut", "exist", "facil", "function", "gener", "gener", "help", "implement", "inform", "interact", "invok", "keyboard", "languag", "limit", "man", "mean", "noninteract", "output", "overcom", "permit", "pertin", "present", "process", "program", "propos", "receiv", "respons", "set", "share", "string", "suggest", "system", "task", "time", "type", "grant"], "word_count": {"accomplish": 1, "argu": 1, "command": 2, "commun": 1, "comput": 1, "consol": 1, "control": 1, "convers": 1, "embed": 1, "environ": 1, "execut": 1, "exist": 1, "facil": 3, "function": 1, "gener": 1, "help": 1, "implement": 1, "inform": 1, "interact": 1, "invok": 1, "keyboard": 1, "languag": 1, "limit": 1, "man": 1, "mean": 1, "noninteract": 1, "output": 1, "overcom": 1, "permit": 1, "pertin": 1, "present": 1, "process": 1, "program": 1, "propos": 1, "receiv": 1, "respons": 1, "set": 1, "share": 2, "string": 1, "suggest": 1, "system": 1, "task": 1, "time": 2, "type": 1, "grant": 1}}, "2037": {"id": "2037", "title": "Permutations of a Set with Repetitions (Algorithm 383 $G6))", "authors": "Chase, P. J.", "words_pool": ["algorithm", "g6", "permut", "repetit", "set", "chase"], "word_count": {"algorithm": 1, "g6": 1, "permut": 1, "repetit": 1, "set": 1, "chase": 1}}, "2038": {"id": "2038", "title": "Combinations of M Out of N Objects (Algorithm 382 $G6))", "authors": "Chase, P. J.", "words_pool": ["algorithm", "combin", "g6", "object", "chase"], "word_count": {"algorithm": 1, "combin": 1, "g6": 1, "object": 1, "chase": 1}}, "2039": {"id": "2039", "title": "Permanent Function of a Square Matrix I and II (Algorithm 361 $G6))", "authors": "Shriver, B. Eberlein, P. J. Dixon, R. D.", "words_pool": ["algorithm", "function", "g6", "ii", "matrix", "perman", "squar", "shriver", "eberlein", "dixon"], "word_count": {"algorithm": 1, "function": 1, "g6": 1, "ii": 1, "matrix": 1, "perman": 1, "squar": 1, "shriver": 1, "eberlein": 1, "dixon": 1}}, "2040": {"id": "2040", "title": "Modified Romberg Quadrature (Algorithm 351 $D1))", "authors": "Wallick, G. C.", "words_pool": ["algorithm", "d1", "modifi", "quadratur", "romberg", "wallick"], "word_count": {"algorithm": 1, "d1": 1, "modifi": 1, "quadratur": 1, "romberg": 1, "wallick": 1}}, "2041": {"id": "2041", "title": "Shellsort (Algorithm 201 $M1))", "authors": "Chandler, J. P. Harrison, W. C.", "words_pool": ["algorithm", "m1", "shellsort", "chandler", "harrison"], "word_count": {"algorithm": 1, "m1": 1, "shellsort": 1, "chandler": 1, "harrison": 1}}, "2042": {"id": "2042", "title": "Treesort 3 (Algorithm 245 $M1))", "abstract": "The certification of an algorithm can take the form of a proof that the algorithm is correct.  As an illustrative but practical example, Algorithm 245, TREESORT 3 for sorting an array, is proved correct.", "authors": "London, R. L.", "words_pool": ["algorithm", "array", "certif", "correct", "form", "illustr", "m1", "practic", "proof", "prove", "sort", "take", "treesort", "london"], "word_count": {"algorithm": 3, "array": 1, "certif": 1, "correct": 2, "form": 1, "illustr": 1, "m1": 1, "practic": 1, "proof": 1, "prove": 1, "sort": 1, "take": 1, "treesort": 1, "london": 1}}, "2043": {"id": "2043", "title": "Eigenvalues and Eigenvectors of a Real Symmetric Matrix $F2) (Algorithm 384)", "authors": "Stewart, G. W.", "words_pool": ["algorithm", "eigenvalu", "eigenvector", "f2", "matrix", "real", "symmetr", "stewart"], "word_count": {"algorithm": 1, "eigenvalu": 1, "eigenvector": 1, "f2": 1, "matrix": 1, "real": 1, "symmetr": 1, "stewart": 1}}, "2044": {"id": "2044", "title": "Permutations of a Set with Repetitions (Algorithm 383 $G6))", "authors": "Chase, P. J.", "words_pool": ["algorithm", "g6", "permut", "repetit", "set", "chase"], "word_count": {"algorithm": 1, "g6": 1, "permut": 1, "repetit": 1, "set": 1, "chase": 1}}, "2045": {"id": "2045", "title": "Combinations of M Out of N Objects (Algorithm 382 $G6))", "authors": "Chase, P. J.", "words_pool": ["algorithm", "combin", "g6", "object", "chase"], "word_count": {"algorithm": 1, "combin": 1, "g6": 1, "object": 1, "chase": 1}}, "2046": {"id": "2046", "title": "A Relational Model of Data for Large Shared Data Banks", "abstract": "Future users of large data banks must be protected from having to know how the  data is organized in the machine (the internal representation).  A prompting service which supplies such information is not a satisfactory solution.  Activities of users at terminals and most application programs should remain unaffected when the internal representation of data is changed and even when some aspects of the external representation  are changed.  Change in data representation will often be needed as a result  of changes in query, update, and report traffic and natural growth in the  types of stored information.  Existing noninferential, formatted data systems  provide users with tree-structured files or slightly more general network  models of the data.  In Section 1, inadequacies of these models are discussed. A model based on n-ary relations, a normal form for data base relations, and the concept of a universal form for data base relations, and the concept of a universal data sublanguage are introduced.  In Section 2, certain operations on relations (other than logical inference) are discussed and applied to the problems of redundancy and consistency in the user's model.", "authors": "Codd, E. F.", "words_pool": ["activ", "applic", "appli", "ari", "aspect", "bank", "base", "base", "chang", "chang", "concept", "consist", "data", "discuss", "exist", "extern", "form", "format", "futur", "gener", "growth", "inadequaci", "infer", "inform", "intern", "introduc", "know", "larg", "logic", "machin", "model", "model", "natur", "need", "network", "noninferenti", "normal", "oper", "organ", "problem", "program", "prompt", "protect", "provid", "queri", "redund", "relat", "relat", "remain", "report", "represent", "result", "satisfactori", "section", "servic", "share", "slightli", "solut", "store", "structur", "sublanguag", "suppli", "system", "termin", "traffic", "tree", "type", "unaffect", "univers", "updat", "user", "user", "codd"], "word_count": {"activ": 1, "applic": 1, "appli": 1, "ari": 1, "aspect": 1, "bank": 1, "base": 3, "chang": 3, "concept": 2, "consist": 1, "data": 9, "discuss": 2, "exist": 1, "extern": 1, "form": 2, "format": 1, "futur": 1, "gener": 1, "growth": 1, "inadequaci": 1, "infer": 1, "inform": 2, "intern": 2, "introduc": 1, "know": 1, "larg": 1, "logic": 1, "machin": 1, "model": 4, "natur": 1, "need": 1, "network": 1, "noninferenti": 1, "normal": 1, "oper": 1, "organ": 1, "problem": 1, "program": 1, "prompt": 1, "protect": 1, "provid": 1, "queri": 1, "redund": 1, "relat": 4, "remain": 1, "report": 1, "represent": 4, "result": 1, "satisfactori": 1, "section": 2, "servic": 1, "share": 1, "slightli": 1, "solut": 1, "store": 1, "structur": 1, "sublanguag": 1, "suppli": 1, "system": 1, "termin": 1, "traffic": 1, "tree": 1, "type": 1, "unaffect": 1, "univers": 2, "updat": 1, "user": 4, "codd": 1}}, "2047": {"id": "2047", "title": "Incorporating Origin Shifts into the QR Algorithm for Symmetric Tridiagonal Matrices", "abstract": "The QR iteration for the eigenvalues of a symmetric tridiagonal matrix can  be accelerated by incorporating a sequence of origin shifts.  The origin shift may be either subtracted directly from the diagonal elements of the matrix or incorporated by means of an implicit algorithm.  Both methods have drawbacks: the direct method can unnecessarily degrade small  eigenvalues, while the implicit method can effectively loose the shift and  thereby retard the convergence.  This paper presents a new method which has  neither drawback.", "authors": "Stewart, G. W.", "words_pool": ["acceler", "algorithm", "converg", "degrad", "diagon", "direct", "directli", "drawback", "drawback", "effect", "eigenvalu", "element", "implicit", "incorpor", "incorpor", "iter", "loos", "matric", "matrix", "mean", "method", "method", "origin", "paper", "present", "qr", "retard", "sequenc", "shift", "shift", "small", "subtract", "symmetr", "tridiagon", "unnecessarili", "stewart"], "word_count": {"acceler": 1, "algorithm": 1, "converg": 1, "degrad": 1, "diagon": 1, "direct": 1, "directli": 1, "drawback": 2, "effect": 1, "eigenvalu": 2, "element": 1, "implicit": 2, "incorpor": 2, "iter": 1, "loos": 1, "matric": 1, "matrix": 2, "mean": 1, "method": 4, "origin": 2, "paper": 1, "present": 1, "qr": 1, "retard": 1, "sequenc": 1, "shift": 3, "small": 1, "subtract": 1, "symmetr": 1, "tridiagon": 1, "unnecessarili": 1, "stewart": 1}}, "2048": {"id": "2048", "title": "Comparison of Several Adaptive Newton-Cotes Quadrature Routines in Evaluating Definite Integrals with Peaked Integrands", "abstract": "This report compares the performance of five different adaptive quadrature  schemes, based on Newton-Cotes (2N + 1) point rules (N = 1, 2, 3, 4, 5), in approximating the set of definite integrals INTEGRAL$1/(x^2 + p^2)) dx with  relative accuracy e.", "authors": "Hillstrom, K. E.", "words_pool": ["2n", "accuraci", "adapt", "approxim", "base", "compar", "comparison", "cote", "definit", "dx", "evalu", "integr", "integr", "integrand", "newton", "peak", "perform", "point", "quadratur", "rel", "report", "routin", "rule", "scheme", "set", "hillstrom"], "word_count": {"2n": 1, "accuraci": 1, "adapt": 1, "approxim": 1, "base": 1, "compar": 1, "comparison": 1, "cote": 1, "definit": 1, "dx": 1, "evalu": 1, "integr": 2, "integrand": 1, "newton": 1, "peak": 1, "perform": 1, "point": 1, "quadratur": 1, "rel": 1, "report": 1, "routin": 1, "rule": 1, "scheme": 1, "set": 1, "hillstrom": 1}}, "2049": {"id": "2049", "title": "Accurate Floating-Point Summation", "abstract": "This paper describes an alternate method for summing a set of floating-point numbers.  Comparison of the error bound for this method with that of the standard summation method shows that it is considerably less sensitive to propagation of round-off error.", "authors": "Linz, P.", "words_pool": ["accur", "altern", "bound", "comparison", "consider", "describ", "error", "float", "method", "number", "paper", "point", "propag", "round", "sensit", "set", "show", "standard", "summat", "sum", "linz"], "word_count": {"accur": 1, "altern": 1, "bound": 1, "comparison": 1, "consider": 1, "describ": 1, "error": 2, "float": 1, "method": 3, "number": 1, "paper": 1, "point": 1, "propag": 1, "round": 1, "sensit": 1, "set": 1, "show": 1, "standard": 1, "summat": 1, "sum": 1, "linz": 1}}, "2050": {"id": "2050", "title": "Automatic Parsing for Content Analysis", "abstract": "Although automatic syntactic and semantic analysis is not yet possible for all of an unrestricted natural language text, some applications, of which  content analysis is one, do not have such a stringent coverage requirement. Preliminary studies show that the Harvard Syntactic Analyzer can produce correct and unambiguous identification of the subject and object of certain verbs for approximately half of the relevant occurrences.  This provides a degree of coverage for content analysis variables which  compares favorably to manual methods, in variables which compares favorably  to manual methods, in which only a sample of the total available text is  normally processed.", "authors": "Damerau, F. J.", "words_pool": ["analysi", "analyz", "applic", "approxim", "automat", "compar", "content", "correct", "coverag", "degre", "favor", "half", "harvard", "identif", "languag", "method", "natur", "object", "occurr", "pars", "preliminari", "process", "produc", "relev", "requir", "sampl", "semant", "show", "stringent", "studi", "subject", "syntact", "text", "total", "unambigu", "unrestrict", "variabl", "verb", "damerau"], "word_count": {"analysi": 3, "analyz": 1, "applic": 1, "approxim": 1, "automat": 1, "compar": 2, "content": 2, "correct": 1, "coverag": 2, "degre": 1, "favor": 2, "half": 1, "harvard": 1, "identif": 1, "languag": 1, "method": 2, "natur": 1, "object": 1, "occurr": 1, "pars": 1, "preliminari": 1, "process": 1, "produc": 1, "relev": 1, "requir": 1, "sampl": 1, "semant": 1, "show": 1, "stringent": 1, "studi": 1, "subject": 1, "syntact": 2, "text": 2, "total": 1, "unambigu": 1, "unrestrict": 1, "variabl": 2, "verb": 1, "damerau": 1}}, "2051": {"id": "2051", "title": "A PL/I Program to Assist the Comparative Linguist", "abstract": "A practical PL/I program is described which can assist comparative linguists to determine the regular sound correspondences between genetically related languages. The investigator must arrange data for input by aligning pairs of suspected cognates.  The program tabulates the correspondences, and uses list processing techniques to sort and count them. Each pair of words is then assigned a relative value that is a function of the total frequency in the data of each correspondence found in that pair of words.  The output is a list of all correspondence types with their frequency of occurrence in the data, and a separate listing of each correspondence with all word-pairs showing that correspondence (unless their relative value is below an arbitrarily  chosen cutoff point).  The article explains the usefulness, as well as the limitations, of the programs, and illustrates its use with a small portion of hypothetical data.", "authors": "Frantz, D. G.", "words_pool": ["align", "arbitrarili", "arrang", "articl", "assign", "assist", "chosen", "cognat", "compar", "correspond", "correspond", "count", "cutoff", "data", "determin", "explain", "found", "frequenc", "function", "genet", "hypothet", "illustr", "input", "investig", "languag", "limit", "linguist", "linguist", "list", "list", "occurr", "output", "pair", "pair", "pl", "point", "portion", "practic", "process", "program", "program", "regular", "relat", "rel", "separ", "show", "small", "sort", "sound", "suspect", "tabul", "techniqu", "total", "type", "use", "word", "word", "frantz"], "word_count": {"align": 1, "arbitrarili": 1, "arrang": 1, "articl": 1, "assign": 1, "assist": 1, "chosen": 1, "cognat": 1, "compar": 1, "correspond": 6, "count": 1, "cutoff": 1, "data": 4, "determin": 1, "explain": 1, "found": 1, "frequenc": 2, "function": 1, "genet": 1, "hypothet": 1, "illustr": 1, "input": 1, "investig": 1, "languag": 1, "limit": 1, "linguist": 1, "list": 3, "occurr": 1, "output": 1, "pair": 4, "pl": 1, "point": 1, "portion": 1, "practic": 1, "process": 1, "program": 3, "regular": 1, "relat": 1, "rel": 2, "separ": 1, "show": 1, "small": 1, "sort": 1, "sound": 1, "suspect": 1, "tabul": 1, "techniqu": 1, "total": 1, "type": 1, "use": 1, "word": 3, "frantz": 1}}, "2052": {"id": "2052", "title": "Scheduling to Reduce Conflict in Meetings", "abstract": "Conflicts in scheduling can be treated as defining an undirected linear graph  independently of the relation of the activities in conflict to additional  constraints of time and space.  Each connected component of such a graph, which can be found by an algorithm described by Gotlieb and Corneil,  corresponds to a set of events that must be scheduled at different times.", "authors": "Grimes, J. E.", "words_pool": ["activ", "addit", "algorithm", "compon", "conflict", "conflict", "connect", "constraint", "corneil", "correspond", "defin", "event", "found", "gotlieb", "graph", "independ", "linear", "meet", "reduc", "relat", "schedul", "schedul", "set", "space", "time", "time", "treat", "undirect", "grime"], "word_count": {"activ": 1, "addit": 1, "algorithm": 1, "compon": 1, "conflict": 2, "connect": 1, "constraint": 1, "corneil": 1, "correspond": 1, "defin": 1, "event": 1, "found": 1, "gotlieb": 1, "graph": 2, "independ": 1, "linear": 1, "meet": 1, "reduc": 1, "relat": 1, "schedul": 2, "set": 1, "space": 1, "time": 2, "treat": 1, "undirect": 1, "grime": 1}}, "2053": {"id": "2053", "title": "On the Conversion of Decision Tables to Computer Programs", "abstract": "The use of execution time diagnostics in pinpointing ambiguities in decision tables is discussed.  It is pointed out that any attempt at resolving ambiguities at compile time will, in general, be impossible.  It is shown that, as a consequence, tree methods of converting decision tables to programs are inadequate in regard to ambiguity detection. Two algorithms for programming decision tables whose merits are simplicity of implementation and detection of ambiguities at execution time are presented. The first algorithm is for limited entry decision tables and clarifies the importance of proper coding of the information in the decision table.  The second algorithm programs a mixed entry decision table directly without going through the intermediate step of conversion to a limited entry form, thereby resulting in storage economy.  A comparison of the algorithms and others  proposed in the literature is made.  Some features of a decision table to Fortran IV translator for the IBM 7044 developed by the authors are given.", "authors": "Muthukrishnan, C. R. Rajaraman, V.", "words_pool": ["algorithm", "algorithm", "ambigu", "ambigu", "attempt", "author", "clarifi", "code", "comparison", "compil", "comput", "consequ", "convers", "convert", "decis", "detect", "develop", "diagnost", "directli", "discuss", "economi", "entri", "execut", "featur", "form", "fortran", "gener", "go", "ibm", "implement", "import", "imposs", "inadequ", "inform", "intermedi", "iv", "limit", "literatur", "made", "merit", "method", "mix", "pinpoint", "point", "present", "program", "program", "proper", "propos", "regard", "resolv", "result", "shown", "simplic", "step", "storag", "tabl", "tabl", "time", "translat", "tree", "muthukrishnan", "rajaraman"], "word_count": {"algorithm": 4, "ambigu": 4, "attempt": 1, "author": 1, "clarifi": 1, "code": 1, "comparison": 1, "compil": 1, "comput": 1, "consequ": 1, "convers": 1, "convert": 1, "decis": 7, "detect": 2, "develop": 1, "diagnost": 1, "directli": 1, "discuss": 1, "economi": 1, "entri": 3, "execut": 2, "featur": 1, "form": 1, "fortran": 1, "gener": 1, "go": 1, "ibm": 1, "implement": 1, "import": 1, "imposs": 1, "inadequ": 1, "inform": 1, "intermedi": 1, "iv": 1, "limit": 2, "literatur": 1, "made": 1, "merit": 1, "method": 1, "mix": 1, "pinpoint": 1, "point": 1, "present": 1, "program": 3, "proper": 1, "propos": 1, "regard": 1, "resolv": 1, "result": 1, "shown": 1, "simplic": 1, "step": 1, "storag": 1, "tabl": 7, "time": 3, "translat": 1, "tree": 1, "muthukrishnan": 1, "rajaraman": 1}}, "2054": {"id": "2054", "title": "On the Feasibility of Voice Input to an On-line Computer Processing System", "abstract": "An on-line digital computer processing system is considered in which an  ordinary telephone is the complete terminal device, input to the computer  being provided as a sequence of spoken words, and output to the user being  audio responses from the machine.  The feasibility of implementing such a  system with a FORTRAN-like algebraic compiler as the object processor is  considered.  Details of a specific word recognition program are given.  This  technique depends on three simplifying restrictions, namely, a \"small\" vocabulary set, \"known\" speakers, and a \"moment of silence\" between each input word.  Experimental results are presented giving error rates for different experimental conditions as well as the machine  resources required to accommodate several users at a time. The results show  that at this time it is both economically and logically feasible to handle at  least 40 users at a time with an IBM 360/65 computer.", "authors": "Elder, H. A.", "words_pool": ["accommod", "algebra", "audio", "compil", "complet", "comput", "condit", "consid", "depend", "detail", "devic", "digit", "econom", "error", "experiment", "feasibl", "feasibl", "fortran", "give", "handl", "ibm", "implement", "input", "known", "line", "logic", "machin", "moment", "object", "ordinari", "output", "present", "process", "processor", "program", "provid", "rate", "recognit", "requir", "resourc", "respons", "restrict", "result", "sequenc", "set", "show", "silenc", "simplifi", "small", "speaker", "specif", "spoken", "system", "techniqu", "telephon", "termin", "time", "user", "user", "vocabulari", "voic", "word", "word", "elder"], "word_count": {"accommod": 1, "algebra": 1, "audio": 1, "compil": 1, "complet": 1, "comput": 3, "condit": 1, "consid": 2, "depend": 1, "detail": 1, "devic": 1, "digit": 1, "econom": 1, "error": 1, "experiment": 2, "feasibl": 2, "fortran": 1, "give": 1, "handl": 1, "ibm": 1, "implement": 1, "input": 2, "known": 1, "line": 1, "logic": 1, "machin": 2, "moment": 1, "object": 1, "ordinari": 1, "output": 1, "present": 1, "process": 1, "processor": 1, "program": 1, "provid": 1, "rate": 1, "recognit": 1, "requir": 1, "resourc": 1, "respons": 1, "restrict": 1, "result": 2, "sequenc": 1, "set": 1, "show": 1, "silenc": 1, "simplifi": 1, "small": 1, "speaker": 1, "specif": 1, "spoken": 1, "system": 2, "techniqu": 1, "telephon": 1, "termin": 1, "time": 3, "user": 3, "vocabulari": 1, "voic": 1, "word": 3, "elder": 1}}, "2055": {"id": "2055", "title": "Subroutine to Perform In-Situ Transposition of a Rectangular Matrix (Algorithm 380)", "authors": "Lachenmaier, R.", "words_pool": ["algorithm", "matrix", "perform", "rectangular", "situ", "subroutin", "transposit", "lachenmai"], "word_count": {"algorithm": 1, "matrix": 1, "perform": 1, "rectangular": 1, "situ": 1, "subroutin": 1, "transposit": 1, "lachenmai": 1}}, "2056": {"id": "2056", "title": "Gomory (Algorithm 263A $H))", "authors": "Proll, L. G.", "words_pool": ["263a", "algorithm", "gomori", "proll"], "word_count": {"263a": 1, "algorithm": 1, "gomori": 1, "proll": 1}}, "2057": {"id": "2057", "title": "Random Vectors Uniform in Solid Angle (Algorithm 381 $G5))", "authors": "Knop, R. E.", "words_pool": ["algorithm", "angl", "g5", "random", "solid", "uniform", "vector", "knop"], "word_count": {"algorithm": 1, "angl": 1, "g5": 1, "random": 1, "solid": 1, "uniform": 1, "vector": 1, "knop": 1}}, "2058": {"id": "2058", "title": "In-Situ Transposition of a Rectangular Matrix (Algorithm 380 $F1))", "authors": "Laflin, S. Brebner, M. A.", "words_pool": ["algorithm", "f1", "matrix", "rectangular", "situ", "transposit", "laflin", "brebner"], "word_count": {"algorithm": 1, "f1": 1, "matrix": 1, "rectangular": 1, "situ": 1, "transposit": 1, "laflin": 1, "brebner": 1}}, "2059": {"id": "2059", "title": "A Language for Treating Graphs", "abstract": "A language for the representation of graph is described, and the formulation of  graph operations such as node and/or link deletion or insertion, union,  intersection, comparison, and traversal of graphs is given.  Graphs are represented by linked lists.  The language is syntactically defined as an extension to ALGOL 60, and it is translated into ALGOL by means of a syntax-driven compiler.  Application areas for this language are operation research, network problems, control theory, traffic problems, etc.", "authors": "Crespi-Reghizzi, S. Morpurgo, R.", "words_pool": ["algol", "applic", "area", "comparison", "compil", "control", "defin", "delet", "driven", "extens", "formul", "graph", "graph", "insert", "intersect", "languag", "link", "link", "list", "mean", "network", "node", "oper", "oper", "problem", "represent", "repres", "research", "syntact", "syntax", "theori", "traffic", "translat", "travers", "treat", "union", "crespi", "reghizzi", "morpurgo"], "word_count": {"algol": 2, "applic": 1, "area": 1, "comparison": 1, "compil": 1, "control": 1, "defin": 1, "delet": 1, "driven": 1, "extens": 1, "formul": 1, "graph": 4, "insert": 1, "intersect": 1, "languag": 3, "link": 2, "list": 1, "mean": 1, "network": 1, "node": 1, "oper": 2, "problem": 2, "represent": 1, "repres": 1, "research": 1, "syntact": 1, "syntax": 1, "theori": 1, "traffic": 1, "translat": 1, "travers": 1, "treat": 1, "union": 1, "crespi": 1, "reghizzi": 1, "morpurgo": 1}}, "2060": {"id": "2060", "title": "GEDANKEN-A Simple Typeless Language Based on the Principle of Completeness and the Reference Concept", "abstract": "GEDANKEN is an experimental programming language with the following  characteristics.  (1) Any value which is permitted in some context of the  language is permissible in any other meaningful context.  In particular, functions and labels are permissible  results of functions and values of variables.  (2) Assignment and indirect addressing are formalized by introducing values, called reference, which in turn possess other values.  The assignment operation always affects the relation between some reference and its value,  (3) All compound data structures are treated as functions.  (4) Type declarations are not permitted.  The functional approach to data structures and the use of references insure that any process which accepts some data structure will accept any logically equivalent structure, regardless of its internal representation.  More generally, any data structure may be implicit; i.e. it may be specified by giving an arbitrary algorithm for computing or accessing its components.  The existence of  label variables permits the construction of coroutines, quasi-parallel processes, and other unorthodox control mechanisms. A variety of programming examples illustrates the generality of the language. Limitations and possible extensions are discussed briefly.", "authors": "Reynolds, J. C.", "words_pool": ["accept", "accept", "access", "address", "affect", "algorithm", "approach", "arbitrari", "assign", "base", "briefli", "call", "characterist", "complet", "compon", "compound", "comput", "concept", "construct", "context", "control", "coroutin", "data", "declar", "discuss", "equival", "exampl", "exist", "experiment", "extens", "formal", "function", "function", "gedanken", "gener", "gener", "give", "illustr", "implicit", "indirect", "insur", "intern", "introduc", "label", "label", "languag", "limit", "logic", "meaning", "mechan", "oper", "parallel", "permiss", "permit", "permit", "possess", "principl", "process", "process", "program", "quasi", "refer", "refer", "regardless", "relat", "represent", "result", "simpl", "structur", "structur", "treat", "turn", "type", "typeless", "unorthodox", "valu", "variabl", "varieti", "reynold"], "word_count": {"accept": 2, "access": 1, "address": 1, "affect": 1, "algorithm": 1, "approach": 1, "arbitrari": 1, "assign": 2, "base": 1, "briefli": 1, "call": 1, "characterist": 1, "complet": 1, "compon": 1, "compound": 1, "comput": 1, "concept": 1, "construct": 1, "context": 2, "control": 1, "coroutin": 1, "data": 4, "declar": 1, "discuss": 1, "equival": 1, "exampl": 1, "exist": 1, "experiment": 1, "extens": 1, "formal": 1, "function": 4, "gedanken": 1, "gener": 2, "give": 1, "illustr": 1, "implicit": 1, "indirect": 1, "insur": 1, "intern": 1, "introduc": 1, "label": 2, "languag": 3, "limit": 1, "logic": 1, "meaning": 1, "mechan": 1, "oper": 1, "parallel": 1, "permiss": 2, "permit": 3, "possess": 1, "principl": 1, "process": 2, "program": 2, "quasi": 1, "refer": 3, "regardless": 1, "relat": 1, "represent": 1, "result": 1, "simpl": 1, "structur": 5, "treat": 1, "turn": 1, "type": 1, "typeless": 1, "unorthodox": 1, "valu": 3, "variabl": 2, "varieti": 1, "reynold": 1}}, "2061": {"id": "2061", "title": "An Algorithm for the Construction Of Bounded-Context Parsers", "abstract": "An algorithm is described which accepts an arbitrary context-free grammar and constructs a bounded-context parser for it whenever such a parser exists.  In the first part of the paper the definition of a context-free grammar and the working of a bounded-context parser are recalled.  The notion of reduction class for a context-free grammar is then introduced and its connection with the structure of a bounded-context parser is indicated.  Next, pushdown automata which generate the different reduction classes of a context-free grammar are defined.  Finally, the algorithm is described; it essentially carries out an exhaustive study of all possible runs of the pushdown automata generating the reduction classes. In the second part, the utility of the algorithm is discuss ed in the light of the experience gained from its use in compiler design. The algorithm is claimed to be particularly useful in the simultaneous design of a language and a compiler for it.", "authors": "Loeckx, J.", "words_pool": ["accept", "algorithm", "arbitrari", "automata", "bound", "carri", "claim", "class", "class", "compil", "connect", "construct", "construct", "context", "defin", "definit", "design", "discuss", "ed", "essenti", "exhaust", "exist", "experi", "final", "free", "gain", "gener", "gener", "grammar", "introduc", "languag", "light", "notion", "paper", "parser", "parser", "part", "pushdown", "recal", "reduct", "run", "simultan", "structur", "studi", "util", "work", "loeckx"], "word_count": {"accept": 1, "algorithm": 4, "arbitrari": 1, "automata": 2, "bound": 3, "carri": 1, "claim": 1, "class": 3, "compil": 2, "connect": 1, "construct": 1, "context": 7, "defin": 1, "definit": 1, "design": 2, "discuss": 1, "ed": 1, "essenti": 1, "exhaust": 1, "exist": 1, "experi": 1, "final": 1, "free": 4, "gain": 1, "gener": 2, "grammar": 4, "introduc": 1, "languag": 1, "light": 1, "notion": 1, "paper": 1, "parser": 4, "part": 2, "pushdown": 2, "recal": 1, "reduct": 3, "run": 1, "simultan": 1, "structur": 1, "studi": 1, "util": 1, "work": 1, "loeckx": 1}}, "2062": {"id": "2062", "title": "The Application of Sequential Sampling to Simulation: An Example Inventory Model", "abstract": "Four different sequential sampling procedures are applied to the analysis of data generated by a computer simulation experiment with a multi-item inventory model.  For each procedure the cost of computer time required to achieve given levels of statistical precision is calculated.  Also the cost of computer time using comparable fixed sample size methods is calculated.  The computer costs of fixed sample size procedures versus sequential sampling procedures are compared.", "authors": "Sasser, W. E. Burdick, D. S. Graham, D. A. Naylor, T. H.", "words_pool": ["achiev", "analysi", "applic", "appli", "calcul", "compar", "compar", "comput", "cost", "cost", "data", "experi", "fix", "gener", "inventori", "item", "level", "method", "model", "multi", "precis", "procedur", "procedur", "requir", "sampl", "sampl", "sequenti", "simul", "size", "statist", "time", "versu", "sasser", "burdick", "graham", "naylor"], "word_count": {"achiev": 1, "analysi": 1, "applic": 1, "appli": 1, "calcul": 2, "compar": 2, "comput": 4, "cost": 3, "data": 1, "experi": 1, "fix": 2, "gener": 1, "inventori": 1, "item": 1, "level": 1, "method": 1, "model": 1, "multi": 1, "precis": 1, "procedur": 4, "requir": 1, "sampl": 4, "sequenti": 2, "simul": 1, "size": 2, "statist": 1, "time": 2, "versu": 1, "sasser": 1, "burdick": 1, "graham": 1, "naylor": 1}}, "2063": {"id": "2063", "title": "Translation Equations (Errata)", "authors": "Vere, S.", "words_pool": ["equat", "errata", "translat", "vere"], "word_count": {"equat": 1, "errata": 1, "translat": 1, "vere": 1}}, "2064": {"id": "2064", "title": "Operations on Generalized Arrays with the Genie Compiler", "abstract": "Operations on vectors, matrices, and higher dimensional storage arrays are  standard features of most compilers today.  The elements of such structures are usually restricted to be scalars.  For many sophisticated applications this restriction can impose cumbersome data representations. An efficient system has been devised and implemented which allows the elements of multidimensional arrays to themselves be multidimensional arrays.  This system was developed from a storage structure in which the location, length, and content of each array is described by a codeword which can be interpreted by the system.  Code words may describe  arrays containing more codewords, thus providing all needed descriptive information for hyperstructures of any form.", "authors": "Sitton, G. A.", "words_pool": ["applic", "array", "array", "code", "codeword", "codeword", "compil", "compil", "content", "cumbersom", "data", "describ", "descript", "develop", "devis", "dimension", "effici", "element", "featur", "form", "gener", "geni", "higher", "hyperstructur", "implement", "impos", "inform", "interpret", "length", "locat", "matric", "multidimension", "need", "oper", "provid", "represent", "restrict", "restrict", "scalar", "sophist", "standard", "storag", "structur", "structur", "system", "today", "vector", "word", "sitton"], "word_count": {"applic": 1, "array": 5, "code": 1, "codeword": 2, "compil": 1, "content": 1, "cumbersom": 1, "data": 1, "describ": 1, "descript": 1, "develop": 1, "devis": 1, "dimension": 1, "effici": 1, "element": 2, "featur": 1, "form": 1, "gener": 1, "geni": 1, "higher": 1, "hyperstructur": 1, "implement": 1, "impos": 1, "inform": 1, "interpret": 1, "length": 1, "locat": 1, "matric": 1, "multidimension": 2, "need": 1, "oper": 1, "provid": 1, "represent": 1, "restrict": 2, "scalar": 1, "sophist": 1, "standard": 1, "storag": 2, "structur": 2, "system": 3, "today": 1, "vector": 1, "word": 1, "sitton": 1}}, "2065": {"id": "2065", "title": "A Programming System for the On-line Analysis of Biomedical Images", "abstract": "A preliminary description of the software for a computer-display system is given with special emphasis on the  man-machine interaction. This  system is intended for a wide variety of biomedical applications. As an example, the methods are applied to the karyotyping of chromosomes.  The  system is separated into four programming tasks: picture transformations, file  maintenance, picture structuring, and display management.  Picture structuring is considered as the vehicle for man-machine communication. A prototype data format for pictures, called a picture-form, is developed. Structure operators are defined which manipulate picture-forms to produce  new pictures-forms.  Many of the ideas are taken from the symbolic mathematical  laboratory at MIT conceived by Marvin Minsky.", "authors": "Hodes, L.", "words_pool": ["analysi", "applic", "appli", "biomed", "call", "chromosom", "commun", "comput", "conceiv", "consid", "data", "defin", "descript", "develop", "display", "emphasi", "form", "format", "form", "idea", "imag", "intend", "interact", "karyotyp", "laboratori", "line", "machin", "mainten", "man", "manag", "manipul", "marvin", "mathemat", "method", "minski", "mit", "oper", "pictur", "pictur", "preliminari", "produc", "program", "prototyp", "separ", "softwar", "special", "structur", "structur", "symbol", "system", "task", "transform", "varieti", "vehicl", "wide", "hode"], "word_count": {"analysi": 1, "applic": 1, "appli": 1, "biomed": 1, "call": 1, "chromosom": 1, "commun": 1, "comput": 1, "conceiv": 1, "consid": 1, "data": 1, "defin": 1, "descript": 1, "develop": 1, "display": 2, "emphasi": 1, "form": 3, "format": 1, "idea": 1, "imag": 1, "intend": 1, "interact": 1, "karyotyp": 1, "laboratori": 1, "line": 1, "machin": 2, "mainten": 1, "man": 2, "manag": 1, "manipul": 1, "marvin": 1, "mathemat": 1, "method": 1, "minski": 1, "mit": 1, "oper": 1, "pictur": 7, "preliminari": 1, "produc": 1, "program": 1, "prototyp": 1, "separ": 1, "softwar": 1, "special": 1, "structur": 3, "symbol": 1, "system": 3, "task": 1, "transform": 1, "varieti": 1, "vehicl": 1, "wide": 1, "hode": 1}}, "2066": {"id": "2066", "title": "An Algol Construction for Procedures as Parameters of Procedures", "authors": "Knight, K. R.", "words_pool": ["algol", "construct", "paramet", "procedur", "knight"], "word_count": {"algol": 1, "construct": 1, "paramet": 1, "procedur": 2, "knight": 1}}, "2067": {"id": "2067", "title": "Comment on Lawler's Multilevel Boolean Minimization", "authors": "DeVries, R. C.", "words_pool": ["boolean", "comment", "lawler", "minim", "multilevel", "devri"], "word_count": {"boolean": 1, "comment": 1, "lawler": 1, "minim": 1, "multilevel": 1, "devri": 1}}, "2068": {"id": "2068", "title": "Comment on Multiprogramming Under a Page on Demand Strategy", "authors": "Smith, J. L.", "words_pool": ["comment", "demand", "multiprogram", "page", "strategi", "smith"], "word_count": {"comment": 1, "demand": 1, "multiprogram": 1, "page": 1, "strategi": 1, "smith": 1}}, "2069": {"id": "2069", "title": "Comments on a Paper by Wallace and Mason", "authors": "Heess Jr., W. F.", "words_pool": ["comment", "mason", "paper", "wallac", "heess", "jr"], "word_count": {"comment": 1, "mason": 1, "paper": 1, "wallac": 1, "heess": 1, "jr": 1}}, "2070": {"id": "2070", "title": "A Formal System for Information Retrieval from Files", "authors": "Hsiao, D. Harary, F.", "words_pool": ["formal", "inform", "retriev", "system", "hsiao", "harari"], "word_count": {"formal": 1, "inform": 1, "retriev": 1, "system": 1, "hsiao": 1, "harari": 1}}, "2071": {"id": "2071", "title": "Filon Quadrature (Algorithm 353 $D1))", "authors": "Fosdick, L. D. Einarsson, Bo", "words_pool": ["algorithm", "d1", "filon", "quadratur", "fosdick", "einarsson", "bo"], "word_count": {"algorithm": 1, "d1": 1, "filon": 1, "quadratur": 1, "fosdick": 1, "einarsson": 1, "bo": 1}}, "2072": {"id": "2072", "title": "Modified Romberg Quadrature (Algorithm 351 $D1))", "authors": "Cook, N. D.", "words_pool": ["algorithm", "d1", "modifi", "quadratur", "romberg", "cook"], "word_count": {"algorithm": 1, "d1": 1, "modifi": 1, "quadratur": 1, "romberg": 1, "cook": 1}}, "2073": {"id": "2073", "title": "Solution of Linear Programs in 0-1 Variables by Implicit Enumeration (Algorithm 341 $H))", "authors": "Guignard, M. M.", "words_pool": ["algorithm", "enumer", "implicit", "linear", "program", "solut", "variabl", "guignard"], "word_count": {"algorithm": 1, "enumer": 1, "implicit": 1, "linear": 1, "program": 1, "solut": 1, "variabl": 1, "guignard": 1}}, "2074": {"id": "2074", "title": "Sqank (Algorithm 379 $D1))", "authors": "Lyness, J. N.", "words_pool": ["algorithm", "d1", "sqank", "lyness"], "word_count": {"algorithm": 1, "d1": 1, "sqank": 1, "lyness": 1}}, "2075": {"id": "2075", "title": "Discretized Newton-Like Method for Solving a System of Simultaneous Nonlinear Equations (Algorithm 378 $C5))", "authors": "Pankiewicz, W.", "words_pool": ["algorithm", "c5", "discret", "equat", "method", "newton", "nonlinear", "simultan", "solv", "system", "pankiewicz"], "word_count": {"algorithm": 1, "c5": 1, "discret": 1, "equat": 1, "method": 1, "newton": 1, "nonlinear": 1, "simultan": 1, "solv": 1, "system": 1, "pankiewicz": 1}}, "2076": {"id": "2076", "title": "Cubic Splines on Uniform Meshes", "abstract": "A very simple procedure is presented for constructing cubic splines, periodic or nonperiodic, on uniform meshes.  Arcs of two cubics suffice to construct a basis of cardinal splines.  An algorithm is given which  requires only minimal storage and computation and permits easy trade-off  of one against the other.", "authors": "Nilson, E. N.", "words_pool": ["algorithm", "arc", "basi", "cardin", "comput", "construct", "construct", "cubic", "cubic", "easi", "mesh", "minim", "nonperiod", "period", "permit", "present", "procedur", "requir", "simpl", "spline", "storag", "suffic", "trade", "uniform", "nilson"], "word_count": {"algorithm": 1, "arc": 1, "basi": 1, "cardin": 1, "comput": 1, "construct": 2, "cubic": 2, "easi": 1, "mesh": 1, "minim": 1, "nonperiod": 1, "period": 1, "permit": 1, "present": 1, "procedur": 1, "requir": 1, "simpl": 1, "spline": 2, "storag": 1, "suffic": 1, "trade": 1, "uniform": 1, "nilson": 1}}, "2077": {"id": "2077", "title": "The Cyclical Majority Problem", "abstract": "The problem of the cyclical majority is presented and some new, simulated results for 3, 4, 5, ..., 40 issues ad 3, 5, 7, ..., 37 judges are reported.", "authors": "Pomeranz, J. E. Weil Jr., R. L.", "words_pool": ["ad", "cyclic", "issu", "judg", "major", "present", "problem", "report", "result", "simul", "pomeranz", "weil", "jr"], "word_count": {"ad": 1, "cyclic": 1, "issu": 1, "judg": 1, "major": 1, "present": 1, "problem": 1, "report": 1, "result": 1, "simul": 1, "pomeranz": 1, "weil": 1, "jr": 1}}, "2078": {"id": "2078", "title": "Representations for Space Planning", "abstract": "Problems involving the arrangement of objects in two-  or three-space where the objective function primarily consists of derivatives of the distance between objects or their arrangement are called space planning problems.  The representational requirements for this problem area are defined and compared with current computer graphic languages.  Four alternative data structures that allow automated space planning are described and compared.", "authors": "Eastman, C. M.", "words_pool": ["allow", "altern", "area", "arrang", "autom", "call", "compar", "comput", "consist", "data", "defin", "deriv", "distanc", "function", "graphic", "involv", "languag", "object", "object", "plan", "primarili", "problem", "problem", "represent", "represent", "requir", "space", "structur", "eastman"], "word_count": {"allow": 1, "altern": 1, "area": 1, "arrang": 2, "autom": 1, "call": 1, "compar": 2, "comput": 1, "consist": 1, "data": 1, "defin": 1, "deriv": 1, "distanc": 1, "function": 1, "graphic": 1, "involv": 1, "languag": 1, "object": 3, "plan": 2, "primarili": 1, "problem": 3, "represent": 1, "requir": 1, "space": 3, "structur": 1, "eastman": 1}}, "2079": {"id": "2079", "title": "On Multiprogramming, Machine Coding, and Computer Organization", "authors": "Wirth, N.", "words_pool": ["code", "comput", "machin", "multiprogram", "organ", "wirth"], "word_count": {"code": 1, "comput": 1, "machin": 1, "multiprogram": 1, "organ": 1, "wirth": 1}}, "2080": {"id": "2080", "title": "The Nucleus of a Multiprogramming System", "abstract": "This paper describes the philosophy and structure of a multiprogramming system  that can be extended with a hierarchy of operating systems to suit diverse  requirements of program scheduling and resource allocation.  The system nucleus simulates an environment in which program execution and input/output are handled uniformly as parallel, cooperating process es.  A fundamental set of primitives allows the dynamic creation and control of a hierarchy of processes as well as the communication among them.", "authors": "Hansen, P. B.", "words_pool": ["alloc", "commun", "control", "cooper", "creation", "describ", "divers", "dynam", "environ", "es", "execut", "extend", "fundament", "handl", "hierarchi", "input", "multiprogram", "nucleu", "oper", "output", "paper", "parallel", "philosophi", "primit", "process", "process", "program", "requir", "resourc", "schedul", "set", "simul", "structur", "suit", "system", "system", "uniformli", "hansen"], "word_count": {"alloc": 1, "commun": 1, "control": 1, "cooper": 1, "creation": 1, "describ": 1, "divers": 1, "dynam": 1, "environ": 1, "es": 1, "execut": 1, "extend": 1, "fundament": 1, "handl": 1, "hierarchi": 2, "input": 1, "multiprogram": 1, "nucleu": 1, "oper": 1, "output": 1, "paper": 1, "parallel": 1, "philosophi": 1, "primit": 1, "process": 2, "program": 2, "requir": 1, "resourc": 1, "schedul": 1, "set": 1, "simul": 1, "structur": 1, "suit": 1, "system": 3, "uniformli": 1, "hansen": 1}}, "2081": {"id": "2081", "title": "Some Complete Calculi for Matrices", "abstract": "A matrix calculus is introduced with the intention of developing data structures suitable for a high level algorithmic language for mathematical programming.   The paper investigates how the special structure of matrices can be described and utilized for efficient computing by saving memory space and superfluous operations.  Sequences of Matrices (and sequences of sequences of matrices) are considered, and matrix operators areext ended to sequence operators and cumulative operators.  Algorithms are given which use symbol manipulation of matrix expressions so as to find the forms best suited for computation.  These forms are called normal forms.  Several completeness results are obtained in the sense that for each expression an equivalent expression in normal form can be found within a specified calculus.", "authors": "Bayer, R. Witzgall, C.", "words_pool": ["algorithm", "algorithm", "areext", "calculi", "calculu", "call", "complet", "complet", "comput", "comput", "consid", "cumul", "data", "develop", "effici", "end", "equival", "express", "express", "find", "form", "form", "found", "high", "intent", "introduc", "investig", "languag", "level", "manipul", "mathemat", "matric", "matrix", "memori", "normal", "obtain", "oper", "oper", "paper", "program", "result", "save", "sens", "sequenc", "sequenc", "space", "special", "structur", "structur", "suitabl", "suit", "superflu", "symbol", "util", "bayer", "witzgal"], "word_count": {"algorithm": 2, "areext": 1, "calculi": 1, "calculu": 2, "call": 1, "complet": 1, "comput": 2, "consid": 1, "cumul": 1, "data": 1, "develop": 1, "effici": 1, "end": 1, "equival": 1, "express": 3, "find": 1, "form": 4, "found": 1, "high": 1, "intent": 1, "introduc": 1, "investig": 1, "languag": 1, "level": 1, "manipul": 1, "mathemat": 1, "matric": 3, "matrix": 3, "memori": 1, "normal": 2, "obtain": 1, "oper": 4, "paper": 1, "program": 1, "result": 1, "save": 1, "sens": 1, "sequenc": 4, "space": 1, "special": 1, "structur": 2, "suitabl": 1, "suit": 1, "superflu": 1, "symbol": 1, "util": 1, "bayer": 1, "witzgal": 1}}, "2082": {"id": "2082", "title": "Syntax-Directed Documentation For PL 360", "abstract": "The language PL 360, together with its phrase structure grammar, is used as a  concrete basis for illustrating an idea called syntax-directed documentation.  This idea is (1) to use the phrase structure of a program to define the  structure of a formal documentation for that program; (2) to use the syntactic  types and identifiers in the resulting structure to trigger the automatic formation of questions to the programmer, whose answers will become part of that documentation; and (3) to provide automatic storage and retrieval facilities so that other programmers who want to understand or modify the program can access the resulting documentation, which is cross-indexed in various ways by syntactic types and objects.  A small PL 360 program, already found in the literature, is worked out as an example.", "authors": "Mills, H. D.", "words_pool": ["access", "answer", "automat", "basi", "call", "concret", "cross", "defin", "direct", "document", "facil", "formal", "format", "found", "grammar", "idea", "identifi", "illustr", "index", "languag", "literatur", "modifi", "object", "part", "phrase", "pl", "program", "programm", "programm", "provid", "question", "result", "retriev", "small", "storag", "structur", "syntact", "syntax", "trigger", "type", "understand", "want", "way", "work", "mill"], "word_count": {"access": 1, "answer": 1, "automat": 2, "basi": 1, "call": 1, "concret": 1, "cross": 1, "defin": 1, "direct": 1, "document": 4, "facil": 1, "formal": 1, "format": 1, "found": 1, "grammar": 1, "idea": 2, "identifi": 1, "illustr": 1, "index": 1, "languag": 1, "literatur": 1, "modifi": 1, "object": 1, "part": 1, "phrase": 2, "pl": 2, "program": 4, "programm": 2, "provid": 1, "question": 1, "result": 2, "retriev": 1, "small": 1, "storag": 1, "structur": 4, "syntact": 2, "syntax": 1, "trigger": 1, "type": 2, "understand": 1, "want": 1, "way": 1, "work": 1, "mill": 1}}, "2083": {"id": "2083", "title": "Creation and Control of Internal Data Bases Under a Fortran Programming Environment", "abstract": "A method is described for the definition of a user's COMMON structure and the automatic generation of the necessary COMMON, DIMENSION, EQUIVALENCE, and type declarations for each of the user's routines.  The definition for the COMMON is contained in an easy to modify form, thus allowing the control of general communications of data between routines. The described system has been implemented on the IBM 7094, CDC 6000 series, and the IBM 360.  The method has proved to be invaluable for the definition and control of COMMON in many large-scale programs.", "authors": "DeSalvio, A. J. Purdy, J. G. Rau, J.", "words_pool": ["allow", "automat", "base", "cdc", "common", "commun", "contain", "control", "creation", "data", "declar", "definit", "dimens", "easi", "environ", "equival", "form", "fortran", "gener", "gener", "ibm", "implement", "intern", "invalu", "larg", "method", "modifi", "program", "program", "prove", "routin", "scale", "seri", "structur", "system", "type", "user", "desalvio", "purdi", "rau"], "word_count": {"allow": 1, "automat": 1, "base": 1, "cdc": 1, "common": 4, "commun": 1, "contain": 1, "control": 2, "creation": 1, "data": 1, "declar": 1, "definit": 3, "dimens": 1, "easi": 1, "environ": 1, "equival": 1, "form": 1, "fortran": 1, "gener": 2, "ibm": 2, "implement": 1, "intern": 1, "invalu": 1, "larg": 1, "method": 2, "modifi": 1, "program": 1, "prove": 1, "routin": 2, "scale": 1, "seri": 1, "structur": 1, "system": 1, "type": 1, "user": 2, "desalvio": 1, "purdi": 1, "rau": 1}}, "2084": {"id": "2084", "title": "A Note on the Complement of Inherently Ambiguous Context-Free Languages", "authors": "Maurer, H. A.", "words_pool": ["ambigu", "complement", "context", "free", "inher", "languag", "note", "maurer"], "word_count": {"ambigu": 1, "complement": 1, "context": 1, "free": 1, "inher": 1, "languag": 1, "note": 1, "maurer": 1}}, "2085": {"id": "2085", "title": "Comment on a Paging Anomaly", "authors": "Dempster, J. R. H.", "words_pool": ["anomali", "comment", "page", "dempster"], "word_count": {"anomali": 1, "comment": 1, "page": 1, "dempster": 1}}, "2086": {"id": "2086", "title": "Another Method of Converting from Hexadecimal to Decimal", "authors": "Kailas, M. V.", "words_pool": ["convert", "decim", "hexadecim", "method", "kaila"], "word_count": {"convert": 1, "decim": 1, "hexadecim": 1, "method": 1, "kaila": 1}}, "2087": {"id": "2087", "title": "A Number System for the Permutations", "authors": "Pager, D.", "words_pool": ["number", "permut", "system", "pager"], "word_count": {"number": 1, "permut": 1, "system": 1, "pager": 1}}, "2088": {"id": "2088", "title": "Netflow (ALgorithm 336 $H))", "authors": "Bray, T. A. Witzgall, C.", "words_pool": ["algorithm", "netflow", "bray", "witzgal"], "word_count": {"algorithm": 1, "netflow": 1, "bray": 1, "witzgal": 1}}, "2089": {"id": "2089", "title": "Prime Number (Algorithm 310 $A1))", "authors": "Rapp, D. G. Scott, L. D.", "words_pool": ["a1", "algorithm", "number", "prime", "rapp", "scott"], "word_count": {"a1": 1, "algorithm": 1, "number": 1, "prime": 1, "rapp": 1, "scott": 1}}, "2090": {"id": "2090", "title": "Symbolic Expansion of Algebraic Expressions (Algorithm 377 $R2))", "authors": "Levine, M. J.", "words_pool": ["algebra", "algorithm", "expans", "express", "r2", "symbol", "levin"], "word_count": {"algebra": 1, "algorithm": 1, "expans": 1, "express": 1, "r2": 1, "symbol": 1, "levin": 1}}, "2091": {"id": "2091", "title": "PDEL-A Language for Partial Differential Equations", "abstract": "Conventional computer methods available to solve continuous system problems characterized by partial differential equations are very time-consuming and cumbersome.  A convenient, easy to learn and to use, high level problem oriented language to solve and study partial differential equation problems has been designed; a practical translator for the language has also been designed, and a working version of it has been constructed for a significant portion of the language.  This Partial Differential Equation Language, PDEL, is outlined, and the highlights of the translator are briefly summarized.", "authors": "Cardenas, A. F. Karplus, W. J.", "words_pool": ["briefli", "character", "comput", "construct", "consum", "continu", "conveni", "convent", "cumbersom", "design", "differenti", "easi", "equat", "equat", "high", "highlight", "languag", "learn", "level", "method", "orient", "outlin", "partial", "pdel", "portion", "practic", "problem", "problem", "signific", "solv", "studi", "summar", "system", "time", "translat", "version", "work", "cardena", "karplu"], "word_count": {"briefli": 1, "character": 1, "comput": 1, "construct": 1, "consum": 1, "continu": 1, "conveni": 1, "convent": 1, "cumbersom": 1, "design": 2, "differenti": 3, "easi": 1, "equat": 3, "high": 1, "highlight": 1, "languag": 4, "learn": 1, "level": 1, "method": 1, "orient": 1, "outlin": 1, "partial": 3, "pdel": 1, "portion": 1, "practic": 1, "problem": 3, "signific": 1, "solv": 2, "studi": 1, "summar": 1, "system": 1, "time": 1, "translat": 2, "version": 1, "work": 1, "cardena": 1, "karplu": 1}}, "2092": {"id": "2092", "title": "A Deductive Question-Answer for Natural Language Inference", "abstract": "The question-answering aspects of the Protosynthex III pro totype language processing system are described and exemplified in detail.  The system is written in LISP 1.5 and operates on the Q-32 time-sharing system.  The system's data structures and their semantic organization, the deductive question-answering formalism of relational properties and complex-relation-forming operators, and the question-answering procedures which employ these features in their operation are all described and illustrated.  Examples of the system's performance and of the limitations of its question-answering  capability are presented and discussed.  It is shown that the use of semantic information in deductive question answering greatly  facilitates the process, and that a top-down procedure which works from question to answer enables effective use to be made of this information.  It is concluded that the development of Protosynthex III into a practically useful system to work with large data bases is possible but will require changes in both the data structures and the algorithms used for question answering.", "authors": "Schwarcz, R. M. Burger, J. F. Simmons, R. F.", "words_pool": ["algorithm", "answer", "answer", "aspect", "base", "capabl", "complex", "conclud", "data", "deduct", "detail", "develop", "discuss", "effect", "employ", "enabl", "exampl", "exemplifi", "facilit", "featur", "formal", "form", "greatli", "iii", "illustr", "infer", "inform", "languag", "larg", "limit", "lisp", "made", "natur", "oper", "oper", "oper", "organ", "perform", "practic", "present", "pro", "procedur", "procedur", "process", "process", "properti", "protosynthex", "question", "relat", "relat", "requir", "semant", "share", "shown", "structur", "system", "time", "top", "totyp", "work", "work", "written", "schwarcz", "burger", "simmon"], "word_count": {"algorithm": 1, "answer": 7, "aspect": 1, "base": 1, "capabl": 1, "complex": 1, "conclud": 1, "data": 3, "deduct": 2, "detail": 1, "develop": 1, "discuss": 1, "effect": 1, "employ": 1, "enabl": 1, "exampl": 1, "exemplifi": 1, "facilit": 1, "featur": 1, "formal": 1, "form": 1, "greatli": 1, "iii": 2, "illustr": 1, "infer": 1, "inform": 2, "languag": 1, "larg": 1, "limit": 1, "lisp": 1, "made": 1, "natur": 1, "oper": 3, "organ": 1, "perform": 1, "practic": 1, "present": 1, "pro": 1, "procedur": 2, "process": 2, "properti": 1, "protosynthex": 2, "question": 7, "relat": 2, "requir": 1, "semant": 2, "share": 1, "shown": 1, "structur": 2, "system": 6, "time": 1, "top": 1, "totyp": 1, "work": 2, "written": 1, "schwarcz": 1, "burger": 1, "simmon": 1}}, "2093": {"id": "2093", "title": "A Comparison of Error Improvement Estimates for Adaptive Trapezoid Integration", "abstract": "Various simple choices of error improvement estimates for the trapezoid rule are studied to demonstrate a comparison procedure which is relatively independent of the profusion of adaptive search and stopping strategies.  Comparisons are based on x^r, `; the inclusion of the noninteger powers makes this more realistic than the usual polynomial based comparison.  Behavior near the singularity was found to be the dominant factor, and a new estimate, based on a constant curvature assumption and parametric differences, was considered slightly better than the other choices considered.", "authors": "Schweikert, D. G.", "words_pool": ["adapt", "assumpt", "base", "behavior", "choic", "comparison", "comparison", "consid", "constant", "curvatur", "demonstr", "differ", "domin", "error", "estim", "estim", "factor", "found", "improv", "inclus", "independ", "integr", "make", "noninteg", "parametr", "polynomi", "power", "procedur", "profus", "realist", "rule", "search", "simpl", "singular", "slightli", "stop", "strategi", "studi", "trapezoid", "usual", "schweikert"], "word_count": {"adapt": 1, "assumpt": 1, "base": 3, "behavior": 1, "choic": 2, "comparison": 3, "consid": 2, "constant": 1, "curvatur": 1, "demonstr": 1, "differ": 1, "domin": 1, "error": 1, "estim": 2, "factor": 1, "found": 1, "improv": 1, "inclus": 1, "independ": 1, "integr": 1, "make": 1, "noninteg": 1, "parametr": 1, "polynomi": 1, "power": 1, "procedur": 1, "profus": 1, "realist": 1, "rule": 1, "search": 1, "simpl": 1, "singular": 1, "slightli": 1, "stop": 1, "strategi": 1, "studi": 1, "trapezoid": 1, "usual": 1, "schweikert": 1}}, "2094": {"id": "2094", "title": "On an Algorithm for Nonlinear Minimax Approximation", "abstract": "Certain nonlinear minimax approximation problems are characterize d by properties which permit the application of special algorithms, mainly based on the exchange algorithms of Remes (1934, 1935), for their solution.  In this paper the application to problems of this type of a general nonlinear algorithm due to Osborne and Watson (1969) is considered.  Examples are given to illustrate that this algorithm can give satisfactory results and, in particular, can successfully solve problems which lead to difficulties with the more conventional specialist method.", "authors": "Watson, G. A.", "words_pool": ["algorithm", "algorithm", "applic", "approxim", "base", "character", "consid", "convent", "difficulti", "due", "exampl", "exchang", "gener", "give", "illustr", "lead", "mainli", "method", "minimax", "nonlinear", "osborn", "paper", "permit", "problem", "properti", "reme", "result", "satisfactori", "solut", "solv", "special", "specialist", "success", "type", "watson", "watson"], "word_count": {"algorithm": 4, "applic": 2, "approxim": 1, "base": 1, "character": 1, "consid": 1, "convent": 1, "difficulti": 1, "due": 1, "exampl": 1, "exchang": 1, "gener": 1, "give": 1, "illustr": 1, "lead": 1, "mainli": 1, "method": 1, "minimax": 1, "nonlinear": 2, "osborn": 1, "paper": 1, "permit": 1, "problem": 3, "properti": 1, "reme": 1, "result": 1, "satisfactori": 1, "solut": 1, "solv": 1, "special": 1, "specialist": 1, "success": 1, "type": 1, "watson": 1}}, "2095": {"id": "2095", "title": "Measurements of Segment Size", "abstract": "Distributions of segment sizes measured under routine operating con ditions on a computer system which utilizes variable sized segments (the Burroughs B5500) are discussed.  The most striking feature of the measurements is the large number of small segments-about 60 percent of the segments in use contain less than 40 words.  Although the results are certainly not installation independent, and although they  are particularly influenced by features of the B5500 ALGOL system, they  should be relevant to the design of new computer systems, especially with respect to the organization of paging schemes.", "authors": "Batson, A. Ju, S. Wood, D. C.", "words_pool": ["algol", "b5500", "burrough", "certainli", "comput", "con", "design", "discuss", "distribut", "dition", "especi", "featur", "featur", "independ", "influenc", "instal", "larg", "measur", "measur", "number", "oper", "organ", "page", "percent", "relev", "respect", "result", "routin", "scheme", "segment", "segment", "size", "size", "size", "small", "strike", "system", "system", "util", "variabl", "word", "batson", "ju", "wood"], "word_count": {"algol": 1, "b5500": 2, "burrough": 1, "certainli": 1, "comput": 2, "con": 1, "design": 1, "discuss": 1, "distribut": 1, "dition": 1, "especi": 1, "featur": 2, "independ": 1, "influenc": 1, "instal": 1, "larg": 1, "measur": 2, "number": 1, "oper": 1, "organ": 1, "page": 1, "percent": 1, "relev": 1, "respect": 1, "result": 1, "routin": 1, "scheme": 1, "segment": 4, "size": 2, "small": 1, "strike": 1, "system": 3, "util": 1, "variabl": 1, "word": 1, "batson": 1, "ju": 1, "wood": 1}}, "2096": {"id": "2096", "title": "Experiments with the M & N Tree-Searching Program", "abstract": "The M & N procedure is an improvement to the mini-max backing-up procedure widely used in computer program for game-playing and other purposes.  It is based on the principle that it is desirable to have many options when making decisions in the face of uncertainty.  The mini-max procedure assigns to a MAX (MIN) node the value of the highest (lowest) valued successor to that node.  The M & N procedure assigns to a MAX (MIN) node some function of the M (N) highest (lowest) valued successors.  An M & N procedure was written in LISP to play the game of kalah, and it was demonstrated that  the M & N procedure is significantly superior to the mini-max procedure.  The statistical significance of important conclusions is given.  Since information on statistical significance has often been lacking in papers  on computer experiments in the artificial intelligence field, these experiments  can perhaps serve as a model for future work.", "authors": "Slagle, J. R. Dixon, J. K.", "words_pool": ["artifici", "assign", "back", "base", "comput", "conclus", "decis", "demonstr", "desir", "experi", "face", "field", "function", "futur", "game", "highest", "import", "improv", "inform", "intellig", "kalah", "lack", "lisp", "lowest", "make", "max", "min", "mini", "model", "node", "option", "paper", "play", "play", "principl", "procedur", "program", "purpos", "search", "serv", "signific", "significantli", "statist", "successor", "successor", "superior", "tree", "uncertainti", "valu", "wide", "work", "written", "slagl", "dixon"], "word_count": {"artifici": 1, "assign": 2, "back": 1, "base": 1, "comput": 2, "conclus": 1, "decis": 1, "demonstr": 1, "desir": 1, "experi": 2, "face": 1, "field": 1, "function": 1, "futur": 1, "game": 2, "highest": 2, "import": 1, "improv": 1, "inform": 1, "intellig": 1, "kalah": 1, "lack": 1, "lisp": 1, "lowest": 2, "make": 1, "max": 5, "min": 2, "mini": 3, "model": 1, "node": 3, "option": 1, "paper": 1, "play": 2, "principl": 1, "procedur": 7, "program": 1, "purpos": 1, "search": 1, "serv": 1, "signific": 2, "significantli": 1, "statist": 2, "successor": 2, "superior": 1, "tree": 1, "uncertainti": 1, "valu": 2, "wide": 1, "work": 1, "written": 1, "slagl": 1, "dixon": 1}}, "2097": {"id": "2097", "title": "A Program to Teach Programming", "abstract": "The TEACH system was developed at MIT to ease the cost and improve the results  of elementary instruction in programming.  To the student, TEACH offers loosely  guided experience with a  conversational language which was designed with teaching in mind.  Faculty involvement is minimal.  A term of experience with TEACH is discussed.  Pedagogically, the system appears to be successful;  straightforward reimplementation will make it economically successful as well.  Similar programs of profound tutorial skill will appear only as the results of extended research.  The outlines of his research are beginning to become clear.", "authors": "Fenichel, R. R. Weizenbaum, J. Yochelson, J. C.", "words_pool": ["appear", "begin", "clear", "convers", "cost", "design", "develop", "discuss", "eas", "econom", "elementari", "experi", "extend", "faculti", "guid", "improv", "instruct", "involv", "languag", "loos", "make", "mind", "minim", "mit", "offer", "outlin", "pedagog", "profound", "program", "program", "program", "reimplement", "research", "result", "similar", "skill", "straightforward", "student", "success", "system", "teach", "teach", "term", "tutori", "fenichel", "weizenbaum", "yochelson"], "word_count": {"appear": 1, "begin": 1, "clear": 1, "convers": 1, "cost": 1, "design": 1, "develop": 1, "discuss": 1, "eas": 1, "econom": 1, "elementari": 1, "experi": 2, "extend": 1, "faculti": 1, "guid": 1, "improv": 1, "instruct": 1, "involv": 1, "languag": 1, "loos": 1, "make": 1, "mind": 1, "minim": 1, "mit": 1, "offer": 1, "outlin": 1, "pedagog": 1, "profound": 1, "program": 2, "reimplement": 1, "research": 2, "result": 2, "similar": 1, "skill": 1, "straightforward": 1, "student": 1, "success": 2, "system": 2, "teach": 4, "term": 1, "tutori": 1, "fenichel": 1, "weizenbaum": 1, "yochelson": 1}}, "2098": {"id": "2098", "title": "t-Test Probabilities (Algorithm 321); Student's t-Distribution (Algorithm 344)", "authors": "Hill, G. W. Loughhead, M.", "words_pool": ["algorithm", "distribut", "probabl", "student", "test", "hill", "loughhead"], "word_count": {"algorithm": 2, "distribut": 1, "probabl": 1, "student": 1, "test": 1, "hill": 1, "loughhead": 1}}, "2099": {"id": "2099", "title": "Eigenvalues and Eigen vectors of a Real General Matrix (Algorithm 343 $F))", "authors": "Knoble, H. D.", "words_pool": ["algorithm", "eigen", "eigenvalu", "gener", "matrix", "real", "vector", "knobl"], "word_count": {"algorithm": 1, "eigen": 1, "eigenvalu": 1, "gener": 1, "matrix": 1, "real": 1, "vector": 1, "knobl": 1}}, "2100": {"id": "2100", "title": "Ortho (Algorithm 127 $F5))", "authors": "Barrodale, I.", "words_pool": ["algorithm", "f5", "ortho", "barrodal"], "word_count": {"algorithm": 1, "f5": 1, "ortho": 1, "barrodal": 1}}, "2101": {"id": "2101", "title": "Least Squares Fit By f(x) = Acos(Bx+C) (Algorithm 376 $E2))", "authors": "Spath, H.", "words_pool": ["aco", "algorithm", "bx", "e2", "fit", "squar", "spath"], "word_count": {"aco": 1, "algorithm": 1, "bx": 1, "e2": 1, "fit": 1, "squar": 1, "spath": 1}}, "2102": {"id": "2102", "title": "Fitting Data To One Exponential (Algorithm 375 $E2))", "authors": "Spath, H.", "words_pool": ["algorithm", "data", "e2", "exponenti", "fit", "spath"], "word_count": {"algorithm": 1, "data": 1, "e2": 1, "exponenti": 1, "fit": 1, "spath": 1}}, "2103": {"id": "2103", "title": "Restricted Partition Generator (Algorithm 374 $A1))", "authors": "White, J. S.", "words_pool": ["a1", "algorithm", "gener", "partit", "restrict", "white"], "word_count": {"a1": 1, "algorithm": 1, "gener": 1, "partit": 1, "restrict": 1, "white": 1}}, "2104": {"id": "2104", "title": "Number of Doubly Restricted Partitions (Algorithm 373 $A1))", "authors": "White, J. S.", "words_pool": ["a1", "algorithm", "doubli", "number", "partit", "restrict", "white"], "word_count": {"a1": 1, "algorithm": 1, "doubli": 1, "number": 1, "partit": 1, "restrict": 1, "white": 1}}, "2105": {"id": "2105", "title": "An Interactive Computer System Using Graphical Flowchart Input", "abstract": "An interactive computer system operational on a graphical computer terminal is  described.  This system was designed to demonstrate a method of programming by  computer interpretation of a flowchart.  The user draws a description of a sampled-data system and specifies description is transmitted to a large scale computer.  The design is simulated, and a graphic representation of the  processed signal is returned to the scope.  A successful design may require  numerous modifications of the original design.  A graphical interactive system  provides an environment to perform this iterative process efficiently and  effectively.", "authors": "Robins, M. F. Beyer, J. D.", "words_pool": ["comput", "data", "demonstr", "descript", "design", "design", "draw", "effect", "effici", "environ", "flowchart", "graphic", "graphic", "input", "interact", "interpret", "iter", "larg", "method", "modif", "numer", "oper", "origin", "perform", "process", "process", "program", "represent", "requir", "sampl", "scale", "scope", "signal", "simul", "specifi", "success", "system", "termin", "transmit", "user", "robin", "beyer"], "word_count": {"comput": 4, "data": 1, "demonstr": 1, "descript": 2, "design": 4, "draw": 1, "effect": 1, "effici": 1, "environ": 1, "flowchart": 1, "graphic": 3, "input": 1, "interact": 2, "interpret": 1, "iter": 1, "larg": 1, "method": 1, "modif": 1, "numer": 1, "oper": 1, "origin": 1, "perform": 1, "process": 2, "program": 1, "represent": 1, "requir": 1, "sampl": 1, "scale": 1, "scope": 1, "signal": 1, "simul": 1, "specifi": 1, "success": 1, "system": 4, "termin": 1, "transmit": 1, "user": 1, "robin": 1, "beyer": 1}}, "2106": {"id": "2106", "title": "Computer Education in a Graduate School of Management", "abstract": "Several years of experience have led to the belief that the creative design and evaluation of management information systems requires a thorough understanding of the related computer technology.  Concepts such as paging and priority interrupt systems can best be explained at the  machine language level.  Any machine used for exposition should fulfill several criteria.  It should: (1) raise as few spurious issues as possible; (2) allow, without undue effort, the solution of interesting problems; (3) be capable of exposing all outstanding issues of significance, capable of exposing all outstanding issues of significance, within the chosen machine; (4) be seful for pursuing issues in great depth when appropriate; (5) not be committed to the equipment provided by any manufacturer; (6) be able to  provide the student with diagnostic aids to a great depth; (7) allow the student ready access to the machine; (8) be capable of extension to expose new issues as they come along.  We have constructed a simulated machine and its associated software which meets these criteria.  This system, called the PRISM system, is documented by a primer and a reference manual.", "authors": "Ness, D. N. Green, R. S. Martin, W. A. Moulton, G. A.", "words_pool": ["abl", "access", "aid", "allow", "belief", "call", "capabl", "chosen", "come", "commit", "comput", "concept", "construct", "creativ", "criteria", "depth", "design", "diagnost", "document", "educ", "effort", "equip", "evalu", "experi", "explain", "expos", "expos", "exposit", "extens", "fulfil", "graduat", "great", "inform", "interest", "interrupt", "issu", "languag", "led", "level", "machin", "manag", "manufactur", "meet", "outstand", "page", "primer", "prioriti", "prism", "problem", "provid", "provid", "pursu", "rais", "readi", "refer", "relat", "requir", "school", "seful", "signific", "simul", "softwar", "solut", "spuriou", "student", "system", "system", "technolog", "understand", "undu", "year", "ness", "green", "martin", "moulton"], "word_count": {"abl": 1, "access": 1, "aid": 1, "allow": 2, "belief": 1, "call": 1, "capabl": 3, "chosen": 1, "come": 1, "commit": 1, "comput": 1, "concept": 1, "construct": 1, "creativ": 1, "criteria": 2, "depth": 2, "design": 1, "diagnost": 1, "document": 1, "educ": 1, "effort": 1, "equip": 1, "evalu": 1, "experi": 1, "explain": 1, "expos": 3, "exposit": 1, "extens": 1, "fulfil": 1, "graduat": 1, "great": 2, "inform": 1, "interest": 1, "interrupt": 1, "issu": 5, "languag": 1, "led": 1, "level": 1, "machin": 5, "manag": 1, "manufactur": 1, "meet": 1, "outstand": 2, "page": 1, "primer": 1, "prioriti": 1, "prism": 1, "problem": 1, "provid": 2, "pursu": 1, "rais": 1, "readi": 1, "refer": 1, "relat": 1, "requir": 1, "school": 1, "seful": 1, "signific": 2, "simul": 1, "softwar": 1, "solut": 1, "spuriou": 1, "student": 2, "system": 4, "technolog": 1, "understand": 1, "undu": 1, "year": 1, "ness": 1, "green": 1, "martin": 1, "moulton": 1}}, "2107": {"id": "2107", "title": "The Quadratic Quotient Method: A Hash Code Eliminating Secondary Clustering", "abstract": "Secondary clustering as a cause of hash code inefficiency is discussed, and a  new hashing method based on its elimination is presented.  Comparisons with  previous methods are made both analytically and empirically.", "authors": "Bell, J. R.", "words_pool": ["analyt", "base", "cluster", "code", "comparison", "discuss", "elimin", "elimin", "empir", "hash", "hash", "ineffici", "made", "method", "method", "present", "previou", "quadrat", "quotient", "secondari", "bell"], "word_count": {"analyt": 1, "base": 1, "cluster": 1, "code": 1, "comparison": 1, "discuss": 1, "elimin": 1, "empir": 1, "hash": 2, "ineffici": 1, "made": 1, "method": 2, "present": 1, "previou": 1, "quadrat": 1, "quotient": 1, "secondari": 1, "bell": 1}}, "2108": {"id": "2108", "title": "A Variation on Sorting by Address Calculation", "abstract": "The principles of address calculation and merging are combined to yield an efficient sorting technique. Detailed flowcharts of the most important program steps are included. The characteristics of the proposed sort are discussed.", "authors": "Jones, B.", "words_pool": ["address", "calcul", "characterist", "combin", "detail", "discuss", "effici", "flowchart", "import", "includ", "merg", "principl", "program", "propos", "sort", "sort", "step", "techniqu", "variat", "yield", "jone"], "word_count": {"address": 1, "calcul": 1, "characterist": 1, "combin": 1, "detail": 1, "discuss": 1, "effici": 1, "flowchart": 1, "import": 1, "includ": 1, "merg": 1, "principl": 1, "program": 1, "propos": 1, "sort": 2, "step": 1, "techniqu": 1, "variat": 1, "yield": 1, "jone": 1}}, "2109": {"id": "2109", "title": "The Use of Quadratic Residue Research", "abstract": "A quadratic residue search method has previously been suggested to avoid the clustering usually encountered when hash address collisions occur and linear search methods are used.  The search size, because of the property of quadratic residues, is limited to one half of the storage table.  It is shown that for some classes of prime numbers the complement of the set of quadratic residues can easily be determined and  hence the entire table of size p, where p is that prime number, can be searched.", "authors": "Radke, C. E.", "words_pool": ["address", "avoid", "class", "cluster", "collis", "complement", "determin", "easili", "encount", "entir", "half", "hash", "limit", "linear", "method", "method", "number", "number", "occur", "previous", "prime", "properti", "quadrat", "research", "residu", "residu", "search", "search", "set", "shown", "size", "storag", "suggest", "tabl", "radk"], "word_count": {"address": 1, "avoid": 1, "class": 1, "cluster": 1, "collis": 1, "complement": 1, "determin": 1, "easili": 1, "encount": 1, "entir": 1, "half": 1, "hash": 1, "limit": 1, "linear": 1, "method": 2, "number": 2, "occur": 1, "previous": 1, "prime": 2, "properti": 1, "quadrat": 3, "research": 1, "residu": 3, "search": 4, "set": 1, "shown": 1, "size": 2, "storag": 1, "suggest": 1, "tabl": 2, "radk": 1}}, "2110": {"id": "2110", "title": "An Efficient Context-free Parsing Algorithm", "abstract": "A parsing algorithm which seems to be the most efficient general context-free  algorithm known is described.  It is similar to both Knuth's LR(k) algorithm  and the familiar top-down algorithm.  It has a time bound proportional to  n^3 (where n is the length of the string being parsed) in general; it has a  n^2 bound for unambiguous grammars; and it runs in linear time on a large  class of grammars, which seems to include most practical context-free programming language grammars.  In an empirical comparison it appears to be superior to the top-down and bottom-up algorithms studied by Griffiths  and Petrick.", "authors": "Earley, J.", "words_pool": ["algorithm", "algorithm", "appear", "bottom", "bound", "class", "comparison", "context", "effici", "empir", "familiar", "free", "gener", "grammar", "griffith", "includ", "known", "knuth", "languag", "larg", "length", "linear", "lr", "pars", "pars", "petrick", "practic", "program", "proport", "run", "similar", "string", "studi", "superior", "time", "top", "unambigu", "earley"], "word_count": {"algorithm": 5, "appear": 1, "bottom": 1, "bound": 2, "class": 1, "comparison": 1, "context": 2, "effici": 1, "empir": 1, "familiar": 1, "free": 2, "gener": 2, "grammar": 3, "griffith": 1, "includ": 1, "known": 1, "knuth": 1, "languag": 1, "larg": 1, "length": 1, "linear": 1, "lr": 1, "pars": 2, "petrick": 1, "practic": 1, "program": 1, "proport": 1, "run": 1, "similar": 1, "string": 1, "studi": 1, "superior": 1, "time": 2, "top": 2, "unambigu": 1, "earley": 1}}, "2111": {"id": "2111", "title": "Spelling Correction in Systems Programs", "abstract": "Several specialized techniques are shown for efficiently incorporating spelling correction algorithms in to compilers and operating systems.  These include the use of syntax and semantics information, the organization of restricted keyword and symbol tables, and the consideration of a limited class of spelling errors.  Sample 360 coding for performing spelling correction is presented.  By using systems which perform spelling correction, the number of debugging runs per program has been decreased, saving both programmer and machine time.", "authors": "Morgan, H. L.", "words_pool": ["algorithm", "class", "code", "compil", "consider", "correct", "debug", "decreas", "effici", "error", "includ", "incorpor", "inform", "keyword", "limit", "machin", "number", "oper", "organ", "perform", "perform", "present", "program", "programm", "program", "restrict", "run", "sampl", "save", "semant", "shown", "special", "spell", "symbol", "syntax", "system", "tabl", "techniqu", "time", "morgan"], "word_count": {"algorithm": 1, "class": 1, "code": 1, "compil": 1, "consider": 1, "correct": 3, "debug": 1, "decreas": 1, "effici": 1, "error": 1, "includ": 1, "incorpor": 1, "inform": 1, "keyword": 1, "limit": 1, "machin": 1, "number": 1, "oper": 1, "organ": 1, "perform": 2, "present": 1, "program": 1, "programm": 1, "restrict": 1, "run": 1, "sampl": 1, "save": 1, "semant": 1, "shown": 1, "special": 1, "spell": 4, "symbol": 1, "syntax": 1, "system": 2, "tabl": 1, "techniqu": 1, "time": 1, "morgan": 1}}, "2112": {"id": "2112", "title": "Translation Equations", "abstract": "Input limited transduction expressions, or translation equations, are used to describe the syntax and left-context sensitive semantics for  context-free languages.  A formal procedure is given for deriving from a set of translation equations the specifications for a pushdown translator. The translator consists of Mealy form finite-state automata interacting by means of a pushdown stack.  Within the framework described string  recognition and parsing may be treated as special cases of the translation  problem.", "authors": "Vere, S.", "words_pool": ["automata", "case", "consist", "context", "deriv", "describ", "equat", "express", "finit", "form", "formal", "framework", "free", "input", "interact", "languag", "left", "limit", "meali", "mean", "pars", "problem", "procedur", "pushdown", "recognit", "semant", "sensit", "set", "special", "specif", "stack", "state", "string", "syntax", "transduct", "translat", "translat", "treat", "vere"], "word_count": {"automata": 1, "case": 1, "consist": 1, "context": 2, "deriv": 1, "describ": 1, "equat": 2, "express": 1, "finit": 1, "form": 1, "formal": 1, "framework": 1, "free": 1, "input": 1, "interact": 1, "languag": 1, "left": 1, "limit": 1, "meali": 1, "mean": 1, "pars": 1, "problem": 1, "procedur": 1, "pushdown": 2, "recognit": 1, "semant": 1, "sensit": 1, "set": 1, "special": 1, "specif": 1, "stack": 1, "state": 1, "string": 1, "syntax": 1, "transduct": 1, "translat": 5, "treat": 1, "vere": 1}}, "2113": {"id": "2113", "title": "The Multistore Parser for Hierarchical Syntactic Structures", "abstract": "A syntactic parser is described for hierarchical concatenation patterns that are presented to the analyzer in the form of linear strings.  Particular emphasis is given to the system of \"significant addresses\" by means of which processing times for large-scale matching procedures can be substantially reduced.  The description makes frequent use of examples taken from the fully operational implementation of the parser in an experimental English sentence analyzer.  By structuring an area of the computer's central core storage in such a way that the individual locations of bytes and bits come to represent the data involved in the matching procedure, the shifting of information is reduced to a minimum, and the searching of lists is eliminated altogether.  The matches are traced by means of binary masks and the state of single bits determines the operational flow of the procedure.  The method could be implemented with any interpretive grammar, provided it can be expressed by the functional classification of the items composing the input hierarchical structures.", "authors": "von Glasersfeld, E.", "words_pool": ["address", "altogeth", "analyz", "area", "binari", "bit", "byte", "central", "classif", "come", "compos", "comput", "concaten", "core", "data", "descript", "determin", "elimin", "emphasi", "english", "exampl", "experiment", "express", "flow", "form", "frequent", "fulli", "function", "grammar", "hierarch", "implement", "implement", "individu", "inform", "input", "interpret", "involv", "item", "larg", "linear", "list", "locat", "make", "mask", "match", "match", "mean", "method", "minimum", "multistor", "oper", "parser", "pattern", "present", "procedur", "procedur", "process", "provid", "reduc", "repres", "scale", "search", "sentenc", "shift", "signific", "singl", "state", "storag", "string", "structur", "structur", "substanti", "syntact", "system", "time", "trace", "von", "glasersfeld"], "word_count": {"address": 1, "altogeth": 1, "analyz": 2, "area": 1, "binari": 1, "bit": 2, "byte": 1, "central": 1, "classif": 1, "come": 1, "compos": 1, "comput": 1, "concaten": 1, "core": 1, "data": 1, "descript": 1, "determin": 1, "elimin": 1, "emphasi": 1, "english": 1, "exampl": 1, "experiment": 1, "express": 1, "flow": 1, "form": 1, "frequent": 1, "fulli": 1, "function": 1, "grammar": 1, "hierarch": 2, "implement": 2, "individu": 1, "inform": 1, "input": 1, "interpret": 1, "involv": 1, "item": 1, "larg": 1, "linear": 1, "list": 1, "locat": 1, "make": 1, "mask": 1, "match": 3, "mean": 2, "method": 1, "minimum": 1, "multistor": 1, "oper": 2, "parser": 2, "pattern": 1, "present": 1, "procedur": 3, "process": 1, "provid": 1, "reduc": 2, "repres": 1, "scale": 1, "search": 1, "sentenc": 1, "shift": 1, "signific": 1, "singl": 1, "state": 1, "storag": 1, "string": 1, "structur": 2, "substanti": 1, "syntact": 1, "system": 1, "time": 1, "trace": 1, "von": 1, "glasersfeld": 1}}, "2114": {"id": "2114", "title": "A Formal System for Information Retrieval from Files", "abstract": "A generalized file structure is provided by which the concepts of keyword, index, record, file, directory, file structure, directory decoding, and record retrieval are defined and from which some of the frequently used file structures such as inverted files, index-sequential files, and multilist files are derived.  Two algorithms which retrieve records from the generalized file  structure are presented.", "authors": "Hsiao, D.", "words_pool": ["algorithm", "concept", "decod", "defin", "deriv", "directori", "formal", "frequent", "gener", "index", "inform", "invert", "keyword", "multilist", "present", "provid", "record", "record", "retriev", "retriev", "sequenti", "structur", "structur", "system", "hsiao"], "word_count": {"algorithm": 1, "concept": 1, "decod": 1, "defin": 1, "deriv": 1, "directori": 2, "formal": 1, "frequent": 1, "gener": 2, "index": 2, "inform": 1, "invert": 1, "keyword": 1, "multilist": 1, "present": 1, "provid": 1, "record": 3, "retriev": 2, "sequenti": 1, "structur": 4, "system": 1, "hsiao": 1}}, "2115": {"id": "2115", "title": "Fortran Tausworthe Pseudorandom Number Generator", "authors": "Payne, W. H.", "words_pool": ["fortran", "gener", "number", "pseudorandom", "tausworth", "payn"], "word_count": {"fortran": 1, "gener": 1, "number": 1, "pseudorandom": 1, "tausworth": 1, "payn": 1}}, "2116": {"id": "2116", "title": "Interchange Rolls of Perforated Tape for Information Interchange* (Proposed American National Standard)", "words_pool": ["american", "inform", "interchang", "nation", "perfor", "propos", "roll", "standard", "tape"], "word_count": {"american": 1, "inform": 1, "interchang": 2, "nation": 1, "perfor": 1, "propos": 1, "roll": 1, "standard": 1, "tape": 1}}, "2117": {"id": "2117", "title": "Representation for Calen dar Date for Machine-to-Machine Data Interchange* (Proposed American National Standard)", "words_pool": ["american", "calen", "dar", "data", "date", "interchang", "machin", "nation", "propos", "represent", "standard"], "word_count": {"american": 1, "calen": 1, "dar": 1, "data": 1, "date": 1, "interchang": 1, "machin": 2, "nation": 1, "propos": 1, "represent": 1, "standard": 1}}, "2118": {"id": "2118", "title": "An Efficient Algorithm for Sorting with Minimal Storage (Algorithm 347 $M1))", "authors": "Griffin, R. Redish, K. A.", "words_pool": ["algorithm", "effici", "m1", "minim", "sort", "storag", "griffin", "redish"], "word_count": {"algorithm": 2, "effici": 1, "m1": 1, "minim": 1, "sort": 1, "storag": 1, "griffin": 1, "redish": 1}}, "2119": {"id": "2119", "title": "Derivatives (Algorithm 282 $S22))", "authors": "Gautschi, W. Klein, B. J.", "words_pool": ["algorithm", "deriv", "s22", "gautschi", "klein"], "word_count": {"algorithm": 1, "deriv": 1, "s22": 1, "gautschi": 1, "klein": 1}}, "2120": {"id": "2120", "title": "An Algorithm to Produce Complex Primes, Csieve (Algorithm 372 $A1))", "authors": "Dunham, K. B.", "words_pool": ["a1", "algorithm", "complex", "csiev", "prime", "produc", "dunham"], "word_count": {"a1": 1, "algorithm": 2, "complex": 1, "csiev": 1, "prime": 1, "produc": 1, "dunham": 1}}, "2121": {"id": "2121", "title": "Partitions in Natural Order (Algorithm 371 $A1))", "authors": "McKay, J. K. S.", "words_pool": ["a1", "algorithm", "natur", "order", "partit", "mckay"], "word_count": {"a1": 1, "algorithm": 1, "natur": 1, "order": 1, "partit": 1, "mckay": 1}}, "2122": {"id": "2122", "title": "General Random Number Generator (Algorithm 370 $G5))", "authors": "Butler, E. L.", "words_pool": ["algorithm", "g5", "gener", "gener", "number", "random", "butler"], "word_count": {"algorithm": 1, "g5": 1, "gener": 2, "number": 1, "random": 1, "butler": 1}}, "2123": {"id": "2123", "title": "Generator of Random Numbers Satisfying the Poisson Distribution (Algorithm 369 $G5))", "authors": "Schaffer, H. E.", "words_pool": ["algorithm", "distribut", "g5", "gener", "number", "poisson", "random", "satisfi", "schaffer"], "word_count": {"algorithm": 1, "distribut": 1, "g5": 1, "gener": 1, "number": 1, "poisson": 1, "random": 1, "satisfi": 1, "schaffer": 1}}, "2124": {"id": "2124", "title": "Numerical Inversion of Laplace Transforms (Algorithm 368 $D5))", "authors": "Stehfest, H.", "words_pool": ["algorithm", "d5", "invers", "laplac", "numer", "transform", "stehfest"], "word_count": {"algorithm": 1, "d5": 1, "invers": 1, "laplac": 1, "numer": 1, "transform": 1, "stehfest": 1}}, "2125": {"id": "2125", "title": "A Note on Minimal Length Polygonal Approximation to a Digitized Contour", "abstract": "A method for extracting a smooth polygonal contour from a digitized image is illustrated. The ordered sequence of contour points and the connection graph of the image are first obtained by a modified Ledley algorithm in one image scan.  A minimal perimeter polygon subjected to specified constraints is then chosen as the approximating contour.  The determination of the minimal  polygon can be reduced to a nonlinear programming problem, solved by an algorithm which takes into account the weak bonds between variables.  Some examples are presented, and the corresponding computing times are listed.", "authors": "Montanari, U.", "words_pool": ["account", "algorithm", "approxim", "approxim", "bond", "chosen", "comput", "connect", "constraint", "contour", "determin", "digit", "exampl", "extract", "graph", "illustr", "imag", "ledley", "length", "list", "method", "minim", "modifi", "nonlinear", "note", "obtain", "order", "perimet", "point", "polygon", "polygon", "present", "problem", "program", "reduc", "scan", "sequenc", "smooth", "solv", "subject", "take", "time", "variabl", "weak", "montanari"], "word_count": {"account": 1, "algorithm": 2, "approxim": 1, "bond": 1, "chosen": 1, "comput": 1, "connect": 1, "constraint": 1, "contour": 3, "determin": 1, "digit": 1, "exampl": 1, "extract": 1, "graph": 1, "illustr": 1, "imag": 3, "ledley": 1, "length": 1, "list": 1, "method": 1, "minim": 2, "modifi": 1, "nonlinear": 1, "note": 1, "obtain": 1, "order": 1, "perimet": 1, "point": 1, "polygon": 3, "present": 1, "problem": 1, "program": 1, "reduc": 1, "scan": 1, "sequenc": 1, "smooth": 1, "solv": 1, "subject": 1, "take": 1, "time": 1, "variabl": 1, "weak": 1, "montanari": 1}}, "2126": {"id": "2126", "title": "Experience with an Extensible Language", "abstract": "An operational extensible language system is described. The system and its base language are appraised with  respect to efficiency, flexibility, and utility for different categories of users.", "authors": "Irons, E. T.", "words_pool": ["apprais", "base", "categori", "effici", "experi", "extens", "flexibl", "languag", "oper", "respect", "system", "user", "util", "iron"], "word_count": {"apprais": 1, "base": 1, "categori": 1, "effici": 1, "experi": 1, "extens": 1, "flexibl": 1, "languag": 2, "oper": 1, "respect": 1, "system": 2, "user": 1, "util": 1, "iron": 1}}, "2127": {"id": "2127", "title": "Natural Language Question-Answering Systems: 1969", "abstract": "Recent experiments in programming natural language question-answering systems are reviewed to summarize the methods that have been developed for syntactic, semantic, and logical analysis of English strings.  It is concluded that at least minimally effective techniques have been devised for answering questions from natural language subsets in small scale experimental systems and that a useful paradigm has evolved to guide research efforts in the field.  Current approaches to semantic analysis and logical inference are seen to be effective beginnings but of questionable generality with respect either to subtle aspects of  meaning or to applications over large subsets of English.  Generalizing from current small-scale experiments to language-processing  systems based on dictionaries with thousands of entries-with correspondingly large grammars and semantic systems-may entail a new order of complexity and require the invention and development of entirely different approaches to semantic analysis and questions answering.", "authors": "Simmons, R. F.", "words_pool": ["analysi", "answer", "applic", "approach", "aspect", "base", "begin", "complex", "conclud", "correspondingli", "develop", "develop", "devis", "dictionari", "effect", "effort", "english", "entail", "entir", "entri", "evolv", "experiment", "experi", "field", "gener", "gener", "grammar", "guid", "infer", "invent", "languag", "larg", "logic", "mean", "method", "minim", "natur", "order", "paradigm", "process", "program", "question", "question", "question", "recent", "requir", "research", "respect", "review", "scale", "seen", "semant", "small", "string", "subset", "subtl", "summar", "syntact", "system", "techniqu", "thousand", "simmon"], "word_count": {"analysi": 3, "answer": 3, "applic": 1, "approach": 2, "aspect": 1, "base": 1, "begin": 1, "complex": 1, "conclud": 1, "correspondingli": 1, "develop": 2, "devis": 1, "dictionari": 1, "effect": 2, "effort": 1, "english": 2, "entail": 1, "entir": 1, "entri": 1, "evolv": 1, "experiment": 1, "experi": 2, "field": 1, "gener": 2, "grammar": 1, "guid": 1, "infer": 1, "invent": 1, "languag": 3, "larg": 2, "logic": 2, "mean": 1, "method": 1, "minim": 1, "natur": 2, "order": 1, "paradigm": 1, "process": 1, "program": 1, "question": 4, "recent": 1, "requir": 1, "research": 1, "respect": 1, "review": 1, "scale": 2, "seen": 1, "semant": 4, "small": 2, "string": 1, "subset": 2, "subtl": 1, "summar": 1, "syntact": 1, "system": 4, "techniqu": 1, "thousand": 1, "simmon": 1}}, "2128": {"id": "2128", "title": "A Processor Allocation Method for Time-Sharing", "abstract": "A scheduling algorithm is proposed which is intended to minimize changes of  tasks on processors and thereby reduce over-head.  The algorithm also has application to more general resource allocation problems.  It is implemented  by means of a method for efficiently handling dynamically changing segmented  lists.", "authors": "Mullery, A. P. Driscoll, G. C.", "words_pool": ["algorithm", "alloc", "applic", "chang", "dynam", "effici", "gener", "handl", "head", "implement", "intend", "list", "mean", "method", "minim", "problem", "processor", "processor", "propos", "reduc", "resourc", "schedul", "segment", "share", "task", "time", "mulleri", "driscol"], "word_count": {"algorithm": 2, "alloc": 1, "applic": 1, "chang": 1, "dynam": 1, "effici": 1, "gener": 1, "handl": 1, "head": 1, "implement": 1, "intend": 1, "list": 1, "mean": 1, "method": 1, "minim": 1, "problem": 1, "processor": 1, "propos": 1, "reduc": 1, "resourc": 1, "schedul": 1, "segment": 1, "share": 1, "task": 1, "time": 1, "mulleri": 1, "driscol": 1}}, "2129": {"id": "2129", "title": "Recursive Computation of Certain Derivatives-A Study of Error Propagation", "abstract": "A brief study is made of the propagation of errors in linear first-order difference equations.  The recursive computation of successive derivatives of (e^x)/x and (cos x)/x is considered as an illustration.", "authors": "Gautschi, W.", "words_pool": ["comput", "consid", "co", "deriv", "differ", "equat", "error", "error", "illustr", "linear", "made", "order", "propag", "recurs", "studi", "success", "gautschi"], "word_count": {"comput": 1, "consid": 1, "co": 1, "deriv": 1, "differ": 1, "equat": 1, "error": 1, "illustr": 1, "linear": 1, "made": 1, "order": 1, "propag": 1, "recurs": 1, "studi": 1, "success": 1, "gautschi": 1}}, "2130": {"id": "2130", "title": "Automatic Segmentation of Cyclic Program Structures Based on Connectivity and Processor Timing", "abstract": "Time-shared, multiprogrammed, and overlayed batch systems frequently require segmentation of computer programs into discrete portions.   These program portions are transferred between executable and peripheral storage whenever necessary; segmentation of program s in a manner that  reduces the frequency of such transfers is the subject of this paper.  Segmentation techniques proposed by C. V. Ramamoorthy are subject to limitations that arise when the preferred segment size is not compatible with the physical restrictions imposed by the available computing equipment.  A generalization of Ramamoorthy's suggestions is made in order to allow their application  when circumstances are other than ideal.", "authors": "Lowe, T. C.", "words_pool": ["allow", "applic", "aris", "automat", "base", "batch", "circumst", "compat", "comput", "comput", "connect", "cyclic", "discret", "equip", "execut", "frequenc", "frequent", "gener", "ideal", "impos", "limit", "made", "manner", "multiprogram", "order", "overlay", "paper", "peripher", "physic", "portion", "prefer", "processor", "program", "program", "propos", "ramamoorthi", "reduc", "requir", "restrict", "segment", "segment", "share", "size", "storag", "structur", "subject", "suggest", "system", "techniqu", "time", "time", "transfer", "transfer", "low"], "word_count": {"allow": 1, "applic": 1, "aris": 1, "automat": 1, "base": 1, "batch": 1, "circumst": 1, "compat": 1, "comput": 2, "connect": 1, "cyclic": 1, "discret": 1, "equip": 1, "execut": 1, "frequenc": 1, "frequent": 1, "gener": 1, "ideal": 1, "impos": 1, "limit": 1, "made": 1, "manner": 1, "multiprogram": 1, "order": 1, "overlay": 1, "paper": 1, "peripher": 1, "physic": 1, "portion": 2, "prefer": 1, "processor": 1, "program": 3, "propos": 1, "ramamoorthi": 2, "reduc": 1, "requir": 1, "restrict": 1, "segment": 4, "share": 1, "size": 1, "storag": 1, "structur": 1, "subject": 2, "suggest": 1, "system": 1, "techniqu": 1, "time": 1, "transfer": 2, "low": 1}}, "2131": {"id": "2131", "title": "Rapid Computation of Weights of Interpolatory Quadrature Rules [D1] (Algorithm 417)", "authors": "Gustafson, S.", "words_pool": ["algorithm", "comput", "d1", "interpolatori", "quadratur", "rapid", "rule", "weight", "gustafson"], "word_count": {"algorithm": 1, "comput": 1, "d1": 1, "interpolatori": 1, "quadratur": 1, "rapid": 1, "rule": 1, "weight": 1, "gustafson": 1}}, "2132": {"id": "2132", "title": "Rapid Computation of Coefficients of Interpolation Formulas [E1] (Algorithm 416)", "authors": "Gustafson, S.", "words_pool": ["algorithm", "coeffici", "comput", "e1", "formula", "interpol", "rapid", "gustafson"], "word_count": {"algorithm": 1, "coeffici": 1, "comput": 1, "e1": 1, "formula": 1, "interpol": 1, "rapid": 1, "gustafson": 1}}, "2133": {"id": "2133", "title": "Algorithm for the Assignment Problem (Rectangular Matrices) [H] (Algorithm 415)", "authors": "Bourgeois, F. Lassalle, J. C.", "words_pool": ["algorithm", "assign", "matric", "problem", "rectangular", "bourgeoi", "lassal"], "word_count": {"algorithm": 2, "assign": 1, "matric": 1, "problem": 1, "rectangular": 1, "bourgeoi": 1, "lassal": 1}}, "2134": {"id": "2134", "title": "An Extension of the Munkres Algorithm for the Assignment Problem to Rectangular Matrices", "abstract": "The assignment problem, together with Munkres proposed algorithm for its solution in square  matrices, is presented first.  Then the authors develop an extension of this algorithm which permits  a solution for rectangular matrices.  Timing results obtained by using an adapted version of Silver's  Algol procedure are discussed, and a relation between solution time and problem size is given.", "authors": "Bourgeois, F. Lassalle, J.", "words_pool": ["adapt", "algol", "algorithm", "assign", "author", "develop", "discuss", "extens", "matric", "munkr", "obtain", "permit", "present", "problem", "procedur", "propos", "rectangular", "relat", "result", "silver", "size", "solut", "squar", "time", "time", "version", "bourgeoi", "lassal"], "word_count": {"adapt": 1, "algol": 1, "algorithm": 2, "assign": 1, "author": 1, "develop": 1, "discuss": 1, "extens": 1, "matric": 2, "munkr": 1, "obtain": 1, "permit": 1, "present": 1, "problem": 2, "procedur": 1, "propos": 1, "rectangular": 1, "relat": 1, "result": 1, "silver": 1, "size": 1, "solut": 3, "squar": 1, "time": 2, "version": 1, "bourgeoi": 1, "lassal": 1}}, "2135": {"id": "2135", "title": "Rapid Computation of General Interpolation Formulas and Mechanical Quadrature Rules", "abstract": "Let f have n continuous on a closed interval [a,b] and let L be a linear functional.  The attempt  is made to approximate L (f) with L (Q) where Q is a polynomial, approximating f.  Algorithms are developed  for rapid computation of L (Q) for a wide class of selections of Q which includes the Lagrangian and  Hermitian rules as special cases.", "authors": "Gustafson, S.", "words_pool": ["algorithm", "approxim", "approxim", "attempt", "case", "class", "close", "comput", "continu", "develop", "formula", "function", "gener", "hermitian", "includ", "interpol", "interv", "lagrangian", "let", "linear", "made", "mechan", "polynomi", "quadratur", "rapid", "rule", "select", "special", "wide", "gustafson"], "word_count": {"algorithm": 1, "approxim": 2, "attempt": 1, "case": 1, "class": 1, "close": 1, "comput": 1, "continu": 1, "develop": 1, "formula": 1, "function": 1, "gener": 1, "hermitian": 1, "includ": 1, "interpol": 1, "interv": 1, "lagrangian": 1, "let": 2, "linear": 1, "made": 1, "mechan": 1, "polynomi": 1, "quadratur": 1, "rapid": 1, "rule": 1, "select": 1, "special": 1, "wide": 1, "gustafson": 1}}, "2136": {"id": "2136", "title": "A Note on \"A Modification of Nordsieck's Method Using an 'Off-Step' Point\"", "authors": "Blumberg, J. W. Foulk, C. R.", "words_pool": ["method", "modif", "nordsieck", "note", "point", "step", "blumberg", "foulk"], "word_count": {"method": 1, "modif": 1, "nordsieck": 1, "note": 1, "point": 1, "step": 1, "blumberg": 1, "foulk": 1}}, "2137": {"id": "2137", "title": "New LISP Techniques for a Paging Environment", "abstract": "The system described herein employs the block concept, and that of global and local variables,  in addition to the methods applied in most LISP systems.  Also, a new means of list representation is  used: \"local sequential\" for lists created during compilation, and \"block level sequential\" for those  created dynamically.  A new garbage collection algorithm has been introduced to make lists as compact  as possible; partial garbage collection is performed after each block exit instead of total garbage collection  when storage is exhausted.  The algorithm does not use the customary flagging procedure.  This combination  of features has eliminated the need for a free list, and effectively minimizes the number of pages used  at any moment.", "authors": "Rochfeld, A.", "words_pool": ["addit", "algorithm", "appli", "block", "collect", "combin", "compact", "compil", "concept", "creat", "customari", "dynam", "effect", "elimin", "employ", "environ", "exhaust", "exit", "featur", "flag", "free", "garbag", "global", "introduc", "level", "lisp", "list", "list", "local", "make", "mean", "method", "minim", "moment", "need", "number", "page", "page", "partial", "perform", "procedur", "represent", "sequenti", "storag", "system", "system", "techniqu", "total", "variabl", "rochfeld"], "word_count": {"addit": 1, "algorithm": 2, "appli": 1, "block": 3, "collect": 3, "combin": 1, "compact": 1, "compil": 1, "concept": 1, "creat": 2, "customari": 1, "dynam": 1, "effect": 1, "elimin": 1, "employ": 1, "environ": 1, "exhaust": 1, "exit": 1, "featur": 1, "flag": 1, "free": 1, "garbag": 3, "global": 1, "introduc": 1, "level": 1, "lisp": 1, "list": 4, "local": 2, "make": 1, "mean": 1, "method": 1, "minim": 1, "moment": 1, "need": 1, "number": 1, "page": 1, "partial": 1, "perform": 1, "procedur": 1, "represent": 1, "sequenti": 2, "storag": 1, "system": 2, "techniqu": 1, "total": 1, "variabl": 1, "rochfeld": 1}}, "2138": {"id": "2138", "title": "BLISS: A Language for Systems Programming", "abstract": "A language, BLISS, is described.  This language is designed so as to be especially suitable  for use in writing production software systems for a specific machine (the PDP-10): compilers, operating  systems, etc.  Prime design goals of the design are the ability to produce highly efficient object code,  to allow access to all relevant hardware features of the host machine, and to provide a rational means  by which to cope with the evolutionary nature of systems programs.  A major feature which contributes  to the realization of these goals is a mechanism permitting the definition of the representation of all  data structures in terms of the access algorithm for elements of the structure.", "authors": "Wulf, W. A. Russell, D. B.", "words_pool": ["abil", "access", "algorithm", "allow", "bliss", "code", "compil", "contribut", "cope", "data", "definit", "design", "design", "effici", "element", "especi", "evolutionari", "featur", "featur", "goal", "hardwar", "highli", "host", "languag", "machin", "major", "mean", "mechan", "natur", "object", "oper", "pdp", "permit", "prime", "produc", "product", "program", "program", "provid", "ration", "realiz", "relev", "represent", "softwar", "specif", "structur", "structur", "suitabl", "system", "term", "write", "wulf", "russel"], "word_count": {"abil": 1, "access": 2, "algorithm": 1, "allow": 1, "bliss": 1, "code": 1, "compil": 1, "contribut": 1, "cope": 1, "data": 1, "definit": 1, "design": 3, "effici": 1, "element": 1, "especi": 1, "evolutionari": 1, "featur": 2, "goal": 2, "hardwar": 1, "highli": 1, "host": 1, "languag": 2, "machin": 2, "major": 1, "mean": 1, "mechan": 1, "natur": 1, "object": 1, "oper": 1, "pdp": 1, "permit": 1, "prime": 1, "produc": 1, "product": 1, "program": 1, "provid": 1, "ration": 1, "realiz": 1, "relev": 1, "represent": 1, "softwar": 1, "specif": 1, "structur": 2, "suitabl": 1, "system": 3, "term": 1, "write": 1, "wulf": 1, "russel": 1}}, "2139": {"id": "2139", "title": "Implementation of the Substring Test by Hashing", "abstract": "A technique is described for implementing the test which determines if one string is a substring  of another.  When there is low probability that the test will be satisfied, it is shown how the operation  can be speeded up considerably if it is preceded by a test on appropriately chosen hash codes of the  strings.", "authors": "Harrison, M. C.", "words_pool": ["appropri", "chosen", "code", "consider", "determin", "hash", "hash", "implement", "implement", "low", "oper", "preced", "probabl", "satisfi", "shown", "speed", "string", "string", "substr", "techniqu", "test", "harrison"], "word_count": {"appropri": 1, "chosen": 1, "code": 1, "consider": 1, "determin": 1, "hash": 1, "implement": 1, "low": 1, "oper": 1, "preced": 1, "probabl": 1, "satisfi": 1, "shown": 1, "speed": 1, "string": 2, "substr": 1, "techniqu": 1, "test": 3, "harrison": 1}}, "2140": {"id": "2140", "title": "Retrieval-Update Speed Tradeoffs Using Combined Indices", "abstract": "In a paper in the November 1970 Communications of the ACM, V. Y. Lum introduced a technique  of file indexing named combined indices.  This technique permitted decreased retrieval time at the cost  of increased storage space.  This paper examines combined indices under conditions of file usage with  different fractions of retrieval and update.  Tradeoff curves are developed to show minimal cost of file  usage by grouping various partially combined indices.", "authors": "Mullin, J. K.", "words_pool": ["acm", "combin", "commun", "condit", "cost", "curv", "decreas", "develop", "examin", "fraction", "group", "increas", "index", "indic", "introduc", "lum", "minim", "name", "novemb", "paper", "partial", "permit", "retriev", "show", "space", "speed", "storag", "techniqu", "time", "tradeoff", "tradeoff", "updat", "usag", "mullin"], "word_count": {"acm": 1, "combin": 3, "commun": 1, "condit": 1, "cost": 2, "curv": 1, "decreas": 1, "develop": 1, "examin": 1, "fraction": 1, "group": 1, "increas": 1, "index": 1, "indic": 3, "introduc": 1, "lum": 1, "minim": 1, "name": 1, "novemb": 1, "paper": 2, "partial": 1, "permit": 1, "retriev": 2, "show": 1, "space": 1, "speed": 1, "storag": 1, "techniqu": 2, "time": 1, "tradeoff": 1, "updat": 1, "usag": 2, "mullin": 1}}, "2141": {"id": "2141", "title": "Algorithmic Selection of the Best Method for Compressing Map Data Strings", "abstract": "The best of a dozen different methods for compressing map data is illustrated.  The choices  are generated by encoding data strings-sequence of like codes-by three methods and in four directions.   Relationships are developed between compression alternatives to avoid comparing all of them.  The technique  has been used to compress data from forest resource maps, but is widely applicable to map and photographic  data reduction.", "authors": "Amidon, E. L. Akin, G. S.", "words_pool": ["algorithm", "altern", "applic", "avoid", "choic", "code", "compar", "compress", "compress", "compress", "data", "develop", "direct", "dozen", "encod", "forest", "gener", "illustr", "map", "map", "method", "method", "photograph", "reduct", "relationship", "resourc", "select", "sequenc", "string", "techniqu", "wide", "amidon", "akin"], "word_count": {"algorithm": 1, "altern": 1, "applic": 1, "avoid": 1, "choic": 1, "code": 1, "compar": 1, "compress": 3, "data": 4, "develop": 1, "direct": 1, "dozen": 1, "encod": 1, "forest": 1, "gener": 1, "illustr": 1, "map": 3, "method": 2, "photograph": 1, "reduct": 1, "relationship": 1, "resourc": 1, "select": 1, "sequenc": 1, "string": 1, "techniqu": 1, "wide": 1, "amidon": 1, "akin": 1}}, "2142": {"id": "2142", "title": "Reconstruction of Pictures from Their Projections", "abstract": "There are situations in the natural sciences and medicine (e.g. in electron microscopy and  X-ray photography) in which it is desirable to estimate the gray levels of a digital picture at the individual  points from the sums of the gray levels along straight lines (projections) at a few angles.  Usually,  in such situations, the picture is far from determined and the problem is to find the \"most representative\"  picture.  Three algorithms are described (all using Monte Carlo methods) which were designed to solve  this problem.  The algorithms are applicable in a large and varied number of fields.  The most important  uses may be the reconstruction of possibly asymmetric particles from electron micrographs and three-dimensional  X-ray analysis.", "authors": "Gordon,R. Herman, G. T.", "words_pool": ["algorithm", "analysi", "angl", "applic", "asymmetr", "carlo", "design", "desir", "determin", "digit", "dimension", "electron", "estim", "field", "find", "gray", "import", "individu", "larg", "level", "line", "medicin", "method", "micrograph", "microscopi", "mont", "natur", "number", "particl", "photographi", "pictur", "pictur", "point", "possibl", "problem", "project", "ray", "reconstruct", "repres", "scienc", "situat", "solv", "straight", "sum", "vari", "gordon", "herman"], "word_count": {"algorithm": 2, "analysi": 1, "angl": 1, "applic": 1, "asymmetr": 1, "carlo": 1, "design": 1, "desir": 1, "determin": 1, "digit": 1, "dimension": 1, "electron": 2, "estim": 1, "field": 1, "find": 1, "gray": 2, "import": 1, "individu": 1, "larg": 1, "level": 2, "line": 1, "medicin": 1, "method": 1, "micrograph": 1, "microscopi": 1, "mont": 1, "natur": 1, "number": 1, "particl": 1, "photographi": 1, "pictur": 3, "point": 1, "possibl": 1, "problem": 2, "project": 1, "ray": 2, "reconstruct": 1, "repres": 1, "scienc": 1, "situat": 2, "solv": 1, "straight": 1, "sum": 1, "vari": 1, "gordon": 1, "herman": 1}}, "2143": {"id": "2143", "title": "Chebyshev Approximation of Continuous Functions by a Chebyshev System of Functions [E2] (Algorithm 414)", "authors": "Bolub, G. H. Smith, L. B.", "words_pool": ["algorithm", "approxim", "chebyshev", "continu", "e2", "function", "system", "bolub", "smith"], "word_count": {"algorithm": 1, "approxim": 1, "chebyshev": 2, "continu": 1, "e2": 1, "function": 2, "system": 1, "bolub": 1, "smith": 1}}, "2144": {"id": "2144", "title": "On Accurate Floating-Point Summation", "abstract": "The accumulation of floating-point sums is considered on a computer which performs t-digit  base B floating-point addition with exponents in the range -m to M.  An algorithm is given for accurately  summing N t-digit floating-point numbers.  Each of these N numbers is split into q parts, forming qN  t-digit floating-point numbers.  Each of these is then added to the appropriate one of n auxiliary t-digit  accumulators.  Finally, the accumulators are added together to yield the computed sum.  In all, qN+n-1  t-digit floating-point additions are performed.  Under usual conditions, the relative error in the computed  sum is at most [(t+1)/v]B^(1-t) for some v.  Further, with an additional q+n-1 t-digit additions, the  computed sum can be corrected to full t-digit accuracy.  For example, for the IBM/360 (B=16, t=14, M=63,  m=64), typical values for q and n are q=2 and n=32.  In this case, (*) becomes N <= 32,768, and we have  [(t+1)/v]B^(1-t) = 4x16^-13.", "authors": "Malcolm, M. A.", "words_pool": ["4x16", "accumul", "accumul", "accuraci", "accur", "accur", "ad", "addit", "addit", "addit", "algorithm", "auxiliari", "base", "case", "comput", "comput", "condit", "consid", "correct", "digit", "error", "expon", "final", "float", "form", "full", "ibm", "number", "part", "perform", "perform", "point", "qn", "rang", "rel", "split", "sum", "summat", "sum", "sum", "typic", "usual", "valu", "yield", "malcolm"], "word_count": {"4x16": 1, "accumul": 3, "accuraci": 1, "accur": 1, "ad": 2, "addit": 4, "algorithm": 1, "auxiliari": 1, "base": 1, "case": 1, "comput": 4, "condit": 1, "consid": 1, "correct": 1, "digit": 7, "error": 1, "expon": 1, "final": 1, "float": 5, "form": 1, "full": 1, "ibm": 1, "number": 3, "part": 1, "perform": 2, "point": 5, "qn": 2, "rang": 1, "rel": 1, "split": 1, "sum": 5, "summat": 1, "typic": 1, "usual": 1, "valu": 1, "yield": 1, "malcolm": 1}}, "2145": {"id": "2145", "title": "Automation of Etching-Pattern Layout", "abstract": "HELP (Heuristic Etching-Pattern Layout Program) is an application program developed to computerize  the tedious and error-prone although vitally important wiring design of printed circuit boards.  HELP  helps automate a design stage one step closer to production than logical design.  It can be used to design  wiring patterns of two-layer circuit boards on which ICs in dual-in-line packages as well as discrete  components such as transistors and resistors have been placed.  HELP employs two methods of wiring.   One is the heuristic method, which simulates human approaches to wiring design, and the other is the  theoretically interesting but time-consuming method of maze-running, based on the Lee's algorithm.  HELP  performs more than 90 percent of required wiring by the heuristic path with respect to a performance  function for each point-to-point, and point-to-line connection.  It can bring the number of successful  wiring connections very close to 100 percent.", "authors": "Aramaki, I. Kawabata, T. Kazuhiko, A.", "words_pool": ["algorithm", "applic", "approach", "autom", "autom", "base", "board", "bring", "circuit", "close", "closer", "compon", "computer", "connect", "connect", "consum", "design", "develop", "discret", "dual", "employ", "error", "etch", "function", "help", "help", "heurist", "human", "ic", "import", "interest", "layer", "layout", "lee", "line", "logic", "maze", "method", "method", "number", "packag", "path", "pattern", "pattern", "percent", "perform", "perform", "point", "print", "product", "program", "prone", "requir", "resistor", "respect", "run", "simul", "stage", "step", "success", "tediou", "theoret", "time", "transistor", "vital", "wire", "aramaki", "kawabata", "kazuhiko"], "word_count": {"algorithm": 1, "applic": 1, "approach": 1, "autom": 1, "base": 1, "board": 2, "bring": 1, "circuit": 2, "close": 1, "closer": 1, "compon": 1, "computer": 1, "connect": 2, "consum": 1, "design": 5, "develop": 1, "discret": 1, "dual": 1, "employ": 1, "error": 1, "etch": 1, "function": 1, "help": 5, "heurist": 3, "human": 1, "ic": 1, "import": 1, "interest": 1, "layer": 1, "layout": 1, "lee": 1, "line": 2, "logic": 1, "maze": 1, "method": 3, "number": 1, "packag": 1, "path": 1, "pattern": 2, "percent": 2, "perform": 2, "point": 3, "print": 1, "product": 1, "program": 2, "prone": 1, "requir": 1, "resistor": 1, "respect": 1, "run": 1, "simul": 1, "stage": 1, "step": 1, "success": 1, "tediou": 1, "theoret": 1, "time": 1, "transistor": 1, "vital": 1, "wire": 6, "aramaki": 1, "kawabata": 1, "kazuhiko": 1}}, "2146": {"id": "2146", "title": "he optimum  algorithm based on minimizing the total number of unit strings read is displayed.  The logic of this  algorithm is rather complicated; hence, several other new dispersion algorithms with more straightforward  logic are presented.  Of the simple dispersion algorithms discussed, the  Horizontal is best.  It does  approximately one-fourth to one and one-half percent less reading and writing than most algorithms in  use today.  An additional two and one-fourth to three percent improvement can be achieved by utilizing  the Modified Optimum Algorithm.  This algorithm is relatively straightforward, but it requires a fairly  close estimate of the total number of unit strings before the dispersion begins.", "abstract": "Various dispersion algorithms for the polyphase sorting procedure are examined", "authors": "Shell, D. L.", "words_pool": ["achiev", "addit", "algorithm", "algorithm", "approxim", "base", "begin", "close", "complic", "discuss", "dispers", "display", "estim", "examin", "fairli", "fourth", "half", "horizont", "improv", "logic", "minim", "modifi", "number", "optimum", "percent", "polyphas", "present", "procedur", "read", "read", "requir", "simpl", "sort", "straightforward", "string", "today", "total", "unit", "util", "write", "shell"], "word_count": {"achiev": 1, "addit": 1, "algorithm": 1, "approxim": 1, "base": 1, "begin": 1, "close": 1, "complic": 1, "discuss": 1, "dispers": 1, "display": 1, "estim": 1, "examin": 1, "fairli": 1, "fourth": 2, "half": 1, "horizont": 1, "improv": 1, "logic": 2, "minim": 1, "modifi": 1, "number": 2, "optimum": 2, "percent": 2, "polyphas": 1, "present": 1, "procedur": 1, "read": 2, "requir": 1, "simpl": 1, "sort": 1, "straightforward": 2, "string": 2, "today": 1, "total": 2, "unit": 2, "util": 1, "write": 1, "shell": 1}}, "2147": {"id": "2147", "title": "Using Computers in Higher Education: Past Recommendations, Status, and Needs", "abstract": "Data from a survey conducted with National Science foundation support, which was published  in December 1970, is reviewed, and it is pointed out that, with regard to computers in higher education,  national goals stated in the Rosser and Pierce Reports have not been attained.  Quality was lacking in  hardware or courses in nearly half of the associate and bachelor's degree programs in data processing,  computer science, etc., offered in 1966-67.  A plea is made for continuing studies on status and goals  for computing in higher education, improvement of degree programs, and a national testing laboratory  for educational technology.", "authors": "Hamblen, J. W.", "words_pool": ["associ", "attain", "bachelor", "comput", "comput", "comput", "conduct", "continu", "cours", "data", "decemb", "degre", "educ", "educ", "foundat", "goal", "half", "hardwar", "higher", "improv", "laboratori", "lack", "made", "nation", "nearli", "need", "offer", "past", "pierc", "plea", "point", "process", "program", "publish", "qualiti", "recommend", "regard", "report", "review", "rosser", "scienc", "state", "statu", "studi", "support", "survey", "technolog", "test", "hamblen"], "word_count": {"associ": 1, "attain": 1, "bachelor": 1, "comput": 3, "conduct": 1, "continu": 1, "cours": 1, "data": 2, "decemb": 1, "degre": 2, "educ": 3, "foundat": 1, "goal": 2, "half": 1, "hardwar": 1, "higher": 2, "improv": 1, "laboratori": 1, "lack": 1, "made": 1, "nation": 3, "nearli": 1, "need": 1, "offer": 1, "past": 1, "pierc": 1, "plea": 1, "point": 1, "process": 1, "program": 2, "publish": 1, "qualiti": 1, "recommend": 1, "regard": 1, "report": 1, "review": 1, "rosser": 1, "scienc": 2, "state": 1, "statu": 1, "studi": 1, "support": 1, "survey": 1, "technolog": 1, "test": 1, "hamblen": 1}}, "2148": {"id": "2148", "title": "The Composition of Semantics in Algol 68", "abstract": "The main features of Algol 68 are explained from a semantic point of view.  It is shown how  the language permits the composition of values and actions, i.e. ultimately programs, from a minimum  set of primitives with a few fundamental recursive rules of composition.  The associated syntax is briefly  reviewed.  An attempt has been made to obtain a structured and simple introduction to both Algol 68 and  its orthogonal design.", "authors": "Branquart, P. Lewi, J. Sintzoff, M. Wodon, P. L.", "words_pool": ["action", "algol", "attempt", "briefli", "composit", "design", "explain", "featur", "fundament", "introduct", "languag", "made", "main", "minimum", "obtain", "orthogon", "permit", "point", "primit", "program", "recurs", "review", "rule", "semant", "semant", "set", "shown", "simpl", "structur", "syntax", "ultim", "valu", "view", "branquart", "lewi", "sintzoff", "wodon"], "word_count": {"action": 1, "algol": 2, "attempt": 1, "briefli": 1, "composit": 2, "design": 1, "explain": 1, "featur": 1, "fundament": 1, "introduct": 1, "languag": 1, "made": 1, "main": 1, "minimum": 1, "obtain": 1, "orthogon": 1, "permit": 1, "point": 1, "primit": 1, "program": 1, "recurs": 1, "review": 1, "rule": 1, "semant": 1, "set": 1, "shown": 1, "simpl": 1, "structur": 1, "syntax": 1, "ultim": 1, "valu": 1, "view": 1, "branquart": 1, "lewi": 1, "sintzoff": 1, "wodon": 1}}, "2149": {"id": "2149", "title": "ENTCAF and ENTCRE: Evaluation of Normalized Taylor Coefficients of an Analytic Function [C5]  (Algorithm 413)", "authors": "Lyness, J. N.", "words_pool": ["algorithm", "analyt", "c5", "coeffici", "entcaf", "entcr", "evalu", "function", "normal", "taylor", "lyness"], "word_count": {"algorithm": 1, "analyt": 1, "c5": 1, "coeffici": 1, "entcaf": 1, "entcr": 1, "evalu": 1, "function": 1, "normal": 1, "taylor": 1, "lyness": 1}}, "2150": {"id": "2150", "title": "Concurrent Control with \"Readers\" and \"Writers\"", "abstract": "The problem of the mutual exclusion of several independent processes from simultaneous access  to a \"critical section\" is discussed for the case where there are two distinct classes of processes known  as \"readers\" and \"writers.\"  The \"readers\" may share the section with each other, but the \"writers\" must  have exclusive access.  Two solutions are presented: one of the case where we wish minimum delay for  the readers; the other for the case where we wish writing to take place as early as possible.", "authors": "Courois, P. J. Heymans, F. Parnas, D. L.", "words_pool": ["access", "case", "class", "concurr", "control", "critic", "delay", "discuss", "distinct", "earli", "exclus", "exclus", "independ", "known", "minimum", "mutual", "place", "present", "problem", "process", "reader", "section", "share", "simultan", "solut", "take", "wish", "writer", "write", "couroi", "heyman", "parna"], "word_count": {"access": 2, "case": 3, "class": 1, "concurr": 1, "control": 1, "critic": 1, "delay": 1, "discuss": 1, "distinct": 1, "earli": 1, "exclus": 2, "independ": 1, "known": 1, "minimum": 1, "mutual": 1, "place": 1, "present": 1, "problem": 1, "process": 2, "reader": 3, "section": 2, "share": 1, "simultan": 1, "solut": 1, "take": 1, "wish": 2, "writer": 2, "write": 1, "couroi": 1, "heyman": 1, "parna": 1}}, "2151": {"id": "2151", "title": "User Program Measurement in a Time-Shared Environment", "abstract": "A general discussion of the measurement of software systems is followed by a description of  a hardware and software scheme for measuring user programs in a time-shared environment.  The TX-2 computer  at MIT Lincoln Laboratory was used for the implementation of such a system and the characteristics of  this implementation are reported.  A scenario showing the system in use is presented.  Finally, it is  shown how other time-sharing systems may provide similar measuring facilities.", "authors": "Nemeth, A. G. Rovner, P. D.", "words_pool": ["characterist", "comput", "descript", "discuss", "environ", "facil", "final", "gener", "hardwar", "implement", "laboratori", "lincoln", "measur", "measur", "mit", "present", "program", "program", "provid", "report", "scenario", "scheme", "share", "share", "show", "shown", "similar", "softwar", "system", "system", "time", "tx", "user", "nemeth", "rovner"], "word_count": {"characterist": 1, "comput": 1, "descript": 1, "discuss": 1, "environ": 1, "facil": 1, "final": 1, "gener": 1, "hardwar": 1, "implement": 2, "laboratori": 1, "lincoln": 1, "measur": 3, "mit": 1, "present": 1, "program": 1, "provid": 1, "report": 1, "scenario": 1, "scheme": 1, "share": 2, "show": 1, "shown": 1, "similar": 1, "softwar": 2, "system": 4, "time": 2, "tx": 1, "user": 1, "nemeth": 1, "rovner": 1}}, "2152": {"id": "2152", "title": "Display Procedures", "abstract": "Although the use of structured display files is widespread in interactive computer graphics,  these structures present a number of problems which tend to restrict their generality and usefulness.   This paper discusses some of these problems, and suggests an alternative approach to display system  design which avoids the use of structured display files.  This technique employs display procedures to  generate information for display.  By including transformations within calls to these procedures it is  possible both to simplify the specification of pictures and to speed up their generation.  Display procedures  permit picture elements to be defined conditionally and also facilitate the processing of inputs from  pointing devices.  The paper is illustrated by examples from aversion of the EULER language in which  display procedures were implemented.", "authors": "Newman, W. M.", "words_pool": ["altern", "approach", "avers", "avoid", "call", "comput", "condit", "defin", "design", "devic", "discuss", "display", "element", "employ", "euler", "exampl", "facilit", "gener", "gener", "gener", "graphic", "illustr", "implement", "includ", "inform", "input", "interact", "languag", "number", "paper", "permit", "pictur", "pictur", "point", "present", "problem", "procedur", "process", "restrict", "simplifi", "specif", "speed", "structur", "structur", "suggest", "system", "techniqu", "tend", "transform", "use", "widespread", "newman"], "word_count": {"altern": 1, "approach": 1, "avers": 1, "avoid": 1, "call": 1, "comput": 1, "condit": 1, "defin": 1, "design": 1, "devic": 1, "discuss": 1, "display": 7, "element": 1, "employ": 1, "euler": 1, "exampl": 1, "facilit": 1, "gener": 3, "graphic": 1, "illustr": 1, "implement": 1, "includ": 1, "inform": 1, "input": 1, "interact": 1, "languag": 1, "number": 1, "paper": 2, "permit": 1, "pictur": 2, "point": 1, "present": 1, "problem": 2, "procedur": 4, "process": 1, "restrict": 1, "simplifi": 1, "specif": 1, "speed": 1, "structur": 3, "suggest": 1, "system": 1, "techniqu": 1, "tend": 1, "transform": 1, "use": 1, "widespread": 1, "newman": 1}}, "2153": {"id": "2153", "title": "Experiments with an Automated Instructional System for Numerical Methods", "abstract": "A computer system was developed at Purdue University to teach portions of an undergraduate  course in numerical methods.  Each instructional unit or lesson is divided into three modes of instruction  which allow the student to press from a computer-controlled presentation to a student-controlled investigation.  The system is designed as a classroom-independent course of study, and has been used for two semesters  by students in lieu of conventional classroom instruction.  Initial measures of effectiveness, student  acceptance, and operational cost are the result of testing the system independent of instructor intervention.   The system is operational on a CDC 6500 with teletype terminals.", "authors": "Oldehoeft, A. E. Conte, S. D.", "words_pool": ["accept", "allow", "autom", "cdc", "classroom", "comput", "control", "convent", "cost", "cours", "design", "develop", "divid", "effect", "experi", "independ", "initi", "instruct", "instruct", "instructor", "intervent", "investig", "lesson", "lieu", "measur", "method", "mode", "numer", "oper", "portion", "present", "press", "purdu", "result", "semest", "student", "student", "studi", "system", "teach", "teletyp", "termin", "test", "undergradu", "unit", "univers", "oldehoeft", "cont"], "word_count": {"accept": 1, "allow": 1, "autom": 1, "cdc": 1, "classroom": 2, "comput": 2, "control": 2, "convent": 1, "cost": 1, "cours": 2, "design": 1, "develop": 1, "divid": 1, "effect": 1, "experi": 1, "independ": 2, "initi": 1, "instruct": 3, "instructor": 1, "intervent": 1, "investig": 1, "lesson": 1, "lieu": 1, "measur": 1, "method": 1, "mode": 1, "numer": 1, "oper": 2, "portion": 1, "present": 1, "press": 1, "purdu": 1, "result": 1, "semest": 1, "student": 4, "studi": 1, "system": 4, "teach": 1, "teletyp": 1, "termin": 1, "test": 1, "undergradu": 1, "unit": 1, "univers": 1, "oldehoeft": 1, "cont": 1}}, "2154": {"id": "2154", "title": "Clarification of Fortran Standards-Second Report", "abstract": "In 1966, after four years of effort, Fortran became the first programming language standardized  in the United States.  Since that initial achievement study and application of the standard specifications  have revealed the need for maintenance of the standards.  As the result of work initiated in 1967, an  initial set of clarifying interpretations was prepared and this clarification was published in Communications  of the ACM in May 1969.  That work has continued and has resulted in the preparation of this second set  of clarifying interpretations.  The nature of the maintenance and the new set of corrections to and interpretations  of the standard specifications are reported.", "authors": "ANSI Subcommittee X3J3", "words_pool": ["achiev", "acm", "applic", "clarif", "clarifi", "commun", "continu", "correct", "effort", "fortran", "initi", "initi", "interpret", "languag", "mainten", "natur", "need", "prepar", "prepar", "program", "publish", "report", "report", "result", "result", "reveal", "set", "specif", "standard", "standard", "standard", "state", "studi", "unit", "work", "year", "ansi", "subcommitte", "x3j3"], "word_count": {"achiev": 1, "acm": 1, "applic": 1, "clarif": 1, "clarifi": 2, "commun": 1, "continu": 1, "correct": 1, "effort": 1, "fortran": 1, "initi": 3, "interpret": 3, "languag": 1, "mainten": 2, "natur": 1, "need": 1, "prepar": 2, "program": 1, "publish": 1, "report": 1, "result": 2, "reveal": 1, "set": 3, "specif": 2, "standard": 4, "state": 1, "studi": 1, "unit": 1, "work": 2, "year": 1, "ansi": 1, "subcommitte": 1, "x3j3": 1}}, "2155": {"id": "2155", "title": "Toward an Understanding of Data Structures", "abstract": "This paper presents a notation and formalism for describing the semantics of data structures.   This is based on directed graphs with named edges and transformations on these graphs.  In addition,  an implementation facility is described which could be part of a programming language, which allows a  programmer who has expressed the semantics of an algorithm in terms of the graphs to then specify the  implementation of some of his data structures in order to gain efficiency.", "authors": "Earley, J.", "words_pool": ["addit", "algorithm", "base", "data", "describ", "direct", "edg", "effici", "express", "facil", "formal", "gain", "graph", "implement", "languag", "name", "notat", "order", "paper", "part", "present", "programm", "program", "semant", "structur", "term", "transform", "understand", "earley"], "word_count": {"addit": 1, "algorithm": 1, "base": 1, "data": 2, "describ": 1, "direct": 1, "edg": 1, "effici": 1, "express": 1, "facil": 1, "formal": 1, "gain": 1, "graph": 3, "implement": 2, "languag": 1, "name": 1, "notat": 1, "order": 1, "paper": 1, "part": 1, "present": 1, "programm": 1, "program": 1, "semant": 2, "structur": 2, "term": 1, "transform": 1, "understand": 1, "earley": 1}}, "2156": {"id": "2156", "title": "Comment on Cheney's List-Compaction Algorithm", "authors": "Fenichel, R. R.", "words_pool": ["algorithm", "cheney", "comment", "compact", "list", "fenichel"], "word_count": {"algorithm": 1, "cheney": 1, "comment": 1, "compact": 1, "list": 1, "fenichel": 1}}, "2157": {"id": "2157", "title": "Average Binary Search Length for Dense Ordered Lists", "authors": "Flores, I. Madpis, G.", "words_pool": ["averag", "binari", "dens", "length", "list", "order", "search", "flore", "madpi"], "word_count": {"averag": 1, "binari": 1, "dens": 1, "length": 1, "list": 1, "order": 1, "search": 1, "flore": 1, "madpi": 1}}, "2158": {"id": "2158", "title": "A Stopping Criterion for the Newton-Raphson Method in Implicit Multistep Integration Algorithms  for Nonlinear Systems of Ordinary Differential Equations", "authors": "Liniger, W.", "words_pool": ["algorithm", "criterion", "differenti", "equat", "implicit", "integr", "method", "multistep", "newton", "nonlinear", "ordinari", "raphson", "stop", "system", "linig"], "word_count": {"algorithm": 1, "criterion": 1, "differenti": 1, "equat": 1, "implicit": 1, "integr": 1, "method": 1, "multistep": 1, "newton": 1, "nonlinear": 1, "ordinari": 1, "raphson": 1, "stop": 1, "system": 1, "linig": 1}}, "2159": {"id": "2159", "title": "A Note on Best One-Sided Approximations", "authors": "Phillips, D. L.", "words_pool": ["approxim", "note", "side", "phillip"], "word_count": {"approxim": 1, "note": 1, "side": 1, "phillip": 1}}, "2160": {"id": "2160", "title": "Canonical Structure in Attribute Based File Organization", "abstract": "A new file structure for attribute based retrieval is proposed in this paper.  It allows queries  involving arbitrary Boolean functions of the attribute-value pairs to be processed without taking intersections  of lists.  The structure is highly dependent on the way in which the file is to be used and is uniquely  determined by the specification of the allowed queries.  Thus, for example, the structure for retrieval  on the basis of ranges of values of a given attribute would be very different from one where only retrieval  on the basis of a single value is permitted.  The file organization being proposed is based on the atoms  of a Boolean algebra generated by the queries.  The desirable properties claimed for this structure are  proved, and file maintenance questions are discussed.", "authors": "Wong, E. Chiang, T. C.", "words_pool": ["algebra", "allow", "arbitrari", "atom", "attribut", "base", "basi", "boolean", "canon", "claim", "depend", "desir", "determin", "discuss", "function", "gener", "highli", "intersect", "involv", "list", "mainten", "organ", "pair", "paper", "permit", "process", "properti", "propos", "prove", "queri", "question", "rang", "retriev", "singl", "specif", "structur", "take", "uniqu", "valu", "wong", "chiang"], "word_count": {"algebra": 1, "allow": 1, "arbitrari": 1, "atom": 1, "attribut": 3, "base": 2, "basi": 2, "boolean": 2, "canon": 1, "claim": 1, "depend": 1, "desir": 1, "determin": 1, "discuss": 1, "function": 1, "gener": 1, "highli": 1, "intersect": 1, "involv": 1, "list": 1, "mainten": 1, "organ": 1, "pair": 1, "paper": 1, "permit": 1, "process": 1, "properti": 1, "propos": 2, "prove": 1, "queri": 3, "question": 1, "rang": 1, "retriev": 3, "singl": 1, "specif": 1, "structur": 4, "take": 1, "uniqu": 1, "valu": 1, "wong": 1, "chiang": 1}}, "2161": {"id": "2161", "title": "An Algorithm for the Blocks and Cutnodes of a Graph (Corrigendum)", "authors": "Paton, K.", "words_pool": ["algorithm", "block", "corrigendum", "cutnod", "graph", "paton"], "word_count": {"algorithm": 1, "block": 1, "corrigendum": 1, "cutnod": 1, "graph": 1, "paton": 1}}, "2162": {"id": "2162", "title": "An Efficient Bit Table Technique for Dynamic Storage Allocation of 2^n-word Blocks", "abstract": "An efficient bit table technique for dynamic storage allocation of 2^n-word blocks, which requires  a minimized amount of memory for bookkeeping purposes, is described. The technique has been tested in  an implementation of the list processing language L^6.  A number of ideas incorporated in the processor  are also described.", "authors": "Isoda, S. Goto, E.", "words_pool": ["alloc", "amount", "bit", "block", "bookkeep", "dynam", "effici", "idea", "implement", "incorpor", "languag", "list", "memori", "minim", "number", "process", "processor", "purpos", "requir", "storag", "tabl", "techniqu", "test", "word", "isoda", "goto"], "word_count": {"alloc": 1, "amount": 1, "bit": 1, "block": 1, "bookkeep": 1, "dynam": 1, "effici": 1, "idea": 1, "implement": 1, "incorpor": 1, "languag": 1, "list": 1, "memori": 1, "minim": 1, "number": 1, "process": 1, "processor": 1, "purpos": 1, "requir": 1, "storag": 1, "tabl": 1, "techniqu": 2, "test": 1, "word": 1, "isoda": 1, "goto": 1}}, "2163": {"id": "2163", "title": "Education Related to the Use of Computers in Organizations", "abstract": "The ACM Curriculum Committee on Computer Education for Management has been carrying out a study  on \"Curriculum Development in Management Information Systems Education in Colleges and Universities\"  under a grant from the National Science Foundation.  This position paper provides a framework for the  study.  Preliminary conclusions are presented on the need for education in administrative information  systems, and appropriate college curricula and courses are suggested.  Also, the role of professional  societies and organizations using computers is discussed, and the plans of the Committee are outlined.   The initial approach of the Committee has been to describe the education necessary for the effective  use of computers in organizations, to classify the positions for which education is required, and to  survey educational programs now available.", "authors": "Teichroew, D.", "words_pool": ["acm", "administr", "approach", "carri", "classifi", "colleg", "colleg", "committe", "comput", "comput", "conclus", "cours", "curricula", "curriculum", "describ", "develop", "discuss", "educ", "educ", "effect", "foundat", "framework", "grant", "inform", "initi", "manag", "nation", "need", "organ", "outlin", "paper", "plan", "posit", "posit", "preliminari", "present", "profession", "program", "relat", "requir", "role", "scienc", "societi", "studi", "suggest", "survey", "system", "univers", "teichroew"], "word_count": {"acm": 1, "administr": 1, "approach": 1, "carri": 1, "classifi": 1, "colleg": 2, "committe": 3, "comput": 3, "conclus": 1, "cours": 1, "curricula": 1, "curriculum": 2, "describ": 1, "develop": 1, "discuss": 1, "educ": 6, "effect": 1, "foundat": 1, "framework": 1, "grant": 1, "inform": 2, "initi": 1, "manag": 2, "nation": 1, "need": 1, "organ": 2, "outlin": 1, "paper": 1, "plan": 1, "posit": 2, "preliminari": 1, "present": 1, "profession": 1, "program": 1, "relat": 1, "requir": 1, "role": 1, "scienc": 1, "societi": 1, "studi": 2, "suggest": 1, "survey": 1, "system": 2, "univers": 1, "teichroew": 1}}, "2164": {"id": "2164", "title": "Symbolic Integration: The Stormy Decade", "abstract": "Three approaches to symbolic integration in the 1960's are described.  The first, from artificial  intelligence, led to Slagle's SAINT and to a large degree to Moses' SIN.  The second, from algebraic  manipulation, led to Manove's implementation and to Horowitz' and Tobey's reexamination of the Hermite  algorithm for integrating rational functions.  The third, from mathematics, led to Richardson's proof  of the unsolvability of the problem for a class of functions and for Risch's decision procedure for the  elementary functions.Generalizations of Risch's algorithm to a class of special functions and programs  for solving differential equations and for finding the definite integral are also described.", "authors": "Moses, J.", "words_pool": ["algebra", "algorithm", "approach", "artifici", "class", "decad", "decis", "definit", "degre", "differenti", "elementari", "equat", "find", "function", "gener", "hermit", "horowitz", "implement", "integr", "integr", "integr", "intellig", "larg", "led", "manipul", "manov", "mathemat", "mose", "problem", "procedur", "program", "proof", "ration", "reexamin", "richardson", "risch", "saint", "sin", "slagl", "solv", "special", "stormi", "symbol", "tobey", "unsolv", "mose"], "word_count": {"algebra": 1, "algorithm": 2, "approach": 1, "artifici": 1, "class": 2, "decad": 1, "decis": 1, "definit": 1, "degre": 1, "differenti": 1, "elementari": 1, "equat": 1, "find": 1, "function": 4, "gener": 1, "hermit": 1, "horowitz": 1, "implement": 1, "integr": 3, "intellig": 1, "larg": 1, "led": 3, "manipul": 1, "manov": 1, "mathemat": 1, "mose": 1, "problem": 1, "procedur": 1, "program": 1, "proof": 1, "ration": 1, "reexamin": 1, "richardson": 1, "risch": 2, "saint": 1, "sin": 1, "slagl": 1, "solv": 1, "special": 1, "stormi": 1, "symbol": 1, "tobey": 1, "unsolv": 1}}, "2165": {"id": "2165", "title": "General Relativity and the Application of Algebraic Manipulative Systems", "abstract": "The paper describes some applications of symbolic algebra systems to problems of general relativity  including the derivation of the field equations, the Petrov classification of a metric, and the solution  of the field equations in the presence of matter in a simple case.  Attention is drawn to the strictly  algebraic difficulties encountered in this work.", "authors": "Barton, D. Fitch, J. P.", "words_pool": ["algebra", "algebra", "applic", "applic", "attent", "case", "classif", "deriv", "describ", "difficulti", "drawn", "encount", "equat", "field", "gener", "includ", "manipul", "matter", "metric", "paper", "petrov", "presenc", "problem", "rel", "simpl", "solut", "strictli", "symbol", "system", "work", "barton", "fitch"], "word_count": {"algebra": 2, "applic": 1, "attent": 1, "case": 1, "classif": 1, "deriv": 1, "describ": 1, "difficulti": 1, "drawn": 1, "encount": 1, "equat": 2, "field": 2, "gener": 1, "includ": 1, "manipul": 1, "matter": 1, "metric": 1, "paper": 1, "petrov": 1, "presenc": 1, "problem": 1, "rel": 1, "simpl": 1, "solut": 1, "strictli": 1, "symbol": 1, "system": 1, "work": 1, "barton": 1, "fitch": 1}}, "2166": {"id": "2166", "title": "Automated Algebraic Manipulation in Celestial Mechanics", "abstract": "In this paper we consider some of the applications of automated algebraic manipulation which  have been made in celestial mechanics.  Particular attention is paid to the use of Poisson series, and  a typical problem in perturbation theory is described.  The requirements of processors for use in celestial  mechanics are considered and compared with those for general manipulation packages.  Some future directions  for research using these systems are briefly outlined.  To illustrate the relative simplicity of the  algorithm required in celestial mechanics, a typical integration problem is considered in an appendix.", "authors": "Jefferys, W. H.", "words_pool": ["algebra", "algorithm", "appendix", "applic", "attent", "autom", "briefli", "celesti", "compar", "consid", "consid", "direct", "futur", "gener", "illustr", "integr", "made", "manipul", "mechan", "outlin", "packag", "paid", "paper", "perturb", "poisson", "problem", "processor", "rel", "requir", "requir", "research", "seri", "simplic", "system", "theori", "typic", "jefferi"], "word_count": {"algebra": 1, "algorithm": 1, "appendix": 1, "applic": 1, "attent": 1, "autom": 1, "briefli": 1, "celesti": 3, "compar": 1, "consid": 3, "direct": 1, "futur": 1, "gener": 1, "illustr": 1, "integr": 1, "made": 1, "manipul": 2, "mechan": 3, "outlin": 1, "packag": 1, "paid": 1, "paper": 1, "perturb": 1, "poisson": 1, "problem": 2, "processor": 1, "rel": 1, "requir": 2, "research": 1, "seri": 1, "simplic": 1, "system": 1, "theori": 1, "typic": 2, "jefferi": 1}}, "2167": {"id": "2167", "title": "Algebraic Simplification: A Guide for the Perplexed", "abstract": "Algebraic simplification is examined first from the point of view of a user who needs to comprehend  a large expression, and second from the point of view of a designer who wants to construct a useful and  efficient system.  First we describe various techniques akin to substitution.  These techniques can be  used to decrease thesize of an expression and make it more intelligible to a user.  Then we delineate  the spectrum of approaches to the design of automatic simplification capabilities in an algebraic manipulation  system.  Systems are divided into five types.  Each type provides different facilities for the manipulation  and simplification of expressions. Finally we discuss some of the theoretical results related to algebraic  simplification.  We describe several positive results about the existence of powerful simplification  algorithms and the number-theoretic conjectures on which they rely.  Results about the nonexistence of  algorithms for certain classes of expressions are included.", "authors": "Moses, J.", "words_pool": ["akin", "algebra", "algorithm", "approach", "automat", "capabl", "class", "comprehend", "conjectur", "construct", "decreas", "delin", "describ", "design", "design", "discuss", "divid", "effici", "examin", "exist", "express", "express", "facil", "final", "guid", "includ", "intellig", "larg", "make", "manipul", "need", "nonexist", "number", "perplex", "point", "posit", "power", "relat", "reli", "result", "simplif", "spectrum", "substitut", "system", "system", "techniqu", "theoret", "theoret", "thesiz", "type", "type", "user", "view", "want", "mose"], "word_count": {"akin": 1, "algebra": 3, "algorithm": 2, "approach": 1, "automat": 1, "capabl": 1, "class": 1, "comprehend": 1, "conjectur": 1, "construct": 1, "decreas": 1, "delin": 1, "describ": 2, "design": 2, "discuss": 1, "divid": 1, "effici": 1, "examin": 1, "exist": 1, "express": 4, "facil": 1, "final": 1, "guid": 1, "includ": 1, "intellig": 1, "larg": 1, "make": 1, "manipul": 2, "need": 1, "nonexist": 1, "number": 1, "perplex": 1, "point": 2, "posit": 1, "power": 1, "relat": 1, "reli": 1, "result": 3, "simplif": 5, "spectrum": 1, "substitut": 1, "system": 3, "techniqu": 2, "theoret": 2, "thesiz": 1, "type": 2, "user": 2, "view": 2, "want": 1, "mose": 1}}, "2168": {"id": "2168", "title": "List Tracing in Systems Allowing Multiple Cell-Types", "abstract": "List-processing systems have each allowed the use of only a single size and configuration of  list cell.  In this paper a system is described which allows the use of arbitrarily many different sizes  and configurations of list cells, possibly not specified until run time.", "authors": "Fenichel, R. R.", "words_pool": ["allow", "allow", "arbitrarili", "cell", "cell", "configur", "configur", "list", "multipl", "paper", "possibl", "process", "run", "singl", "size", "size", "system", "system", "time", "trace", "type", "fenichel"], "word_count": {"allow": 1, "arbitrarili": 1, "cell": 2, "configur": 2, "list": 3, "multipl": 1, "paper": 1, "possibl": 1, "process": 1, "run": 1, "singl": 1, "size": 2, "system": 2, "time": 1, "trace": 1, "type": 1, "fenichel": 1}}, "2169": {"id": "2169", "title": "The Altran System for Rational Function Manipulation-A Survey", "abstract": "Altran is a complete system for symbolic computation with rational functions in several variables  with integer coefficients.  It has been designed and implemented to handle large problems with ease and  efficiency.  Considerable effort has been spent to ensure a minimum amount of machine dependence in the  implementation, thus permitting the system to be installed quickly and easily on a variety of computing  machines.  In this paper a brief description of the language, run time data structures, and implementation  is given.", "authors": "Hall Jr., A. D.", "words_pool": ["altran", "amount", "coeffici", "complet", "comput", "comput", "consider", "data", "depend", "descript", "design", "eas", "easili", "effici", "effort", "ensur", "function", "function", "handl", "implement", "implement", "instal", "integ", "languag", "larg", "machin", "machin", "manipul", "minimum", "paper", "permit", "problem", "quickli", "ration", "run", "spent", "structur", "survey", "symbol", "system", "time", "variabl", "varieti", "hall", "jr"], "word_count": {"altran": 1, "amount": 1, "coeffici": 1, "complet": 1, "comput": 2, "consider": 1, "data": 1, "depend": 1, "descript": 1, "design": 1, "eas": 1, "easili": 1, "effici": 1, "effort": 1, "ensur": 1, "function": 1, "handl": 1, "implement": 3, "instal": 1, "integ": 1, "languag": 1, "larg": 1, "machin": 2, "manipul": 1, "minimum": 1, "paper": 1, "permit": 1, "problem": 1, "quickli": 1, "ration": 1, "run": 1, "spent": 1, "structur": 1, "survey": 1, "symbol": 1, "system": 2, "time": 1, "variabl": 1, "varieti": 1, "hall": 1, "jr": 1}}, "2170": {"id": "2170", "title": "Applications of Symbol Manipulation in Theoretical Physics", "abstract": "This paper surveys the applications of symbolic computation techniques to problems in theoretical  physics.  Particular emphasis is placed on applications in quantum electrodynamics where the most activity  has occurred.", "authors": "Hearn, A. C.", "words_pool": ["activ", "applic", "comput", "electrodynam", "emphasi", "manipul", "occur", "paper", "physic", "problem", "quantum", "survey", "symbol", "symbol", "techniqu", "theoret", "hearn"], "word_count": {"activ": 1, "applic": 2, "comput": 1, "electrodynam": 1, "emphasi": 1, "manipul": 1, "occur": 1, "paper": 1, "physic": 1, "problem": 1, "quantum": 1, "survey": 1, "symbol": 1, "techniqu": 1, "theoret": 1, "hearn": 1}}, "2171": {"id": "2171", "title": "Solution of Simultaneous Nonlinear Equations", "authors": "Raduchel, W. J.", "words_pool": ["equat", "nonlinear", "simultan", "solut", "raduchel"], "word_count": {"equat": 1, "nonlinear": 1, "simultan": 1, "solut": 1, "raduchel": 1}}, "2172": {"id": "2172", "title": "Graph Plotter [J6] (Algorithm 412)", "authors": "Cermak, J.", "words_pool": ["algorithm", "graph", "j6", "plotter", "cermak"], "word_count": {"algorithm": 1, "graph": 1, "j6": 1, "plotter": 1, "cermak": 1}}, "2173": {"id": "2173", "title": "Three Procedures for the Stable Marriage Problem [H] (Algorithm 411)", "authors": "McVitie, D. G. Wilson, L. B.", "words_pool": ["algorithm", "marriag", "problem", "procedur", "stabl", "mcviti", "wilson"], "word_count": {"algorithm": 1, "marriag": 1, "problem": 1, "procedur": 1, "stabl": 1, "mcviti": 1, "wilson": 1}}, "2174": {"id": "2174", "title": "The Stable Marriage Problem", "abstract": "The original work of Gale and Shapley on an assignment method using the stable marriage criterion  has been extended to find all the stable marriage assignments.  The algorithm derived for finding all  the stable marriage assignments is proved to satisfy all the conditions of the problem.  Algorithm 411  applies to this paper.", "authors": "McVitie, D. G. Wilson,L. B.", "words_pool": ["algorithm", "appli", "assign", "assign", "condit", "criterion", "deriv", "extend", "find", "find", "gale", "marriag", "method", "origin", "paper", "problem", "prove", "satisfi", "shapley", "stabl", "work", "mcviti", "wilson"], "word_count": {"algorithm": 2, "appli": 1, "assign": 3, "condit": 1, "criterion": 1, "deriv": 1, "extend": 1, "find": 2, "gale": 1, "marriag": 3, "method": 1, "origin": 1, "paper": 1, "problem": 1, "prove": 1, "satisfi": 1, "shapley": 1, "stabl": 3, "work": 1, "mcviti": 1, "wilson": 1}}, "2175": {"id": "2175", "title": "Subexpression Ordering in the Execution of Arithmetic Expressions", "abstract": "An arithmetic expression can often be broken down into its component subexpressions.  Depending  on the hardware environment in which the expression is to be executed, these subexpressions can be evaluated  in serials, in parallel, or in a combination of these modes.  This paper shows that expression execution  time can be minimized only if consideration is given to the ordering of the subexpressions.  In particular,  subexpressions should be executed in order of decreasing memory and processor time requirements.  This  observation is valid for configurations ranging from a uniprocessor with an unbuffered main memory to  multiprocessor with a \"cache\" buffer memory.  If the number of subexpressions which can be executed in  parallel exceeds the number of available processors, then execution of some of these subexpressions must  be postponed.  A procedure is given which combines this requirement with the earlier ordering considerations  to provide an optimal execution sequence.", "authors": "Ramamoorthy, C. V. Gonzalez, M. J.", "words_pool": ["arithmet", "broken", "buffer", "cach", "combin", "combin", "compon", "configur", "consider", "consider", "decreas", "depend", "earlier", "environ", "evalu", "exce", "execut", "execut", "express", "express", "hardwar", "main", "memori", "minim", "mode", "multiprocessor", "number", "observ", "optim", "order", "order", "paper", "parallel", "postpon", "procedur", "processor", "processor", "provid", "rang", "requir", "requir", "sequenc", "serial", "show", "subexpress", "subexpress", "time", "unbuff", "uniprocessor", "valid", "ramamoorthi", "gonzalez"], "word_count": {"arithmet": 1, "broken": 1, "buffer": 1, "cach": 1, "combin": 2, "compon": 1, "configur": 1, "consider": 2, "decreas": 1, "depend": 1, "earlier": 1, "environ": 1, "evalu": 1, "exce": 1, "execut": 6, "express": 3, "hardwar": 1, "main": 1, "memori": 3, "minim": 1, "mode": 1, "multiprocessor": 1, "number": 2, "observ": 1, "optim": 1, "order": 3, "paper": 1, "parallel": 2, "postpon": 1, "procedur": 1, "processor": 2, "provid": 1, "rang": 1, "requir": 2, "sequenc": 1, "serial": 1, "show": 1, "subexpress": 6, "time": 2, "unbuff": 1, "uniprocessor": 1, "valid": 1, "ramamoorthi": 1, "gonzalez": 1}}, "2176": {"id": "2176", "title": "Buffer Allocation in Merge-Sorting", "abstract": "A fixed buffer allocation for merge-sorting is presented here which minimizes the number of  input-output operations for a given order of merge.  When sorting on movable arm disks, the number of  seeks is equal to the number of input-output operations, and the seek time usually controls the sort  time.  First some standard terminology is introduced.  Then the input buffer allocation method is described,  followed by an analysis of the improvement to be expected over more conventional allocation.  This analysis  makes use of a particular distribution function.  An analysis of a completely different distribution  is given which yields similar results.  This suggests that the results do not depend on a particular  distribution function.  An optimum output buffer size is also determined.  It is concluded that this  buffering allocation can significantly reduce the time of merge sorting on movable arm disks when the  input data are not random, and that this output buffer allocation should be used whether the data is  random or not.", "authors": "Ferguson, D. E.", "words_pool": ["alloc", "analysi", "arm", "buffer", "buffer", "complet", "conclud", "control", "convent", "data", "depend", "determin", "disk", "distribut", "equal", "expect", "fix", "function", "improv", "input", "introduc", "make", "merg", "method", "minim", "movabl", "number", "oper", "optimum", "order", "output", "present", "random", "reduc", "result", "seek", "seek", "significantli", "similar", "size", "sort", "sort", "standard", "suggest", "terminolog", "time", "yield", "ferguson"], "word_count": {"alloc": 5, "analysi": 3, "arm": 2, "buffer": 5, "complet": 1, "conclud": 1, "control": 1, "convent": 1, "data": 2, "depend": 1, "determin": 1, "disk": 2, "distribut": 3, "equal": 1, "expect": 1, "fix": 1, "function": 2, "improv": 1, "input": 4, "introduc": 1, "make": 1, "merg": 3, "method": 1, "minim": 1, "movabl": 2, "number": 3, "oper": 2, "optimum": 1, "order": 1, "output": 4, "present": 1, "random": 2, "reduc": 1, "result": 2, "seek": 2, "significantli": 1, "similar": 1, "size": 1, "sort": 4, "standard": 1, "suggest": 1, "terminolog": 1, "time": 3, "yield": 1, "ferguson": 1}}, "2177": {"id": "2177", "title": "An Algorithm for the Blocks and Cutnodes of a Graph", "abstract": "An efficient method is presented for finding blocks and cutnodes of an arbitrary undirected  graph.  The graph may be represented either (i) as an ordered list of edges or (ii) as a packed adjacency  matrix.  If w denotes the word length of the machine employed, the storage (in machine words) required  for a graph with n nodes and m edges increases essentially as 2(m+n) in case (i), or (n^2)/win case  (ii).  A spanning tree with labeled edges is grown, two edges finally bearing different labels if and  only if they belong to different blocks.  For both representations the time required to analyze a graph  on n nodes increases as n^G where G depends on the type of graph, 1 <= G <= 2, and both bounds are attained.   Values of G are derived for each of several suitable families of test graphs, generated by an extension  of the web grammar approach.  The algorithm is compared in detail with that proposed by Read for which  1 <= G <= 3.", "authors": "Paton, K.", "words_pool": ["adjac", "algorithm", "analyz", "approach", "arbitrari", "attain", "bear", "belong", "block", "bound", "case", "compar", "cutnod", "denot", "depend", "deriv", "detail", "edg", "effici", "employ", "essenti", "extens", "famili", "final", "find", "gener", "grammar", "graph", "graph", "grown", "ii", "increas", "label", "label", "length", "list", "machin", "matrix", "method", "node", "order", "pack", "present", "propos", "read", "represent", "repres", "requir", "span", "storag", "suitabl", "test", "time", "tree", "type", "undirect", "valu", "web", "win", "word", "word", "paton"], "word_count": {"adjac": 1, "algorithm": 1, "analyz": 1, "approach": 1, "arbitrari": 1, "attain": 1, "bear": 1, "belong": 1, "block": 2, "bound": 1, "case": 2, "compar": 1, "cutnod": 1, "denot": 1, "depend": 1, "deriv": 1, "detail": 1, "edg": 4, "effici": 1, "employ": 1, "essenti": 1, "extens": 1, "famili": 1, "final": 1, "find": 1, "gener": 1, "grammar": 1, "graph": 6, "grown": 1, "ii": 2, "increas": 2, "label": 2, "length": 1, "list": 1, "machin": 2, "matrix": 1, "method": 1, "node": 2, "order": 1, "pack": 1, "present": 1, "propos": 1, "read": 1, "represent": 1, "repres": 1, "requir": 2, "span": 1, "storag": 1, "suitabl": 1, "test": 1, "time": 1, "tree": 1, "type": 1, "undirect": 1, "valu": 1, "web": 1, "win": 1, "word": 2, "paton": 1}}, "2178": {"id": "2178", "title": "A Language Extension for Graph Processing and Its Formal Semantics", "abstract": "A simple programming language \"extension,\" Graspe, for processing directed graphs is defined.   Graspe consists of a type of directed graph data structure and a set of primitive operations for manipulating  these structures.  Graspe may be most easily implemented by embedding it in a host language.  Emphasis  is placed both on Graspe itself and on its method of definition.  Commonly, the definition of a language  involves definition of the syntactic elements and explanation of the meaning to be assigned them (the  semantics).  The definition of Graspe here is solely in terms of its semantics; that is, the data structures  and operations are defined precisely but without assignment of a particular syntactic representation.   Only when the language is implemented is assignment of an explicit syntax necessary.  An example of  an implementation of Graspe embedded in Lisp is given as an illustration.  The advantages and disadvantages  of the definition of a language in terms of its semantics are discussed.", "authors": "Pratt, T. W. Friedman, D. P.", "words_pool": ["advantag", "assign", "assign", "commonli", "consist", "data", "defin", "definit", "direct", "disadvantag", "discuss", "easili", "element", "embed", "embed", "emphasi", "explan", "explicit", "extens", "formal", "graph", "graph", "grasp", "host", "illustr", "implement", "implement", "involv", "languag", "lisp", "manipul", "mean", "method", "oper", "precis", "primit", "process", "program", "represent", "semant", "set", "simpl", "sole", "structur", "structur", "syntact", "syntax", "term", "type", "pratt", "friedman"], "word_count": {"advantag": 1, "assign": 3, "commonli": 1, "consist": 1, "data": 2, "defin": 2, "definit": 5, "direct": 2, "disadvantag": 1, "discuss": 1, "easili": 1, "element": 1, "embed": 2, "emphasi": 1, "explan": 1, "explicit": 1, "extens": 1, "formal": 1, "graph": 2, "grasp": 6, "host": 1, "illustr": 1, "implement": 3, "involv": 1, "languag": 5, "lisp": 1, "manipul": 1, "mean": 1, "method": 1, "oper": 2, "precis": 1, "primit": 1, "process": 1, "program": 1, "represent": 1, "semant": 3, "set": 1, "simpl": 1, "sole": 1, "structur": 3, "syntact": 2, "syntax": 1, "term": 2, "type": 1, "pratt": 1, "friedman": 1}}, "2179": {"id": "2179", "title": "Simple LR(k) Grammars", "abstract": "A class of context-free grammars, called the \"Simple LR(k)\" or SLR(k) grammars is defined.   This class has been shown to include weak precedence and simple precedence grammars as proper subsets.   How to construct parsers for the SLR(k) grammars is also shown.  These parser-construction techniques  are extendible to cover all of the LR(k) grammars of Knuth; they have been implemented and by direct  comparison proved to be superior to precedence techniques, not only in the range of grammars covered,  but also in the speed of parser construction and in the size and speed of the resulting parsers.", "authors": "DeRemer, F. L.", "words_pool": ["call", "class", "comparison", "construct", "construct", "context", "cover", "cover", "defin", "direct", "extend", "free", "grammar", "implement", "includ", "knuth", "lr", "parser", "parser", "preced", "proper", "prove", "rang", "result", "shown", "simpl", "size", "slr", "speed", "subset", "superior", "techniqu", "weak", "derem"], "word_count": {"call": 1, "class": 2, "comparison": 1, "construct": 3, "context": 1, "cover": 2, "defin": 1, "direct": 1, "extend": 1, "free": 1, "grammar": 6, "implement": 1, "includ": 1, "knuth": 1, "lr": 2, "parser": 4, "preced": 3, "proper": 1, "prove": 1, "rang": 1, "result": 1, "shown": 2, "simpl": 2, "size": 1, "slr": 2, "speed": 2, "subset": 1, "superior": 1, "techniqu": 2, "weak": 1, "derem": 1}}, "2180": {"id": "2180", "title": "A Programmer Training Project", "abstract": "A project is described whose purpose is to train selected black residents of the Albany-Schenectady  area in computer programming and arrange for jobs for them in the computer field. Both the organization  and curriculum of the course are discussed.", "authors": "Bernstein, A. J.", "words_pool": ["albani", "area", "arrang", "black", "comput", "cours", "curriculum", "discuss", "field", "job", "organ", "programm", "program", "project", "purpos", "resid", "schenectadi", "select", "train", "train", "bernstein"], "word_count": {"albani": 1, "area": 1, "arrang": 1, "black": 1, "comput": 2, "cours": 1, "curriculum": 1, "discuss": 1, "field": 1, "job": 1, "organ": 1, "programm": 1, "program": 1, "project": 1, "purpos": 1, "resid": 1, "schenectadi": 1, "select": 1, "train": 1, "bernstein": 1}}, "2181": {"id": "2181", "title": "The State of Computer Oriented Curricula in Business Schools 1970", "abstract": "The ACM Committee on Computer Education for Management, supported by a National Science Foundation  Grant, is established to appraise the state of the art and to develop a series of recommendations for  improving computer education for management.  To provide the Committee with material for its study of  curricular needs, five regional meetings in the United States were held in 1970, at each of which a broad  cross section of invited academicians and practitioners considered the state of curricula in business  schools.  Three topics were covered: curricula for the general manager; computer-related material in  required and functional courses; and curricula for students concentrating on computer-based information  systems.  An analysis of the minutes of the meetings revealed a common set of experiences which raised  similar pedagogic and economic issues.  This presentation gives a summary of the discussions; a condensation of the pedagogic and substantive concerns raised; and consideration of the resource allocation issues  involved.  Preliminary to the Committee's recommendations for improving computer education for management,  this report has been prepared to provide the participants and the administrators of their institutions  with background information for the ongoing task of course development.  Chairman of the ten-man Committee  is Daniel Teichroew (The University of Michigan).", "authors": "McKenney, J. L. Tonge, F. M.", "words_pool": ["academician", "acm", "administr", "alloc", "analysi", "apprais", "art", "background", "base", "broad", "busi", "chairman", "committe", "common", "comput", "concentr", "concern", "condens", "consider", "consid", "cours", "cours", "cover", "cross", "curricula", "curricular", "daniel", "develop", "develop", "discuss", "econom", "educ", "establish", "experi", "foundat", "function", "gener", "grant", "held", "improv", "inform", "institut", "invit", "involv", "issu", "man", "manag", "manag", "materi", "meet", "michigan", "minut", "nation", "need", "ongo", "orient", "particip", "pedagog", "practition", "preliminari", "prepar", "present", "provid", "rais", "recommend", "region", "relat", "report", "requir", "resourc", "reveal", "school", "scienc", "section", "seri", "set", "similar", "state", "state", "student", "studi", "substant", "summari", "support", "system", "task", "teichroew", "ten", "topic", "unit", "univers", "mckenney", "tong"], "word_count": {"academician": 1, "acm": 1, "administr": 1, "alloc": 1, "analysi": 1, "apprais": 1, "art": 1, "background": 1, "base": 1, "broad": 1, "busi": 1, "chairman": 1, "committe": 4, "common": 1, "comput": 5, "concentr": 1, "concern": 1, "condens": 1, "consider": 1, "consid": 1, "cours": 2, "cover": 1, "cross": 1, "curricula": 3, "curricular": 1, "daniel": 1, "develop": 2, "discuss": 1, "econom": 1, "educ": 3, "establish": 1, "experi": 1, "foundat": 1, "function": 1, "gener": 1, "grant": 1, "held": 1, "improv": 2, "inform": 2, "institut": 1, "invit": 1, "involv": 1, "issu": 2, "man": 1, "manag": 4, "materi": 2, "meet": 2, "michigan": 1, "minut": 1, "nation": 1, "need": 1, "ongo": 1, "orient": 1, "particip": 1, "pedagog": 2, "practition": 1, "preliminari": 1, "prepar": 1, "present": 1, "provid": 2, "rais": 2, "recommend": 2, "region": 1, "relat": 1, "report": 1, "requir": 1, "resourc": 1, "reveal": 1, "school": 1, "scienc": 1, "section": 1, "seri": 1, "set": 1, "similar": 1, "state": 3, "student": 1, "studi": 1, "substant": 1, "summari": 1, "support": 1, "system": 1, "task": 1, "teichroew": 1, "ten": 1, "topic": 1, "unit": 1, "univers": 1, "mckenney": 1, "tong": 1}}, "2182": {"id": "2182", "title": "Interrupt Driven Programming", "authors": "Zelkowitz, M.", "words_pool": ["driven", "interrupt", "program", "zelkowitz"], "word_count": {"driven": 1, "interrupt": 1, "program": 1, "zelkowitz": 1}}, "2183": {"id": "2183", "title": "Binary Summation", "authors": "Walker, R. J.", "words_pool": ["binari", "summat", "walker"], "word_count": {"binari": 1, "summat": 1, "walker": 1}}, "2184": {"id": "2184", "title": "On the Meaning of Names in Programming Systems", "abstract": "It is assumed that there is a similarity of function between the data names of a programming  language and the file names of an operating system.  The two functions are discussed in terms of the  same basic concepts in order to identify the extent to which they overlap. It is suggested that there  is some similarity between the idea of a file directory and a storable object of type context.  Manipulations  with contexts are then discussed at length.  It is noted that there is a simple extension of Church's  Lambda notation that deals nicely with these ideas of context manipulation.  Whereas a function can be  regarded as the abstraction based upon the first two terms of the expression Lambda(name list)(expression)(value list),  it is found that a context can be viewed as an abstraction based upon the first two terms in the equivalent  expression Mu(name list)(value list)(expression).", "authors": "Fraser, A. G.", "words_pool": ["abstract", "assum", "base", "basic", "church", "concept", "context", "context", "data", "deal", "directori", "discuss", "equival", "express", "extens", "extent", "found", "function", "function", "idea", "idea", "identifi", "lambda", "languag", "length", "list", "manipul", "manipul", "mean", "mu", "name", "nice", "notat", "note", "object", "oper", "order", "overlap", "program", "regard", "similar", "simpl", "storabl", "suggest", "system", "system", "term", "type", "view", "fraser"], "word_count": {"abstract": 2, "assum": 1, "base": 2, "basic": 1, "church": 1, "concept": 1, "context": 4, "data": 1, "deal": 1, "directori": 1, "discuss": 2, "equival": 1, "express": 4, "extens": 1, "extent": 1, "found": 1, "function": 3, "idea": 2, "identifi": 1, "lambda": 2, "languag": 1, "length": 1, "list": 4, "manipul": 2, "mean": 1, "mu": 1, "name": 2, "nice": 1, "notat": 1, "note": 1, "object": 1, "oper": 1, "order": 1, "overlap": 1, "program": 1, "regard": 1, "similar": 2, "simpl": 1, "storabl": 1, "suggest": 1, "system": 1, "term": 3, "type": 1, "view": 1, "fraser": 1}}, "2185": {"id": "2185", "title": "A Note on Compiling Fixed Point Binary Multiplications", "abstract": "An algorithm is developed for compiling, as a sequence of shifts, additions,and subtractions,  many fixed point binary multiplications involving a constant.  The most significant characteristics of  the algorithm are the simplicity of the test which determines if the algorithm should be applied and  the degree to which it \"suggests\" efficient object code.", "authors": "Glaswin, H. T.", "words_pool": ["addit", "algorithm", "appli", "binari", "characterist", "code", "compil", "constant", "degre", "determin", "develop", "effici", "fix", "involv", "multipl", "note", "object", "point", "sequenc", "shift", "signific", "simplic", "subtract", "suggest", "test", "glaswin"], "word_count": {"addit": 1, "algorithm": 3, "appli": 1, "binari": 1, "characterist": 1, "code": 1, "compil": 1, "constant": 1, "degre": 1, "determin": 1, "develop": 1, "effici": 1, "fix": 1, "involv": 1, "multipl": 1, "note": 1, "object": 1, "point": 1, "sequenc": 1, "shift": 1, "signific": 1, "simplic": 1, "subtract": 1, "suggest": 1, "test": 1, "glaswin": 1}}, "2186": {"id": "2186", "title": "Numerical Properties of the Ritz-Trefftz Algorithm for Optimal Control", "abstract": "In this paper the Ritz-Trefftz algorithm is applied to the computer solution of the state regulator  problem.  The algorithm represents a modification of the Ritz direct method and is designed to improve  the speed of solution and the storage requirements to the point where real-time implementation becomes  feasible.  The modification is shown to be more stable computationally than the traditional Ritz approach.   The first concern of the paper is to describe the algorithm and establish its properties as a valid  and useful numerical technique.  In particular such useful properties as definiteness and reasonableness  of condition are established for the method.  The second part of the paper is devoted to a comparison  of the new techniques with the standard procedure of numerically integrating a matrix Riccati equation  to determine a feedback matrix.  The new technique is shown to be significantly faster for comparable  accuracy.", "authors": "Bosarge Jr., W. E. Johnson, O. G.", "words_pool": ["accuraci", "algorithm", "appli", "approach", "compar", "comparison", "comput", "comput", "concern", "condit", "control", "definit", "describ", "design", "determin", "devot", "direct", "equat", "establish", "establish", "faster", "feasibl", "feedback", "implement", "improv", "integr", "matrix", "method", "modif", "numer", "numer", "optim", "paper", "part", "point", "problem", "procedur", "properti", "real", "reason", "regul", "repres", "requir", "riccati", "ritz", "shown", "significantli", "solut", "speed", "stabl", "standard", "state", "storag", "techniqu", "techniqu", "time", "tradit", "trefftz", "valid", "bosarg", "jr", "johnson"], "word_count": {"accuraci": 1, "algorithm": 3, "appli": 1, "approach": 1, "compar": 1, "comparison": 1, "comput": 2, "concern": 1, "condit": 1, "control": 1, "definit": 1, "describ": 1, "design": 1, "determin": 1, "devot": 1, "direct": 1, "equat": 1, "establish": 2, "faster": 1, "feasibl": 1, "feedback": 1, "implement": 1, "improv": 1, "integr": 1, "matrix": 2, "method": 2, "modif": 2, "numer": 2, "optim": 1, "paper": 3, "part": 1, "point": 1, "problem": 1, "procedur": 1, "properti": 2, "real": 1, "reason": 1, "regul": 1, "repres": 1, "requir": 1, "riccati": 1, "ritz": 3, "shown": 2, "significantli": 1, "solut": 2, "speed": 1, "stabl": 1, "standard": 1, "state": 1, "storag": 1, "techniqu": 3, "time": 1, "tradit": 1, "trefftz": 1, "valid": 1, "bosarg": 1, "jr": 1, "johnson": 1}}, "2187": {"id": "2187", "title": "Computer Science: A Conceptual Framework for Curriculum Planning", "abstract": "Two views of computer science are considered: a global view which attempts to capture broad  characteristics of the field and its relationships to other fields, and a local view which focuses on  the inner structure of the field.  This structure is presented in terms of the kinds of knowledge, problems,  and activities that exist within the discipline, as well as the relations between them.  An approach  to curriculum planning in computer science is presented which is guided by the structure of the field,  by the fact that change is an important feature of the situation, and by the expectation that computer science will continue to increase its working contacts with other disciplines.", "authors": "Amarel, S.", "words_pool": ["activ", "approach", "attempt", "broad", "captur", "chang", "characterist", "comput", "conceptu", "consid", "contact", "continu", "curriculum", "disciplin", "disciplin", "exist", "expect", "fact", "featur", "field", "field", "focus", "framework", "global", "guid", "import", "increas", "kind", "knowledg", "local", "plan", "present", "problem", "relat", "relationship", "scienc", "situat", "structur", "term", "view", "view", "work", "amarel"], "word_count": {"activ": 1, "approach": 1, "attempt": 1, "broad": 1, "captur": 1, "chang": 1, "characterist": 1, "comput": 3, "conceptu": 1, "consid": 1, "contact": 1, "continu": 1, "curriculum": 1, "disciplin": 2, "exist": 1, "expect": 1, "fact": 1, "featur": 1, "field": 4, "focus": 1, "framework": 1, "global": 1, "guid": 1, "import": 1, "increas": 1, "kind": 1, "knowledg": 1, "local": 1, "plan": 1, "present": 2, "problem": 1, "relat": 1, "relationship": 1, "scienc": 3, "situat": 1, "structur": 3, "term": 1, "view": 3, "work": 1, "amarel": 1}}, "2188": {"id": "2188", "title": "An Approach to the Optimum Design of Computer Graphics Systems", "abstract": "Display system designers are faced with the difficult task of selecting major subsystems in  an intelligent way.  Each subsystem is chosen from large numbers of alternatives; the selection is based  on considerations such as system response time, system cost, and the distribution of data storage and  processing between the graphics processor and its supporting data processing system.  The work reported  here develops an objective, quantitative design procedure and helps give a better understanding of now  to  configure display systems.  This is accomplished by means of a mathematical model of a computer driven  graphics system.  The parameters of the model are functions of the capabilities of the graphics hardware  and of the computational requirements of the graphics application.  The model can be analyzed using numerical  queueing analysis or simulation to obtain an average response time prediction.  By combining the model  with an optimization, the best graphics system configuration, subject to a cost constraint, is found  for several applications.  The optimum configurations are in turn used to find general display system  design guidelines.", "authors": "Foley, J. D.", "words_pool": ["accomplish", "altern", "analysi", "analyz", "applic", "applic", "approach", "averag", "base", "capabl", "chosen", "combin", "comput", "comput", "configur", "configur", "configur", "consider", "constraint", "cost", "data", "design", "design", "develop", "difficult", "display", "distribut", "driven", "face", "find", "found", "function", "gener", "give", "graphic", "guidelin", "hardwar", "help", "intellig", "larg", "major", "mathemat", "mean", "model", "number", "numer", "object", "obtain", "optim", "optimum", "paramet", "predict", "procedur", "process", "processor", "quantit", "queue", "report", "requir", "respons", "select", "select", "simul", "storag", "subject", "subsystem", "subsystem", "support", "system", "system", "task", "time", "turn", "understand", "work", "foley"], "word_count": {"accomplish": 1, "altern": 1, "analysi": 1, "analyz": 1, "applic": 2, "approach": 1, "averag": 1, "base": 1, "capabl": 1, "chosen": 1, "combin": 1, "comput": 2, "configur": 3, "consider": 1, "constraint": 1, "cost": 2, "data": 2, "design": 3, "develop": 1, "difficult": 1, "display": 3, "distribut": 1, "driven": 1, "face": 1, "find": 1, "found": 1, "function": 1, "gener": 1, "give": 1, "graphic": 5, "guidelin": 1, "hardwar": 1, "help": 1, "intellig": 1, "larg": 1, "major": 1, "mathemat": 1, "mean": 1, "model": 4, "number": 1, "numer": 1, "object": 1, "obtain": 1, "optim": 1, "optimum": 1, "paramet": 1, "predict": 1, "procedur": 1, "process": 2, "processor": 1, "quantit": 1, "queue": 1, "report": 1, "requir": 1, "respons": 2, "select": 2, "simul": 1, "storag": 1, "subject": 1, "subsystem": 2, "support": 1, "system": 8, "task": 1, "time": 2, "turn": 1, "understand": 1, "work": 1, "foley": 1}}, "2189": {"id": "2189", "title": "Generation of Rosary Permutations Expressed in Hamiltonian Circuits", "abstract": "Systematic generation of a specific class of permutations fundamental to scheduling problems  is described.  In a nonoriented complete graph with n vertices, Hamitonian circuits equivalent to .5(n  - 1)! specific permutations of n elements, termed rosary permutations, can be defined.  Each of them  corresponds to two circular permutations which mirror-image each other, and is generated successively  by a number system covering 3*4*...*(n-1) sets of edges.  Every set of edges {E[k]}, 1 <= E[k] <= k,  3 <= k <= (n-1) is determined recursively by constructing a Hamiltonian circuit with k vertices from  a Hamiltonian circuit with k-1 vertices, starting with the Hamiltonian circuit of 3 vertices.  The basic  operation consists of transposition of a pair of adjacent vertices where the position of the pair in  the permutation is determined by {E[k]}.  Two algorithms treating the same example for five vertices  are presented.  It is very easy to derive all possible n! permutations  from the .5(n - 1 )! rosary permutations  be cycling the permutations and by taking them in the reverse order-procedures which can be performed  fairly efficiently by computer.", "authors": "Harada, K.", "words_pool": ["adjac", "algorithm", "basic", "circuit", "circuit", "circular", "class", "complet", "comput", "consist", "construct", "correspond", "cover", "cycl", "defin", "deriv", "determin", "easi", "edg", "effici", "element", "equival", "express", "fairli", "fundament", "gener", "gener", "graph", "hamiltonian", "hamitonian", "imag", "mirror", "nonori", "number", "oper", "order", "pair", "perform", "permut", "permut", "posit", "present", "problem", "procedur", "recurs", "revers", "rosari", "schedul", "set", "set", "specif", "start", "success", "system", "systemat", "take", "term", "transposit", "treat", "vertic", "harada"], "word_count": {"adjac": 1, "algorithm": 1, "basic": 1, "circuit": 4, "circular": 1, "class": 1, "complet": 1, "comput": 1, "consist": 1, "construct": 1, "correspond": 1, "cover": 1, "cycl": 1, "defin": 1, "deriv": 1, "determin": 2, "easi": 1, "edg": 2, "effici": 1, "element": 1, "equival": 1, "express": 1, "fairli": 1, "fundament": 1, "gener": 2, "graph": 1, "hamiltonian": 3, "hamitonian": 1, "imag": 1, "mirror": 1, "nonori": 1, "number": 1, "oper": 1, "order": 1, "pair": 2, "perform": 1, "permut": 8, "posit": 1, "present": 1, "problem": 1, "procedur": 1, "recurs": 1, "revers": 1, "rosari": 2, "schedul": 1, "set": 2, "specif": 2, "start": 1, "success": 1, "system": 1, "systemat": 1, "take": 1, "term": 1, "transposit": 1, "treat": 1, "vertic": 6, "harada": 1}}, "2190": {"id": "2190", "title": "Function Minimization", "authors": "House, F. R.", "words_pool": ["function", "minim", "hous"], "word_count": {"function": 1, "minim": 1, "hous": 1}}, "2191": {"id": "2191", "title": "ALGORITHM 410 Partial Sorting [M1]", "authors": "Chambers, J. M.", "words_pool": ["algorithm", "m1", "partial", "sort", "chamber"], "word_count": {"algorithm": 1, "m1": 1, "partial": 1, "sort": 1, "chamber": 1}}, "2192": {"id": "2192", "title": "Another Recursion Induction Principle", "abstract": "An inductive method for proving things about recursively defined functions is described.  It  is shown to be useful for proving partial functions equivalent and thus applicable in proofs about interpreters  for programming languages.", "authors": "Morris Jr., J. H.", "words_pool": ["applic", "defin", "equival", "function", "induct", "induct", "interpret", "languag", "method", "partial", "principl", "program", "proof", "prove", "recurs", "recurs", "shown", "thing", "morri", "jr"], "word_count": {"applic": 1, "defin": 1, "equival": 1, "function": 2, "induct": 1, "interpret": 1, "languag": 1, "method": 1, "partial": 1, "principl": 1, "program": 1, "proof": 1, "prove": 2, "recurs": 1, "shown": 1, "thing": 1, "morri": 1, "jr": 1}}, "2193": {"id": "2193", "title": "On Implementation of Label Variables", "abstract": "Variables of label mode are conventionally implemented with a technique which fails to trap  certain programming errors.  Fine-grained calendar clocks have recently become available; these allow  implementation of label variables via a new technique which traps all programming errors of this variety.", "authors": "Fenichel, R. R.", "words_pool": ["allow", "calendar", "clock", "convent", "error", "fail", "fine", "grain", "implement", "implement", "label", "mode", "program", "recent", "techniqu", "trap", "trap", "variabl", "varieti", "fenichel"], "word_count": {"allow": 1, "calendar": 1, "clock": 1, "convent": 1, "error": 2, "fail": 1, "fine": 1, "grain": 1, "implement": 2, "label": 2, "mode": 1, "program": 2, "recent": 1, "techniqu": 2, "trap": 2, "variabl": 2, "varieti": 1, "fenichel": 1}}, "2194": {"id": "2194", "title": "How To Keep the Addresses Short", "abstract": "An algorithm is presented for minimizing the sum of the lengths of the blocks of coding produced  by an assembler or compiler when (1) the length of each computer instruction is assumed to be either  \"long\" or \"short\" (\"long,\" if the memory location addressed is more than a predetermined distance from  the current location; \"short,\" otherwise), and (2) there are blocks of instructions whose beginnings  (origins) are separated by prespecified amounts. For example, some computers permit either 8-bit addressing  (interpreted relative to the location counter) or full 16-bit addressing of all of memory.  When assembling  or compiling two or more blocks of instructions which have many mutual references in such a computer,  there is no simple iterative procedure for keeping as many of the addresses short as possible.  This  paper demonstrates that a wide class of problems of this type can be formulated as covering problems  solvable by means of elementary arithmetic operations on the column vectors of a ternary matrix.", "authors": "Richards, D. L.", "words_pool": ["address", "address", "address", "algorithm", "amount", "arithmet", "assembl", "assembl", "assum", "begin", "bit", "block", "class", "code", "column", "compil", "compil", "comput", "comput", "counter", "cover", "demonstr", "distanc", "elementari", "formul", "full", "instruct", "instruct", "interpret", "iter", "keep", "length", "length", "locat", "long", "matrix", "mean", "memori", "minim", "mutual", "oper", "origin", "paper", "permit", "predetermin", "present", "prespecifi", "problem", "procedur", "produc", "refer", "rel", "separ", "short", "simpl", "solvabl", "sum", "ternari", "type", "vector", "wide", "richard"], "word_count": {"address": 4, "algorithm": 1, "amount": 1, "arithmet": 1, "assembl": 2, "assum": 1, "begin": 1, "bit": 2, "block": 3, "class": 1, "code": 1, "column": 1, "compil": 2, "comput": 3, "counter": 1, "cover": 1, "demonstr": 1, "distanc": 1, "elementari": 1, "formul": 1, "full": 1, "instruct": 3, "interpret": 1, "iter": 1, "keep": 1, "length": 2, "locat": 3, "long": 2, "matrix": 1, "mean": 1, "memori": 2, "minim": 1, "mutual": 1, "oper": 1, "origin": 1, "paper": 1, "permit": 1, "predetermin": 1, "present": 1, "prespecifi": 1, "problem": 2, "procedur": 1, "produc": 1, "refer": 1, "rel": 1, "separ": 1, "short": 3, "simpl": 1, "solvabl": 1, "sum": 1, "ternari": 1, "type": 1, "vector": 1, "wide": 1, "richard": 1}}, "2195": {"id": "2195", "title": "On the Optimal Detection of Curves in Noisy Pictures", "abstract": "A technique for recognizing systems of lines is presented.  In this technique the heuristic  of the problem is not embedded in the recognition algorithm but is expressed in a figure of merit.    A multistage decision process is then able to recognize in the input picture the optimal system of lines  according to the given figure of merit.  Due to the global approach, greater flexibility and adequacy  in the particular problem is achieved.  The relation between the structure of the figure of merit and  the complexity of the optimization process is then discussed.  The method described is suitable for parallel  processing because the operations relative to each state can be computed in parallel, and the number of stages is equal to the length N of the curves (or to log2 N if the approximate method is used).", "authors": "Montanari, U.", "words_pool": ["abl", "accord", "achiev", "adequaci", "algorithm", "approach", "approxim", "complex", "comput", "curv", "decis", "detect", "discuss", "due", "embed", "equal", "express", "figur", "flexibl", "global", "greater", "heurist", "input", "length", "line", "log2", "merit", "method", "multistag", "noisi", "number", "oper", "optim", "optim", "parallel", "pictur", "pictur", "present", "problem", "process", "process", "recognit", "recogn", "recogn", "relat", "rel", "stage", "state", "structur", "suitabl", "system", "system", "techniqu", "montanari"], "word_count": {"abl": 1, "accord": 1, "achiev": 1, "adequaci": 1, "algorithm": 1, "approach": 1, "approxim": 1, "complex": 1, "comput": 1, "curv": 1, "decis": 1, "detect": 1, "discuss": 1, "due": 1, "embed": 1, "equal": 1, "express": 1, "figur": 3, "flexibl": 1, "global": 1, "greater": 1, "heurist": 1, "input": 1, "length": 1, "line": 2, "log2": 1, "merit": 3, "method": 2, "multistag": 1, "noisi": 1, "number": 1, "oper": 1, "optim": 2, "parallel": 2, "pictur": 1, "present": 1, "problem": 2, "process": 3, "recognit": 1, "recogn": 2, "relat": 1, "rel": 1, "stage": 1, "state": 1, "structur": 1, "suitabl": 1, "system": 2, "techniqu": 2, "montanari": 1}}, "2196": {"id": "2196", "title": "A Man-Machine Approach Toward Solving the Traveling Salesman Problem", "abstract": "The traveling salesman problem belongs to an important class of scheduling and routing problems.   It is also a subproblem in solving others, such as the warehouse distribution problem.  It has been  attacked by many mathematical methods with but meager success.  Only for special forms of the problem  or for problems with a moderate number of points can it be solved exactly, even if very large amounts  of computer time are used.  Heuristic procedures have been proposed and tested with only slightly better  results.  This paper describes a computer aided heuristic technique which uses only a modest amount of  computer time in real-time to solve large (100-200) point problems.  This technique takes advantage of  both the computer's and the human's problem-solving abilities.  The computer is not asked to solve the  problem in a brute force way as in many of today's heuristics, but it is asked to organize the data for  the human so that the human can solve the problem easily.  The technique used in this paper seems to  point to new directions in the field of man-machine interaction and in the field of artificial intelligence.", "authors": "Krolak, P. Felts, W. Marble, G.", "words_pool": ["abil", "advantag", "aid", "amount", "amount", "approach", "artifici", "ask", "attack", "belong", "brute", "class", "comput", "data", "describ", "direct", "distribut", "easili", "exactli", "field", "forc", "form", "heurist", "heurist", "human", "import", "intellig", "interact", "larg", "machin", "man", "mathemat", "meager", "method", "moder", "modest", "number", "organ", "paper", "point", "point", "problem", "problem", "procedur", "propos", "real", "result", "rout", "salesman", "schedul", "slightli", "solv", "solv", "solv", "special", "subproblem", "success", "take", "techniqu", "test", "time", "today", "travel", "warehous", "krolak", "felt", "marbl"], "word_count": {"abil": 1, "advantag": 1, "aid": 1, "amount": 2, "approach": 1, "artifici": 1, "ask": 2, "attack": 1, "belong": 1, "brute": 1, "class": 1, "comput": 5, "data": 1, "describ": 1, "direct": 1, "distribut": 1, "easili": 1, "exactli": 1, "field": 2, "forc": 1, "form": 1, "heurist": 3, "human": 3, "import": 1, "intellig": 1, "interact": 1, "larg": 2, "machin": 1, "man": 1, "mathemat": 1, "meager": 1, "method": 1, "moder": 1, "modest": 1, "number": 1, "organ": 1, "paper": 2, "point": 3, "problem": 9, "procedur": 1, "propos": 1, "real": 1, "result": 1, "rout": 1, "salesman": 1, "schedul": 1, "slightli": 1, "solv": 6, "special": 1, "subproblem": 1, "success": 1, "take": 1, "techniqu": 3, "test": 1, "time": 3, "today": 1, "travel": 1, "warehous": 1, "krolak": 1, "felt": 1, "marbl": 1}}, "2197": {"id": "2197", "title": "The Merit of Regional Computing Networks", "abstract": "One of the suggested means for stimulating the spread of computing capabilities in institutions  of higher learning is through the construction of regional computing networks.  One such network has  been constructed in the San Francisco Bay Area by Stanford University.  This paper reports upon the lessons  learned from the operation of the network over the past two years.  A major impact of the network was  not so much the computer power delivered to the schools as the awakening of computing awareness and the  fostering of capability development at these schools. The expertise and assistance from the central facility as well as the sharing of ideas among the participants were other important benefits.  Both the quality  and variety of services provided by the central facility were found to play a key role in the effectiveness  of the network.  A regional network brings many benefits and should not be judged as a purveyor of raw  computer power alone.", "authors": "Nielsen, N. R.", "words_pool": ["area", "assist", "awaken", "awar", "bay", "benefit", "bring", "capabl", "capabl", "central", "comput", "comput", "construct", "construct", "deliv", "develop", "effect", "expertis", "facil", "foster", "found", "francisco", "higher", "idea", "impact", "import", "institut", "judg", "key", "learn", "learn", "lesson", "major", "mean", "merit", "network", "network", "oper", "paper", "particip", "past", "play", "power", "provid", "purveyor", "qualiti", "raw", "region", "report", "role", "san", "school", "servic", "share", "spread", "stanford", "stimul", "suggest", "univers", "varieti", "year", "nielsen"], "word_count": {"area": 1, "assist": 1, "awaken": 1, "awar": 1, "bay": 1, "benefit": 2, "bring": 1, "capabl": 2, "central": 2, "comput": 5, "construct": 2, "deliv": 1, "develop": 1, "effect": 1, "expertis": 1, "facil": 2, "foster": 1, "found": 1, "francisco": 1, "higher": 1, "idea": 1, "impact": 1, "import": 1, "institut": 1, "judg": 1, "key": 1, "learn": 2, "lesson": 1, "major": 1, "mean": 1, "merit": 1, "network": 6, "oper": 1, "paper": 1, "particip": 1, "past": 1, "play": 1, "power": 2, "provid": 1, "purveyor": 1, "qualiti": 1, "raw": 1, "region": 2, "report": 1, "role": 1, "san": 1, "school": 2, "servic": 1, "share": 1, "spread": 1, "stanford": 1, "stimul": 1, "suggest": 1, "univers": 1, "varieti": 1, "year": 1, "nielsen": 1}}, "2198": {"id": "2198", "title": "Introduction to \"Feature Analysis of Generalized Data Base Management Systems\"", "abstract": "This paper is a separately published introduction to a main report which analyzes the features  of generalized data base management systems.  This introduction gives a review of the current state of  the art in these systems and discusses the differences and similarities between capabilities found in  host language systems and those found in self-contained systems.  After some discussion of the problems  of data independence and binding,the four user levels are identified and described.  Technical problems  facing future designers are described.  The first of these is that of handling existing stored data and  the next is that of providing more complex data structures than those already available in conventional  programming languages.  The problem of high level interrogation and update functions acting on network  structures is mentioned, followed by a discussion of the problem of catering to a high volume of transactions  initiated from terminals by parametric users-the lowest level of user.  The use of Cobol as a basis for  further development work is considered at some length with respect to data structures, host language  capabilities, and self-contained capabilities.  This section also assesses the effect of the Data Base  Task Group proposals.  The final section outlines the ten major topics in the main body of the full report.", "authors": "Codasyl Systems Committee", "words_pool": ["act", "analysi", "analyz", "art", "assess", "base", "basi", "bind", "bodi", "capabl", "cater", "cobol", "complex", "consid", "contain", "convent", "data", "design", "develop", "differ", "discuss", "discuss", "effect", "exist", "face", "featur", "featur", "final", "found", "full", "function", "futur", "gener", "group", "handl", "high", "host", "identifi", "independ", "initi", "interrog", "introduct", "languag", "languag", "length", "level", "level", "lowest", "main", "major", "manag", "mention", "network", "outlin", "paper", "parametr", "problem", "problem", "program", "propos", "provid", "publish", "report", "respect", "review", "section", "separ", "similar", "state", "store", "structur", "system", "task", "technic", "ten", "termin", "topic", "transact", "updat", "user", "user", "volum", "work", "codasyl", "system", "committe"], "word_count": {"act": 1, "analysi": 1, "analyz": 1, "art": 1, "assess": 1, "base": 2, "basi": 1, "bind": 1, "bodi": 1, "capabl": 3, "cater": 1, "cobol": 1, "complex": 1, "consid": 1, "contain": 2, "convent": 1, "data": 6, "design": 1, "develop": 1, "differ": 1, "discuss": 3, "effect": 1, "exist": 1, "face": 1, "featur": 1, "final": 1, "found": 2, "full": 1, "function": 1, "futur": 1, "gener": 1, "group": 1, "handl": 1, "high": 2, "host": 2, "identifi": 1, "independ": 1, "initi": 1, "interrog": 1, "introduct": 2, "languag": 3, "length": 1, "level": 3, "lowest": 1, "main": 2, "major": 1, "manag": 1, "mention": 1, "network": 1, "outlin": 1, "paper": 1, "parametr": 1, "problem": 4, "program": 1, "propos": 1, "provid": 1, "publish": 1, "report": 2, "respect": 1, "review": 1, "section": 2, "separ": 1, "similar": 1, "state": 1, "store": 1, "structur": 3, "system": 4, "task": 1, "technic": 1, "ten": 1, "termin": 1, "topic": 1, "transact": 1, "updat": 1, "user": 3, "volum": 1, "work": 1, "codasyl": 1, "committe": 1}}, "2199": {"id": "2199", "title": "A Sparse Matrix Package (Part I) [F4] (Algorithm 408)", "authors": "McNamee, J. M.", "words_pool": ["algorithm", "f4", "matrix", "packag", "part", "spars", "mcname"], "word_count": {"algorithm": 1, "f4": 1, "matrix": 1, "packag": 1, "part": 1, "spars": 1, "mcname": 1}}, "2200": {"id": "2200", "title": "On Complement Division", "abstract": "The division algorithm theorem is expressed in a form that permits it to serve as the basis  for devising division operations that produce both quotient and remainder in complement form.  Algorithms  for division yielding complement results are derived for numbers represented in any base greater than  one.  Both radix and radix-less-one complementation schemes are considered.  The binary form of the algorithms  thus includes both two's and one's complement implementation.  The problem of quotient overflow for complement  results is dealt with as is that of selecting an appropriate form of the remainder condition for complement  division.", "authors": "Stein, M. L. Munro, W. D.", "words_pool": ["algorithm", "algorithm", "base", "basi", "binari", "complement", "complement", "condit", "consid", "dealt", "deriv", "devis", "divis", "express", "form", "greater", "implement", "includ", "number", "oper", "overflow", "permit", "problem", "produc", "quotient", "radix", "remaind", "repres", "result", "scheme", "select", "serv", "theorem", "yield", "stein", "munro"], "word_count": {"algorithm": 3, "base": 1, "basi": 1, "binari": 1, "complement": 6, "condit": 1, "consid": 1, "dealt": 1, "deriv": 1, "devis": 1, "divis": 4, "express": 1, "form": 4, "greater": 1, "implement": 1, "includ": 1, "number": 1, "oper": 1, "overflow": 1, "permit": 1, "problem": 1, "produc": 1, "quotient": 2, "radix": 2, "remaind": 2, "repres": 1, "result": 2, "scheme": 1, "select": 1, "serv": 1, "theorem": 1, "yield": 1, "stein": 1, "munro": 1}}, "2201": {"id": "2201", "title": "he DEC-338 serves as an input  terminal for movie making, allowing the trial and error design of picture sequences in a conversational  mode.  During all stages on the system input elements (light pen, pushbuttons, and teletype) is maintained.   At the user's request, this record is sent to the IBM 360/75 where the S-D 4020 instructions necessary  to produce the same sequence of pictures can be generated.  It is anticipated that one of the primary  contributions of Animator will be the provision of a facility which will allow any professor to produce  his own expository film strips.", "abstract": "Animator is a computer animation system which was designed to overcome some of the inherent  disadvantages associated with conventional computer animation techniques", "authors": "Talbot, P. A. Carr III, J. W. Coulter Jr., R. R. Hwang, R. C.", "words_pool": ["allow", "allow", "anim", "anim", "anticip", "comput", "contribut", "convent", "convers", "dec", "design", "design", "disadvantag", "element", "error", "expositori", "facil", "film", "gener", "ibm", "inher", "input", "instruct", "light", "maintain", "make", "mode", "movi", "overcom", "pen", "pictur", "pictur", "primari", "produc", "professor", "provis", "pushbutton", "record", "request", "sequenc", "sequenc", "serv", "stage", "strip", "system", "techniqu", "teletyp", "termin", "trial", "user", "talbot", "carr", "iii", "coulter", "jr", "hwang"], "word_count": {"allow": 2, "anim": 3, "anticip": 1, "comput": 2, "contribut": 1, "convent": 1, "convers": 1, "dec": 1, "design": 1, "disadvantag": 1, "element": 1, "error": 1, "expositori": 1, "facil": 1, "film": 1, "gener": 1, "ibm": 1, "inher": 1, "input": 2, "instruct": 1, "light": 1, "maintain": 1, "make": 1, "mode": 1, "movi": 1, "overcom": 1, "pen": 1, "pictur": 2, "primari": 1, "produc": 2, "professor": 1, "provis": 1, "pushbutton": 1, "record": 1, "request": 1, "sequenc": 2, "serv": 1, "stage": 1, "strip": 1, "system": 1, "techniqu": 1, "teletyp": 1, "termin": 1, "trial": 1, "user": 1, "talbot": 1, "carr": 1, "iii": 1, "coulter": 1, "jr": 1, "hwang": 1}}, "2202": {"id": "2202", "title": "Dynamic Microprogramming: Processor Organization and Programming", "abstract": "A dynamically microprogrammed processor is characterized by a small (4^k 64-bit word) read-write  \"micro\" storage.  The access time of this storage is similar to the cycle time of the machine (50-100  nsec).  This microstorage is used to contain both data and subroutines.  The (micro) instructions in  such a processor differ from the conventional in that they perform only purely combinatorial operations;  sequencing is under the control of the microinstruction. The presence of the read-write microstorage  permits a more flexible assignment of resources than the read-only storage.  In particular, the processor  developed in this paper stresses the simultaneous operation (within the microinstruction) of the adder,  shifter, masker, and testing facilities of the processor.  A microassembly language is developed and  the overhead involved in subroutine linkages is analyzed.  The efficiency of a flexible software linkage  scheme is examined as to its overhead for various subroutine characteristics.  Finally, three examples  of problem-oriented programming are considered and the resulting coding is compared against a System/360  assembly language version, with the technology normalized.", "authors": "Tucker, A. B. Flynn, M. J.", "words_pool": ["access", "adder", "analyz", "assembl", "assign", "bit", "characterist", "character", "code", "combinatori", "compar", "consid", "control", "convent", "cycl", "data", "develop", "differ", "dynam", "dynam", "effici", "examin", "exampl", "facil", "final", "flexibl", "instruct", "involv", "languag", "linkag", "linkag", "machin", "masker", "micro", "microassembl", "microinstruct", "microprogram", "microprogram", "microstorag", "normal", "nsec", "oper", "oper", "organ", "orient", "overhead", "paper", "perform", "permit", "presenc", "problem", "processor", "program", "pure", "read", "resourc", "result", "scheme", "sequenc", "shifter", "similar", "simultan", "small", "softwar", "storag", "stress", "subroutin", "subroutin", "system", "technolog", "test", "time", "version", "word", "write", "tucker", "flynn"], "word_count": {"access": 1, "adder": 1, "analyz": 1, "assembl": 1, "assign": 1, "bit": 1, "characterist": 1, "character": 1, "code": 1, "combinatori": 1, "compar": 1, "consid": 1, "control": 1, "convent": 1, "cycl": 1, "data": 1, "develop": 2, "differ": 1, "dynam": 1, "effici": 1, "examin": 1, "exampl": 1, "facil": 1, "final": 1, "flexibl": 2, "instruct": 1, "involv": 1, "languag": 2, "linkag": 2, "machin": 1, "masker": 1, "micro": 2, "microassembl": 1, "microinstruct": 2, "microprogram": 1, "microstorag": 2, "normal": 1, "nsec": 1, "oper": 2, "organ": 1, "orient": 1, "overhead": 2, "paper": 1, "perform": 1, "permit": 1, "presenc": 1, "problem": 1, "processor": 4, "program": 1, "pure": 1, "read": 3, "resourc": 1, "result": 1, "scheme": 1, "sequenc": 1, "shifter": 1, "similar": 1, "simultan": 1, "small": 1, "softwar": 1, "storag": 3, "stress": 1, "subroutin": 3, "system": 1, "technolog": 1, "test": 1, "time": 2, "version": 1, "word": 1, "write": 2, "tucker": 1, "flynn": 1}}, "2203": {"id": "2203", "title": "Key-to-Address Transform Techniques: A Fundamental Performance Study on Large Existing Formatted  Files", "abstract": "The results of a study of eight different key-to-address transformation methods applied to  a set of existing files are presented.  As each method is applied to a particular file, load factor and  bucket size are varied over a wide range.  In addition, appropriate variables pertinent only to a specific  method take on different values.  The performance of each method is summarized in terms of the number  of accesses required to get to a record and the number of overflow records created by a transformation.   Peculiarities of each method are discussed.  Practical guidelines obtained from the results are stated.   Finally, a proposal for further quantitative fundamental study is outlined.", "authors": "Lum, V. Y. Yuen, P. S. T. Dodd, M.", "words_pool": ["access", "addit", "address", "appli", "bucket", "creat", "discuss", "exist", "factor", "final", "format", "fundament", "guidelin", "key", "larg", "load", "method", "method", "number", "obtain", "outlin", "overflow", "peculiar", "perform", "pertin", "practic", "present", "propos", "quantit", "rang", "record", "record", "requir", "result", "set", "size", "specif", "state", "studi", "summar", "take", "techniqu", "term", "transform", "transform", "valu", "variabl", "vari", "wide", "lum", "yuen", "dodd"], "word_count": {"access": 1, "addit": 1, "address": 1, "appli": 2, "bucket": 1, "creat": 1, "discuss": 1, "exist": 1, "factor": 1, "final": 1, "format": 1, "fundament": 1, "guidelin": 1, "key": 1, "larg": 1, "load": 1, "method": 5, "number": 2, "obtain": 1, "outlin": 1, "overflow": 1, "peculiar": 1, "perform": 1, "pertin": 1, "practic": 1, "present": 1, "propos": 1, "quantit": 1, "rang": 1, "record": 2, "requir": 1, "result": 2, "set": 1, "size": 1, "specif": 1, "state": 1, "studi": 2, "summar": 1, "take": 1, "techniqu": 1, "term": 1, "transform": 2, "valu": 1, "variabl": 1, "vari": 1, "wide": 1, "lum": 1, "yuen": 1, "dodd": 1}}, "2204": {"id": "2204", "title": "Program Development by Stepwise Refinement", "abstract": "The creative activity of programming-to be distinguished from coding-is usually taught by examples  serving to exhibit certain techniques.  It is here considered as a sequence of design decisions concerning  the decomposition of tasks into subtasks and of data into data structures.  The process of successive  refinement of specifications is illustrated by a short but nontrivial example, from which a number of  conclusions are drawn regarding the art and the instruction of programming.", "authors": "Wirth, N.", "words_pool": ["activ", "art", "code", "concern", "conclus", "consid", "creativ", "data", "decis", "decomposit", "design", "develop", "distinguish", "drawn", "exampl", "exhibit", "illustr", "instruct", "nontrivi", "number", "process", "program", "program", "refin", "regard", "sequenc", "serv", "short", "specif", "stepwis", "structur", "subtask", "success", "task", "taught", "techniqu", "wirth"], "word_count": {"activ": 1, "art": 1, "code": 1, "concern": 1, "conclus": 1, "consid": 1, "creativ": 1, "data": 2, "decis": 1, "decomposit": 1, "design": 1, "develop": 1, "distinguish": 1, "drawn": 1, "exampl": 1, "exhibit": 1, "illustr": 1, "instruct": 1, "nontrivi": 1, "number": 1, "process": 1, "program": 2, "refin": 1, "regard": 1, "sequenc": 1, "serv": 1, "short": 1, "specif": 1, "stepwis": 1, "structur": 1, "subtask": 1, "success": 1, "task": 1, "taught": 1, "techniqu": 1, "wirth": 1}}, "2205": {"id": "2205", "title": "DIFSUB for Solution of Ordinary Differential Equations [D2] (Algorithm 407)", "authors": "Gear, C. W.", "words_pool": ["algorithm", "d2", "differenti", "difsub", "equat", "ordinari", "solut", "gear"], "word_count": {"algorithm": 1, "d2": 1, "differenti": 1, "difsub": 1, "equat": 1, "ordinari": 1, "solut": 1, "gear": 1}}, "2206": {"id": "2206", "title": "Exact Solution of Linear Equations Using Residue Arithmetic [F4] (Algorithm 406)", "authors": "Howell, J.", "words_pool": ["algorithm", "arithmet", "equat", "exact", "f4", "linear", "residu", "solut", "howel"], "word_count": {"algorithm": 1, "arithmet": 1, "equat": 1, "exact": 1, "f4": 1, "linear": 1, "residu": 1, "solut": 1, "howel": 1}}, "2207": {"id": "2207", "title": "The Automatic Integration of Ordinary Differential Equations", "abstract": "An integration technique for the automatic solution of an initial value problem for a set of  ordinary differential equations is described.  A criterion for the selection of the order of approximation  is proposed.  The objective of the criterion is to increase the step size so as to reduce solution time.  An option permits the solution of \"stiff\" differential equations.  A program embodying the techniques  discussed appears in Algorithm 407.", "authors": "Gear, C. W.", "words_pool": ["algorithm", "appear", "approxim", "automat", "criterion", "differenti", "discuss", "embodi", "equat", "increas", "initi", "integr", "object", "option", "order", "ordinari", "permit", "problem", "program", "propos", "reduc", "select", "set", "size", "solut", "step", "stiff", "techniqu", "techniqu", "time", "gear"], "word_count": {"algorithm": 1, "appear": 1, "approxim": 1, "automat": 1, "criterion": 2, "differenti": 2, "discuss": 1, "embodi": 1, "equat": 2, "increas": 1, "initi": 1, "integr": 1, "object": 1, "option": 1, "order": 1, "ordinari": 1, "permit": 1, "problem": 1, "program": 1, "propos": 1, "reduc": 1, "select": 1, "set": 1, "size": 1, "solut": 3, "step": 1, "stiff": 1, "techniqu": 2, "time": 1, "gear": 1}}, "2208": {"id": "2208", "title": "his expression gives a measure of how effectively the first-level store is being used.  By means  of examples, storage utilization is then studied as a function of the hashing algorithm, the number of  storage areas into which the first-level store is divided and the total size of the first-level store.", "abstract": "The utilization of storage is studied in a two-level memory hierarchy.  The first storage level,  which is the fast store, is divided into a number of storage areas.  When an entry is to be filed in  the hierarchy, a hashing algorithm will attempt to place the entry into one of these areas.  If this  particular area is full, then the entry will be placed into the slower second-level store, even though  other areas in the first-level store may have space available.  Given the N entries have been filed in  the entire hierarchy, an expression is derived for the expected number of entries filed in the first-level  store", "authors": "Williams, J. G.", "words_pool": ["algorithm", "area", "area", "attempt", "deriv", "divid", "effect", "entir", "entri", "entri", "exampl", "expect", "express", "fast", "file", "full", "function", "hash", "hierarchi", "level", "mean", "measur", "memori", "number", "place", "size", "slower", "space", "storag", "store", "studi", "total", "util", "william"], "word_count": {"algorithm": 1, "area": 4, "attempt": 1, "deriv": 1, "divid": 1, "effect": 1, "entir": 1, "entri": 5, "exampl": 1, "expect": 1, "express": 1, "fast": 1, "file": 3, "full": 1, "function": 1, "hash": 1, "hierarchi": 3, "level": 5, "mean": 1, "measur": 1, "memori": 1, "number": 2, "place": 1, "size": 1, "slower": 1, "space": 1, "storag": 3, "store": 4, "studi": 1, "total": 1, "util": 1, "william": 1}}, "2209": {"id": "2209", "title": "A Scheduling Algorithm for a Computer Assisted Registration System", "abstract": "This paper presents the scheduling algorithm used in the Computer Assisted Registration System  at the University of Tennessee.  Notation is defined and the logic of the algorithm necessary to implement  educational policy is described.  Results from the first term's implementation are presented.", "authors": "Winters, W. K.", "words_pool": ["algorithm", "assist", "comput", "defin", "educ", "implement", "implement", "logic", "notat", "paper", "polici", "present", "present", "registr", "result", "schedul", "system", "tennesse", "term", "univers", "winter"], "word_count": {"algorithm": 2, "assist": 1, "comput": 1, "defin": 1, "educ": 1, "implement": 2, "logic": 1, "notat": 1, "paper": 1, "polici": 1, "present": 2, "registr": 1, "result": 1, "schedul": 1, "system": 1, "tennesse": 1, "term": 1, "univers": 1, "winter": 1}}, "2210": {"id": "2210", "title": "Toward Automatic Program Synthesis", "abstract": "An elementary outline of the theorem-proving approach to automatic program synthesis is given,  without dwelling on technical details.  The method is illustrated by the automatic construction of both  recursive and iterative programs operating on natural numbers,lists, and trees,  In order to construct  a program satisfying certain specifications a theorem induced by those specifications is proved, and  the desired program is extracted from the proof.  The same technique is applied to transform recursively  defined functions into iterative programs, frequently with a major gain inefficiency.  It is emphasized  that in order to construct a program with loops or with recursion, the principle of mathematical induction  must be applied. The relation between the version of the induction rule used and the form of the program  constructed is explored in some detail.", "authors": "Manna, Z. Waldinger, R. J.", "words_pool": ["appli", "approach", "automat", "construct", "construct", "construct", "defin", "desir", "detail", "detail", "dwell", "elementari", "emphas", "explor", "extract", "form", "frequent", "function", "gain", "illustr", "induc", "induct", "ineffici", "iter", "list", "loop", "major", "mathemat", "method", "natur", "number", "oper", "order", "outlin", "principl", "program", "program", "proof", "prove", "prove", "recurs", "recurs", "recurs", "relat", "rule", "satisfi", "specif", "synthesi", "technic", "techniqu", "theorem", "transform", "tree", "version", "manna", "walding"], "word_count": {"appli": 2, "approach": 1, "automat": 2, "construct": 4, "defin": 1, "desir": 1, "detail": 2, "dwell": 1, "elementari": 1, "emphas": 1, "explor": 1, "extract": 1, "form": 1, "frequent": 1, "function": 1, "gain": 1, "illustr": 1, "induc": 1, "induct": 2, "ineffici": 1, "iter": 2, "list": 1, "loop": 1, "major": 1, "mathemat": 1, "method": 1, "natur": 1, "number": 1, "oper": 1, "order": 2, "outlin": 1, "principl": 1, "program": 7, "proof": 1, "prove": 2, "recurs": 3, "relat": 1, "rule": 1, "satisfi": 1, "specif": 2, "synthesi": 1, "technic": 1, "techniqu": 1, "theorem": 2, "transform": 1, "tree": 1, "version": 1, "manna": 1, "walding": 1}}, "2211": {"id": "2211", "title": "Scanned-Display Computer Graphics", "abstract": "A television-like scanned-display system has been successfully implemented on a Honeywell DDP-224  computer installation.  The scanned image is stored in the core memory of the computer, and software  scan conversion is used to convert the rectangular coordinates of a point to the appropriate word and  bit in an output display array in core storage.  Results thus far indicate that flicker-free displays  of large amounts of data are possible with reasonably fast graphical interaction.  A scanned image of  size 240 X 254 points is displayed at a 30 frame-per-second rate.", "authors": "Noll, A. M.", "words_pool": ["amount", "array", "bit", "comput", "convers", "convert", "coordin", "core", "data", "ddp", "display", "display", "display", "fast", "flicker", "frame", "free", "graphic", "graphic", "honeywel", "imag", "implement", "instal", "interact", "larg", "memori", "output", "point", "point", "rate", "reason", "rectangular", "result", "scan", "scan", "size", "softwar", "storag", "store", "success", "system", "televis", "word", "noll"], "word_count": {"amount": 1, "array": 1, "bit": 1, "comput": 2, "convers": 1, "convert": 1, "coordin": 1, "core": 2, "data": 1, "ddp": 1, "display": 4, "fast": 1, "flicker": 1, "frame": 1, "free": 1, "graphic": 1, "honeywel": 1, "imag": 2, "implement": 1, "instal": 1, "interact": 1, "larg": 1, "memori": 1, "output": 1, "point": 2, "rate": 1, "reason": 1, "rectangular": 1, "result": 1, "scan": 4, "size": 1, "softwar": 1, "storag": 1, "store": 1, "success": 1, "system": 1, "televis": 1, "word": 1, "noll": 1}}, "2212": {"id": "2212", "title": "F-DISTRIBUTION", "authors": "Tolman, H.", "words_pool": ["distribut", "tolman"], "word_count": {"distribut": 1, "tolman": 1}}, "2213": {"id": "2213", "title": "Roots of Matrix Pencils: The Generalized Eigenvalue Problem [F2] (Algorithm 405)", "authors": "Dell, A. M. Weil, R. L. Thompson, G. L.", "words_pool": ["algorithm", "eigenvalu", "f2", "gener", "matrix", "pencil", "problem", "root", "dell", "weil", "thompson"], "word_count": {"algorithm": 1, "eigenvalu": 1, "f2": 1, "gener": 1, "matrix": 1, "pencil": 1, "problem": 1, "root": 1, "dell": 1, "weil": 1, "thompson": 1}}, "2214": {"id": "2214", "title": "Complex Interval Arithmetic", "abstract": "Complex interval arithmetic is defined using real interval arithmetic.  Complex interval division  is defined so as to assure smallest possible resulting intervals.", "authors": "Rokne, J. Lancaster, P.", "words_pool": ["arithmet", "assur", "complex", "defin", "divis", "interv", "interv", "real", "result", "smallest", "rokn", "lancast"], "word_count": {"arithmet": 2, "assur": 1, "complex": 2, "defin": 2, "divis": 1, "interv": 4, "real": 1, "result": 1, "smallest": 1, "rokn": 1, "lancast": 1}}, "2215": {"id": "2215", "title": "Application of Game Tree Searching Techniques to Sequential Pattern Recognition", "abstract": "A sequential pattern recognition (SPR) procedure does not test all the features of a pattern  at once.  Instead, it selects a feature to be tested.  After receiving the result of that test, the procedure  either classifies the unknown pattern or selects another feature to be tested, etc.  Medical diagnosis  is an example of SPR.  In this paper the authors suggest that SPR be viewed as a one-person game played  against nature (chance).  Virtually all the powerful techniques developed for searching two-person, strictly  competitive game trees can easily be incorporated either directly or by analogy into SPR procedures.   In particular, one can incorporate the \"mini average backing-up procedure\" and the \"gamma procedure,\"  which are the analogues of the \"minimax backing-up procedure\" and the \"alpha-beta procedure,\" respectively.   Some computer simulated experiments in character recognition are presented.  The results indicate that  the approach is promising.", "authors": "Slagle, J. R. Lee, R. C. T.", "words_pool": ["alpha", "analogu", "analog", "applic", "approach", "author", "averag", "back", "beta", "chanc", "charact", "classifi", "competit", "comput", "develop", "diagnosi", "directli", "easili", "experi", "featur", "featur", "game", "gamma", "incorpor", "incorpor", "medic", "mini", "minimax", "natur", "paper", "pattern", "person", "play", "power", "present", "procedur", "procedur", "promis", "receiv", "recognit", "result", "result", "search", "select", "sequenti", "simul", "spr", "strictli", "suggest", "techniqu", "test", "test", "tree", "tree", "unknown", "view", "virtual", "slagl", "lee"], "word_count": {"alpha": 1, "analogu": 1, "analog": 1, "applic": 1, "approach": 1, "author": 1, "averag": 1, "back": 2, "beta": 1, "chanc": 1, "charact": 1, "classifi": 1, "competit": 1, "comput": 1, "develop": 1, "diagnosi": 1, "directli": 1, "easili": 1, "experi": 1, "featur": 3, "game": 2, "gamma": 1, "incorpor": 2, "medic": 1, "mini": 1, "minimax": 1, "natur": 1, "paper": 1, "pattern": 3, "person": 2, "play": 1, "power": 1, "present": 1, "procedur": 7, "promis": 1, "receiv": 1, "recognit": 2, "result": 2, "search": 1, "select": 2, "sequenti": 1, "simul": 1, "spr": 4, "strictli": 1, "suggest": 1, "techniqu": 1, "test": 4, "tree": 1, "unknown": 1, "view": 1, "virtual": 1, "slagl": 1, "lee": 1}}, "2216": {"id": "2216", "title": "On the Probability Distribution of the Values of Binary Trees", "abstract": "An integral equation is derived for the generating function for binary tree values, the values  reflecting sorting effort. The analysis does not assume uniformly distributed branching ratios, and  therefore is applicable to a family of sorting algorithms discussed by Hoare, Singleton, and van Emden.   The solution to the integral equation indicates that using more advanced algorithms in the family makes  only minor reductions in the expected sorting effort, but substantially reduces the variance in sorting  effort.  Statistical tests of the values of several thousand trees containing up to 10,000 points have  given first, second, and third moments of the value distribution function in satisfactory agreement with  the moments computed from the generating function.  The empirical tests, as well as the analytical results,  are in agreement with previously published results for the first moment in the cases of uniform and nonuniform  distribution of branching ratio, and for the second moment in the case of uniform distribution of branching  ratio.", "authors": "Hurwitz Jr., H.", "words_pool": ["advanc", "agreement", "algorithm", "analysi", "analyt", "applic", "assum", "binari", "branch", "case", "case", "comput", "deriv", "discuss", "distribut", "distribut", "effort", "emden", "empir", "equat", "expect", "famili", "function", "gener", "hoar", "integr", "make", "minor", "moment", "moment", "nonuniform", "point", "previous", "probabl", "publish", "ratio", "ratio", "reduc", "reduct", "reflect", "result", "satisfactori", "singleton", "solut", "sort", "statist", "substanti", "test", "thousand", "tree", "tree", "uniform", "uniformli", "valu", "van", "varianc", "hurwitz", "jr"], "word_count": {"advanc": 1, "agreement": 2, "algorithm": 2, "analysi": 1, "analyt": 1, "applic": 1, "assum": 1, "binari": 1, "branch": 3, "case": 2, "comput": 1, "deriv": 1, "discuss": 1, "distribut": 4, "effort": 3, "emden": 1, "empir": 1, "equat": 2, "expect": 1, "famili": 2, "function": 3, "gener": 2, "hoar": 1, "integr": 2, "make": 1, "minor": 1, "moment": 4, "nonuniform": 1, "point": 1, "previous": 1, "probabl": 1, "publish": 1, "ratio": 3, "reduc": 1, "reduct": 1, "reflect": 1, "result": 2, "satisfactori": 1, "singleton": 1, "solut": 1, "sort": 4, "statist": 1, "substanti": 1, "test": 2, "thousand": 1, "tree": 2, "uniform": 2, "uniformli": 1, "valu": 3, "van": 1, "varianc": 1, "hurwitz": 1, "jr": 1}}, "2217": {"id": "2217", "title": "Experiments in Automatic Learning for a Multipurpose Heuristic Program", "abstract": "An automatic learning capability has been developed and implemented for use with the MULTIPLE  (MULTIpurpose Program that LEarns) heuristic tree-searching program, which is presently being applied  to resolution theorem-proving in predicate calculus. MULTIPLE's proving program (PP) uses two evaluation  functions to guide its search for a proof of whether or not a particular goal is achievable.  Thirteen  general features of predicate calculus clauses were created for use in the automatic learning of better  evaluation functions for PP.  A multiple regression program was used to produce optimal coefficients  for linear polynomial functions in terms of the features.  Also, automatic data-handling routines were  written for passing data between the learning program and the proving program, and for analyzing and  summarizing results.  Data was generally collected for learning (regression analysis) from the experience  of PP.  A number of experiments were performed to test the effectiveness and generality of the learning  program. Results showed that the learning produced dramatic improvements in the solutions to problems  which were in the same domain as those used for collection learning data.  Learning was also shown to  generalize successfully to domains other than those used for data collection.  Another experiment demonstrated  that the learning program could simultaneously improve performance on problems in a specific domain and  on problems in a variety of domains.  Some variations of the learning program were also tested.", "authors": "Slagle, J. R. Farrell, C. D.", "words_pool": ["achiev", "analysi", "analyz", "appli", "automat", "calculu", "capabl", "claus", "coeffici", "collect", "collect", "creat", "data", "demonstr", "develop", "domain", "domain", "dramat", "effect", "evalu", "experi", "experi", "experi", "featur", "function", "gener", "gener", "gener", "gener", "goal", "guid", "handl", "heurist", "implement", "improv", "improv", "learn", "learn", "linear", "multipl", "multipurpos", "number", "optim", "pass", "perform", "perform", "polynomi", "pp", "predic", "present", "problem", "produc", "produc", "program", "proof", "prove", "regress", "resolut", "result", "routin", "search", "search", "show", "shown", "simultan", "solut", "specif", "success", "summar", "term", "test", "test", "theorem", "thirteen", "tree", "variat", "varieti", "written", "slagl", "farrel"], "word_count": {"achiev": 1, "analysi": 1, "analyz": 1, "appli": 1, "automat": 3, "calculu": 2, "capabl": 1, "claus": 1, "coeffici": 1, "collect": 3, "creat": 1, "data": 5, "demonstr": 1, "develop": 1, "domain": 4, "dramat": 1, "effect": 1, "evalu": 2, "experi": 3, "featur": 2, "function": 3, "gener": 4, "goal": 1, "guid": 1, "handl": 1, "heurist": 1, "implement": 1, "improv": 2, "learn": 11, "linear": 1, "multipl": 3, "multipurpos": 1, "number": 1, "optim": 1, "pass": 1, "perform": 2, "polynomi": 1, "pp": 3, "predic": 2, "present": 1, "problem": 3, "produc": 2, "program": 9, "proof": 1, "prove": 3, "regress": 2, "resolut": 1, "result": 2, "routin": 1, "search": 2, "show": 1, "shown": 1, "simultan": 1, "solut": 1, "specif": 1, "success": 1, "summar": 1, "term": 1, "test": 2, "theorem": 1, "thirteen": 1, "tree": 1, "variat": 1, "varieti": 1, "written": 1, "slagl": 1, "farrel": 1}}, "2218": {"id": "2218", "title": "An Analysis of Some Time-Sharing Techniques", "abstract": "The effectiveness of certain time-sharing techniques such as program, relocation, disk rotational  delay minimization, and swap volume minimization is investigated.  Summary data is presented, and the  findings are discussed.  The vehicle for this investigation was a SIMULA based simulation model reflecting  an early framework for a planned Burroughs B6500 time-sharing system.  Inasmuch as the B6500 system is  based upon the use of variable sized segments and a dynamic overlay procedure, data is also presented  which provides some indication of the effectiveness of this type of organization in a time-sharing environment.   The design characteristics and operational capabilities of the simulation model are also described.", "authors": "Nielsen, N. R.", "words_pool": ["analysi", "b6500", "base", "burrough", "capabl", "characterist", "data", "delay", "design", "discuss", "disk", "dynam", "earli", "effect", "environ", "find", "framework", "indic", "investig", "investig", "minim", "model", "oper", "organ", "overlay", "plan", "present", "procedur", "program", "reflect", "reloc", "rotat", "segment", "share", "simula", "simul", "size", "summari", "swap", "system", "techniqu", "time", "type", "variabl", "vehicl", "volum", "nielsen"], "word_count": {"analysi": 1, "b6500": 2, "base": 2, "burrough": 1, "capabl": 1, "characterist": 1, "data": 2, "delay": 1, "design": 1, "discuss": 1, "disk": 1, "dynam": 1, "earli": 1, "effect": 2, "environ": 1, "find": 1, "framework": 1, "indic": 1, "investig": 2, "minim": 2, "model": 2, "oper": 1, "organ": 1, "overlay": 1, "plan": 1, "present": 2, "procedur": 1, "program": 1, "reflect": 1, "reloc": 1, "rotat": 1, "segment": 1, "share": 3, "simula": 1, "simul": 2, "size": 1, "summari": 1, "swap": 1, "system": 2, "techniqu": 1, "time": 3, "type": 1, "variabl": 1, "vehicl": 1, "volum": 1, "nielsen": 1}}, "2219": {"id": "2219", "title": "A Policy-Driven Scheduler for a Time-Sharing System", "abstract": "The service received by a process from a time-sharing operating system can be characterized  by a resource count SUM{w[i]R[ij]} where R[ij] is the number of units of service received by process  i from resource i and w[i] is the cost per unit of the service.  Each class of users can be characterized  by a policy function which specifies the amount of service a user who belongs to this class should receive  as a function of time.  Priority changes dynamically as a function of the difference between the service  promised to the user by the policy function and the service he actually receives.  A scheduling and swapping  algorithm which keeps the resource count of each process above its policy function will provide the specified  level of service.  Overhead can be reduced by avoiding swaps of process which have received at least  his level of service.  The algorithm has been implemented in a general purpose operating system, and  it has provided significantly better service to interactive and to batch jobs than the previous scheduler.", "authors": "Bernstein, A. J. Sharp, J. C.", "words_pool": ["actual", "algorithm", "amount", "avoid", "batch", "belong", "character", "class", "cost", "count", "differ", "driven", "dynam", "function", "gener", "ij", "implement", "interact", "job", "keep", "level", "number", "oper", "overhead", "polici", "previou", "prioriti", "process", "promis", "provid", "provid", "purpos", "receiv", "receiv", "receiv", "reduc", "resourc", "schedul", "schedul", "servic", "share", "significantli", "specifi", "sum", "swap", "swap", "system", "time", "unit", "unit", "user", "user", "bernstein", "sharp"], "word_count": {"actual": 1, "algorithm": 2, "amount": 1, "avoid": 1, "batch": 1, "belong": 1, "character": 2, "class": 2, "cost": 1, "count": 2, "differ": 1, "driven": 1, "dynam": 1, "function": 5, "gener": 1, "ij": 2, "implement": 1, "interact": 1, "job": 1, "keep": 1, "level": 2, "number": 1, "oper": 2, "overhead": 1, "polici": 3, "previou": 1, "prioriti": 1, "process": 4, "promis": 1, "provid": 2, "purpos": 1, "receiv": 5, "reduc": 1, "resourc": 3, "schedul": 2, "servic": 9, "share": 1, "significantli": 1, "specifi": 1, "sum": 1, "swap": 2, "system": 2, "time": 2, "unit": 2, "user": 3, "bernstein": 1, "sharp": 1}}, "2220": {"id": "2220", "title": "Conversion of Limited-Entry Decision Tables to Computer Programs-A Proposed Modification to Pollack's  Algorithm", "abstract": "Pollack has proposed an algorithm for converting decision tables into flowcharts which minimize  subsequent execution time when compiled into a computer program.  Two modifications of this algorithm  are proposed.  The first relies on Shannon's noiseless coding theorem and the communications concept  of entropy but does not completely test the ELSE Rule.  The second modification completely tests the  ELSE Rule but results in more executions than the first modification.  Both modifications result in modification  guarantees a globally optimal solution.", "authors": "Shwayder, K.", "words_pool": ["algorithm", "code", "commun", "compil", "complet", "comput", "concept", "convers", "convert", "decis", "entropi", "entri", "execut", "execut", "flowchart", "global", "guarante", "limit", "minim", "modif", "modif", "noiseless", "optim", "pollack", "program", "program", "propos", "reli", "result", "result", "rule", "shannon", "solut", "subsequ", "tabl", "test", "test", "theorem", "time", "shwayder"], "word_count": {"algorithm": 2, "code": 1, "commun": 1, "compil": 1, "complet": 2, "comput": 1, "concept": 1, "convers": 1, "convert": 1, "decis": 1, "entropi": 1, "entri": 1, "execut": 2, "flowchart": 1, "global": 1, "guarante": 1, "limit": 1, "minim": 1, "modif": 5, "noiseless": 1, "optim": 1, "pollack": 1, "program": 1, "propos": 2, "reli": 1, "result": 2, "rule": 2, "shannon": 1, "solut": 1, "subsequ": 1, "tabl": 1, "test": 2, "theorem": 1, "time": 1, "shwayder": 1}}, "2221": {"id": "2221", "title": "Comment on the Conversion of Decision Tables to Computer Programs", "authors": "Pollack, S. L.", "words_pool": ["comment", "comput", "convers", "decis", "program", "tabl", "pollack"], "word_count": {"comment": 1, "comput": 1, "convers": 1, "decis": 1, "program": 1, "tabl": 1, "pollack": 1}}, "2222": {"id": "2222", "title": "Comment on London's Certification of Algorithm 245", "authors": "Redish, K. A.", "words_pool": ["algorithm", "certif", "comment", "london", "redish"], "word_count": {"algorithm": 1, "certif": 1, "comment": 1, "london": 1, "redish": 1}}, "2223": {"id": "2223", "title": "Minit Algorithm For Linear Programming (Algorithm 222 [H])", "authors": "Kolm, A. Dahlstrand, T.", "words_pool": ["algorithm", "linear", "minit", "program", "kolm", "dahlstrand"], "word_count": {"algorithm": 2, "linear": 1, "minit": 1, "program": 1, "kolm": 1, "dahlstrand": 1}}, "2224": {"id": "2224", "title": "Complex Gamma Function [S14] (Algorithm 404)", "authors": "Lucas Jr., C. W. Terrill, C. W.", "words_pool": ["algorithm", "complex", "function", "gamma", "s14", "luca", "jr", "terril"], "word_count": {"algorithm": 1, "complex": 1, "function": 1, "gamma": 1, "s14": 1, "luca": 1, "jr": 1, "terril": 1}}, "2225": {"id": "2225", "title": "Circular Integer Partitioning [A1] (Algorithm 403)", "authors": "Coleman, M. W. Taylor, M. S.", "words_pool": ["a1", "algorithm", "circular", "integ", "partit", "coleman", "taylor"], "word_count": {"a1": 1, "algorithm": 1, "circular": 1, "integ": 1, "partit": 1, "coleman": 1, "taylor": 1}}, "2226": {"id": "2226", "title": "Further Evidence for the Analysis of Algorithms for the Zero-One Programming Problem", "abstract": "The purpose of this note is to report computational experience additional to that recently  summarized by Gue et al, with two algorithms for the zero-one linear programming problem.  An error in  Gue's paper is corrected.  The utility of one of the algorithms as a suboptimizer is indicated.", "authors": "Proll, L. G.", "words_pool": ["addit", "al", "algorithm", "analysi", "comput", "correct", "error", "evid", "experi", "gue", "linear", "note", "paper", "problem", "program", "purpos", "recent", "report", "suboptim", "summar", "util", "proll"], "word_count": {"addit": 1, "al": 1, "algorithm": 2, "analysi": 1, "comput": 1, "correct": 1, "error": 1, "evid": 1, "experi": 1, "gue": 2, "linear": 1, "note": 1, "paper": 1, "problem": 1, "program": 1, "purpos": 1, "recent": 1, "report": 1, "suboptim": 1, "summar": 1, "util": 1, "proll": 1}}, "2227": {"id": "2227", "title": "Proof of a Program: FIND", "abstract": "A proof is given of the correctness of the algorithm \"Find.\"  First, a informal description  is given of the purpose of the program and the method used.  A systematic technique is described for  constructing the program proof during the process of coding it, in such a way as to prevent the intrusion  of logical errors.  The proof of termination is treated as a separate exercise.  Finally, some conclusions  relating to general programming methodology are drawn.", "authors": "Hoare, C. A. R.", "words_pool": ["algorithm", "code", "conclus", "construct", "correct", "descript", "drawn", "error", "exercis", "final", "find", "gener", "inform", "intrus", "logic", "method", "methodolog", "prevent", "process", "program", "program", "proof", "purpos", "relat", "separ", "systemat", "techniqu", "termin", "treat", "hoar"], "word_count": {"algorithm": 1, "code": 1, "conclus": 1, "construct": 1, "correct": 1, "descript": 1, "drawn": 1, "error": 1, "exercis": 1, "final": 1, "find": 1, "gener": 1, "inform": 1, "intrus": 1, "logic": 1, "method": 1, "methodolog": 1, "prevent": 1, "process": 1, "program": 3, "proof": 3, "purpos": 1, "relat": 1, "separ": 1, "systemat": 1, "techniqu": 1, "termin": 1, "treat": 1, "hoar": 1}}, "2228": {"id": "2228", "title": "Comments on Prevention of System Deadlocks", "abstract": "Habermann's method of deadlock prevention is discussed, where deadlock is defined as a system  state from which resource allocations to certain processes are not possible.  It is shown that the scheduler  may introduce \"artificial\" deadlocks which Habermann's method does not prevent.  Permanent blocking is  the situation where certain processes never receive their resource requests.  It is shown that deadlock  prevention does not necessarily eliminate permanent blocking.  A method of preventing permanent blocking  is given.", "authors": "Holt, R. C.", "words_pool": ["alloc", "artifici", "block", "comment", "deadlock", "deadlock", "defin", "discuss", "elimin", "habermann", "introduc", "method", "necessarili", "perman", "prevent", "prevent", "prevent", "process", "receiv", "request", "resourc", "schedul", "shown", "situat", "state", "system", "holt"], "word_count": {"alloc": 1, "artifici": 1, "block": 3, "comment": 1, "deadlock": 4, "defin": 1, "discuss": 1, "elimin": 1, "habermann": 2, "introduc": 1, "method": 3, "necessarili": 1, "perman": 3, "prevent": 4, "process": 2, "receiv": 1, "request": 1, "resourc": 2, "schedul": 1, "shown": 2, "situat": 1, "state": 1, "system": 1, "holt": 1}}, "2229": {"id": "2229", "title": "Construction of Rational and Negative Powers of a Formal Series", "abstract": "Some methods are described for the generation of fractional and negative powers of any formal  series, such as Poisson series or Chebyshev series.  It is shown that, with the use of the three elementary  operations of addition, subtraction, and multiplication, all rational (positive and negative) powers  of a series can be constructed.  There are basically two approaches: the binomial theorem and the iteration  methods.  Both methods are described here, and the relationship between them is pointed out.  Some well-known  classical formulas are obtained as particular cases, and it is shown how the convergence properties of  these formulas can be improved with very little additional computations.  Finally, at the end of the  article, some numerical experiments are described with Chebyshev series and with Fourier series.", "authors": "Brucke, R. A.", "words_pool": ["addit", "addit", "approach", "articl", "basic", "binomi", "case", "chebyshev", "classic", "comput", "construct", "construct", "converg", "elementari", "end", "experi", "final", "formal", "formula", "fourier", "fraction", "gener", "improv", "iter", "known", "method", "multipl", "neg", "numer", "obtain", "oper", "point", "poisson", "posit", "power", "properti", "ration", "relationship", "seri", "shown", "subtract", "theorem", "bruck"], "word_count": {"addit": 2, "approach": 1, "articl": 1, "basic": 1, "binomi": 1, "case": 1, "chebyshev": 2, "classic": 1, "comput": 1, "construct": 1, "converg": 1, "elementari": 1, "end": 1, "experi": 1, "final": 1, "formal": 1, "formula": 2, "fourier": 1, "fraction": 1, "gener": 1, "improv": 1, "iter": 1, "known": 1, "method": 3, "multipl": 1, "neg": 2, "numer": 1, "obtain": 1, "oper": 1, "point": 1, "poisson": 1, "posit": 1, "power": 2, "properti": 1, "ration": 1, "relationship": 1, "seri": 6, "shown": 2, "subtract": 1, "theorem": 1, "bruck": 1}}, "2230": {"id": "2230", "title": "A Language for Treating Geometric Patterns in a Two-dimensional space", "abstract": "In this paper CADEP, a problem-oriented language for positioning geometric patterns in a two-dimensional  space, is presented.  Although the language has been specifically designed for the automatic generation  of integrated circuit masks, it turns out to be well suited also for such other placement problems as  architecture design, urban planning, logical and block diagram representation.  The design criteria,  the structure, and the specific features of CADEP are illustrated.", "authors": "Bracchi, G. Ferrari, D.", "words_pool": ["architectur", "automat", "block", "cadep", "circuit", "criteria", "design", "design", "diagram", "dimension", "featur", "gener", "geometr", "illustr", "integr", "languag", "logic", "mask", "orient", "paper", "pattern", "placement", "plan", "posit", "present", "problem", "problem", "represent", "space", "specif", "specif", "structur", "suit", "treat", "turn", "urban", "bracchi", "ferrari"], "word_count": {"architectur": 1, "automat": 1, "block": 1, "cadep": 2, "circuit": 1, "criteria": 1, "design": 3, "diagram": 1, "dimension": 1, "featur": 1, "gener": 1, "geometr": 1, "illustr": 1, "integr": 1, "languag": 2, "logic": 1, "mask": 1, "orient": 1, "paper": 1, "pattern": 1, "placement": 1, "plan": 1, "posit": 1, "present": 1, "problem": 2, "represent": 1, "space": 1, "specif": 2, "structur": 1, "suit": 1, "treat": 1, "turn": 1, "urban": 1, "bracchi": 1, "ferrari": 1}}, "2231": {"id": "2231", "title": "The Reconstruction of Binary Patterns from Their Projections", "abstract": "Given the horizontal and vertical projections of a finite binary pattern f, can we construct  the original pattern f?  In this paper we give a characterization of patterns that are reconstructable  from their projection.  Three algorithms are developed to reconstruct both unambiguous and ambiguous  patterns.  It is shown that an unambiguous pattern can be perfectly reconstructed in time m X n and that  a pattern similar to an ambiguous pattern can also be constructed in time m X n, where m, n are the dimensions  of the pattern frame.", "authors": "Chang, S.", "words_pool": ["algorithm", "ambigu", "binari", "character", "construct", "construct", "develop", "dimens", "finit", "frame", "give", "horizont", "origin", "paper", "pattern", "pattern", "perfectli", "project", "project", "reconstruct", "reconstruct", "reconstruct", "reconstruct", "shown", "similar", "time", "unambigu", "vertic", "chang"], "word_count": {"algorithm": 1, "ambigu": 2, "binari": 1, "character": 1, "construct": 2, "develop": 1, "dimens": 1, "finit": 1, "frame": 1, "give": 1, "horizont": 1, "origin": 1, "paper": 1, "pattern": 8, "perfectli": 1, "project": 2, "reconstruct": 3, "shown": 1, "similar": 1, "time": 2, "unambigu": 2, "vertic": 1, "chang": 1}}, "2232": {"id": "2232", "title": "Pattern Width at a Given Angle", "abstract": "That the pattern feature \"width as a function of angle\" possesses several possible interpretations  is demonstrated in this paper, which is a review of the width concept in pattern recognition and the  geometrical concept itself.  The object of the work is to clarify how the word description can be made  precise so that computer algorithms for feature extraction may be obtained; the focus is on the theoretical  subject matter.  The results consist of a set-theoretic definition of width-at-angle, a theorem relating  it to the pattern boundary radius vector, and descriptions of alternate widths.  All widths are calculated  for an illustrative example; graphical and tabular comparisons are given.  Substantial variation in width-at-angle  magnitude is found.  The principal conclusion is that the set-theoretic width-at-angle is a useful pattern  feature when it can be easily computed.  Further investigation of the information contained in only part  of a width function is recommended for cases where computation of width-at-angle is difficult.", "authors": "Klinger, A.", "words_pool": ["algorithm", "altern", "angl", "boundari", "calcul", "case", "clarifi", "comparison", "comput", "comput", "comput", "concept", "conclus", "consist", "contain", "definit", "demonstr", "descript", "descript", "difficult", "easili", "extract", "featur", "focu", "found", "function", "geometr", "graphic", "illustr", "inform", "interpret", "investig", "made", "magnitud", "matter", "object", "obtain", "paper", "part", "pattern", "possess", "precis", "princip", "radiu", "recognit", "recommend", "relat", "result", "review", "set", "subject", "substanti", "tabular", "theorem", "theoret", "theoret", "variat", "vector", "width", "width", "word", "work", "klinger"], "word_count": {"algorithm": 1, "altern": 1, "angl": 5, "boundari": 1, "calcul": 1, "case": 1, "clarifi": 1, "comparison": 1, "comput": 3, "concept": 2, "conclus": 1, "consist": 1, "contain": 1, "definit": 1, "demonstr": 1, "descript": 2, "difficult": 1, "easili": 1, "extract": 1, "featur": 3, "focu": 1, "found": 1, "function": 2, "geometr": 1, "graphic": 1, "illustr": 1, "inform": 1, "interpret": 1, "investig": 1, "made": 1, "magnitud": 1, "matter": 1, "object": 1, "obtain": 1, "paper": 1, "part": 1, "pattern": 4, "possess": 1, "precis": 1, "princip": 1, "radiu": 1, "recognit": 1, "recommend": 1, "relat": 1, "result": 1, "review": 1, "set": 2, "subject": 1, "substanti": 1, "tabular": 1, "theorem": 1, "theoret": 3, "variat": 1, "vector": 1, "width": 9, "word": 1, "work": 1, "klinger": 1}}, "2233": {"id": "2233", "title": "Signature Simulation and Certain Cryptographic Codes", "abstract": "Three cyphers allegedly authored by Thomas Jefferson Beale in 1822 have been the subject of  intensive study for over 100 years.  Generations of cryptanalysts have expended untold man-years, thus  far without success, attempting tode code them; vast armies of fortune hunters and treasure seekers have  devoted Herculean labors to digging up the rolling hills of Virginia trying to locate the promised bonanza.   The history of pertinent activities would fill volumes, yet serious students of cryptography have always  had nagging doubts about the cyphers' authenticity.  It has been alleged that the \"known solution\" to  Cypher Number Two: 115, 73, 24, 818, 37, 52, 49,...(\"I have deposited in the County of Bedford about  four miles from Buford's in an excavation or vault...\") with the aid of an unsanitized version of the  Declaration of Independence was merely a superb, imaginative, and grandiose hoax perpetrated ages ago  for whatever reasons.  Modern computer technology could obviously perform signature analyses the process  of encoding itself so as to yield new clues and deeper insights into their construction.  For the benefit  of the uninitiated, the encoding method used in the second cypher employs a specified document whose  words are simply numbered consecutively, and first letters of these words are sought out at random to  match the letters of these words are sought out at random to match the letters of the clear text or message.   The sequence of numbers corresponding to these matches is then written down as the final code.  While  primitive, the process has the advantage of relative security until the source document becomes known;  at that moment the cypher can be decoded even by second graders.  The work now completed with the help  of our UNIVAC 1108 includes numerous analytical studies of the Beale cyphers and various types of simulations.   For example, we have turned the entire process of simulated encoding by various schemes over to the  machine and analyzed the signatures of these synthetic codes; we have also encoded various messages by  hand, using different texts and a variety of methods to obtain their signatures. These simulations provide  convincing evidence that the signatures are both process and data dependent; they indicate also very  strongly that Mr. Beale's cyphers are for real and that it is merely a matter of time before someone  finds the correct source document and locates the right vault in the common-wealth of Virginia.", "authors": "Hammer, C.", "words_pool": ["activ", "advantag", "age", "ago", "aid", "alleg", "allegedli", "analys", "analyt", "analyz", "armi", "attempt", "authent", "author", "beal", "bedford", "benefit", "bonanza", "buford", "clear", "clue", "code", "code", "common", "complet", "comput", "consecut", "construct", "convinc", "correct", "counti", "cryptanalyst", "cryptograph", "cryptographi", "cypher", "cypher", "data", "declar", "decod", "deeper", "depend", "deposit", "devot", "dig", "document", "doubt", "employ", "encod", "encod", "entir", "evid", "excav", "expend", "fill", "final", "find", "fortun", "gener", "grader", "grandios", "hand", "help", "herculean", "hill", "histori", "hoax", "hunter", "imagin", "includ", "independ", "insight", "intens", "jefferson", "known", "labor", "letter", "locat", "locat", "machin", "man", "match", "match", "matter", "mere", "messag", "messag", "method", "method", "mile", "modern", "moment", "mr", "nag", "number", "number", "number", "numer", "obtain", "obvious", "perform", "perpetr", "pertin", "primit", "process", "promis", "provid", "random", "real", "reason", "rel", "roll", "scheme", "secur", "seeker", "sequenc", "signatur", "signatur", "simpli", "simul", "simul", "simul", "solut", "sought", "sourc", "strongli", "student", "studi", "studi", "subject", "success", "superb", "synthet", "technolog", "text", "text", "thoma", "time", "tode", "treasur", "tri", "turn", "type", "uniniti", "univac", "unsanit", "untold", "varieti", "vast", "vault", "version", "virginia", "volum", "wealth", "word", "work", "written", "year", "yield", "hammer"], "word_count": {"activ": 1, "advantag": 1, "age": 1, "ago": 1, "aid": 1, "alleg": 1, "allegedli": 1, "analys": 1, "analyt": 1, "analyz": 1, "armi": 1, "attempt": 1, "authent": 1, "author": 1, "beal": 3, "bedford": 1, "benefit": 1, "bonanza": 1, "buford": 1, "clear": 1, "clue": 1, "code": 3, "common": 1, "complet": 1, "comput": 1, "consecut": 1, "construct": 1, "convinc": 1, "correct": 1, "counti": 1, "cryptanalyst": 1, "cryptograph": 1, "cryptographi": 1, "cypher": 7, "data": 1, "declar": 1, "decod": 1, "deeper": 1, "depend": 1, "deposit": 1, "devot": 1, "dig": 1, "document": 3, "doubt": 1, "employ": 1, "encod": 4, "entir": 1, "evid": 1, "excav": 1, "expend": 1, "fill": 1, "final": 1, "find": 1, "fortun": 1, "gener": 1, "grader": 1, "grandios": 1, "hand": 1, "help": 1, "herculean": 1, "hill": 1, "histori": 1, "hoax": 1, "hunter": 1, "imagin": 1, "includ": 1, "independ": 1, "insight": 1, "intens": 1, "jefferson": 1, "known": 2, "labor": 1, "letter": 3, "locat": 2, "machin": 1, "man": 1, "match": 3, "matter": 1, "mere": 2, "messag": 2, "method": 2, "mile": 1, "modern": 1, "moment": 1, "mr": 1, "nag": 1, "number": 3, "numer": 1, "obtain": 1, "obvious": 1, "perform": 1, "perpetr": 1, "pertin": 1, "primit": 1, "process": 4, "promis": 1, "provid": 1, "random": 2, "real": 1, "reason": 1, "rel": 1, "roll": 1, "scheme": 1, "secur": 1, "seeker": 1, "sequenc": 1, "signatur": 4, "simpli": 1, "simul": 3, "solut": 1, "sought": 2, "sourc": 2, "strongli": 1, "student": 1, "studi": 2, "subject": 1, "success": 1, "superb": 1, "synthet": 1, "technolog": 1, "text": 2, "thoma": 1, "time": 1, "tode": 1, "treasur": 1, "tri": 1, "turn": 1, "type": 1, "uniniti": 1, "univac": 1, "unsanit": 1, "untold": 1, "varieti": 1, "vast": 1, "vault": 2, "version": 1, "virginia": 2, "volum": 1, "wealth": 1, "word": 3, "work": 1, "written": 1, "year": 2, "yield": 1, "hammer": 1}}, "2234": {"id": "2234", "title": "Roots of Matrix Pencils (Algorithm R405)", "authors": "Heiberger, R. M.", "words_pool": ["algorithm", "matrix", "pencil", "r405", "root", "heiberg"], "word_count": {"algorithm": 1, "matrix": 1, "pencil": 1, "r405": 1, "root": 1, "heiberg": 1}}, "2235": {"id": "2235", "title": "Decision Table Translation (Algorithm R394)", "authors": "Marshall, D. R. T.", "words_pool": ["algorithm", "decis", "r394", "tabl", "translat", "marshal"], "word_count": {"algorithm": 1, "decis": 1, "r394": 1, "tabl": 1, "translat": 1, "marshal": 1}}, "2236": {"id": "2236", "title": "Remarks on Characteristic Values and Associated Solutions of Mathieus Differential Equation,  Exponential Integral, and Systems of Hyperbolic P.D.E. (Algorithms R352, R385, R392)", "authors": "Frisch, M. J.", "words_pool": ["algorithm", "characterist", "differenti", "equat", "exponenti", "hyperbol", "integr", "mathieu", "r352", "r385", "r392", "remark", "solut", "system", "valu", "frisch"], "word_count": {"algorithm": 1, "characterist": 1, "differenti": 1, "equat": 1, "exponenti": 1, "hyperbol": 1, "integr": 1, "mathieu": 1, "r352": 1, "r385": 1, "r392": 1, "remark": 1, "solut": 1, "system": 1, "valu": 1, "frisch": 1}}, "2237": {"id": "2237", "title": "BANDSOLVE (Algorithm R195)", "authors": "Schuegraf, E.", "words_pool": ["algorithm", "bandsolv", "r195", "schuegraf"], "word_count": {"algorithm": 1, "bandsolv": 1, "r195": 1, "schuegraf": 1}}, "2238": {"id": "2238", "title": "Least Squares Surface Fit (Algorithm R176)", "authors": "Schuegraf, E.", "words_pool": ["algorithm", "fit", "r176", "squar", "surfac", "schuegraf"], "word_count": {"algorithm": 1, "fit": 1, "r176": 1, "squar": 1, "surfac": 1, "schuegraf": 1}}, "2239": {"id": "2239", "title": "Squank (Algorithm C379)", "authors": "Hallet, P. Mund, E.", "words_pool": ["algorithm", "c379", "squank", "hallet", "mund"], "word_count": {"algorithm": 1, "c379": 1, "squank": 1, "hallet": 1, "mund": 1}}, "2240": {"id": "2240", "title": "Pseudo-Random Numbers [G5] (Algorithm C266)", "authors": "Sullins, W. L.", "words_pool": ["algorithm", "c266", "g5", "number", "pseudo", "random", "sullin"], "word_count": {"algorithm": 1, "c266": 1, "g5": 1, "number": 1, "pseudo": 1, "random": 1, "sullin": 1}}, "2241": {"id": "2241", "title": "Product Type Three-point Gauss-Legendre-Simpson's Integration [D1] (Algorithm A439)", "authors": "Boland, W. R.", "words_pool": ["a439", "algorithm", "d1", "gauss", "integr", "legendr", "point", "product", "simpson", "type", "boland"], "word_count": {"a439": 1, "algorithm": 1, "d1": 1, "gauss": 1, "integr": 1, "legendr": 1, "point": 1, "product": 1, "simpson": 1, "type": 1, "boland": 1}}, "2242": {"id": "2242", "title": "Product Type Two-Point Gauss-Legendre-Simpson's Integration [D1] (Algorithm A438)", "authors": "Boland, W. R.", "words_pool": ["a438", "algorithm", "d1", "gauss", "integr", "legendr", "point", "product", "simpson", "type", "boland"], "word_count": {"a438": 1, "algorithm": 1, "d1": 1, "gauss": 1, "integr": 1, "legendr": 1, "point": 1, "product": 1, "simpson": 1, "type": 1, "boland": 1}}, "2243": {"id": "2243", "title": "Product Type Simpson's Integration [D1] (Algorithm A437)", "authors": "Boland, W. R.", "words_pool": ["a437", "algorithm", "d1", "integr", "product", "simpson", "type", "boland"], "word_count": {"a437": 1, "algorithm": 1, "d1": 1, "integr": 1, "product": 1, "simpson": 1, "type": 1, "boland": 1}}, "2244": {"id": "2244", "title": "Product Type Trapezoidal Integration (Algorithm A436)", "authors": "Boland, W. R.", "words_pool": ["a436", "algorithm", "integr", "product", "trapezoid", "type", "boland"], "word_count": {"a436": 1, "algorithm": 1, "integr": 1, "product": 1, "trapezoid": 1, "type": 1, "boland": 1}}, "2245": {"id": "2245", "title": "Trace-Driven Modeling and Analysis of CPU Scheduling in Multiprogramming System", "abstract": "Microscopic level job stream data obtained in a production environment by an event-driven software  probe is used to drive a model of a multiprogramming computer system.  The CPU scheduling algorithm of  the model is systematically varied.  This technique, called trace-driven modeling, provides an accurate  replica of a production environment for the testing of variations in the system.  At the same time alterations  in scheduling methods can be easily carried out in a controlled way with cause and effects relationships  being isolated.  The scheduling methods tested included the best possible and worst possible methods,  the traditional methods of multiprogramming theory, round-robin, first-come-first-served, etc., and dynamic  predictors.  The relative and absolute performances of these scheduling methods are given.  It is concluded  that a successful CPU scheduling method must be preemptive and must prevent a given job from holding  the CPU for too long a period.", "authors": "Sherman, S. Baskett III, F. Browne, J. C.", "words_pool": ["absolut", "accur", "algorithm", "alter", "analysi", "call", "carri", "come", "comput", "conclud", "control", "cpu", "data", "drive", "driven", "dynam", "easili", "effect", "environ", "event", "hold", "includ", "isol", "job", "level", "long", "method", "method", "microscop", "model", "model", "multiprogram", "obtain", "perform", "period", "predictor", "preemptiv", "prevent", "probe", "product", "relationship", "rel", "replica", "robin", "round", "schedul", "serv", "softwar", "stream", "success", "system", "systemat", "techniqu", "test", "test", "theori", "time", "trace", "tradit", "variat", "vari", "worst", "sherman", "baskett", "iii", "brown"], "word_count": {"absolut": 1, "accur": 1, "algorithm": 1, "alter": 1, "analysi": 1, "call": 1, "carri": 1, "come": 1, "comput": 1, "conclud": 1, "control": 1, "cpu": 3, "data": 1, "drive": 1, "driven": 2, "dynam": 1, "easili": 1, "effect": 1, "environ": 2, "event": 1, "hold": 1, "includ": 1, "isol": 1, "job": 2, "level": 1, "long": 1, "method": 6, "microscop": 1, "model": 3, "multiprogram": 2, "obtain": 1, "perform": 1, "period": 1, "predictor": 1, "preemptiv": 1, "prevent": 1, "probe": 1, "product": 2, "relationship": 1, "rel": 1, "replica": 1, "robin": 1, "round": 1, "schedul": 5, "serv": 1, "softwar": 1, "stream": 1, "success": 1, "system": 2, "systemat": 1, "techniqu": 1, "test": 2, "theori": 1, "time": 1, "trace": 1, "tradit": 1, "variat": 1, "vari": 1, "worst": 1, "sherman": 1, "baskett": 1, "iii": 1, "brown": 1}}, "2246": {"id": "2246", "title": "Levels of Language for Portable Software", "abstract": "An increasing amount of software is being implemented in a portable form.  A popular way of  accomplishing this is to encode the software in a specially designed machine-independent language and  then to map this language, often using a macro processor, into the assembly language of each desired  object machine.  The design of the machine-independent language is the key factor in this operation.   This paper discusses the relative merits of pitching this language at a high level or a low level, and  presents some comparative results.", "authors": "Brown, P. J.", "words_pool": ["accomplish", "amount", "assembl", "compar", "design", "design", "desir", "discuss", "encod", "factor", "form", "high", "implement", "increas", "independ", "key", "languag", "level", "level", "low", "machin", "macro", "map", "merit", "object", "oper", "paper", "pitch", "popular", "portabl", "present", "processor", "rel", "result", "softwar", "special", "brown"], "word_count": {"accomplish": 1, "amount": 1, "assembl": 1, "compar": 1, "design": 2, "desir": 1, "discuss": 1, "encod": 1, "factor": 1, "form": 1, "high": 1, "implement": 1, "increas": 1, "independ": 2, "key": 1, "languag": 5, "level": 2, "low": 1, "machin": 3, "macro": 1, "map": 1, "merit": 1, "object": 1, "oper": 1, "paper": 1, "pitch": 1, "popular": 1, "portabl": 1, "present": 1, "processor": 1, "rel": 1, "result": 1, "softwar": 2, "special": 1, "brown": 1}}, "2247": {"id": "2247", "title": "On the Criteria To Be Used in Decomposing Systems into Modules", "abstract": "This paper discusses modularization as a mechanism for improving the flexibility ad comprehensibility  of a system while allowing the shortening of its development time.  The effectiveness of a \"modularization\"  is dependent upon the criteria used in dividing the system into modules.  A system design problem is presented and both a conventional and unconventional decomposition are described.  It is shown that the  unconventional decompositions have distinct advantages for the goals outlined.  The criteria used in  arriving at the decompositions are discussed.  The unconventional decomposition, if implemented with  the conventional assumption that a module consists of one or more subroutines, will be less efficient  in most cases.  An alternative approach to implementation which does not have this effect is sketched.", "authors": "Parnas, D. L.", "words_pool": ["ad", "advantag", "allow", "altern", "approach", "arriv", "assumpt", "case", "comprehens", "consist", "convent", "criteria", "decompos", "decomposit", "decomposit", "depend", "design", "develop", "discuss", "discuss", "distinct", "divid", "effect", "effect", "effici", "flexibl", "goal", "implement", "implement", "improv", "mechan", "modular", "modul", "modul", "outlin", "paper", "present", "problem", "shorten", "shown", "sketch", "subroutin", "system", "system", "time", "unconvent", "parna"], "word_count": {"ad": 1, "advantag": 1, "allow": 1, "altern": 1, "approach": 1, "arriv": 1, "assumpt": 1, "case": 1, "comprehens": 1, "consist": 1, "convent": 2, "criteria": 2, "decompos": 1, "decomposit": 4, "depend": 1, "design": 1, "develop": 1, "discuss": 2, "distinct": 1, "divid": 1, "effect": 2, "effici": 1, "flexibl": 1, "goal": 1, "implement": 2, "improv": 1, "mechan": 1, "modular": 2, "modul": 2, "outlin": 1, "paper": 1, "present": 1, "problem": 1, "shorten": 1, "shown": 1, "sketch": 1, "subroutin": 1, "system": 3, "time": 1, "unconvent": 3, "parna": 1}}, "2248": {"id": "2248", "title": "A New Method for the Solution of the Cauchy Problem for Parabolic Equations", "abstract": "An integral equation representation is given for parabolic partial differential equations.   When the equations are defined in unbounded domains, as in the initial value (Cauchy) problem, the solution  of the integral equation by the method of successive approximation has inherent advantages over other  methods.  Error bounds for the methods are of order h^(3/2) and h^(7/2) (his the increment size) depending  on the finite difference approximations involved.", "authors": "Moore, J. Robinson, P.", "words_pool": ["advantag", "approxim", "approxim", "bound", "cauchi", "defin", "depend", "differ", "differenti", "domain", "equat", "equat", "error", "finit", "increment", "inher", "initi", "integr", "involv", "method", "method", "order", "parabol", "partial", "problem", "represent", "size", "solut", "success", "unbound", "moor", "robinson"], "word_count": {"advantag": 1, "approxim": 2, "bound": 1, "cauchi": 1, "defin": 1, "depend": 1, "differ": 1, "differenti": 1, "domain": 1, "equat": 4, "error": 1, "finit": 1, "increment": 1, "inher": 1, "initi": 1, "integr": 2, "involv": 1, "method": 3, "order": 1, "parabol": 1, "partial": 1, "problem": 1, "represent": 1, "size": 1, "solut": 1, "success": 1, "unbound": 1, "moor": 1, "robinson": 1}}, "2249": {"id": "2249", "title": "A Comparison of Multivariate Normal Generators", "abstract": "Three methods for generating outcomes on multivariate normal random vectors with a specified  variance-covariance matrix are presented.  A comparison is made to determine which method requires the  least computer execution time and memory space when utilizing the IBM 360/67.  All methods use as a basis  a standard Gaussian random number generator.  Results of the comparison indicate that the method based  on triangular factorization of the covariance matrix generally requires less memory space and computer  time than the other two methods.", "authors": "Barr, D. R. Sezak, N. L.", "words_pool": ["base", "basi", "comparison", "comput", "covari", "determin", "execut", "factor", "gaussian", "gener", "gener", "gener", "gener", "ibm", "made", "matrix", "memori", "method", "method", "multivari", "normal", "number", "outcom", "present", "random", "requir", "result", "space", "standard", "time", "triangular", "util", "varianc", "vector", "barr", "sezak"], "word_count": {"base": 1, "basi": 1, "comparison": 2, "comput": 2, "covari": 2, "determin": 1, "execut": 1, "factor": 1, "gaussian": 1, "gener": 3, "ibm": 1, "made": 1, "matrix": 2, "memori": 2, "method": 5, "multivari": 1, "normal": 1, "number": 1, "outcom": 1, "present": 1, "random": 2, "requir": 2, "result": 1, "space": 2, "standard": 1, "time": 2, "triangular": 1, "util": 1, "varianc": 1, "vector": 1, "barr": 1, "sezak": 1}}, "2250": {"id": "2250", "title": "Computer Methods for Sampling from the Exponential and Normal Distributions (Corrigendum)", "authors": "Ahrens, J. H. Dieter, U.", "words_pool": ["comput", "corrigendum", "distribut", "exponenti", "method", "normal", "sampl", "ahren", "dieter"], "word_count": {"comput": 1, "corrigendum": 1, "distribut": 1, "exponenti": 1, "method": 1, "normal": 1, "sampl": 1, "ahren": 1, "dieter": 1}}, "2251": {"id": "2251", "title": "Weighted Increment Linear Search for Scatter Tables", "abstract": "A new linear search for hash tables whose increment step is a function of the key being addressed  is presented.  Comparisons with known methods are given, in terms of efficiency and computation complexity.   In particular, the new method applies to tables of size n = 2^r.  It allows full table searching, and  practically eliminates primary clustering at a very low cost.", "authors": "Luccio, F.", "words_pool": ["address", "appli", "cluster", "comparison", "complex", "comput", "cost", "effici", "elimin", "full", "function", "hash", "increment", "key", "known", "linear", "low", "method", "method", "practic", "present", "primari", "scatter", "search", "search", "size", "step", "tabl", "tabl", "term", "weight", "luccio"], "word_count": {"address": 1, "appli": 1, "cluster": 1, "comparison": 1, "complex": 1, "comput": 1, "cost": 1, "effici": 1, "elimin": 1, "full": 1, "function": 1, "hash": 1, "increment": 1, "key": 1, "known": 1, "linear": 1, "low": 1, "method": 2, "practic": 1, "present": 1, "primari": 1, "scatter": 1, "search": 2, "size": 1, "step": 1, "tabl": 3, "term": 1, "weight": 1, "luccio": 1}}, "2252": {"id": "2252", "title": "A Method for Incrementally Compiling Languages with Nested Statement Structure", "abstract": "A method of incremental compilation is presented which applies especially to programming languages  in which statements can be nested (such as Algol and PL/I).  The method permits editing of the source  language using a general purpose text editor, and incremental processing of changes without frequent  recompilation of entire routines.  The essential points of the method are: (1) the syntax of the language  is restricted insof ar as which constructs may occur on lines; (2) an internal data structure (called  the skeleton) is maintained to represent the statement structure; (3) the recompilation is partially  batched in the sense that recompilation of modified lines does not occur until the last of a set of editing  commands has been received; and (4) the parsing and compilation are factored into two parts, that done  on individual lines and that done globally to handle the relationships between the lines.", "authors": "Earley, J. Caizergues, P.", "words_pool": ["algol", "appli", "ar", "batch", "call", "command", "compil", "compil", "construct", "data", "edit", "editor", "entir", "especi", "essenti", "factor", "frequent", "gener", "global", "handl", "increment", "increment", "individu", "insof", "intern", "languag", "languag", "line", "maintain", "method", "modifi", "nest", "occur", "pars", "partial", "part", "permit", "pl", "point", "present", "process", "program", "purpos", "receiv", "recompil", "relationship", "repres", "restrict", "routin", "sens", "set", "skeleton", "sourc", "statement", "statement", "structur", "syntax", "text", "earley", "caizergu"], "word_count": {"algol": 1, "appli": 1, "ar": 1, "batch": 1, "call": 1, "command": 1, "compil": 2, "construct": 1, "data": 1, "edit": 2, "editor": 1, "entir": 1, "especi": 1, "essenti": 1, "factor": 1, "frequent": 1, "gener": 1, "global": 1, "handl": 1, "increment": 2, "individu": 1, "insof": 1, "intern": 1, "languag": 3, "line": 4, "maintain": 1, "method": 3, "modifi": 1, "nest": 1, "occur": 2, "pars": 1, "partial": 1, "part": 1, "permit": 1, "pl": 1, "point": 1, "present": 1, "process": 1, "program": 1, "purpos": 1, "receiv": 1, "recompil": 3, "relationship": 1, "repres": 1, "restrict": 1, "routin": 1, "sens": 1, "set": 1, "skeleton": 1, "sourc": 1, "statement": 2, "structur": 2, "syntax": 1, "text": 1, "earley": 1, "caizergu": 1}}, "2253": {"id": "2253", "title": "Index Ranges for Matrix Calculi", "abstract": "The paper describes a scheme for symbolic manipulation of index expressions which arise as  a by-product of the symbolic manipulation of expressions in the matrix calculi described by the authors  in a previous paper.  This scheme attempts program optimization by transforming the original algorithm  rather than the machine code.  The goal is to automatically generate code for handling the tedious address  calculations necessitated by complicated data structures.  The paper is therefore preoccupied with \"indexing  by position.\"  The relationship of \"indexing by name\" and \"indexing by position\" is discussed.", "authors": "Bayer, R. Witzgall, C.", "words_pool": ["address", "algorithm", "aris", "attempt", "author", "calcul", "calculi", "code", "complic", "data", "describ", "discuss", "express", "gener", "goal", "handl", "index", "index", "machin", "manipul", "matrix", "necessit", "optim", "origin", "paper", "posit", "preoccupi", "previou", "product", "program", "rang", "relationship", "scheme", "structur", "symbol", "tediou", "transform", "bayer", "witzgal"], "word_count": {"address": 1, "algorithm": 1, "aris": 1, "attempt": 1, "author": 1, "calcul": 1, "calculi": 1, "code": 2, "complic": 1, "data": 1, "describ": 1, "discuss": 1, "express": 2, "gener": 1, "goal": 1, "handl": 1, "index": 4, "machin": 1, "manipul": 2, "matrix": 1, "necessit": 1, "optim": 1, "origin": 1, "paper": 3, "posit": 2, "preoccupi": 1, "previou": 1, "product": 1, "program": 1, "rang": 1, "relationship": 1, "scheme": 2, "structur": 1, "symbol": 2, "tediou": 1, "transform": 1, "bayer": 1, "witzgal": 1}}, "2254": {"id": "2254", "title": "Dynamic Partitioning for Array Languages", "abstract": "The classical process of partitioning an array into subarrays is extended to a more useful  array language operation.  Various modes of partitioning are defined for different types of arrays, so  that subarrays may vary over the original array in a nearly arbitrary manner.  These definitions are  motivated with several realistic examples to illustrate the value of partitioning for array languages.   Of general interest is the data structure for partitioning.  This consists of dynamic tree structures  which are used to derive and maintain the array control information.  These are described in sufficient  detail to be of value in the design of other array languages.  The description presented in this paper  is implemented in a new array language, OL/2, currently under development at the University of Illinois.", "authors": "Phillips, J. R. Adams, H. C.", "words_pool": ["arbitrari", "array", "array", "classic", "consist", "control", "data", "defin", "definit", "deriv", "descript", "design", "detail", "develop", "dynam", "exampl", "extend", "gener", "illinoi", "illustr", "implement", "inform", "interest", "languag", "languag", "maintain", "manner", "mode", "motiv", "nearli", "ol", "oper", "origin", "paper", "partit", "present", "process", "realist", "structur", "structur", "subarray", "suffici", "tree", "type", "univers", "vari", "phillip", "adam"], "word_count": {"arbitrari": 1, "array": 8, "classic": 1, "consist": 1, "control": 1, "data": 1, "defin": 1, "definit": 1, "deriv": 1, "descript": 1, "design": 1, "detail": 1, "develop": 1, "dynam": 1, "exampl": 1, "extend": 1, "gener": 1, "illinoi": 1, "illustr": 1, "implement": 1, "inform": 1, "interest": 1, "languag": 4, "maintain": 1, "manner": 1, "mode": 1, "motiv": 1, "nearli": 1, "ol": 1, "oper": 1, "origin": 1, "paper": 1, "partit": 4, "present": 1, "process": 1, "realist": 1, "structur": 2, "subarray": 2, "suffici": 1, "tree": 1, "type": 1, "univers": 1, "vari": 1, "phillip": 1, "adam": 1}}, "2255": {"id": "2255", "title": "Comments on Moorer's Music and Computer Composition", "authors": "Smoliar, S. W.", "words_pool": ["comment", "composit", "comput", "moorer", "music", "smoliar"], "word_count": {"comment": 1, "composit": 1, "comput": 1, "moorer": 1, "music": 1, "smoliar": 1}}, "2256": {"id": "2256", "title": "Further Comments on Dijkstra's Concurrent Programming Control Problem", "authors": "Eisenberg, M. A. McGuire, M. R.", "words_pool": ["comment", "concurr", "control", "dijkstra", "problem", "program", "eisenberg", "mcguir"], "word_count": {"comment": 1, "concurr": 1, "control": 1, "dijkstra": 1, "problem": 1, "program": 1, "eisenberg": 1, "mcguir": 1}}, "2257": {"id": "2257", "title": "A Note on Optimal Doubly-Chained Trees", "authors": "Kennedy, S.", "words_pool": ["chain", "doubli", "note", "optim", "tree", "kennedi"], "word_count": {"chain": 1, "doubli": 1, "note": 1, "optim": 1, "tree": 1, "kennedi": 1}}, "2258": {"id": "2258", "title": "Additional Results on Key-to-Address Transform Techniques: A Fundamental Performance Study on  Large Existing Formatted Files", "authors": "Lum, V. Y. Yuen, P. S. T.", "words_pool": ["addit", "address", "exist", "format", "fundament", "key", "larg", "perform", "result", "studi", "techniqu", "transform", "lum", "yuen"], "word_count": {"addit": 1, "address": 1, "exist": 1, "format": 1, "fundament": 1, "key": 1, "larg": 1, "perform": 1, "result": 1, "studi": 1, "techniqu": 1, "transform": 1, "lum": 1, "yuen": 1}}, "2259": {"id": "2259", "title": "Modified Incomplete Gamma Function [S14] (Algorithm A435)", "authors": "Fullerton, W.", "words_pool": ["a435", "algorithm", "function", "gamma", "incomplet", "modifi", "s14", "fullerton"], "word_count": {"a435": 1, "algorithm": 1, "function": 1, "gamma": 1, "incomplet": 1, "modifi": 1, "s14": 1, "fullerton": 1}}, "2260": {"id": "2260", "title": "Exact Probabilities for R x C Contingency Tables [G2] (Algorithm A434)", "authors": "March, D. L.", "words_pool": ["a434", "algorithm", "conting", "exact", "g2", "probabl", "tabl", "march"], "word_count": {"a434": 1, "algorithm": 1, "conting": 1, "exact": 1, "g2": 1, "probabl": 1, "tabl": 1, "march": 1}}, "2261": {"id": "2261", "title": "An Approximate Method for Generating Symmetric Random Variables", "abstract": "A method for generating values of continuous symmetric random variables that is relatively  fast, requires essentially no computer memory, and is easy to use is developed.  The method, which uses  a uniform zero-one random number source, is based on the inverse function of the lambda distribution  of Turkey.  Since it approximates many of the continuous theoretical distributions and empirical distributions  frequently used in simulations, the method should be useful to simulation practitioners.", "authors": "Ramberg, J. S. Schmeiser, B. W.", "words_pool": ["approxim", "approxim", "base", "comput", "continu", "develop", "distribut", "distribut", "easi", "empir", "essenti", "fast", "frequent", "function", "gener", "invers", "lambda", "memori", "method", "number", "practition", "random", "requir", "simul", "simul", "sourc", "symmetr", "theoret", "turkey", "uniform", "valu", "variabl", "ramberg", "schmeiser"], "word_count": {"approxim": 1, "base": 1, "comput": 1, "continu": 2, "develop": 1, "distribut": 3, "easi": 1, "empir": 1, "essenti": 1, "fast": 1, "frequent": 1, "function": 1, "gener": 1, "invers": 1, "lambda": 1, "memori": 1, "method": 3, "number": 1, "practition": 1, "random": 2, "requir": 1, "simul": 2, "sourc": 1, "symmetr": 1, "theoret": 1, "turkey": 1, "uniform": 1, "valu": 1, "variabl": 1, "ramberg": 1, "schmeiser": 1}}, "2262": {"id": "2262", "title": "Garbage Collection for Virtual Memory Computer Systems", "abstract": "In list processing there is typically a growing demand for space during program execution.   This paper examines the practical implications of this growth within a virtual memory computer system,  proposes two new garbage collection techniques for virtual memory systems, and compares them with traditional  methods by discussion and by simulation.", "authors": "Baecker, H. D.", "words_pool": ["collect", "compar", "comput", "demand", "discuss", "examin", "execut", "garbag", "grow", "growth", "implic", "list", "memori", "method", "paper", "practic", "process", "program", "propos", "simul", "space", "system", "system", "techniqu", "tradit", "typic", "virtual", "baecker"], "word_count": {"collect": 1, "compar": 1, "comput": 1, "demand": 1, "discuss": 1, "examin": 1, "execut": 1, "garbag": 1, "grow": 1, "growth": 1, "implic": 1, "list": 1, "memori": 2, "method": 1, "paper": 1, "practic": 1, "process": 1, "program": 1, "propos": 1, "simul": 1, "space": 1, "system": 2, "techniqu": 1, "tradit": 1, "typic": 1, "virtual": 2, "baecker": 1}}, "2263": {"id": "2263", "title": "The Conversion of Limited-Entry Decision Tables to Optimal and Near-Optimal Flowcharts: Two New  Algorithms", "abstract": "Two new algorithms for deriving optimal and near-optimal flowcharts from limited entry decision  tables are presented.  Both take into account rule frequencies and the time needed to test conditions.   One of the algorithms, called the optimum-finding algorithm, leads to a flowchart which truly minimizes  execution time for a decision table in which simple rules are already contracted to complex rules.  The  other one, called the optimum-approaching algorithm, requires many fewer calculations but does not necessarily  produce the optimum flowchart.  The algorithms are first derived for treating decision tables not containing  an ELSE-rule, but the optimum-approaching algorithm is shown to be equally valid for tables including  such a rule.  Both algorithms are compared with existing ones and are applied to a somewhat large decision  table derived from a real case.  From this comparison two conclusions are drawn.  (1) The optimum-approaching  algorithm will usually lead to better results than comparable existing ones and will not require more,  but usually less, computation time.(2) In general, the greater computation effort needed for applying  the optimum-finding algorithm will not be justified by the small reduction in execution time obtained.", "authors": "Verhelst, M.", "words_pool": ["account", "algorithm", "algorithm", "appli", "appli", "approach", "calcul", "call", "case", "compar", "compar", "comparison", "complex", "comput", "conclus", "condit", "contract", "convers", "decis", "deriv", "deriv", "drawn", "effort", "entri", "equal", "execut", "exist", "fewer", "find", "flowchart", "flowchart", "frequenc", "gener", "greater", "includ", "justifi", "larg", "lead", "lead", "limit", "minim", "necessarili", "need", "obtain", "optim", "optimum", "present", "produc", "real", "reduct", "requir", "requir", "result", "rule", "rule", "shown", "simpl", "small", "tabl", "tabl", "take", "test", "time", "treat", "truli", "valid", "verhelst"], "word_count": {"account": 1, "algorithm": 9, "appli": 2, "approach": 3, "calcul": 1, "call": 2, "case": 1, "compar": 2, "comparison": 1, "complex": 1, "comput": 2, "conclus": 1, "condit": 1, "contract": 1, "convers": 1, "decis": 4, "deriv": 3, "drawn": 1, "effort": 1, "entri": 1, "equal": 1, "execut": 2, "exist": 2, "fewer": 1, "find": 2, "flowchart": 3, "frequenc": 1, "gener": 1, "greater": 1, "includ": 1, "justifi": 1, "larg": 1, "lead": 2, "limit": 1, "minim": 1, "necessarili": 1, "need": 2, "obtain": 1, "optim": 2, "optimum": 6, "present": 1, "produc": 1, "real": 1, "reduct": 1, "requir": 2, "result": 1, "rule": 5, "shown": 1, "simpl": 1, "small": 1, "tabl": 5, "take": 1, "test": 1, "time": 4, "treat": 1, "truli": 1, "valid": 1, "verhelst": 1}}, "2264": {"id": "2264", "title": "Derived Semantics for Some Programming Language Constructs", "abstract": "The constructs of a simple programming language are introduced and described informally in  terms of values and side-effects.  A translator is defined which translates the language into flowcharts  for a simple machine.  The action of the machine in executing a flowchart is defined.  A proof is constructed  that the effect of translating and executing any program can be expressed solely in terms of the value  and side-effect of the program.  During the course of constructing the proof, formal definitions of the  concepts of value and side-effect are derived in order to make the proof rigorous.  Correctness of the  implementation involves checking that the definitions derived in the step above are an acceptable formalization  of the informal description given in the first step.", "authors": "Henderson, P.", "words_pool": ["accept", "action", "check", "concept", "construct", "construct", "construct", "correct", "cours", "defin", "definit", "deriv", "descript", "effect", "effect", "execut", "express", "flowchart", "flowchart", "formal", "formal", "implement", "inform", "inform", "introduc", "involv", "languag", "machin", "make", "order", "program", "program", "proof", "rigor", "semant", "side", "simpl", "sole", "step", "term", "translat", "translat", "translat", "valu", "henderson"], "word_count": {"accept": 1, "action": 1, "check": 1, "concept": 1, "construct": 3, "correct": 1, "cours": 1, "defin": 2, "definit": 2, "deriv": 2, "descript": 1, "effect": 4, "execut": 2, "express": 1, "flowchart": 2, "formal": 2, "implement": 1, "inform": 2, "introduc": 1, "involv": 1, "languag": 2, "machin": 2, "make": 1, "order": 1, "program": 3, "proof": 3, "rigor": 1, "semant": 1, "side": 3, "simpl": 2, "sole": 1, "step": 2, "term": 2, "translat": 3, "valu": 1, "henderson": 1}}, "2265": {"id": "2265", "title": "A Model for Type Checking", "abstract": "Most current programming languages treat computation over different classes of objects (e.g.  numbers, strings, labels and functions).  For correct compilation and execution, the following question  then arises: is a program properly constructed so that its operations and operands are compatible?  The  activity of answering this question is usually called type checking.  This paper attempts to isolate  the notion of type checking and presents a partial solution to the type checking problem based on the  notions of abstraction and application of functions.  In particular, a program is mapped into an expression  within a decidable subset of the Lambda calculus, which characterizes the type relations within the program  and eliminates all other information.  The determination of the type-wise correctness or incorrectness  of the program is resolved by reducing its corresponding Lambda calculus expression to one of two normal  forms, the constant \"correct\" for a type-wise correct program or the constant \"error\".  An application  to type checking in Algol 60 is made, and the attendant problems faced for any notion of type checking  are discussed.", "authors": "Ledgard, H. F.", "words_pool": ["abstract", "activ", "algol", "answer", "applic", "aris", "attempt", "attend", "base", "calculu", "call", "character", "check", "class", "compat", "compil", "comput", "constant", "construct", "correct", "correct", "decid", "determin", "discuss", "elimin", "error", "execut", "express", "face", "form", "function", "incorrect", "inform", "isol", "label", "lambda", "languag", "made", "map", "model", "normal", "notion", "notion", "number", "object", "operand", "oper", "paper", "partial", "present", "problem", "problem", "program", "program", "properli", "question", "reduc", "relat", "resolv", "solut", "string", "subset", "treat", "type", "wise", "ledgard"], "word_count": {"abstract": 1, "activ": 1, "algol": 1, "answer": 1, "applic": 2, "aris": 1, "attempt": 1, "attend": 1, "base": 1, "calculu": 2, "call": 1, "character": 1, "check": 5, "class": 1, "compat": 1, "compil": 1, "comput": 1, "constant": 2, "construct": 1, "correct": 4, "decid": 1, "determin": 1, "discuss": 1, "elimin": 1, "error": 1, "execut": 1, "express": 2, "face": 1, "form": 1, "function": 2, "incorrect": 1, "inform": 1, "isol": 1, "label": 1, "lambda": 2, "languag": 1, "made": 1, "map": 1, "model": 1, "normal": 1, "notion": 3, "number": 1, "object": 1, "operand": 1, "oper": 1, "paper": 1, "partial": 1, "present": 1, "problem": 2, "program": 6, "properli": 1, "question": 2, "reduc": 1, "relat": 1, "resolv": 1, "solut": 1, "string": 1, "subset": 1, "treat": 1, "type": 8, "wise": 2, "ledgard": 1}}, "2266": {"id": "2266", "title": "A Highly Parallel Algorithm for Approximating All Zeros of a Polynomial with Only Real Zeros", "abstract": "An algorithm is described based on Newton's method which simultaneously approximates all zeros  of a polynomial with only real zeros.  The algorithm, which is conceptually suitable for parallel computation,  determines its own starting values so that convergence to the zeros is guaranteed.  Multiple zeros and  their multiplicity are readily determined.  At no point in the method is polynomial deflation used.", "authors": "Patrick, M. L.", "words_pool": ["algorithm", "approxim", "approxim", "base", "comput", "conceptu", "converg", "deflat", "determin", "determin", "guarante", "highli", "method", "multipl", "multipl", "newton", "parallel", "point", "polynomi", "readili", "real", "simultan", "start", "suitabl", "valu", "zero", "patrick"], "word_count": {"algorithm": 2, "approxim": 1, "base": 1, "comput": 1, "conceptu": 1, "converg": 1, "deflat": 1, "determin": 2, "guarante": 1, "highli": 1, "method": 2, "multipl": 2, "newton": 1, "parallel": 1, "point": 1, "polynomi": 2, "readili": 1, "real": 1, "simultan": 1, "start": 1, "suitabl": 1, "valu": 1, "zero": 4, "patrick": 1}}, "2267": {"id": "2267", "title": "Algorithms To Reveal Properties of Floating-Point Arithmetic", "abstract": "Two algorithms are presented in the form of Fortran subroutines.  Each subroutine computes  the radix and number of digits of the floating-point numbers and whether rounding or chopping is done  by the machine on which it is run.  The methods are shown to work on any \"reasonable\" floating-point  computer.", "authors": "Malcolm, M. A.", "words_pool": ["algorithm", "arithmet", "chop", "comput", "comput", "digit", "float", "form", "fortran", "machin", "method", "number", "number", "point", "present", "properti", "radix", "reason", "reveal", "round", "run", "shown", "subroutin", "subroutin", "work", "malcolm"], "word_count": {"algorithm": 1, "arithmet": 1, "chop": 1, "comput": 2, "digit": 1, "float": 2, "form": 1, "fortran": 1, "machin": 1, "method": 1, "number": 2, "point": 2, "present": 1, "properti": 1, "radix": 1, "reason": 1, "reveal": 1, "round": 1, "run": 1, "shown": 1, "subroutin": 2, "work": 1, "malcolm": 1}}, "2268": {"id": "2268", "title": "A Comparative Study of Computer Programs for Integrating Differential Equations", "abstract": "A study comparing the performance of several computer programs for integrating systems of ordinary  differential equations is reported.  The integration methods represented include multistep methods (predictor-correctors),  single-step methods (Runge-Kutta) and extrapolation methods (both polynomial and rational).  The testing  procedure is described together with the evaluation criteria applied.  A set of test problems on which  the programs were tested is included in an appendix.  For the particular problems and criteria used in  the investigation it was found that a program based on rational extrapolation showed the best performance.", "authors": "Fox, P.", "words_pool": ["appendix", "appli", "base", "compar", "compar", "comput", "corrector", "criteria", "differenti", "equat", "evalu", "extrapol", "found", "includ", "includ", "integr", "integr", "investig", "kutta", "method", "multistep", "ordinari", "perform", "polynomi", "predictor", "problem", "procedur", "program", "program", "ration", "report", "repres", "rung", "set", "show", "singl", "step", "studi", "system", "test", "test", "test", "fox"], "word_count": {"appendix": 1, "appli": 1, "base": 1, "compar": 1, "comput": 1, "corrector": 1, "criteria": 2, "differenti": 1, "equat": 1, "evalu": 1, "extrapol": 2, "found": 1, "includ": 2, "integr": 2, "investig": 1, "kutta": 1, "method": 4, "multistep": 1, "ordinari": 1, "perform": 2, "polynomi": 1, "predictor": 1, "problem": 2, "procedur": 1, "program": 3, "ration": 2, "report": 1, "repres": 1, "rung": 1, "set": 1, "show": 1, "singl": 1, "step": 1, "studi": 1, "system": 1, "test": 3, "fox": 1}}, "2269": {"id": "2269", "title": "Tableless Date Conversion (Algorithm R398)", "authors": "Robertson, J. D.", "words_pool": ["algorithm", "convers", "date", "r398", "tableless", "robertson"], "word_count": {"algorithm": 1, "convers": 1, "date": 1, "r398": 1, "tableless": 1, "robertson": 1}}, "2270": {"id": "2270", "title": "Interpolation and Smooth Curve Fitting Based on Local Procedures [E2] (Algorithm A433)", "authors": "Akima, H.", "words_pool": ["a433", "algorithm", "base", "curv", "e2", "fit", "interpol", "local", "procedur", "smooth", "akima"], "word_count": {"a433": 1, "algorithm": 1, "base": 1, "curv": 1, "e2": 1, "fit": 1, "interpol": 1, "local": 1, "procedur": 1, "smooth": 1, "akima": 1}}, "2271": {"id": "2271", "title": "Aesthetics and the Human Factor in Programming (Corrigendum)", "authors": "Ershov,A. P.", "words_pool": ["aesthet", "corrigendum", "factor", "human", "program", "ershov"], "word_count": {"aesthet": 1, "corrigendum": 1, "factor": 1, "human": 1, "program": 1, "ershov": 1}}, "2272": {"id": "2272", "title": "Sorting by Natural Selection", "abstract": "A family of sorting algorithms is proposed, the members of which make fuller use of the memory  space and thus yield longer sorted strings.  Extensive simulation results are presented, and various  implications and further applications are discussed.", "authors": "Frazer, W. D. Wong, C. K.", "words_pool": ["algorithm", "applic", "discuss", "extens", "famili", "fuller", "implic", "longer", "make", "member", "memori", "natur", "present", "propos", "result", "select", "simul", "sort", "sort", "space", "string", "yield", "frazer", "wong"], "word_count": {"algorithm": 1, "applic": 1, "discuss": 1, "extens": 1, "famili": 1, "fuller": 1, "implic": 1, "longer": 1, "make": 1, "member": 1, "memori": 1, "natur": 1, "present": 1, "propos": 1, "result": 1, "select": 1, "simul": 1, "sort": 2, "space": 1, "string": 1, "yield": 1, "frazer": 1, "wong": 1}}, "2273": {"id": "2273", "title": "Conversion of Decision Tables By Rule Mask Method Without Rule Mask", "abstract": "Two algorithms for generating computer programs from decision tables are described.  The algorithms  allow handling limited entry, extended entry, and mixed entry tables.  The algorithms are based on the  rule mask method but need not have the masks at execution time.  They perform the logical operations  immediately rather than at the end of the interpreting process.  Execution time can be considerably reduced  by instantly marking rules which are not applicable (Algorithms 1 and 2) or conditions which are already  tested (Algorithm 2).  The new algorithms combine to a certain degree the advantages of mask methods with  those of tree methods.", "authors": "Dathe, G.", "words_pool": ["advantag", "algorithm", "algorithm", "allow", "applic", "base", "combin", "comput", "condit", "consider", "convers", "decis", "degre", "end", "entri", "execut", "extend", "gener", "handl", "immedi", "instantli", "interpret", "limit", "logic", "mark", "mask", "mask", "method", "method", "mix", "need", "oper", "perform", "process", "program", "reduc", "rule", "rule", "tabl", "test", "time", "tree", "dath"], "word_count": {"advantag": 1, "algorithm": 6, "allow": 1, "applic": 1, "base": 1, "combin": 1, "comput": 1, "condit": 1, "consider": 1, "convers": 1, "decis": 1, "degre": 1, "end": 1, "entri": 3, "execut": 2, "extend": 1, "gener": 1, "handl": 1, "immedi": 1, "instantli": 1, "interpret": 1, "limit": 1, "logic": 1, "mark": 1, "mask": 3, "method": 3, "mix": 1, "need": 1, "oper": 1, "perform": 1, "process": 1, "program": 1, "reduc": 1, "rule": 2, "tabl": 2, "test": 1, "time": 2, "tree": 1, "dath": 1}}, "2274": {"id": "2274", "title": "Generating English Discourse from Semantic Networks", "abstract": "A system is described for generating English sentences from a form of semantic nets in which  the nodes are word-sense meanings and the paths are primarily deep case relations.  The grammar used  by the system is in the form of a network that imposes an ordering on a set of syntactic transformations  that are expressed as LISP functions.  The generation algorithm uses the information in the semantic  network to select appropriate generation paths through the grammar.  The system is designed for use as  a computational tool that allows a linguist to develop and study methods for generating surface strings  from an underlying semantic structure.  Initial finding with regard to form determiners such as voice,  form, tense, and mood, some rules for embedding sentences, and some attention to pronominal substitution  are reported.  The system is programmed in LISP 1.5 and is available from the authors.", "authors": "Simmons, R. Slocum, J.", "words_pool": ["algorithm", "attent", "author", "case", "comput", "deep", "design", "determin", "develop", "discours", "embed", "english", "express", "find", "form", "function", "gener", "gener", "grammar", "impos", "inform", "initi", "linguist", "lisp", "mean", "method", "mood", "net", "network", "network", "node", "order", "path", "primarili", "program", "pronomin", "regard", "relat", "report", "rule", "select", "semant", "sens", "sentenc", "set", "string", "structur", "studi", "substitut", "surfac", "syntact", "system", "tens", "tool", "transform", "underli", "voic", "word", "simmon", "slocum"], "word_count": {"algorithm": 1, "attent": 1, "author": 1, "case": 1, "comput": 1, "deep": 1, "design": 1, "determin": 1, "develop": 1, "discours": 1, "embed": 1, "english": 1, "express": 1, "find": 1, "form": 4, "function": 1, "gener": 4, "grammar": 2, "impos": 1, "inform": 1, "initi": 1, "linguist": 1, "lisp": 2, "mean": 1, "method": 1, "mood": 1, "net": 1, "network": 2, "node": 1, "order": 1, "path": 2, "primarili": 1, "program": 1, "pronomin": 1, "regard": 1, "relat": 1, "report": 1, "rule": 1, "select": 1, "semant": 3, "sens": 1, "sentenc": 2, "set": 1, "string": 1, "structur": 1, "studi": 1, "substitut": 1, "surfac": 1, "syntact": 1, "system": 4, "tens": 1, "tool": 1, "transform": 1, "underli": 1, "voic": 1, "word": 1, "simmon": 1, "slocum": 1}}, "2275": {"id": "2275", "title": "Integral Equations of Immunology", "abstract": "The inversion of a particular integral equation of the first (Fredholm) kind is the basic problem  considered.  The strategy which yielded success consisted of three essential points: (1) fit the known  experimental data by a curve with properties which derive from properties of the (as yet unknown) function;  (2) stabilize the computation for the unknown function by using singular value decomposition; (3) constrain  the unknown function approximation (since it represents a probability distribution) to be nonnegative.   A number of test cases are presented. One set of actual experimental data is analyzed with the procedures  presented.", "authors": "Hanson, R. J.", "words_pool": ["actual", "analyz", "approxim", "basic", "case", "comput", "consid", "consist", "constrain", "curv", "data", "decomposit", "deriv", "distribut", "equat", "equat", "essenti", "experiment", "fit", "fredholm", "function", "immunolog", "integr", "invers", "kind", "known", "nonneg", "number", "point", "present", "probabl", "problem", "procedur", "properti", "repres", "set", "singular", "stabil", "strategi", "success", "test", "unknown", "yield", "hanson"], "word_count": {"actual": 1, "analyz": 1, "approxim": 1, "basic": 1, "case": 1, "comput": 1, "consid": 1, "consist": 1, "constrain": 1, "curv": 1, "data": 2, "decomposit": 1, "deriv": 1, "distribut": 1, "equat": 1, "essenti": 1, "experiment": 2, "fit": 1, "fredholm": 1, "function": 3, "immunolog": 1, "integr": 1, "invers": 1, "kind": 1, "known": 1, "nonneg": 1, "number": 1, "point": 1, "present": 2, "probabl": 1, "problem": 1, "procedur": 1, "properti": 2, "repres": 1, "set": 1, "singular": 1, "stabil": 1, "strategi": 1, "success": 1, "test": 1, "unknown": 3, "yield": 1, "hanson": 1}}, "2276": {"id": "2276", "title": "Computer Methods for Sampling from the Exponential and Normal Distributions", "abstract": "Various methods are known for transforming uniformly distributed random numbers into exponentially and normally distributed quantities.  The most efficient ones are compared, in terms of memory requirements  and speed, with some new algorithms.  A number of procedures convert Taylor series expansions directly  into sampling steps, an approach which may be used for sampling from any continuous distribution.  For  the exponential distribution a definite recommendation can be made, whereas in the case of the normal  distribution there remains a choice between slower and shorter algorithms and faster but space consuming  methods.", "authors": "Ahrens, J. H. Dieter, U.", "words_pool": ["algorithm", "approach", "case", "choic", "compar", "comput", "consum", "continu", "convert", "definit", "directli", "distribut", "distribut", "distribut", "effici", "expans", "exponenti", "exponenti", "faster", "known", "made", "memori", "method", "normal", "number", "number", "procedur", "quantiti", "random", "recommend", "remain", "requir", "sampl", "seri", "shorter", "slower", "space", "speed", "step", "taylor", "term", "transform", "uniformli", "ahren", "dieter"], "word_count": {"algorithm": 2, "approach": 1, "case": 1, "choic": 1, "compar": 1, "comput": 1, "consum": 1, "continu": 1, "convert": 1, "definit": 1, "directli": 1, "distribut": 5, "effici": 1, "expans": 1, "exponenti": 2, "faster": 1, "known": 1, "made": 1, "memori": 1, "method": 2, "normal": 1, "number": 2, "procedur": 1, "quantiti": 1, "random": 1, "recommend": 1, "remain": 1, "requir": 1, "sampl": 2, "seri": 1, "shorter": 1, "slower": 1, "space": 1, "speed": 1, "step": 1, "taylor": 1, "term": 1, "transform": 1, "uniformli": 1, "ahren": 1, "dieter": 1}}, "2277": {"id": "2277", "title": "Demand Paging Through Utilization of Working Sets on the MANIAC II", "abstract": "A hardware implementation on the Maniac II computer of the working set model for demand paging,  as introduced by Denning, is discussed.  Characteristics of the Maniac II are given, along with a description  of the basic demand paging scheme and the associate memory which has been added to the Maniac II hardware.   Finally, a description of the hardware design for implementation of the working set model is discussed  and a specification of the actions taken under various conditions which may arise during the operation  of the full working set model, demand paging system is given.", "authors": "Morris, J. B.", "words_pool": ["action", "ad", "aris", "associ", "basic", "characterist", "comput", "condit", "demand", "den", "descript", "design", "discuss", "final", "full", "hardwar", "ii", "implement", "introduc", "maniac", "memori", "model", "oper", "page", "scheme", "set", "set", "specif", "system", "util", "work", "morri"], "word_count": {"action": 1, "ad": 1, "aris": 1, "associ": 1, "basic": 1, "characterist": 1, "comput": 1, "condit": 1, "demand": 3, "den": 1, "descript": 2, "design": 1, "discuss": 2, "final": 1, "full": 1, "hardwar": 3, "ii": 3, "implement": 2, "introduc": 1, "maniac": 3, "memori": 1, "model": 3, "oper": 1, "page": 3, "scheme": 1, "set": 3, "specif": 1, "system": 1, "util": 1, "work": 3, "morri": 1}}, "2278": {"id": "2278", "title": "On Foster's Information Storage and Retrieval Using AVL Trees", "authors": "Tan, K. C.", "words_pool": ["avl", "foster", "inform", "retriev", "storag", "tree", "tan"], "word_count": {"avl": 1, "foster": 1, "inform": 1, "retriev": 1, "storag": 1, "tree": 1, "tan": 1}}, "2279": {"id": "2279", "title": "A Controller for a Braille Terminal", "authors": "Rubinstein, R. Feldman, J.", "words_pool": ["braill", "control", "termin", "rubinstein", "feldman"], "word_count": {"braill": 1, "control": 1, "termin": 1, "rubinstein": 1, "feldman": 1}}, "2280": {"id": "2280", "title": "Comment on Deadlock Prevention Method", "authors": "Parnas, D. L. Habermann, A. N.", "words_pool": ["comment", "deadlock", "method", "prevent", "parna", "habermann"], "word_count": {"comment": 1, "deadlock": 1, "method": 1, "prevent": 1, "parna": 1, "habermann": 1}}, "2281": {"id": "2281", "title": "The Eigen problem of Block Tridiagonal Matrices", "authors": "Khalil, H. M.", "words_pool": ["block", "eigen", "matric", "problem", "tridiagon", "khalil"], "word_count": {"block": 1, "eigen": 1, "matric": 1, "problem": 1, "tridiagon": 1, "khalil": 1}}, "2282": {"id": "2282", "title": "A Comparison of Floating Point Summation Methods", "authors": "Gregory, J.", "words_pool": ["comparison", "float", "method", "point", "summat", "gregori"], "word_count": {"comparison": 1, "float": 1, "method": 1, "point": 1, "summat": 1, "gregori": 1}}, "2283": {"id": "2283", "title": "Thinning Algorithms on Rectangular, Hexagonal, and Triangular Arrays", "abstract": "In this report three thinning algorithms are developed: one each for use with rectangular,  hexagonal, and triangular arrays.  The approach to the development of each algorithm is the same.  Pictorial  results produced by each of the algorithms are presented and the relative performances of the algorithms  are compared.  It is found that the algorithm operating with the triangular array is the most sensitive  to image irregularities and noise, yet it will yield a thinned image with an overall reduced number of  points.  It is concluded that the algorithm operating in conjunction with the hexagonal array has features  which strike a balance between those of the other two arrays.", "authors": "Deutsch, E. S.", "words_pool": ["algorithm", "algorithm", "approach", "array", "array", "balanc", "compar", "conclud", "conjunct", "develop", "develop", "featur", "found", "hexagon", "imag", "irregular", "nois", "number", "oper", "perform", "pictori", "point", "present", "produc", "rectangular", "reduc", "rel", "report", "result", "sensit", "strike", "thin", "thin", "triangular", "yield", "deutsch"], "word_count": {"algorithm": 6, "approach": 1, "array": 4, "balanc": 1, "compar": 1, "conclud": 1, "conjunct": 1, "develop": 2, "featur": 1, "found": 1, "hexagon": 2, "imag": 2, "irregular": 1, "nois": 1, "number": 1, "oper": 2, "perform": 1, "pictori": 1, "point": 1, "present": 1, "produc": 1, "rectangular": 1, "reduc": 1, "rel": 1, "report": 1, "result": 1, "sensit": 1, "strike": 1, "thin": 2, "triangular": 2, "yield": 1, "deutsch": 1}}, "2284": {"id": "2284", "title": "Solution of the Matrix Equation AX+XB=C [F4] (Algorithm A432)", "authors": "Bartels, R. H. Stewart, G. W.", "words_pool": ["a432", "algorithm", "ax", "equat", "f4", "matrix", "solut", "xb", "bartel", "stewart"], "word_count": {"a432": 1, "algorithm": 1, "ax": 1, "equat": 1, "f4": 1, "matrix": 1, "solut": 1, "xb": 1, "bartel": 1, "stewart": 1}}, "2285": {"id": "2285", "title": "Computer Routine for Quadratic and Linear Programming Problems [H] (Algorithm A431)", "abstract": "A computer program based on Lemke's complementary pivot algorithm is presented.  This can be  used to solve linear and quadratic programming problems.  The program has been extensively tested on a wide range of problems and the results have been extremely satisfactory.", "authors": "Ravindran, A.", "words_pool": ["a431", "algorithm", "base", "complementari", "comput", "extens", "extrem", "lemk", "linear", "pivot", "present", "problem", "program", "program", "quadrat", "rang", "result", "routin", "satisfactori", "solv", "test", "wide", "ravindran"], "word_count": {"a431": 1, "algorithm": 1, "base": 1, "complementari": 1, "comput": 1, "extens": 1, "extrem": 1, "lemk": 1, "linear": 1, "pivot": 1, "present": 1, "problem": 2, "program": 3, "quadrat": 1, "rang": 1, "result": 1, "routin": 1, "satisfactori": 1, "solv": 1, "test": 1, "wide": 1, "ravindran": 1}}, "2286": {"id": "2286", "title": "Automatic Error Analysis for Determining Precision", "abstract": "The problem considered is that of evaluating a rational expression to within any desired tolerance  on a computer which performs variable-precision floating-point arithmetic operations.    An automatic  error analysis technique is given for determining, directly from the results of a trial low-precision  interval arithmetic calculation, just how much precision and data accuracy are required to achieve a  desired final accuracy.  The technique given generalize easily to the evaluation of many nonrational  expressions.", "authors": "Richman, P. L.", "words_pool": ["accuraci", "achiev", "analysi", "arithmet", "automat", "calcul", "comput", "consid", "data", "desir", "determin", "directli", "easili", "error", "evalu", "evalu", "express", "express", "final", "float", "gener", "interv", "low", "nonrat", "oper", "perform", "point", "precis", "problem", "ration", "requir", "result", "techniqu", "toler", "trial", "variabl", "richman"], "word_count": {"accuraci": 2, "achiev": 1, "analysi": 1, "arithmet": 2, "automat": 1, "calcul": 1, "comput": 1, "consid": 1, "data": 1, "desir": 2, "determin": 1, "directli": 1, "easili": 1, "error": 1, "evalu": 2, "express": 2, "final": 1, "float": 1, "gener": 1, "interv": 1, "low": 1, "nonrat": 1, "oper": 1, "perform": 1, "point": 1, "precis": 3, "problem": 1, "ration": 1, "requir": 1, "result": 1, "techniqu": 2, "toler": 1, "trial": 1, "variabl": 1, "richman": 1}}, "2287": {"id": "2287", "title": "A New Approach to Automatic Scanning of Contour Maps", "abstract": "The problem of automatic digitizing of contour maps is discussed.  The structure of a general  contour map is analyzed, and its topological properties are utilized in developing a new scanning algorithm.   The problem of detection and recognition of contour lines is solved by a two color labeling method.   It is shown that for maps containing normal contour lines only, it suffices to distinguish between so-called  \"even\" and \"odd\" lines.  The \"tangency problem\" involved in practical scanning is discussed, and a solution  based on minimizing computer memory space and simplifying control program is suggested.", "authors": "Mor, M. Lamdan, T.", "words_pool": ["algorithm", "analyz", "approach", "automat", "base", "call", "color", "comput", "contour", "control", "detect", "develop", "digit", "discuss", "distinguish", "gener", "involv", "label", "line", "map", "map", "memori", "method", "minim", "normal", "odd", "practic", "problem", "program", "properti", "recognit", "scan", "shown", "simplifi", "solut", "solv", "space", "structur", "suffic", "suggest", "tangenc", "topolog", "util", "mor", "lamdan"], "word_count": {"algorithm": 1, "analyz": 1, "approach": 1, "automat": 1, "base": 1, "call": 1, "color": 1, "comput": 1, "contour": 4, "control": 1, "detect": 1, "develop": 1, "digit": 1, "discuss": 2, "distinguish": 1, "gener": 1, "involv": 1, "label": 1, "line": 3, "map": 3, "memori": 1, "method": 1, "minim": 1, "normal": 1, "odd": 1, "practic": 1, "problem": 3, "program": 1, "properti": 1, "recognit": 1, "scan": 2, "shown": 1, "simplifi": 1, "solut": 1, "solv": 1, "space": 1, "structur": 1, "suffic": 1, "suggest": 1, "tangenc": 1, "topolog": 1, "util": 1, "mor": 1, "lamdan": 1}}, "2288": {"id": "2288", "title": "File Organization: The Consecutive Retrieval Property", "abstract": "The consecutive retrieval property is an important relation between a query set and record  set.  Its existence enables the design of an information retrieval system with a minimal search time  and no redundant storage.  Some important theorems on the consecutive retrieval property are proved in  this paper.  Conditions under which the consecutive retrieval property exists and remain invariant have  been established.  An outline for designing an information retrieval system based on the consecutive  retrieval property is also discussed.", "authors": "Ghosh, S. P.", "words_pool": ["base", "condit", "consecut", "design", "design", "discuss", "enabl", "establish", "exist", "exist", "import", "inform", "invari", "minim", "organ", "outlin", "paper", "properti", "prove", "queri", "record", "redund", "relat", "remain", "retriev", "search", "set", "storag", "system", "theorem", "time", "ghosh"], "word_count": {"base": 1, "condit": 1, "consecut": 4, "design": 2, "discuss": 1, "enabl": 1, "establish": 1, "exist": 2, "import": 2, "inform": 2, "invari": 1, "minim": 1, "organ": 1, "outlin": 1, "paper": 1, "properti": 4, "prove": 1, "queri": 1, "record": 1, "redund": 1, "relat": 1, "remain": 1, "retriev": 6, "search": 1, "set": 2, "storag": 1, "system": 2, "theorem": 1, "time": 1, "ghosh": 1}}, "2289": {"id": "2289", "title": "Cellular Arrays for the Solution of Graph Problems", "abstract": "A cellular array is a two-dimensional, checkerboard type interconnection of identical modules  (or cells), where each cell contains a few bits of memory and a small amount of combinational logic,  and communicates mainly with its immediate neighbors in the array.  The chief computational advantage  offered by cellular arrays is the improvement in speed achieved by virtue of the possibilities for parallel  processing.  In this paper it is shown that cellular arrays are inherently well suited for the solution  of many graph problems.  For example, the adjacency matrix of a graph is easily mapped onto an array;  each matrix element is stored in one cell of the array, and typical row and column operations are readily  implemented by simple cell logic.  A major challenge in the effective use of cellular arrays for the  solution of graph problems is the determination of algorithms that exploit the possibilities for parallelism,  especially for problems whose solutions appear to be inherently serial.  In particular, several parallelized  algorithms are presented for the solution of certain spanning tree, distance, and path problems, with  direct applications to wire routing, PERT chart analysis, and the analysis of many types of networks.   These algorithms exhibit a computation time that in many cases grows at a rate not exceeding log2 n,  where n is the number of nodes in the graph.  Straightforward cellular implementations of the well-known  serial algorithms for these problems require about n steps, and noncellular implementations require from  n^2 to n^3 steps.", "authors": "Levitt, K. N. Kautz, W. H.", "words_pool": ["achiev", "adjac", "advantag", "algorithm", "amount", "analysi", "applic", "array", "array", "bit", "case", "cell", "cell", "cellular", "challeng", "chart", "checkerboard", "chief", "column", "combin", "commun", "comput", "comput", "determin", "dimension", "direct", "distanc", "easili", "effect", "element", "especi", "exceed", "exhibit", "exploit", "graph", "grow", "ident", "implement", "implement", "improv", "inher", "interconnect", "known", "log2", "logic", "mainli", "major", "map", "matrix", "memori", "modul", "neighbor", "network", "node", "noncellular", "number", "offer", "oper", "paper", "parallel", "parallel", "parallel", "path", "pert", "possibl", "present", "problem", "process", "rate", "readili", "requir", "rout", "row", "serial", "shown", "simpl", "small", "solut", "solut", "span", "speed", "step", "store", "straightforward", "suit", "time", "tree", "type", "type", "typic", "virtu", "wire", "levitt", "kautz"], "word_count": {"achiev": 1, "adjac": 1, "advantag": 1, "algorithm": 4, "amount": 1, "analysi": 2, "applic": 1, "array": 7, "bit": 1, "case": 1, "cell": 4, "cellular": 5, "challeng": 1, "chart": 1, "checkerboard": 1, "chief": 1, "column": 1, "combin": 1, "commun": 1, "comput": 2, "determin": 1, "dimension": 1, "direct": 1, "distanc": 1, "easili": 1, "effect": 1, "element": 1, "especi": 1, "exceed": 1, "exhibit": 1, "exploit": 1, "graph": 4, "grow": 1, "ident": 1, "implement": 3, "improv": 1, "inher": 2, "interconnect": 1, "known": 1, "log2": 1, "logic": 2, "mainli": 1, "major": 1, "map": 1, "matrix": 2, "memori": 1, "modul": 1, "neighbor": 1, "network": 1, "node": 1, "noncellular": 1, "number": 1, "offer": 1, "oper": 1, "paper": 1, "parallel": 3, "path": 1, "pert": 1, "possibl": 2, "present": 1, "problem": 5, "process": 1, "rate": 1, "readili": 1, "requir": 2, "rout": 1, "row": 1, "serial": 2, "shown": 1, "simpl": 1, "small": 1, "solut": 4, "span": 1, "speed": 1, "step": 2, "store": 1, "straightforward": 1, "suit": 1, "time": 1, "tree": 1, "type": 2, "typic": 1, "virtu": 1, "wire": 1, "levitt": 1, "kautz": 1}}, "2290": {"id": "2290", "title": "Immediate Predominators in a Directed Graph [H] (Algorithm A430)", "authors": "Purdom Jr., P. W. Moore, E. F.", "words_pool": ["a430", "algorithm", "direct", "graph", "predomin", "purdom", "jr", "moor"], "word_count": {"a430": 1, "algorithm": 1, "direct": 1, "graph": 1, "predomin": 1, "purdom": 1, "jr": 1, "moor": 1}}, "2291": {"id": "2291", "title": "Localization of the Roots of a Polynomial [C2] (Algorithm A429)", "authors": "Squire, W.", "words_pool": ["a429", "algorithm", "c2", "local", "polynomi", "root", "squir"], "word_count": {"a429": 1, "algorithm": 1, "c2": 1, "local": 1, "polynomi": 1, "root": 1, "squir": 1}}, "2292": {"id": "2292", "title": "A Note on the Generation of Rosary Permutations", "authors": "Read, R. C.", "words_pool": ["gener", "note", "permut", "rosari", "read"], "word_count": {"gener": 1, "note": 1, "permut": 1, "rosari": 1, "read": 1}}, "2293": {"id": "2293", "title": "Comment on Average Binary Search Length", "authors": "Jones, P. R.", "words_pool": ["averag", "binari", "comment", "length", "search", "jone"], "word_count": {"averag": 1, "binari": 1, "comment": 1, "length": 1, "search": 1, "jone": 1}}, "2294": {"id": "2294", "title": "A Bonus from van Wijngaarden's Device", "authors": "Morris Jr., J. H.", "words_pool": ["bonu", "devic", "van", "wijngaarden", "morri", "jr"], "word_count": {"bonu": 1, "devic": 1, "van": 1, "wijngaarden": 1, "morri": 1, "jr": 1}}, "2295": {"id": "2295", "title": "Comment on the Composition of Semantics in Algol 68", "authors": "van der Poel, W. L.", "words_pool": ["algol", "comment", "composit", "semant", "van", "der", "poel"], "word_count": {"algol": 1, "comment": 1, "composit": 1, "semant": 1, "van": 1, "der": 1, "poel": 1}}, "2296": {"id": "2296", "title": "Compiling Fixed-Point Multiplications", "authors": "Bernstein, H. J.", "words_pool": ["compil", "fix", "multipl", "point", "bernstein"], "word_count": {"compil": 1, "fix": 1, "multipl": 1, "point": 1, "bernstein": 1}}, "2297": {"id": "2297", "title": "A Model of Memory Contention in a Paging Machine", "abstract": "This paper is concerned with certain aspects of contention for main memory resources in a multiprogrammed  computer system operating under demand paging.  In the model presented, the number of page-frames of  main memory allocated to a problem program varies in time.  These changes in memory configuration are  represented explicitly in the model, CPU requirements and page exception characteristics of program material  being described statistically.  Expressions for the distribution of the number of page-frames allocated  to an executing program, the long run expected fraction of a program's execution time in a given number  of page-frames, and the average execution interval of the multiprogrammed load are obtained.  It is pointed  out heuristically and demonstrated numerically that an increase is obtain able in the average execution  interval of the multiprogrammed load over that resulting from equal fixed partitioning of main memory.", "authors": "Oden, P. H. Shedler, G. S.", "words_pool": ["abl", "alloc", "aspect", "averag", "characterist", "comput", "concern", "configur", "content", "cpu", "demand", "demonstr", "distribut", "equal", "except", "execut", "execut", "expect", "explicitli", "express", "fix", "fraction", "frame", "heurist", "increas", "interv", "load", "long", "machin", "main", "materi", "memori", "model", "multiprogram", "number", "numer", "obtain", "obtain", "oper", "page", "page", "paper", "partit", "point", "present", "problem", "program", "repres", "requir", "resourc", "result", "run", "statist", "system", "time", "vari", "oden", "shedler"], "word_count": {"abl": 1, "alloc": 2, "aspect": 1, "averag": 2, "characterist": 1, "comput": 1, "concern": 1, "configur": 1, "content": 1, "cpu": 1, "demand": 1, "demonstr": 1, "distribut": 1, "equal": 1, "except": 1, "execut": 4, "expect": 1, "explicitli": 1, "express": 1, "fix": 1, "fraction": 1, "frame": 3, "heurist": 1, "increas": 1, "interv": 2, "load": 2, "long": 1, "machin": 1, "main": 3, "materi": 1, "memori": 4, "model": 2, "multiprogram": 3, "number": 3, "numer": 1, "obtain": 2, "oper": 1, "page": 5, "paper": 1, "partit": 1, "point": 1, "present": 1, "problem": 1, "program": 4, "repres": 1, "requir": 1, "resourc": 1, "result": 1, "run": 1, "statist": 1, "system": 1, "time": 2, "vari": 1, "oden": 1, "shedler": 1}}, "2298": {"id": "2298", "title": "An Environment for Research in Microprogramming and Emulation", "abstract": "The development of the research project in microprogramming and emulation at State University  of New York at Buffalo consisted of three phases: the evaluation of various possible machines to support  this research; the decision to purchase one such machine, which appears to be superior to the others  considered; and the organization and definition of goals for each group in the project.  Each of these  phases is reported, with emphasis placed on the early results achieved in this research.", "authors": "Rosin, R. F. Frieder, G. Eckhouse Jr., R. H.", "words_pool": ["achiev", "appear", "buffalo", "consid", "consist", "decis", "definit", "develop", "earli", "emphasi", "emul", "environ", "evalu", "goal", "group", "machin", "machin", "microprogram", "organ", "phase", "project", "purchas", "report", "research", "result", "state", "superior", "support", "univers", "york", "rosin", "frieder", "eckhous", "jr"], "word_count": {"achiev": 1, "appear": 1, "buffalo": 1, "consid": 1, "consist": 1, "decis": 1, "definit": 1, "develop": 1, "earli": 1, "emphasi": 1, "emul": 1, "environ": 1, "evalu": 1, "goal": 1, "group": 1, "machin": 2, "microprogram": 1, "organ": 1, "phase": 2, "project": 2, "purchas": 1, "report": 1, "research": 3, "result": 1, "state": 1, "superior": 1, "support": 1, "univers": 1, "york": 1, "rosin": 1, "frieder": 1, "eckhous": 1, "jr": 1}}, "2299": {"id": "2299", "title": "An Extensible Editor for a Small Machine with Disk Storage", "abstract": "A design philosophy for developing a sophisticated utility program is illustrated by the actual  design and implementation of a text editor.  A versatile data structure is employed so that only a small  number of programmed subroutines are necessary for all types of data manipulation.  Such a data structure  is described, and its merits are illustrated by the ease with which powerful extensions can be implemented  in terms of a few basic editing function.", "authors": "Benjamin, A. J.", "words_pool": ["actual", "basic", "data", "design", "develop", "disk", "eas", "edit", "editor", "employ", "extens", "extens", "function", "illustr", "implement", "implement", "machin", "manipul", "merit", "number", "philosophi", "power", "program", "program", "small", "sophist", "storag", "structur", "subroutin", "term", "text", "type", "util", "versatil", "benjamin"], "word_count": {"actual": 1, "basic": 1, "data": 3, "design": 2, "develop": 1, "disk": 1, "eas": 1, "edit": 1, "editor": 1, "employ": 1, "extens": 1, "function": 1, "illustr": 2, "implement": 2, "machin": 1, "manipul": 1, "merit": 1, "number": 1, "philosophi": 1, "power": 1, "program": 2, "small": 1, "sophist": 1, "storag": 1, "structur": 2, "subroutin": 1, "term": 1, "text": 1, "type": 1, "util": 1, "versatil": 1, "benjamin": 1}}, "2300": {"id": "2300", "title": "Political Redistricting by Computer", "abstract": "The problems of political redistricting are considered and a computer method for redistricting  is presented.  Criteria for acceptable redistricting are discussed, including population equality, compactness,  contiguity, and preservation of natural and/or political boundaries.  Only nonpartisan criteria are considered.   Using 1970 Bureau of Census population data, specific results are given for the ten Congressional Districts  in the state of Missouri and for the seven St. Louis County Council seats.  Results from the use of the  algorithm indicate the feasibility of political redistricting with the aid of a computer.", "authors": "Helbig, R. E. Orr, P. K. Roediger, R. R.", "words_pool": ["accept", "aid", "algorithm", "boundari", "bureau", "censu", "compact", "comput", "congression", "consid", "contigu", "council", "counti", "criteria", "data", "discuss", "district", "equal", "feasibl", "includ", "loui", "method", "missouri", "natur", "nonpartisan", "polit", "popul", "present", "preserv", "problem", "redistrict", "result", "seat", "specif", "st", "state", "ten", "helbig", "orr", "roedig"], "word_count": {"accept": 1, "aid": 1, "algorithm": 1, "boundari": 1, "bureau": 1, "censu": 1, "compact": 1, "comput": 2, "congression": 1, "consid": 2, "contigu": 1, "council": 1, "counti": 1, "criteria": 2, "data": 1, "discuss": 1, "district": 1, "equal": 1, "feasibl": 1, "includ": 1, "loui": 1, "method": 1, "missouri": 1, "natur": 1, "nonpartisan": 1, "polit": 3, "popul": 2, "present": 1, "preserv": 1, "problem": 1, "redistrict": 4, "result": 2, "seat": 1, "specif": 1, "st": 1, "state": 1, "ten": 1, "helbig": 1, "orr": 1, "roedig": 1}}, "2301": {"id": "2301", "title": "Generating Parsers for Affix Grammars", "abstract": "Affix grammars are two-level grammars which are similar to van Wijngaarden's two-level grammars  used in the definition of Algol 68.  Affix grammars are shown by Koster to be equal in power to van Wijngaarden  grammars.  They are much more suited to parsing than are the latter, however.  Koster, the inventor of  affix based on recursive procedures.  This paper presents a bottom-up scheme for parsing them, based  on an extension of Floyd Production Language (FPL).  Included is an algorithm, similar to that of DeRemer's,  for converting a large class of affix grammars into FPL.  The paper concludes by discussing briefly the  applicabilities of the conversion algorithm and affix grammars in general, and some possible extensions  to Koster's definition of affix grammars.", "authors": "Crowe, D.", "words_pool": ["affix", "algol", "algorithm", "applic", "base", "bottom", "briefli", "class", "conclud", "convers", "convert", "definit", "derem", "discuss", "equal", "extens", "extens", "floyd", "fpl", "gener", "gener", "grammar", "includ", "inventor", "koster", "languag", "larg", "level", "paper", "parser", "pars", "power", "present", "procedur", "product", "recurs", "scheme", "shown", "similar", "suit", "van", "wijngaarden", "crow"], "word_count": {"affix": 6, "algol": 1, "algorithm": 2, "applic": 1, "base": 2, "bottom": 1, "briefli": 1, "class": 1, "conclud": 1, "convers": 1, "convert": 1, "definit": 2, "derem": 1, "discuss": 1, "equal": 1, "extens": 2, "floyd": 1, "fpl": 2, "gener": 1, "grammar": 8, "includ": 1, "inventor": 1, "koster": 3, "languag": 1, "larg": 1, "level": 2, "paper": 2, "parser": 1, "pars": 2, "power": 1, "present": 1, "procedur": 1, "product": 1, "recurs": 1, "scheme": 1, "shown": 1, "similar": 2, "suit": 1, "van": 2, "wijngaarden": 2, "crow": 1}}, "2302": {"id": "2302", "title": "Computers and Employment", "abstract": "The relationship of computers and automation to employment is part of the more general relation  of technological change to employment.  The most obvious effect is that increase in productivity due  to technology can eliminate jobs.  Technology affects the individual worker, in the nature and amount  of his work, and in his attitudes toward that work.  Technological change affects the occupational structure  of the entire labor force.  Because of the central importance of these effects, the impact of technology  has been the subject of extensive study by economists, sociologists, political scientists, and psychologists.   Even within a single discipline, studies are often contradictory, and conclusions are colored by political  overtones.  We wish to delineate some of the issues, and present arguments given to support different  viewpoints.", "authors": "Borodin, A. Gotlieb, C. C.", "words_pool": ["affect", "amount", "argument", "attitud", "autom", "central", "chang", "color", "comput", "conclus", "contradictori", "delin", "disciplin", "due", "economist", "effect", "effect", "elimin", "employ", "entir", "extens", "forc", "gener", "impact", "import", "increas", "individu", "issu", "job", "labor", "natur", "obviou", "occup", "overton", "part", "polit", "present", "product", "psychologist", "relat", "relationship", "scientist", "singl", "sociologist", "structur", "studi", "studi", "subject", "support", "technolog", "technolog", "viewpoint", "wish", "work", "worker", "borodin", "gotlieb"], "word_count": {"affect": 2, "amount": 1, "argument": 1, "attitud": 1, "autom": 1, "central": 1, "chang": 2, "color": 1, "comput": 1, "conclus": 1, "contradictori": 1, "delin": 1, "disciplin": 1, "due": 1, "economist": 1, "effect": 2, "elimin": 1, "employ": 2, "entir": 1, "extens": 1, "forc": 1, "gener": 1, "impact": 1, "import": 1, "increas": 1, "individu": 1, "issu": 1, "job": 1, "labor": 1, "natur": 1, "obviou": 1, "occup": 1, "overton": 1, "part": 1, "polit": 2, "present": 1, "product": 1, "psychologist": 1, "relat": 1, "relationship": 1, "scientist": 1, "singl": 1, "sociologist": 1, "structur": 1, "studi": 2, "subject": 1, "support": 1, "technolog": 5, "viewpoint": 1, "wish": 1, "work": 2, "worker": 1, "borodin": 1, "gotlieb": 1}}, "2303": {"id": "2303", "title": "Archaeology of Computers - Reminiscences, 1945-1947", "abstract": "The period preceding the founding of ACM was dominated by the first large computer ENIAC.   Its characteristics, described here, foreshadow later developments.", "authors": "Alt, F. L.", "words_pool": ["acm", "archaeolog", "characterist", "comput", "comput", "develop", "domin", "eniac", "foreshadow", "found", "larg", "later", "period", "preced", "reminisc", "alt"], "word_count": {"acm": 1, "archaeolog": 1, "characterist": 1, "comput": 1, "develop": 1, "domin": 1, "eniac": 1, "foreshadow": 1, "found": 1, "larg": 1, "later": 1, "period": 1, "preced": 1, "reminisc": 1, "alt": 1}}, "2304": {"id": "2304", "title": "A Western View of Computer History", "abstract": "Many U.S. histories of the digital computer field have tended to be impersonal, with heavy  emphasis on eastern universities and commercial developments.  This article records the events of the  early years in a personal way.  The people, organizations, technologies, and computers of the 1945-55  period in the western part of the United Statesare described as they happened.", "authors": "Sprague, R. E.", "words_pool": ["articl", "commerci", "comput", "comput", "develop", "digit", "earli", "eastern", "emphasi", "event", "field", "happen", "heavi", "histori", "histori", "imperson", "organ", "part", "peopl", "period", "person", "record", "statesar", "technolog", "tend", "unit", "univers", "view", "western", "year", "spragu"], "word_count": {"articl": 1, "commerci": 1, "comput": 2, "develop": 1, "digit": 1, "earli": 1, "eastern": 1, "emphasi": 1, "event": 1, "field": 1, "happen": 1, "heavi": 1, "histori": 1, "imperson": 1, "organ": 1, "part": 1, "peopl": 1, "period": 1, "person": 1, "record": 1, "statesar": 1, "technolog": 1, "tend": 1, "unit": 1, "univers": 1, "view": 1, "western": 1, "year": 1, "spragu": 1}}, "2305": {"id": "2305", "title": "The \"Plankalkul\" of Konrad Zuse: A Forerunner of Today's Programming Languages", "abstract": "Plankalkul was an attempt by Korrad Zuse in the 1940's to devise a notational and conceptual  system for writing what today is termed a program.  Although this early approach to a programming language  did not lead to practical use, the plan is described here because it contains features that are standard  in today's programming languages.  The investigation is of historical interest; also, it may provide  insights that would lead to advancements in the state of the art.  Using modern programming terminology,  the Plankalkul is presented to the extent it has possible to reconstruct it from the published literature.", "authors": "Bauer, F. L. Wossner, H.", "words_pool": ["advanc", "approach", "art", "attempt", "conceptu", "devis", "earli", "extent", "featur", "forerunn", "histor", "insight", "interest", "investig", "konrad", "korrad", "languag", "languag", "lead", "literatur", "modern", "notat", "plan", "plankalkul", "practic", "present", "program", "program", "provid", "publish", "reconstruct", "standard", "state", "system", "term", "terminolog", "today", "write", "zuse", "bauer", "wossner"], "word_count": {"advanc": 1, "approach": 1, "art": 1, "attempt": 1, "conceptu": 1, "devis": 1, "earli": 1, "extent": 1, "featur": 1, "forerunn": 1, "histor": 1, "insight": 1, "interest": 1, "investig": 1, "konrad": 1, "korrad": 1, "languag": 2, "lead": 2, "literatur": 1, "modern": 1, "notat": 1, "plan": 1, "plankalkul": 2, "practic": 1, "present": 1, "program": 4, "provid": 1, "publish": 1, "reconstruct": 1, "standard": 1, "state": 1, "system": 1, "term": 1, "terminolog": 1, "today": 2, "write": 1, "zuse": 1, "bauer": 1, "wossner": 1}}, "2306": {"id": "2306", "title": "Ancient Babylonian Algorithms", "abstract": "The early origins of mathematics are discussed, emphasizing those aspects which seem to be  of greatest interest from the standpoint of computer science.  A number of old Babylonian tablets, many  of which have never before been translated into English, are quoted.", "authors": "Knuth, D. E.", "words_pool": ["algorithm", "ancient", "aspect", "babylonian", "comput", "discuss", "earli", "emphas", "english", "greatest", "interest", "mathemat", "number", "origin", "quot", "scienc", "standpoint", "tablet", "translat", "knuth"], "word_count": {"algorithm": 1, "ancient": 1, "aspect": 1, "babylonian": 1, "comput": 1, "discuss": 1, "earli": 1, "emphas": 1, "english": 1, "greatest": 1, "interest": 1, "mathemat": 1, "number": 1, "origin": 1, "quot": 1, "scienc": 1, "standpoint": 1, "tablet": 1, "translat": 1, "knuth": 1}}, "2307": {"id": "2307", "title": "Dynamic Document Processing", "abstract": "The current role of computers in automatic document processing is briefly outlined, and some  reasons are given why the early promise of library automation and of the mechanization of documentation  processes has not been fulfilled.  A new dynamic document environment is then outlined in which clustered files are searched and information is retrieved following an interactive user-controlled search process.   Methods are described for an automatic query modification based on user needs, and for a continuous  reorganization of the stored information as a function of earlier file processing and of normal collection  growth.  The proposed procedures provide powerful tools for information retrieval and for the control  of dynamic library collections in which new items are continually added and old ones are retired.", "authors": "Salton, G.", "words_pool": ["ad", "automat", "autom", "base", "briefli", "cluster", "collect", "collect", "comput", "continu", "continu", "control", "control", "document", "document", "dynam", "earlier", "earli", "environ", "fulfil", "function", "growth", "inform", "interact", "item", "librari", "mechan", "method", "modif", "need", "normal", "outlin", "power", "procedur", "process", "process", "process", "promis", "propos", "provid", "queri", "reason", "reorgan", "retir", "retriev", "retriev", "role", "search", "search", "store", "tool", "user", "salton"], "word_count": {"ad": 1, "automat": 2, "autom": 1, "base": 1, "briefli": 1, "cluster": 1, "collect": 2, "comput": 1, "continu": 2, "control": 2, "document": 3, "dynam": 2, "earlier": 1, "earli": 1, "environ": 1, "fulfil": 1, "function": 1, "growth": 1, "inform": 3, "interact": 1, "item": 1, "librari": 2, "mechan": 1, "method": 1, "modif": 1, "need": 1, "normal": 1, "outlin": 2, "power": 1, "procedur": 1, "process": 4, "promis": 1, "propos": 1, "provid": 1, "queri": 1, "reason": 1, "reorgan": 1, "retir": 1, "retriev": 2, "role": 1, "search": 2, "store": 1, "tool": 1, "user": 2, "salton": 1}}, "2308": {"id": "2308", "title": "Computers and Urban Society", "abstract": "This brief survey of the use of computers in urban society covers the broad range of activities  found in any city.  The future scope of applications is limited only by the imagination and inventiveness  of future system designers, programmers, analysts, and decision makers.  The computer can be, if properly  used, with respect for human dignity and civil liberty, a significant factor in improving the efficiency  of the urban process.  It is expected that the benefits of such computer usage will outweigh the costs  and that we may look forward to an expansion of such usage.", "authors": "Sturman, G. M.", "words_pool": ["activ", "analyst", "applic", "benefit", "broad", "citi", "civil", "comput", "comput", "cost", "cover", "decis", "design", "digniti", "effici", "expans", "expect", "factor", "forward", "found", "futur", "human", "imagin", "improv", "invent", "liberti", "limit", "look", "maker", "outweigh", "process", "programm", "properli", "rang", "respect", "scope", "signific", "societi", "survey", "system", "urban", "usag", "sturman"], "word_count": {"activ": 1, "analyst": 1, "applic": 1, "benefit": 1, "broad": 1, "citi": 1, "civil": 1, "comput": 3, "cost": 1, "cover": 1, "decis": 1, "design": 1, "digniti": 1, "effici": 1, "expans": 1, "expect": 1, "factor": 1, "forward": 1, "found": 1, "futur": 2, "human": 1, "imagin": 1, "improv": 1, "invent": 1, "liberti": 1, "limit": 1, "look": 1, "maker": 1, "outweigh": 1, "process": 1, "programm": 1, "properli": 1, "rang": 1, "respect": 1, "scope": 1, "signific": 1, "societi": 1, "survey": 1, "system": 1, "urban": 2, "usag": 2, "sturman": 1}}, "2309": {"id": "2309", "title": "Computers in the Instructional Process: Directions for Research and Development", "abstract": "A survey is given of computer applications to the instructional process which suggests how  the computer professional can contribute to effective educational systems.", "authors": "Zinn, K. L.", "words_pool": ["applic", "comput", "comput", "contribut", "develop", "direct", "educ", "effect", "instruct", "process", "profession", "research", "suggest", "survey", "system", "zinn"], "word_count": {"applic": 1, "comput": 2, "contribut": 1, "develop": 1, "direct": 1, "educ": 1, "effect": 1, "instruct": 1, "process": 1, "profession": 1, "research": 1, "suggest": 1, "survey": 1, "system": 1, "zinn": 1}}, "2310": {"id": "2310", "title": "hus, for those  areas of the humanities for which rigor and precision are necessary (e.g. analyzing literature or teaching  a student to write a composition) the computer can be a critically important facilitator.", "abstract": "The use of the computer in the language-oriented humanities for exhaustive listing of detail  (as in indices and concordances) is widespread and accepted as desirable.  The implications of the computer  for a \"science\" of the humanities-a science entailing gathering data for the construction and testing  of models-are neither widely recognized nor accepted.  This paper argues that the computer's  major role  as to language analysis in the humanities will be the establishing of such a science", "authors": "Sedelow, S. Y.", "words_pool": ["accept", "analysi", "analyz", "area", "argu", "composit", "comput", "concord", "construct", "critic", "data", "desir", "detail", "entail", "establish", "exhaust", "facilit", "gather", "human", "hu", "implic", "import", "indic", "languag", "list", "literatur", "major", "model", "orient", "paper", "precis", "recogn", "rigor", "role", "scienc", "student", "teach", "test", "wide", "widespread", "write", "sedelow"], "word_count": {"accept": 2, "analysi": 1, "analyz": 1, "area": 1, "argu": 1, "composit": 1, "comput": 3, "concord": 1, "construct": 1, "critic": 1, "data": 1, "desir": 1, "detail": 1, "entail": 1, "establish": 1, "exhaust": 1, "facilit": 1, "gather": 1, "human": 3, "hu": 1, "implic": 1, "import": 1, "indic": 1, "languag": 2, "list": 1, "literatur": 1, "major": 1, "model": 1, "orient": 1, "paper": 1, "precis": 1, "recogn": 1, "rigor": 1, "role": 1, "scienc": 3, "student": 1, "teach": 1, "test": 1, "wide": 1, "widespread": 1, "write": 1, "sedelow": 1}}, "2311": {"id": "2311", "title": "A Generational Perspective of Information System Development", "abstract": "System development is categorized from a generational point of view that parallels the commonly  described computing system generations.  For each generation, the scope of development projects and the  technological world view of the system developer are examined.", "authors": "Benjamin, R. I.", "words_pool": ["categor", "commonli", "comput", "develop", "develop", "examin", "gener", "gener", "gener", "inform", "parallel", "perspect", "point", "project", "scope", "system", "technolog", "view", "world", "benjamin"], "word_count": {"categor": 1, "commonli": 1, "comput": 1, "develop": 3, "examin": 1, "gener": 3, "inform": 1, "parallel": 1, "perspect": 1, "point": 1, "project": 1, "scope": 1, "system": 3, "technolog": 1, "view": 2, "world": 1, "benjamin": 1}}, "2312": {"id": "2312", "title": "On the Present and Future of Scientific Computation", "abstract": "A pessimistic forecast is given of what can be expected to happen in the application of computers  to the physical sciences.", "authors": "Rice, J. R.", "words_pool": ["applic", "comput", "comput", "expect", "forecast", "futur", "happen", "pessimist", "physic", "present", "scienc", "scientif", "rice"], "word_count": {"applic": 1, "comput": 1, "expect": 1, "forecast": 1, "futur": 1, "happen": 1, "pessimist": 1, "physic": 1, "present": 1, "scienc": 1, "scientif": 1, "rice": 1}}, "2313": {"id": "2313", "title": "The Evolution of Storage Structures", "abstract": "Data base management systems have grown rapidly in their power and complexity over the 15-year  history of data processing on commercially available computers.  The original concepts have split, and  new terms have been adopted to name and refer to these concepts.  The Data Structure Diagram graphic  technique is used to illustrate the splitting of the concepts and the structural relations which exist  between these concepts at each point in the evolution.", "authors": "Bachman, C. W.", "words_pool": ["adopt", "base", "commerci", "complex", "comput", "concept", "data", "diagram", "evolut", "exist", "graphic", "grown", "histori", "illustr", "manag", "origin", "point", "power", "process", "rapidli", "refer", "relat", "split", "split", "storag", "structur", "structur", "structur", "system", "techniqu", "term", "year", "bachman"], "word_count": {"adopt": 1, "base": 1, "commerci": 1, "complex": 1, "comput": 1, "concept": 4, "data": 3, "diagram": 1, "evolut": 1, "exist": 1, "graphic": 1, "grown": 1, "histori": 1, "illustr": 1, "manag": 1, "origin": 1, "point": 1, "power": 1, "process": 1, "rapidli": 1, "refer": 1, "relat": 1, "split": 2, "storag": 1, "structur": 2, "system": 1, "techniqu": 1, "term": 1, "year": 1, "bachman": 1}}, "2314": {"id": "2314", "title": "Requirements for Advanced Programming Systems for List Processing", "abstract": "List processing systems should be designed to facilitate production of large programs to manipulate  large complex symbolic data stores.  This paper presents an overview of a number of system features which  the author feels are important to improve the productivity of programmers working in such domains.  A  system view it taken, rather than focusing just on language features, since algorithms must be not only  coded in a language form, but debugged, modified, made efficient, and run on data.  Because of this general  framework,the requirements specified are applicable to the design of advanced programming systems for  a wide range of applications.  Three aspects of programming systems are highlighted: good interactive  facilities, programmable control structures, and sophisticated data communication mechanisms.  Interactive  features are described to facilitate program composition, entry, testing, debugging, editing, optimization,  and packaging.  Implementation of a generalized environment structure model specified would allow programming  of various control regimes including multiprocesses, coroutines and backtracking.  Alternative methods  of procedure invocation required include invocation by pattern and by monitoring condition.  The  need  for extended data forms, storage management, and extensibility are stressed, as is the duality of data  retrieval and function evaluation.  Syntax directed input and output of data would facilitate use of  complex data stores.", "authors": "Bobrow, D. G.", "words_pool": ["advanc", "algorithm", "allow", "altern", "applic", "applic", "aspect", "author", "backtrack", "code", "commun", "complex", "composit", "condit", "control", "coroutin", "data", "debug", "debug", "design", "design", "direct", "domain", "dualiti", "edit", "effici", "entri", "environ", "evalu", "extend", "extens", "facilit", "facil", "featur", "feel", "focus", "form", "form", "framework", "function", "gener", "gener", "good", "highlight", "implement", "import", "improv", "includ", "includ", "input", "interact", "invoc", "languag", "larg", "list", "made", "manag", "manipul", "mechan", "method", "model", "modifi", "monitor", "multiprocess", "need", "number", "optim", "output", "overview", "packag", "paper", "pattern", "present", "procedur", "process", "product", "product", "program", "programm", "programm", "program", "program", "rang", "regim", "requir", "requir", "retriev", "run", "sophist", "storag", "store", "stress", "structur", "structur", "symbol", "syntax", "system", "system", "test", "view", "wide", "work", "bobrow"], "word_count": {"advanc": 1, "algorithm": 1, "allow": 1, "altern": 1, "applic": 2, "aspect": 1, "author": 1, "backtrack": 1, "code": 1, "commun": 1, "complex": 2, "composit": 1, "condit": 1, "control": 2, "coroutin": 1, "data": 7, "debug": 2, "design": 2, "direct": 1, "domain": 1, "dualiti": 1, "edit": 1, "effici": 1, "entri": 1, "environ": 1, "evalu": 1, "extend": 1, "extens": 1, "facilit": 3, "facil": 1, "featur": 3, "feel": 1, "focus": 1, "form": 2, "framework": 1, "function": 1, "gener": 2, "good": 1, "highlight": 1, "implement": 1, "import": 1, "improv": 1, "includ": 2, "input": 1, "interact": 2, "invoc": 2, "languag": 2, "larg": 2, "list": 1, "made": 1, "manag": 1, "manipul": 1, "mechan": 1, "method": 1, "model": 1, "modifi": 1, "monitor": 1, "multiprocess": 1, "need": 1, "number": 1, "optim": 1, "output": 1, "overview": 1, "packag": 1, "paper": 1, "pattern": 1, "present": 1, "procedur": 1, "process": 1, "product": 2, "program": 5, "programm": 2, "rang": 1, "regim": 1, "requir": 2, "retriev": 1, "run": 1, "sophist": 1, "storag": 1, "store": 2, "stress": 1, "structur": 2, "symbol": 1, "syntax": 1, "system": 5, "test": 1, "view": 1, "wide": 1, "work": 1, "bobrow": 1}}, "2315": {"id": "2315", "title": "The Production of Better Mathematical Software", "abstract": "Some observations are made on steps to be taken toward the creation of better mathematical  software.  These steps suggest the need for a coordinated effort and the creation of a center to focus  activities in this area.", "authors": "Fosdick, L. D.", "words_pool": ["activ", "area", "center", "coordin", "creation", "effort", "focu", "made", "mathemat", "need", "observ", "product", "softwar", "step", "suggest", "fosdick"], "word_count": {"activ": 1, "area": 1, "center": 1, "coordin": 1, "creation": 2, "effort": 1, "focu": 1, "made": 1, "mathemat": 1, "need": 1, "observ": 1, "product": 1, "softwar": 1, "step": 2, "suggest": 1, "fosdick": 1}}, "2316": {"id": "2316", "title": "Programming Languages: History and Future", "abstract": "This paper discusses both the history and future of programming languages (= higher level languages).   Some of the difficulties in writing such a history are indicated.  A key part of the paper is a tree  showing the chronological development of languages and their interrelationships.  Reasons for the proliferation  of languages are given.  The major languages are listed with the reasons for their importance.  A section  on chronology indicates the happenings of the significant previous time periods and the major topics  of 1972.  Key concepts other than specific languages are discussed.", "authors": "Sammet, J. E.", "words_pool": ["chronolog", "chronolog", "concept", "develop", "difficulti", "discuss", "discuss", "futur", "happen", "higher", "histori", "import", "interrelationship", "key", "languag", "level", "list", "major", "paper", "part", "period", "previou", "program", "prolifer", "reason", "section", "show", "signific", "specif", "time", "topic", "tree", "write", "sammet"], "word_count": {"chronolog": 2, "concept": 1, "develop": 1, "difficulti": 1, "discuss": 2, "futur": 1, "happen": 1, "higher": 1, "histori": 2, "import": 1, "interrelationship": 1, "key": 2, "languag": 6, "level": 1, "list": 1, "major": 2, "paper": 2, "part": 1, "period": 1, "previou": 1, "program": 1, "prolifer": 1, "reason": 2, "section": 1, "show": 1, "signific": 1, "specif": 1, "time": 1, "topic": 1, "tree": 1, "write": 1, "sammet": 1}}, "2317": {"id": "2317", "title": "Programming Systems and Languages 1965-1975", "abstract": "In spite of impressive gains by PL/I, Fortran and Cobol remain the languages in which most  of the world's production programs are written and will remain so into the foreseeable future.  There  is a great deal of theoretical interest in Algol 68 and in extensible languages, but so far at least  they have had little practical impact.  Problem-oriented languages may very well become the most important  language development area in the next five to ten years.  In the operating system area all major computer  manufacturers set out to produce very ambitious multiprogramming systems, and they all ran into similar  problems.  A number of university projects,though not directly comparable to those of the manufacturers,  have contributed greatly to a better understanding of operating system principles.  Important trends  include the increased interest in the development of system measurement and evaluation techniques,and  increased use of microprogramming for some programming system functions.", "authors": "Rosen, S.", "words_pool": ["algol", "ambiti", "area", "cobol", "compar", "comput", "contribut", "deal", "develop", "directli", "evalu", "extens", "forese", "fortran", "function", "futur", "gain", "great", "greatli", "impact", "import", "impress", "includ", "increas", "interest", "languag", "languag", "major", "manufactur", "measur", "microprogram", "multiprogram", "number", "oper", "orient", "pl", "practic", "principl", "problem", "problem", "produc", "product", "program", "program", "project", "ran", "remain", "set", "similar", "spite", "system", "system", "techniqu", "ten", "theoret", "trend", "understand", "univers", "world", "written", "year", "rosen"], "word_count": {"algol": 1, "ambiti": 1, "area": 2, "cobol": 1, "compar": 1, "comput": 1, "contribut": 1, "deal": 1, "develop": 2, "directli": 1, "evalu": 1, "extens": 1, "forese": 1, "fortran": 1, "function": 1, "futur": 1, "gain": 1, "great": 1, "greatli": 1, "impact": 1, "import": 2, "impress": 1, "includ": 1, "increas": 2, "interest": 2, "languag": 4, "major": 1, "manufactur": 2, "measur": 1, "microprogram": 1, "multiprogram": 1, "number": 1, "oper": 2, "orient": 1, "pl": 1, "practic": 1, "principl": 1, "problem": 2, "produc": 1, "product": 1, "program": 2, "project": 1, "ran": 1, "remain": 2, "set": 1, "similar": 1, "spite": 1, "system": 5, "techniqu": 1, "ten": 1, "theoret": 1, "trend": 1, "understand": 1, "univers": 1, "world": 1, "written": 1, "year": 1, "rosen": 1}}, "2318": {"id": "2318", "title": "The Role of Computer System Models in Performance Evaluation", "abstract": "Models constitute a useful means of investigating computer system performance.  This paper  examines the interrelationships between models and other methods for evaluating the performance of computer  systems and establishes circumstances under which the use of a model is appropriate.", "authors": "Kimbleton, S. R.", "words_pool": ["circumst", "comput", "constitut", "establish", "evalu", "evalu", "examin", "interrelationship", "investig", "mean", "method", "model", "model", "paper", "perform", "role", "system", "system", "kimbleton"], "word_count": {"circumst": 1, "comput": 2, "constitut": 1, "establish": 1, "evalu": 1, "examin": 1, "interrelationship": 1, "investig": 1, "mean": 1, "method": 1, "model": 3, "paper": 1, "perform": 2, "role": 1, "system": 2, "kimbleton": 1}}, "2319": {"id": "2319", "title": "Operating System Performance", "abstract": "An overview of the current and future positions with respect to operating system performance  is given.  While a great deal of information and a large number of models for subsystems have been developed,  gaps still exist in out knowledge.  Because of the severe interactions between the various subsystems  of an operating system, an overall model of the total system must be developed to be able to analyze  and design the performance aspects of an operating system although such total system designs are exceptional  today, it is projected that they will become increasingly more common and necessary in the near future.   Such a design philosophy will clearly have a severe impact on the way we go about modularizing operating  and computer systems.", "authors": "Lynch, W. C.", "words_pool": ["abl", "analyz", "aspect", "clearli", "common", "comput", "deal", "design", "design", "develop", "except", "exist", "futur", "gap", "great", "impact", "increasingli", "inform", "interact", "knowledg", "larg", "model", "model", "modular", "number", "oper", "overview", "perform", "philosophi", "posit", "project", "respect", "sever", "subsystem", "system", "system", "today", "total", "lynch"], "word_count": {"abl": 1, "analyz": 1, "aspect": 1, "clearli": 1, "common": 1, "comput": 1, "deal": 1, "design": 3, "develop": 2, "except": 1, "exist": 1, "futur": 2, "gap": 1, "great": 1, "impact": 1, "increasingli": 1, "inform": 1, "interact": 1, "knowledg": 1, "larg": 1, "model": 2, "modular": 1, "number": 1, "oper": 4, "overview": 1, "perform": 2, "philosophi": 1, "posit": 1, "project": 1, "respect": 1, "sever": 2, "subsystem": 2, "system": 6, "today": 1, "total": 2, "lynch": 1}}, "2320": {"id": "2320", "title": "Structured Multiprogramming", "abstract": "This paper presents a proposal for structured representation of multiprogramming in a high  level language.  The notation used explicitly associates a data structure shared by concurrent processes  with operations defined on it.  This clarifies the meaning of programs and permits a large class of time-dependent  errors to be caught at compile time.  A combination of critical regions and event variables enables the  programmer to control scheduling of resources among competing processes to any degree desired.  These  concepts are sufficiently safe to use not only within operating systems but also within user programs.", "authors": "Hansen, P. B.", "words_pool": ["associ", "caught", "clarifi", "class", "combin", "compet", "compil", "concept", "concurr", "control", "critic", "data", "defin", "degre", "depend", "desir", "enabl", "error", "event", "explicitli", "high", "languag", "larg", "level", "mean", "multiprogram", "notat", "oper", "oper", "paper", "permit", "present", "process", "programm", "program", "propos", "region", "represent", "resourc", "safe", "schedul", "share", "structur", "structur", "suffici", "system", "time", "user", "variabl", "hansen"], "word_count": {"associ": 1, "caught": 1, "clarifi": 1, "class": 1, "combin": 1, "compet": 1, "compil": 1, "concept": 1, "concurr": 1, "control": 1, "critic": 1, "data": 1, "defin": 1, "degre": 1, "depend": 1, "desir": 1, "enabl": 1, "error": 1, "event": 1, "explicitli": 1, "high": 1, "languag": 1, "larg": 1, "level": 1, "mean": 1, "multiprogram": 1, "notat": 1, "oper": 2, "paper": 1, "permit": 1, "present": 1, "process": 2, "programm": 1, "program": 2, "propos": 1, "region": 1, "represent": 1, "resourc": 1, "safe": 1, "schedul": 1, "share": 1, "structur": 2, "suffici": 1, "system": 1, "time": 2, "user": 1, "variabl": 1, "hansen": 1}}, "2321": {"id": "2321", "title": "On the Interface Between Computers and Data Communications Systems", "abstract": "Future systems that combine computers, digital terminals, and communications equipment present  design optimization problems that require reconsideration of the traditional functional responsibilities  of the respective subsystems.  Several \"standard\" interfaces, by means of which computers and digital  terminals connect to the communications systems will be required.  When specifying these interfaces,  consideration must be given to problems of coordination, synchronization, error control, signaling, stream  multiplexing, and switch control, in addition to minimizing the technological interdependence of specific  subsystem designs.  A focus on some of the problems is obtained in a discussion of a detailed specification  for a particular computer-communications system interface.", "authors": "Fraser, A. G.", "words_pool": ["addit", "combin", "commun", "comput", "comput", "connect", "consider", "control", "coordin", "data", "design", "design", "detail", "digit", "discuss", "equip", "error", "focu", "function", "futur", "interdepend", "interfac", "interfac", "mean", "minim", "multiplex", "obtain", "optim", "present", "problem", "reconsider", "requir", "requir", "respect", "respons", "signal", "specif", "specif", "standard", "stream", "subsystem", "subsystem", "switch", "synchron", "system", "system", "technolog", "termin", "tradit", "fraser"], "word_count": {"addit": 1, "combin": 1, "commun": 3, "comput": 3, "connect": 1, "consider": 1, "control": 2, "coordin": 1, "data": 1, "design": 2, "detail": 1, "digit": 2, "discuss": 1, "equip": 1, "error": 1, "focu": 1, "function": 1, "futur": 1, "interdepend": 1, "interfac": 3, "mean": 1, "minim": 1, "multiplex": 1, "obtain": 1, "optim": 1, "present": 1, "problem": 3, "reconsider": 1, "requir": 2, "respect": 1, "respons": 1, "signal": 1, "specif": 2, "standard": 1, "stream": 1, "subsystem": 2, "switch": 1, "synchron": 1, "system": 3, "technolog": 1, "termin": 2, "tradit": 1, "fraser": 1}}, "2322": {"id": "2322", "title": "A View of computer Architecture", "abstract": "An attempt is made to predict the developments of the next 25 years in the field of computer  architecture.  Standardized, inexpensive microcomputers on a single chip are predicted.  These will be  used extensively to provide logical functions for noncomputational devices and incidentally for the design  of superscale computers.", "authors": "Foster, C. C.", "words_pool": ["architectur", "attempt", "chip", "comput", "comput", "design", "develop", "devic", "extens", "field", "function", "incident", "inexpens", "logic", "made", "microcomput", "noncomput", "predict", "predict", "provid", "singl", "standard", "superscal", "view", "year", "foster"], "word_count": {"architectur": 1, "attempt": 1, "chip": 1, "comput": 2, "design": 1, "develop": 1, "devic": 1, "extens": 1, "field": 1, "function": 1, "incident": 1, "inexpens": 1, "logic": 1, "made": 1, "microcomput": 1, "noncomput": 1, "predict": 2, "provid": 1, "singl": 1, "standard": 1, "superscal": 1, "view": 1, "year": 1, "foster": 1}}, "2323": {"id": "2323", "title": "Toward a General Theory of Special Functions", "abstract": "A list of a number of natural developments for the field of algebraic manipulation is given.   Then the prospects for a general theory of functions defined by ordinary differential equations are  discussed.  The claim is made that recent developments in mathematics indicate that it should be possible  to algorithmically generate many properties of solutions to differential equations.  Such a theory is  preferable to a less general effort to make algebraic manipulation systems knowledgeable about the usual  special functions (e.g. exponential, hypergeometric).", "authors": "Moses, J.", "words_pool": ["algebra", "algorithm", "claim", "defin", "develop", "differenti", "discuss", "effort", "equat", "exponenti", "field", "function", "gener", "gener", "hypergeometr", "knowledg", "list", "made", "make", "manipul", "mathemat", "natur", "number", "ordinari", "prefer", "properti", "prospect", "recent", "solut", "special", "system", "theori", "usual", "mose"], "word_count": {"algebra": 2, "algorithm": 1, "claim": 1, "defin": 1, "develop": 2, "differenti": 2, "discuss": 1, "effort": 1, "equat": 2, "exponenti": 1, "field": 1, "function": 2, "gener": 3, "hypergeometr": 1, "knowledg": 1, "list": 1, "made": 1, "make": 1, "manipul": 2, "mathemat": 1, "natur": 1, "number": 1, "ordinari": 1, "prefer": 1, "properti": 1, "prospect": 1, "recent": 1, "solut": 1, "special": 1, "system": 1, "theori": 2, "usual": 1, "mose": 1}}, "2324": {"id": "2324", "title": "Management Science: A View from Nonlinear Programming", "abstract": "A brief history of integer and continuous nonlinear programming is presented as well as the  current obstacles to practical use of these mathematical programming techniques.  It is forecast that  the useful contributions to nonlinear programming actually made in the next few years are more likely  to be consolidations than theoretical breakthroughs.  These contributions are likely to be the documentation  of standard test problems, construction of user oriented software, and comparisons of currently known  algorithms to demonstrate which techniques are best for specific problems.", "authors": "Shanno, D. F. Weil, R. L.", "words_pool": ["actual", "algorithm", "breakthrough", "comparison", "consolid", "construct", "continu", "contribut", "demonstr", "document", "forecast", "histori", "integ", "known", "like", "made", "manag", "mathemat", "nonlinear", "obstacl", "orient", "practic", "present", "problem", "program", "scienc", "softwar", "specif", "standard", "techniqu", "test", "theoret", "user", "view", "year", "shanno", "weil"], "word_count": {"actual": 1, "algorithm": 1, "breakthrough": 1, "comparison": 1, "consolid": 1, "construct": 1, "continu": 1, "contribut": 2, "demonstr": 1, "document": 1, "forecast": 1, "histori": 1, "integ": 1, "known": 1, "like": 2, "made": 1, "manag": 1, "mathemat": 1, "nonlinear": 2, "obstacl": 1, "orient": 1, "practic": 1, "present": 1, "problem": 2, "program": 3, "scienc": 1, "softwar": 1, "specif": 1, "standard": 1, "techniqu": 2, "test": 1, "theoret": 1, "user": 1, "view": 1, "year": 1, "shanno": 1, "weil": 1}}, "2325": {"id": "2325", "title": "Numerical Mathematics and Computer Science", "abstract": "Numerical mathematics is viewed as the analysis of continuous algorithms.  Four of the components  of numerical mathematics are discussed.  These are: foundations (finite precision number systems, computational  complexity), synthesis and analysis of algorithms, analysis of error, programs and program libraries.", "authors": "Traub, J. F.", "words_pool": ["algorithm", "analysi", "complex", "compon", "comput", "comput", "continu", "discuss", "error", "finit", "foundat", "librari", "mathemat", "number", "numer", "precis", "program", "program", "scienc", "synthesi", "system", "view", "traub"], "word_count": {"algorithm": 2, "analysi": 3, "complex": 1, "compon": 1, "comput": 1, "continu": 1, "discuss": 1, "error": 1, "finit": 1, "foundat": 1, "librari": 1, "mathemat": 2, "number": 1, "numer": 2, "precis": 1, "program": 2, "scienc": 1, "synthesi": 1, "system": 1, "view": 1, "traub": 1}}, "2326": {"id": "2326", "title": "Fix point Approach to the Theory of Computation", "abstract": "Following the fix point theory of Scott, the semantics of computer programs are defined in terms  of the least fix points of recursive programs.  This allows not only the justification of all existing  verification techniques, but also their extension to the handling, in a uniform manner of various properties  of computer programs, including correctness, termination, and equivalence.", "authors": "Manna, Z. Vuillemin, J.", "words_pool": ["approach", "comput", "comput", "correct", "defin", "equival", "exist", "extens", "fix", "handl", "includ", "justif", "manner", "point", "point", "program", "properti", "recurs", "scott", "semant", "techniqu", "termin", "term", "theori", "uniform", "verif", "manna", "vuillemin"], "word_count": {"approach": 1, "comput": 2, "correct": 1, "defin": 1, "equival": 1, "exist": 1, "extens": 1, "fix": 2, "handl": 1, "includ": 1, "justif": 1, "manner": 1, "point": 2, "program": 3, "properti": 1, "recurs": 1, "scott": 1, "semant": 1, "techniqu": 1, "termin": 1, "term": 1, "theori": 1, "uniform": 1, "verif": 1, "manna": 1, "vuillemin": 1}}, "2327": {"id": "2327", "title": "Toward an Automata Theory of Brains", "abstract": "A source of ideas for automata theory-the study of the brain-has been pushed aside in mathematical  development of the theory.  This paper suggests the ways in which automata theory might evolve over the  next 25 years if it is to contribute to an understanding of how the brain processes information.", "authors": "Arbib, M. A.", "words_pool": ["automata", "brain", "brain", "contribut", "develop", "evolv", "idea", "inform", "mathemat", "paper", "process", "push", "sourc", "studi", "suggest", "theori", "understand", "way", "year", "arbib"], "word_count": {"automata": 2, "brain": 2, "contribut": 1, "develop": 1, "evolv": 1, "idea": 1, "inform": 1, "mathemat": 1, "paper": 1, "process": 1, "push": 1, "sourc": 1, "studi": 1, "suggest": 1, "theori": 3, "understand": 1, "way": 1, "year": 1, "arbib": 1}}, "2328": {"id": "2328", "title": "Individualizing Instruction in a Generative CAI Tutor", "authors": "Koffman, E. B.", "words_pool": ["cai", "gener", "individu", "instruct", "tutor", "koffman"], "word_count": {"cai": 1, "gener": 1, "individu": 1, "instruct": 1, "tutor": 1, "koffman": 1}}, "2329": {"id": "2329", "title": "Computer Science-A Vicious Circle", "authors": "Kandel, A.", "words_pool": ["circl", "comput", "scienc", "viciou", "kandel"], "word_count": {"circl": 1, "comput": 1, "scienc": 1, "viciou": 1, "kandel": 1}}, "2330": {"id": "2330", "title": "Calculation of Fourier Integrals (Algorithm R418)", "authors": "Einarsson, B.", "words_pool": ["algorithm", "calcul", "fourier", "integr", "r418", "einarsson"], "word_count": {"algorithm": 1, "calcul": 1, "fourier": 1, "integr": 1, "r418": 1, "einarsson": 1}}, "2331": {"id": "2331", "title": "An Integer Programming Problem (Algorithm R397)", "authors": "Johnson, S. C. Kernighan, B. W.", "words_pool": ["algorithm", "integ", "problem", "program", "r397", "johnson", "kernighan"], "word_count": {"algorithm": 1, "integ": 1, "problem": 1, "program": 1, "r397": 1, "johnson": 1, "kernighan": 1}}, "2332": {"id": "2332", "title": "Special Series Summation with Arbitrary Precision (Algorithm R393)", "authors": "Sale, A. H. J.", "words_pool": ["algorithm", "arbitrari", "precis", "r393", "seri", "special", "summat", "sale"], "word_count": {"algorithm": 1, "arbitrari": 1, "precis": 1, "r393": 1, "seri": 1, "special": 1, "summat": 1, "sale": 1}}, "2333": {"id": "2333", "title": "Random Vectors Uniform is Solid Angle (Algorithm R381)", "authors": "Schrack, G. F.", "words_pool": ["algorithm", "angl", "r381", "random", "solid", "uniform", "vector", "schrack"], "word_count": {"algorithm": 1, "angl": 1, "r381": 1, "random": 1, "solid": 1, "uniform": 1, "vector": 1, "schrack": 1}}, "2334": {"id": "2334", "title": "General Random Number Generator (Algorithm R370)", "authors": "Proll, L. G.", "words_pool": ["algorithm", "gener", "gener", "number", "r370", "random", "proll"], "word_count": {"algorithm": 1, "gener": 2, "number": 1, "r370": 1, "random": 1, "proll": 1}}, "2335": {"id": "2335", "title": "Eigenvalues and Eigenvectors of a Real General matrix (Algorithm R343)", "authors": "Niessner, H.", "words_pool": ["algorithm", "eigenvalu", "eigenvector", "gener", "matrix", "r343", "real", "niessner"], "word_count": {"algorithm": 1, "eigenvalu": 1, "eigenvector": 1, "gener": 1, "matrix": 1, "r343": 1, "real": 1, "niessner": 1}}, "2336": {"id": "2336", "title": "Complex Error Function (Algorithm C363)", "authors": "Kolbig, K. S.", "words_pool": ["algorithm", "c363", "complex", "error", "function", "kolbig"], "word_count": {"algorithm": 1, "c363": 1, "complex": 1, "error": 1, "function": 1, "kolbig": 1}}, "2337": {"id": "2337", "title": "A Sorting Problem and Its Complexity", "abstract": "A technique for proving min-max norms of sorting algorithms is given.  One new algorithm for  finding the minimum and maximum elements of a set with fewest comparisons is proved optimal with this  technique.", "authors": "Pohl, I.", "words_pool": ["algorithm", "algorithm", "comparison", "complex", "element", "fewest", "find", "max", "maximum", "min", "minimum", "norm", "optim", "problem", "prove", "prove", "set", "sort", "techniqu", "pohl"], "word_count": {"algorithm": 2, "comparison": 1, "complex": 1, "element": 1, "fewest": 1, "find": 1, "max": 1, "maximum": 1, "min": 1, "minimum": 1, "norm": 1, "optim": 1, "problem": 1, "prove": 2, "set": 1, "sort": 1, "techniqu": 2, "pohl": 1}}, "2338": {"id": "2338", "title": "A Starting Method for Solving Nonlinear Volterra Integral Equations of the Second Kind", "abstract": "A fourth-order starting method is given for Volterra integral equations of the second kind  and numerical examples are presented.", "authors": "Iguchi, K.", "words_pool": ["equat", "exampl", "fourth", "integr", "kind", "method", "nonlinear", "numer", "order", "present", "solv", "start", "volterra", "iguchi"], "word_count": {"equat": 1, "exampl": 1, "fourth": 1, "integr": 1, "kind": 1, "method": 1, "nonlinear": 1, "numer": 1, "order": 1, "present": 1, "solv": 1, "start": 1, "volterra": 1, "iguchi": 1}}, "2339": {"id": "2339", "title": "Computer-Assigned Codes from Verbal Responses", "abstract": "It is often desirable to convert verbal responses to multidigit codes. This conversion is generally  accomplished by clerk-coders.  A study was conducted to test the feasibility of translating verbal descriptions  to numerical codes in a computer program.  Primary emphasis was placed on computerized construction of  a reference file of verbal descriptions for use by the program.  The results of the study clearly show  that such procedures are feasible.", "authors": "O'Reagan, R. T.", "words_pool": ["accomplish", "assign", "clearli", "clerk", "coder", "code", "comput", "computer", "conduct", "construct", "convers", "convert", "descript", "desir", "emphasi", "feasibl", "feasibl", "gener", "multidigit", "numer", "primari", "procedur", "program", "refer", "respons", "result", "show", "studi", "test", "translat", "verbal", "reagan"], "word_count": {"accomplish": 1, "assign": 1, "clearli": 1, "clerk": 1, "coder": 1, "code": 2, "comput": 1, "computer": 1, "conduct": 1, "construct": 1, "convers": 1, "convert": 1, "descript": 2, "desir": 1, "emphasi": 1, "feasibl": 2, "gener": 1, "multidigit": 1, "numer": 1, "primari": 1, "procedur": 1, "program": 2, "refer": 1, "respons": 1, "result": 1, "show": 1, "studi": 2, "test": 1, "translat": 1, "verbal": 3, "reagan": 1}}, "2340": {"id": "2340", "title": "A Boolean Matrix Method for the Computation of Linear Precedence Functions", "abstract": "A modified version of Bell's Boolean matrix method for the computation of linear precedence  functions associated with a conflict-free matrix of precedence relations is given.  This algorithm not  only detects when the precedence functions do not  exist, but also provides an indication of why they  do not exist, so that corrective action can be taken if possible.  Necessary and sufficient conditions  for the existence of precedence functions are given.  The use of Boolean matrices to prove the existence  of precedence functions associated with classes of conflict-free grammars is illustrated through an example.", "authors": "Martin, D. F.", "words_pool": ["action", "algorithm", "bell", "boolean", "class", "comput", "condit", "conflict", "correct", "detect", "exist", "exist", "free", "function", "grammar", "illustr", "indic", "linear", "matric", "matrix", "method", "modifi", "preced", "prove", "relat", "suffici", "version", "martin"], "word_count": {"action": 1, "algorithm": 1, "bell": 1, "boolean": 2, "class": 1, "comput": 1, "condit": 1, "conflict": 2, "correct": 1, "detect": 1, "exist": 4, "free": 2, "function": 4, "grammar": 1, "illustr": 1, "indic": 1, "linear": 1, "matric": 1, "matrix": 2, "method": 1, "modifi": 1, "preced": 5, "prove": 1, "relat": 1, "suffici": 1, "version": 1, "martin": 1}}, "2341": {"id": "2341", "title": "hat is, blocks require  little in the way of specialized syntax and could readily be absorbed into the external structure of  most programming languages.", "abstract": "A new data type, called a block, has been implemented for SNOBOL4.  A block is a three-dimensional  aggregate of characters in the form of a right parallelepiped, best thought of as a three-dimensional  extension to a string.  (The third dimension is used for overstriking.)  Blocks may be printed, concatenated  in any of three dimensions, and merged on the basis of program-defined connection points.  Some blocks  adapt in size and shape to their environment.  Blocks and their operations are mainly used for composing  printable output.  A variety of graphical problems (including flowcharting, bargraphs, logic diagrams,  mathematical-equation formation, and text justification and preparation) have been programmed on a printer  in what appears to be an easy and natural way.  In addition to these somewhat specialized applications,  blocks appear to be a good general purpose device-independent output formation mechanism especially suitable  for nonnumerical work.  The concept of a block is largely language independent", "authors": "Gimpel, J. F.", "words_pool": ["absorb", "adapt", "addit", "aggreg", "appear", "applic", "bargraph", "basi", "block", "block", "call", "charact", "compos", "concaten", "concept", "connect", "data", "defin", "devic", "diagram", "dimens", "dimension", "dimens", "easi", "environ", "equat", "especi", "extens", "extern", "flowchart", "form", "format", "gener", "good", "graphic", "hat", "implement", "includ", "independ", "justif", "languag", "languag", "larg", "logic", "mainli", "mathemat", "mechan", "merg", "natur", "nonnumer", "oper", "output", "overstrik", "parallelepip", "point", "prepar", "printabl", "print", "printer", "problem", "program", "program", "program", "purpos", "readili", "requir", "shape", "size", "snobol4", "special", "string", "structur", "suitabl", "syntax", "text", "thought", "type", "varieti", "work", "gimpel"], "word_count": {"absorb": 1, "adapt": 1, "addit": 1, "aggreg": 1, "appear": 1, "applic": 1, "bargraph": 1, "basi": 1, "block": 7, "call": 1, "charact": 1, "compos": 1, "concaten": 1, "concept": 1, "connect": 1, "data": 1, "defin": 1, "devic": 1, "diagram": 1, "dimens": 2, "dimension": 2, "easi": 1, "environ": 1, "equat": 1, "especi": 1, "extens": 1, "extern": 1, "flowchart": 1, "form": 1, "format": 2, "gener": 1, "good": 1, "graphic": 1, "hat": 1, "implement": 1, "includ": 1, "independ": 2, "justif": 1, "languag": 1, "larg": 1, "logic": 1, "mainli": 1, "mathemat": 1, "mechan": 1, "merg": 1, "natur": 1, "nonnumer": 1, "oper": 1, "output": 2, "overstrik": 1, "parallelepip": 1, "point": 1, "prepar": 1, "printabl": 1, "print": 1, "printer": 1, "problem": 1, "program": 2, "purpos": 1, "readili": 1, "requir": 1, "shape": 1, "size": 1, "snobol4": 1, "special": 1, "string": 1, "structur": 1, "suitabl": 1, "syntax": 1, "text": 1, "thought": 1, "type": 1, "varieti": 1, "work": 1, "gimpel": 1}}, "2342": {"id": "2342", "title": "Interference Between Communicating Parallel Processes", "abstract": "Various kinds of interference between communicating parallel processes have been examined by  Dijkstra, Knuth, and others.  Solutions have been given for the mutual exclusion problem and associated  subproblems, in the form of parallel programs, and informal proofs of correctness have been given for  these solutions.  In this paper a system of parallel processes is regarded as a machine which proceeds  from one state S (i.e. a collection of pertinent data values and process configurations) to a next state  S' in accordance with a transition rule S --> S'.  A set of such rules yields sequences of states, which  dictate the system's behavior.  The mutual exclusion problem and the associated subproblems are formulated  as questions of inclusion between sets of states, or of the existence of certain sequences.  A mechanical  proof procedure is shown, which will either verify (prove the correctness of ) or discredit (prove the  incorrectness of) an attempted solution, with respect to any of the interference properties.  It is shown  how to calculate transition rules from the \"partial rules\" by which the individual processes operate.   The formation of partial rules and the calculation of transition rules are both applicable to hardware  processes as well as to software processes, and symmetry between processes is not required.", "authors": "Gilbert, P. Chandler, W. J.", "words_pool": ["accord", "applic", "attempt", "behavior", "calcul", "calcul", "collect", "commun", "configur", "correct", "data", "dictat", "dijkstra", "discredit", "examin", "exclus", "exist", "form", "format", "formul", "hardwar", "inclus", "incorrect", "individu", "inform", "interfer", "kind", "knuth", "machin", "mechan", "mutual", "oper", "paper", "parallel", "partial", "pertin", "problem", "procedur", "proce", "process", "process", "program", "proof", "proof", "properti", "prove", "question", "regard", "requir", "respect", "rule", "rule", "sequenc", "set", "set", "shown", "softwar", "solut", "solut", "state", "state", "subproblem", "symmetri", "system", "transit", "valu", "verifi", "yield", "gilbert", "chandler"], "word_count": {"accord": 1, "applic": 1, "attempt": 1, "behavior": 1, "calcul": 2, "collect": 1, "commun": 1, "configur": 1, "correct": 2, "data": 1, "dictat": 1, "dijkstra": 1, "discredit": 1, "examin": 1, "exclus": 2, "exist": 1, "form": 1, "format": 1, "formul": 1, "hardwar": 1, "inclus": 1, "incorrect": 1, "individu": 1, "inform": 1, "interfer": 2, "kind": 1, "knuth": 1, "machin": 1, "mechan": 1, "mutual": 2, "oper": 1, "paper": 1, "parallel": 3, "partial": 2, "pertin": 1, "problem": 2, "procedur": 1, "proce": 1, "process": 7, "program": 1, "proof": 2, "properti": 1, "prove": 2, "question": 1, "regard": 1, "requir": 1, "respect": 1, "rule": 6, "sequenc": 2, "set": 2, "shown": 2, "softwar": 1, "solut": 3, "state": 4, "subproblem": 2, "symmetri": 1, "system": 2, "transit": 3, "valu": 1, "verifi": 1, "yield": 1, "gilbert": 1, "chandler": 1}}, "2343": {"id": "2343", "title": "A Proposal To Establish a Pseudo Virtual Memory via Writable Overlays", "abstract": "Many computer systems solve executable storage size problems for large programs by using overlays.   However, it appears that no one overlay scheme contains a well-balanced combination of the most useful  capabilities which are found in various existing techniques.  A proposal is presented which utilizes  several of the best capabilities from existing schemes and is complemented by several additional features,  e.g. writable overlays.  The writable overlay capability provides a virtual memory effect, although the  programmer may still be required to design the overlay configuration.  Since overlay structuring is a  complex task, several tools (including a graphic display) are included in the proposal in order to aid  the programmer in the design.  The content of overlays is briefly discussed, and it is noted that many  of the details of the final overlay configuration may be decided after the fact.", "authors": "Spacek, T. R.", "words_pool": ["addit", "aid", "appear", "balanc", "briefli", "capabl", "capabl", "combin", "complement", "complex", "comput", "configur", "content", "decid", "design", "detail", "discuss", "display", "effect", "establish", "execut", "exist", "fact", "featur", "final", "found", "graphic", "includ", "includ", "larg", "memori", "note", "order", "overlay", "overlay", "present", "problem", "programm", "program", "propos", "pseudo", "requir", "scheme", "scheme", "size", "solv", "storag", "structur", "system", "task", "techniqu", "tool", "util", "virtual", "writabl", "spacek"], "word_count": {"addit": 1, "aid": 1, "appear": 1, "balanc": 1, "briefli": 1, "capabl": 3, "combin": 1, "complement": 1, "complex": 1, "comput": 1, "configur": 2, "content": 1, "decid": 1, "design": 2, "detail": 1, "discuss": 1, "display": 1, "effect": 1, "establish": 1, "execut": 1, "exist": 2, "fact": 1, "featur": 1, "final": 1, "found": 1, "graphic": 1, "includ": 2, "larg": 1, "memori": 1, "note": 1, "order": 1, "overlay": 8, "present": 1, "problem": 1, "programm": 2, "program": 1, "propos": 2, "pseudo": 1, "requir": 1, "scheme": 2, "size": 1, "solv": 1, "storag": 1, "structur": 1, "system": 1, "task": 1, "techniqu": 1, "tool": 1, "util": 1, "virtual": 1, "writabl": 2, "spacek": 1}}, "2344": {"id": "2344", "title": "On the Optimization of Performance of Time-Sharing Systems by Simulation", "abstract": "A simulation model of a time-sharing system with a finite noncontiguous store and an infinite  auxiliary store is used to study the variation of system parameters such as store size, number of jobs  allowed to execute simultaneously, job-scheduling algorithm, etc.  The effects of these variations on  a measure of system performance is used to ascertain which of the parameters controllable by the job-scheduling  algorithm, including the scheduling itself, require optimization, and which of the parameters not normally  controllable by the scheduling algorithm have a marked effect on system performance.  System performance  is based upon the mean cost of delay to all jobs processed.  It is shown that significant improvements  in the measure of system performance can be obtained by using variable time-slice techniques and by selecting  the optimum round-robin cycle time.  It appears that these features would benefit from optimization whereas  other parameters controllable by the scheduling algorithm affect system performance in a predictable  manner and would not benefit from optimization.  Features not normally under the control of the scheduling  algorithm can also have a marked effect on the measure of performance; in particular, supervisor overheads,  the size of the store, and the speed of the CPU.  A comparison is made between the results of the simulation  model and two analytical equations for quantum-oriented nonpreemptive time-sharing systems.  The comparison  is found to be very favorable.", "authors": "Blatny, J. Clark, S. R. Rourke, T. A.", "words_pool": ["affect", "algorithm", "allow", "analyt", "appear", "ascertain", "auxiliari", "base", "benefit", "comparison", "control", "control", "cost", "cpu", "cycl", "delay", "effect", "effect", "equat", "execut", "favor", "featur", "finit", "found", "improv", "includ", "infinit", "job", "job", "made", "manner", "mark", "mean", "measur", "model", "noncontigu", "nonpreempt", "number", "obtain", "optim", "optimum", "orient", "overhead", "paramet", "perform", "predict", "process", "quantum", "requir", "result", "robin", "round", "schedul", "select", "share", "shown", "signific", "simul", "simultan", "size", "slice", "speed", "store", "studi", "supervisor", "system", "system", "techniqu", "time", "variabl", "variat", "variat", "blatni", "clark", "rourk"], "word_count": {"affect": 1, "algorithm": 5, "allow": 1, "analyt": 1, "appear": 1, "ascertain": 1, "auxiliari": 1, "base": 1, "benefit": 2, "comparison": 2, "control": 4, "cost": 1, "cpu": 1, "cycl": 1, "delay": 1, "effect": 3, "equat": 1, "execut": 1, "favor": 1, "featur": 2, "finit": 1, "found": 1, "improv": 1, "includ": 1, "infinit": 1, "job": 4, "made": 1, "manner": 1, "mark": 2, "mean": 1, "measur": 3, "model": 2, "noncontigu": 1, "nonpreempt": 1, "number": 1, "obtain": 1, "optim": 3, "optimum": 1, "orient": 1, "overhead": 1, "paramet": 4, "perform": 6, "predict": 1, "process": 1, "quantum": 1, "requir": 1, "result": 1, "robin": 1, "round": 1, "schedul": 6, "select": 1, "share": 2, "shown": 1, "signific": 1, "simul": 2, "simultan": 1, "size": 2, "slice": 1, "speed": 1, "store": 4, "studi": 1, "supervisor": 1, "system": 8, "techniqu": 1, "time": 4, "variabl": 1, "variat": 2, "blatni": 1, "clark": 1, "rourk": 1}}, "2345": {"id": "2345", "title": "Curriculum Recommendations for Graduate Professional Programs in Information Systems", "abstract": "The need for education related to information systems in organizations is discussed, and a  curriculum is proposed for graduate professional programs in universities, at the Master's level.  Material  necessary for such programs is identified, and courses incorporating it are specified.  Detailed course  descriptions are presented, program organization discussed, and implementation questions considered.", "authors": "Ashenhurst, R. L.", "words_pool": ["consid", "cours", "cours", "curriculum", "descript", "detail", "discuss", "educ", "graduat", "identifi", "implement", "incorpor", "inform", "level", "master", "materi", "need", "organ", "organ", "present", "profession", "program", "program", "propos", "question", "recommend", "relat", "system", "univers", "ashenhurst"], "word_count": {"consid": 1, "cours": 2, "curriculum": 1, "descript": 1, "detail": 1, "discuss": 2, "educ": 1, "graduat": 1, "identifi": 1, "implement": 1, "incorpor": 1, "inform": 1, "level": 1, "master": 1, "materi": 1, "need": 1, "organ": 2, "present": 1, "profession": 1, "program": 3, "propos": 1, "question": 1, "recommend": 1, "relat": 1, "system": 1, "univers": 1, "ashenhurst": 1}}, "2346": {"id": "2346", "title": "Hu-Tucker Minimum Redundancy Alphabetic Coding Method [Z] (Algorithm A428)", "authors": "Yohe, J. M.", "words_pool": ["a428", "algorithm", "alphabet", "code", "hu", "method", "minimum", "redund", "tucker", "yohe"], "word_count": {"a428": 1, "algorithm": 1, "alphabet": 1, "code": 1, "hu": 1, "method": 1, "minimum": 1, "redund": 1, "tucker": 1, "yohe": 1}}, "2347": {"id": "2347", "title": "Fourier Cosine Integral [D1] (Algorithm A427)", "authors": "Linz, P.", "words_pool": ["a427", "algorithm", "cosin", "d1", "fourier", "integr", "linz"], "word_count": {"a427": 1, "algorithm": 1, "cosin": 1, "d1": 1, "fourier": 1, "integr": 1, "linz": 1}}, "2348": {"id": "2348", "title": "Merge Sort Algorithm [M1] (Algorithm A426)", "authors": "Bron, C.", "words_pool": ["a426", "algorithm", "m1", "merg", "sort", "bron"], "word_count": {"a426": 1, "algorithm": 2, "m1": 1, "merg": 1, "sort": 1, "bron": 1}}, "2349": {"id": "2349", "title": "Generation of Random Correlated Normal Variables [G5] (Algorithm A425)", "authors": "Hurst, R. L. Knop, R. E.", "words_pool": ["a425", "algorithm", "correl", "g5", "gener", "normal", "random", "variabl", "hurst", "knop"], "word_count": {"a425": 1, "algorithm": 1, "correl": 1, "g5": 1, "gener": 1, "normal": 1, "random": 1, "variabl": 1, "hurst": 1, "knop": 1}}, "2350": {"id": "2350", "title": "Clenshaw-Curtis Quadrature [D1] (Algorithm A424)", "authors": "Gentleman, W.M.", "words_pool": ["a424", "algorithm", "clenshaw", "curti", "d1", "quadratur", "gentleman"], "word_count": {"a424": 1, "algorithm": 1, "clenshaw": 1, "curti": 1, "d1": 1, "quadratur": 1, "gentleman": 1}}, "2351": {"id": "2351", "title": "The Optimality of Winograd's Formula", "authors": "Harter, R.", "words_pool": ["formula", "optim", "winograd", "harter"], "word_count": {"formula": 1, "optim": 1, "winograd": 1, "harter": 1}}, "2352": {"id": "2352", "title": "Minimax Nonlinear Approximation by Approximation on Subsets", "authors": "Dunham, C. B.", "words_pool": ["approxim", "minimax", "nonlinear", "subset", "dunham"], "word_count": {"approxim": 2, "minimax": 1, "nonlinear": 1, "subset": 1, "dunham": 1}}, "2353": {"id": "2353", "title": "Fast Finite-Difference Solution of Biharmonic Problems", "abstract": "Setting the Reynolds number equal to zero, in a method for solving the Navier-Strokes equations  numerically, results in a fast numerical method for biharmonic problems.  The equation is treated as  a system of two second order equations and a simple smoothing process is essential for convergence.   An application is made to a crack-type problem.", "authors": "Greenspan, D. Schultz, D.", "words_pool": ["applic", "biharmon", "converg", "crack", "differ", "equal", "equat", "equat", "essenti", "fast", "finit", "made", "method", "navier", "number", "numer", "numer", "order", "problem", "problem", "process", "result", "reynold", "set", "simpl", "smooth", "solut", "solv", "stroke", "system", "treat", "type", "greenspan", "schultz"], "word_count": {"applic": 1, "biharmon": 1, "converg": 1, "crack": 1, "differ": 1, "equal": 1, "equat": 3, "essenti": 1, "fast": 1, "finit": 1, "made": 1, "method": 2, "navier": 1, "number": 1, "numer": 2, "order": 1, "problem": 2, "process": 1, "result": 1, "reynold": 1, "set": 1, "simpl": 1, "smooth": 1, "solut": 1, "solv": 1, "stroke": 1, "system": 1, "treat": 1, "type": 1, "greenspan": 1, "schultz": 1}}, "2354": {"id": "2354", "title": "Implementing Clenshaw-Curtis Quadrature, II Computing the Cosine Transformation", "abstract": "In a companion paper to this, \"I Methodology and Experiences,\" the automatic Clenshaw-Curtis  quadrature scheme was described and how each quadrature formula used in the scheme requires a cosine  transformation of the integrand values was shown.  The high cost of these cosine transformations has  been a serious drawback in using Clenshaw-Curtis quadrature.  Two other problems related to the cosine  transformation have also been trouble some.  First, the conventional computation of the cosine transformation  by recurrence relation is numerically unstable, particularly at the low frequencies which have the largest  effect upon the integral.  Second, in case the automatic scheme should require refinement of the sampling,  storage is required to save the integrand values after the cosine transformation is computed.  This second  part of the paper shows how the cosine transformation can be computed by a modification of the fast Fourier  transform and all three problems overcome.  The modification is also applicable in other circumstances  requiring cosine or sine transformations, such as polynomial interpolation through the Chebyshev points.", "authors": "Gentleman, W. M.", "words_pool": ["applic", "automat", "case", "chebyshev", "circumst", "clenshaw", "companion", "comput", "comput", "comput", "convent", "cosin", "cost", "curti", "drawback", "effect", "experi", "fast", "formula", "fourier", "frequenc", "high", "ii", "implement", "integr", "integrand", "interpol", "largest", "low", "methodolog", "modif", "numer", "overcom", "paper", "part", "point", "polynomi", "problem", "quadratur", "recurr", "refin", "relat", "relat", "requir", "requir", "requir", "requir", "sampl", "save", "scheme", "shown", "show", "sine", "storag", "transform", "transform", "transform", "troubl", "unstabl", "valu", "gentleman"], "word_count": {"applic": 1, "automat": 2, "case": 1, "chebyshev": 1, "circumst": 1, "clenshaw": 2, "companion": 1, "comput": 3, "convent": 1, "cosin": 7, "cost": 1, "curti": 2, "drawback": 1, "effect": 1, "experi": 1, "fast": 1, "formula": 1, "fourier": 1, "frequenc": 1, "high": 1, "ii": 1, "implement": 1, "integr": 1, "integrand": 2, "interpol": 1, "largest": 1, "low": 1, "methodolog": 1, "modif": 2, "numer": 1, "overcom": 1, "paper": 2, "part": 1, "point": 1, "polynomi": 1, "problem": 2, "quadratur": 3, "recurr": 1, "refin": 1, "relat": 2, "requir": 4, "sampl": 1, "save": 1, "scheme": 3, "shown": 1, "show": 1, "sine": 1, "storag": 1, "transform": 8, "troubl": 1, "unstabl": 1, "valu": 2, "gentleman": 1}}, "2355": {"id": "2355", "title": "Implementing Clenshaw-Curtis quadrature, I Methodology and Experience", "abstract": "Clenshaw-Curtis quadrature is a particularly important automatic quadrature scheme for a variety  of reasons, especially the high accuracy obtained from relatively few integrand values.  However, it  has received little use because it requires the computation of a cosine transformation and the arithmetic  cost of this has been prohibitive.  This paper is in two parts; a companion paper, \"II Computing the  Cosine Transformation,\" shows that this objection can be overcome by computing the cosine transformation  by a modification of the fast Fourier transform algorithm.  This first part discusses the strategy and  various error estimates, and summarizes experience with a particular implementation of the scheme.", "authors": "Gentleman, W. M.", "words_pool": ["accuraci", "algorithm", "arithmet", "automat", "clenshaw", "companion", "comput", "comput", "cosin", "cost", "curti", "discuss", "error", "especi", "estim", "experi", "fast", "fourier", "high", "ii", "implement", "implement", "import", "integrand", "methodolog", "modif", "object", "obtain", "overcom", "paper", "part", "part", "prohibit", "quadratur", "reason", "receiv", "requir", "scheme", "show", "strategi", "summar", "transform", "transform", "valu", "varieti", "gentleman"], "word_count": {"accuraci": 1, "algorithm": 1, "arithmet": 1, "automat": 1, "clenshaw": 1, "companion": 1, "comput": 3, "cosin": 3, "cost": 1, "curti": 1, "discuss": 1, "error": 1, "especi": 1, "estim": 1, "experi": 1, "fast": 1, "fourier": 1, "high": 1, "ii": 1, "implement": 1, "import": 1, "integrand": 1, "methodolog": 1, "modif": 1, "object": 1, "obtain": 1, "overcom": 1, "paper": 2, "part": 2, "prohibit": 1, "quadratur": 2, "reason": 1, "receiv": 1, "requir": 1, "scheme": 2, "show": 1, "strategi": 1, "summar": 1, "transform": 4, "valu": 1, "varieti": 1, "gentleman": 1}}, "2356": {"id": "2356", "title": "A Technique for Software Module Specification with Examples", "abstract": "This paper presents an approach to writing specifications for parts of software systems.  The  main goal is to provide specifications sufficiently precise and complete that other pieces of software  can be written to interact with the piece specified without additional information.  The secondary goal  is to include in the specification no more information than necessary to meet the first goal.  The technique  is illustrated by means of a variety of examples from a tutorial system.", "authors": "Parnas, D. L.", "words_pool": ["addit", "approach", "complet", "exampl", "goal", "illustr", "includ", "inform", "interact", "main", "mean", "meet", "modul", "paper", "part", "piec", "piec", "precis", "present", "provid", "secondari", "softwar", "specif", "specif", "suffici", "system", "system", "techniqu", "tutori", "varieti", "write", "written", "parna"], "word_count": {"addit": 1, "approach": 1, "complet": 1, "exampl": 1, "goal": 3, "illustr": 1, "includ": 1, "inform": 2, "interact": 1, "main": 1, "mean": 1, "meet": 1, "modul": 1, "paper": 1, "part": 1, "piec": 2, "precis": 1, "present": 1, "provid": 1, "secondari": 1, "softwar": 2, "specif": 3, "suffici": 1, "system": 2, "techniqu": 1, "tutori": 1, "varieti": 1, "write": 1, "written": 1, "parna": 1}}, "2357": {"id": "2357", "title": "MUX, a Simple Approach to On-Line Computing", "abstract": "An on-line system operating as part of a normal batch system for the CDC 6600 computer is described.   The system, which required one man-year for initial software implementation, although basically simple, provides the necessary elements to input and modify files, submit them for batch execution, and provide  results at the user's terminal.  A multiplexer designed and developed as part of the project cost one  man-year for design and checkout, and $16,000 for parts and fabrication.  All aspects of the system are  described, including design criteria, implementation, cost, overhead, and user reactions.", "authors": "Christman, R. D.", "words_pool": ["approach", "aspect", "basic", "batch", "cdc", "checkout", "comput", "comput", "cost", "criteria", "design", "design", "develop", "element", "execut", "fabric", "implement", "includ", "initi", "input", "line", "man", "modifi", "multiplex", "mux", "normal", "oper", "overhead", "part", "part", "project", "provid", "reaction", "requir", "result", "simpl", "softwar", "submit", "system", "termin", "user", "year", "christman"], "word_count": {"approach": 1, "aspect": 1, "basic": 1, "batch": 2, "cdc": 1, "checkout": 1, "comput": 1, "cost": 2, "criteria": 1, "design": 3, "develop": 1, "element": 1, "execut": 1, "fabric": 1, "implement": 2, "includ": 1, "initi": 1, "input": 1, "line": 1, "man": 2, "modifi": 1, "multiplex": 1, "mux": 1, "normal": 1, "oper": 1, "overhead": 1, "part": 3, "project": 1, "provid": 1, "reaction": 1, "requir": 1, "result": 1, "simpl": 1, "softwar": 1, "submit": 1, "system": 4, "termin": 1, "user": 2, "year": 2, "christman": 1}}, "2358": {"id": "2358", "title": "The Multics Virtual Memory: Concepts and Design", "abstract": "As experience with use of on-line operating systems has grown, the need to share information  among system users has become increasingly apparent.  Many contemporary systems permit some degree of  sharing.  Usually, sharing is accomplished by allowing several users to share data via input and output  of information stored in files kept in secondary storage.  Through the use of segmentation, however,  Multics provides direct hardware addressing by user and system programs of all information, independent  of its physical storage location.  Information is stored in segments each of which is potentially sharable  and carries its own independent attributes of size and access privilege.  Here, the design and implementation  considerations of segmentation and sharing in Multics are first discussed under the assumption that all  information resides in large, segmented main memory.  Since the size of main memory on contemporary systems  is rather limited, it is then shown how the Multics software achieves the effect of a large segmented  main memory through the use of the Honeywell 645 segmentation and paging hardware.", "authors": "Bensoussan, A. Clingen, C. T. Daley, R. C.", "words_pool": ["access", "accomplish", "achiev", "address", "allow", "appar", "assumpt", "attribut", "carri", "concept", "consider", "contemporari", "data", "degre", "design", "direct", "discuss", "effect", "experi", "grown", "hardwar", "honeywel", "implement", "increasingli", "independ", "inform", "input", "larg", "limit", "line", "locat", "main", "memori", "multic", "need", "oper", "output", "page", "permit", "physic", "potenti", "privileg", "program", "resid", "secondari", "segment", "segment", "segment", "sharabl", "share", "share", "shown", "size", "softwar", "storag", "store", "system", "system", "user", "user", "virtual", "bensoussan", "clingen", "daley"], "word_count": {"access": 1, "accomplish": 1, "achiev": 1, "address": 1, "allow": 1, "appar": 1, "assumpt": 1, "attribut": 1, "carri": 1, "concept": 1, "consider": 1, "contemporari": 2, "data": 1, "degre": 1, "design": 1, "direct": 1, "discuss": 1, "effect": 1, "experi": 1, "grown": 1, "hardwar": 2, "honeywel": 1, "implement": 1, "increasingli": 1, "independ": 2, "inform": 5, "input": 1, "larg": 2, "limit": 1, "line": 1, "locat": 1, "main": 3, "memori": 3, "multic": 3, "need": 1, "oper": 1, "output": 1, "page": 1, "permit": 1, "physic": 1, "potenti": 1, "privileg": 1, "program": 1, "resid": 1, "secondari": 1, "segment": 6, "sharabl": 1, "share": 5, "shown": 1, "size": 2, "softwar": 1, "storag": 2, "store": 2, "system": 5, "user": 3, "virtual": 1, "bensoussan": 1, "clingen": 1, "daley": 1}}, "2359": {"id": "2359", "title": "An Improved Index Sequential Access Method Using Hashed Overflow", "abstract": "The Index Sequential Access Method (ISAM) is one of the most important file management systems  used with moveable head disk devices.  This study investigates the use of an unconventional method of  treating overflow records.  The method is to use hashing techniques to allocate space for such records.   If certain conditions are satisfied, this is superior to the conventional ISAM method of chaining the  overflow records via linked list techniques.  These conditions are: long overflow chains with significant  overflow; lack of tight disk space constraints; record keys which are small compared to the total record  size; and significant use of the file in the index as opposed to the sequential mode.  Using hashed overflow,  the time to locate a record is dependent not on the total volume of overflow records as in conventional  ISAM, but on the percentage use of space dedicated to overflow records.", "authors": "Mullin, J. K.", "words_pool": ["access", "alloc", "chain", "chain", "compar", "condit", "constraint", "convent", "dedic", "depend", "devic", "disk", "hash", "hash", "head", "import", "improv", "index", "investig", "isam", "key", "lack", "link", "list", "locat", "long", "manag", "method", "mode", "moveabl", "oppos", "overflow", "percentag", "record", "record", "satisfi", "sequenti", "signific", "size", "small", "space", "studi", "superior", "system", "techniqu", "tight", "time", "total", "treat", "unconvent", "volum", "mullin"], "word_count": {"access": 1, "alloc": 1, "chain": 2, "compar": 1, "condit": 2, "constraint": 1, "convent": 2, "dedic": 1, "depend": 1, "devic": 1, "disk": 2, "hash": 2, "head": 1, "import": 1, "improv": 1, "index": 2, "investig": 1, "isam": 3, "key": 1, "lack": 1, "link": 1, "list": 1, "locat": 1, "long": 1, "manag": 1, "method": 4, "mode": 1, "moveabl": 1, "oppos": 1, "overflow": 7, "percentag": 1, "record": 8, "satisfi": 1, "sequenti": 2, "signific": 2, "size": 1, "small": 1, "space": 3, "studi": 1, "superior": 1, "system": 1, "techniqu": 2, "tight": 1, "time": 1, "total": 2, "treat": 1, "unconvent": 1, "volum": 1, "mullin": 1}}, "2360": {"id": "2360", "title": "A Comment on the Double-Chained Tree", "authors": "Hu, T. C.", "words_pool": ["chain", "comment", "doubl", "tree", "hu"], "word_count": {"chain": 1, "comment": 1, "doubl": 1, "tree": 1, "hu": 1}}, "2361": {"id": "2361", "title": "A Note on Cheney's Nonrecursive List-Compacting Algorithm", "authors": "Walden, D. C.", "words_pool": ["algorithm", "cheney", "compact", "list", "nonrecurs", "note", "walden"], "word_count": {"algorithm": 1, "cheney": 1, "compact": 1, "list": 1, "nonrecurs": 1, "note": 1, "walden": 1}}, "2362": {"id": "2362", "title": "Linear Equation Solver [F4] (Algorithm A423)", "authors": "Moler, C. B.", "words_pool": ["a423", "algorithm", "equat", "f4", "linear", "solver", "moler"], "word_count": {"a423": 1, "algorithm": 1, "equat": 1, "f4": 1, "linear": 1, "solver": 1, "moler": 1}}, "2363": {"id": "2363", "title": "Minimal Spanning Tree [H] (Algorithm A422)", "authors": "Whitney, V. K. M.", "words_pool": ["a422", "algorithm", "minim", "span", "tree", "whitney"], "word_count": {"a422": 1, "algorithm": 1, "minim": 1, "span": 1, "tree": 1, "whitney": 1}}, "2364": {"id": "2364", "title": "Complex Gamma Function with Error Control [S14] (Algorithm A421)", "authors": "Kuki, H.", "words_pool": ["a421", "algorithm", "complex", "control", "error", "function", "gamma", "s14", "kuki"], "word_count": {"a421": 1, "algorithm": 1, "complex": 1, "control": 1, "error": 1, "function": 1, "gamma": 1, "s14": 1, "kuki": 1}}, "2365": {"id": "2365", "title": "Matrix Computations with Fortran and Paging", "abstract": "The efficiency of conventional Fortran programs for matrix computations can often be improved  by reversing the order of nested loops.  Such modifications produce modest savings in many common situations  and very significant savings for large problems run under an operating system which uses paging.", "authors": "Moler, C. B.", "words_pool": ["common", "comput", "convent", "effici", "fortran", "improv", "larg", "loop", "matrix", "modest", "modif", "nest", "oper", "order", "page", "problem", "produc", "program", "revers", "run", "save", "signific", "situat", "system", "moler"], "word_count": {"common": 1, "comput": 1, "convent": 1, "effici": 1, "fortran": 1, "improv": 1, "larg": 1, "loop": 1, "matrix": 1, "modest": 1, "modif": 1, "nest": 1, "oper": 1, "order": 1, "page": 1, "problem": 1, "produc": 1, "program": 1, "revers": 1, "run": 1, "save": 2, "signific": 1, "situat": 1, "system": 1, "moler": 1}}, "2366": {"id": "2366", "title": "Complex Gamma Function with Error Control", "abstract": "An algorithm to compute the gamma function and log gamma function of a complex variable is presented.   The standard algorithm is modified in several respects to insure the continuity of the function value  and to reduce accumulation of round-off errors.  In addition to computation of function values, this  algorithm includes an object-time estimation of round-off errors.  Experimental data with regard to the  effectiveness of this error control are presented.  A Fortran program for the algorithm appears in the  algorithms section of this issue.", "authors": "Kuki, H.", "words_pool": ["accumul", "addit", "algorithm", "algorithm", "appear", "complex", "comput", "comput", "continu", "control", "data", "effect", "error", "error", "estim", "experiment", "fortran", "function", "gamma", "includ", "insur", "issu", "log", "modifi", "object", "present", "program", "reduc", "regard", "respect", "round", "section", "standard", "time", "valu", "variabl", "kuki"], "word_count": {"accumul": 1, "addit": 1, "algorithm": 5, "appear": 1, "complex": 1, "comput": 2, "continu": 1, "control": 1, "data": 1, "effect": 1, "error": 3, "estim": 1, "experiment": 1, "fortran": 1, "function": 4, "gamma": 2, "includ": 1, "insur": 1, "issu": 1, "log": 1, "modifi": 1, "object": 1, "present": 2, "program": 1, "reduc": 1, "regard": 1, "respect": 1, "round": 2, "section": 1, "standard": 1, "time": 1, "valu": 1, "variabl": 1, "kuki": 1}}, "2367": {"id": "2367", "title": "Computers and Society: A Proposed Course for Computer Scientists", "abstract": "The purpose of this paper is to describe a course concerned with both the effects of computers  on society and the responsibilities of computer scientists to society.  The impact of computers is divided  into five components: political, economic, cultural, social, and moral; the main part of the paper defines  each component and presents examples of the relevant issues.  In the remaining portions the possible  formats for such a course are discussed, a topic by topic outline is given, and a selected set of references  is listed.  It is hoped that the proposal will make it easier to initiate courses on this subject.", "authors": "Horowitz, E. Morgan, H. L. Shaw, A. C.", "words_pool": ["compon", "compon", "comput", "comput", "concern", "cours", "cours", "cultur", "defin", "describ", "discuss", "divid", "easier", "econom", "effect", "exampl", "format", "hope", "impact", "initi", "issu", "list", "main", "make", "moral", "outlin", "paper", "part", "polit", "portion", "present", "propos", "propos", "purpos", "refer", "relev", "remain", "respons", "scientist", "select", "set", "social", "societi", "subject", "topic", "horowitz", "morgan", "shaw"], "word_count": {"compon": 2, "comput": 3, "concern": 1, "cours": 3, "cultur": 1, "defin": 1, "describ": 1, "discuss": 1, "divid": 1, "easier": 1, "econom": 1, "effect": 1, "exampl": 1, "format": 1, "hope": 1, "impact": 1, "initi": 1, "issu": 1, "list": 1, "main": 1, "make": 1, "moral": 1, "outlin": 1, "paper": 2, "part": 1, "polit": 1, "portion": 1, "present": 1, "propos": 1, "purpos": 1, "refer": 1, "relev": 1, "remain": 1, "respons": 1, "scientist": 1, "select": 1, "set": 1, "social": 1, "societi": 2, "subject": 1, "topic": 2, "horowitz": 1, "morgan": 1, "shaw": 1}}, "2368": {"id": "2368", "title": "An Implemented Graph Algorithm for Winning Shannon Switching games", "abstract": "In this tutorial paper a computer program which wins Shannon Switching Games is described.  Since these games are played on graphs, the program is a good example of the implementation of graph  algorithms.  The two players in a Shannon Switching Game, CONNECT and CUT, have nonsimilar goals.  Either  CONNECT, CUT, or the player moving first is guaranteed the existence of a winning strategy.  The simple  strategy explained in this paper is valid in all three cases.  In fact, the major routines never need  to know whether the computer is CONNECT or CUT.", "authors": "Chase, S. M.", "words_pool": ["algorithm", "algorithm", "case", "comput", "connect", "cut", "exist", "explain", "fact", "game", "game", "goal", "good", "graph", "graph", "guarante", "implement", "implement", "know", "major", "move", "need", "nonsimilar", "paper", "play", "player", "player", "program", "routin", "shannon", "simpl", "strategi", "switch", "tutori", "valid", "win", "win", "chase"], "word_count": {"algorithm": 1, "case": 1, "comput": 2, "connect": 3, "cut": 3, "exist": 1, "explain": 1, "fact": 1, "game": 3, "goal": 1, "good": 1, "graph": 2, "guarante": 1, "implement": 1, "know": 1, "major": 1, "move": 1, "need": 1, "nonsimilar": 1, "paper": 2, "play": 1, "player": 2, "program": 2, "routin": 1, "shannon": 2, "simpl": 1, "strategi": 2, "switch": 2, "tutori": 1, "valid": 1, "win": 2, "chase": 1}}, "2369": {"id": "2369", "title": "Hidden Lines Elimination for a Rotating Object", "abstract": "A method is presented of determining which parts of three-dimensional objects are visible and  which are invisible when the objects are rotated about some axis.  This paper describes a polygon comparison  scheme in which the relationships of two polygons can be classified into tree types, and also discusses  how the relationship is changed for each pair of polygons under rotation about some axis.  A rotation  table is defined for each pair of polygons, which remains fixed as long as rotation is about one axis  and provides a means of rapidly determining the visible and hidden line relationship between two polygons.   Additional work must be done to extend this approach to simultaneous rotation about several axes.", "authors": "Matsushita, Y.", "words_pool": ["addit", "approach", "axe", "axi", "chang", "classifi", "comparison", "defin", "describ", "determin", "dimension", "discuss", "elimin", "extend", "fix", "hidden", "invis", "line", "line", "long", "mean", "method", "object", "object", "pair", "paper", "part", "polygon", "polygon", "present", "rapidli", "relationship", "relationship", "remain", "rotat", "rotat", "rotat", "scheme", "simultan", "tabl", "tree", "type", "visibl", "work", "matsushita"], "word_count": {"addit": 1, "approach": 1, "axe": 1, "axi": 3, "chang": 1, "classifi": 1, "comparison": 1, "defin": 1, "describ": 1, "determin": 2, "dimension": 1, "discuss": 1, "elimin": 1, "extend": 1, "fix": 1, "hidden": 1, "invis": 1, "line": 1, "long": 1, "mean": 1, "method": 1, "object": 2, "pair": 2, "paper": 1, "part": 1, "polygon": 5, "present": 1, "rapidli": 1, "relationship": 3, "remain": 1, "rotat": 5, "scheme": 1, "simultan": 1, "tabl": 1, "tree": 1, "type": 1, "visibl": 2, "work": 1, "matsushita": 1}}, "2370": {"id": "2370", "title": "An Experimental Laboratory for Pattern Recognition and Signal Processing", "abstract": "An interactive computer-controlled scanning and display system has been in operation at the  IBM Thomas J. Watson Research Center for three years.  The system includes two flying-spot scanners and  a TV camera specially interfaced to a process control digital computer, dot-mode and vector displays,  analog input and output facilities, and a variety of other experimental equipment.  The system design  and programming support are described and typical applications in scanner control, optical character  recognition,and image processing are presented.", "authors": "Herbst, N. M. Will, P. M.", "words_pool": ["analog", "applic", "camera", "center", "charact", "comput", "control", "control", "design", "digit", "display", "display", "dot", "equip", "experiment", "facil", "fli", "ibm", "imag", "includ", "input", "interact", "interfac", "laboratori", "mode", "oper", "optic", "output", "pattern", "present", "process", "process", "program", "recognit", "research", "scanner", "scanner", "scan", "signal", "special", "spot", "support", "system", "thoma", "tv", "typic", "varieti", "vector", "watson", "year", "herbst"], "word_count": {"analog": 1, "applic": 1, "camera": 1, "center": 1, "charact": 1, "comput": 2, "control": 3, "design": 1, "digit": 1, "display": 2, "dot": 1, "equip": 1, "experiment": 1, "facil": 1, "fli": 1, "ibm": 1, "imag": 1, "includ": 1, "input": 1, "interact": 1, "interfac": 1, "laboratori": 1, "mode": 1, "oper": 1, "optic": 1, "output": 1, "pattern": 1, "present": 1, "process": 2, "program": 1, "recognit": 1, "research": 1, "scanner": 2, "scan": 1, "signal": 1, "special": 1, "spot": 1, "support": 1, "system": 3, "thoma": 1, "tv": 1, "typic": 1, "varieti": 1, "vector": 1, "watson": 1, "year": 1, "herbst": 1}}, "2371": {"id": "2371", "title": "A System for Interprocess Communication in a Resource Sharing Computer Network", "abstract": "A system of communication between processes in a time-sharing system is described and the communication  system is extended so that it may be used between processes distributed throughout a computer network.   The hypothetical application of the system to an existing network is discussed.", "authors": "Walden, D. C.", "words_pool": ["applic", "commun", "comput", "discuss", "distribut", "exist", "extend", "hypothet", "interprocess", "network", "process", "resourc", "share", "system", "time", "walden"], "word_count": {"applic": 1, "commun": 2, "comput": 1, "discuss": 1, "distribut": 1, "exist": 1, "extend": 1, "hypothet": 1, "interprocess": 1, "network": 2, "process": 2, "resourc": 1, "share": 1, "system": 4, "time": 1, "walden": 1}}, "2372": {"id": "2372", "title": "On the Implementation of Security Measures in Information Systems", "abstract": "The security of an information system may be represented by a model matrix whose elements are  decision rules and whose row and column indices are users and data items respectively.  A set of four  functions is used to access this matrix at translation and execution time.  Distinguishing between data  dependent and data independent decision rules enables one to perform much of the checking of security  only once at translation time rather than repeatedly at execution time.  The model is used to explain  security features of several existing systems, and serves as a framework for a proposal for general security  system implementation within today's languages and operating systems.", "authors": "Conway, R. W. Maxwell, W. L. Morgan, H. L.", "words_pool": ["access", "check", "column", "data", "decis", "depend", "distinguish", "element", "enabl", "execut", "exist", "explain", "featur", "framework", "function", "gener", "implement", "independ", "indic", "inform", "item", "languag", "matrix", "measur", "model", "oper", "perform", "propos", "repeatedli", "repres", "row", "rule", "secur", "serv", "set", "system", "system", "time", "today", "translat", "user", "conway", "maxwel", "morgan"], "word_count": {"access": 1, "check": 1, "column": 1, "data": 3, "decis": 2, "depend": 1, "distinguish": 1, "element": 1, "enabl": 1, "execut": 2, "exist": 1, "explain": 1, "featur": 1, "framework": 1, "function": 1, "gener": 1, "implement": 1, "independ": 1, "indic": 1, "inform": 1, "item": 1, "languag": 1, "matrix": 2, "measur": 1, "model": 2, "oper": 1, "perform": 1, "propos": 1, "repeatedli": 1, "repres": 1, "row": 1, "rule": 2, "secur": 4, "serv": 1, "set": 1, "system": 4, "time": 3, "today": 1, "translat": 2, "user": 1, "conway": 1, "maxwel": 1, "morgan": 1}}, "2373": {"id": "2373", "title": "Properties of the Working-Set Model", "abstract": "A program's working set W(t,T) at time t is the set of distinct pages among the T most recently  referenced pages.  Relations between the average working-set size, the missing-page rate, and the interreference-interval  distribution may be derived both from time-average definitions and from ensemble-average (statistical)  definitions. An efficient algorithm for estimating these quantities is given.  The relation to LRU (least  recently used) paging is characterized.  The independent-reference model, in which page references are  statistically independent, is used to assess the effects to interpage dependencies on working-set size  observations. Under general assumptions, working-set size is shown to be normally distributed.", "authors": "Denning, P. J. Schwartz, S. C.", "words_pool": ["algorithm", "assess", "assumpt", "averag", "character", "definit", "depend", "deriv", "distinct", "distribut", "distribut", "effect", "effici", "ensembl", "estim", "gener", "independ", "interpag", "interrefer", "interv", "lru", "miss", "model", "observ", "page", "page", "page", "program", "properti", "quantiti", "rate", "recent", "refer", "referenc", "refer", "relat", "relat", "set", "shown", "size", "statist", "statist", "time", "work", "den", "schwartz"], "word_count": {"algorithm": 1, "assess": 1, "assumpt": 1, "averag": 3, "character": 1, "definit": 2, "depend": 1, "deriv": 1, "distinct": 1, "distribut": 2, "effect": 1, "effici": 1, "ensembl": 1, "estim": 1, "gener": 1, "independ": 2, "interpag": 1, "interrefer": 1, "interv": 1, "lru": 1, "miss": 1, "model": 1, "observ": 1, "page": 5, "program": 1, "properti": 1, "quantiti": 1, "rate": 1, "recent": 2, "refer": 2, "referenc": 1, "relat": 2, "set": 5, "shown": 1, "size": 3, "statist": 2, "time": 2, "work": 4, "den": 1, "schwartz": 1}}, "2374": {"id": "2374", "title": "A Study of Storage Partitioning Using a Mathematical Model of Locality", "abstract": "Both fixed and dynamic storage partitioning procedures are examined for use in multiprogramming  systems.  The storage requirement of programs is modeled as a stationary Gaussian process.  Experiments  justifying this model are described.  By means of this model dynamic storage partitioning is shown to  provide substantial increases in storage utilization and operating efficiency over fixed partitioning.", "authors": "Coffman Jr., E. G. Ryan Jr., T. A.", "words_pool": ["dynam", "effici", "examin", "experi", "fix", "gaussian", "increas", "justifi", "local", "mathemat", "mean", "model", "model", "multiprogram", "oper", "partit", "procedur", "process", "program", "provid", "requir", "shown", "stationari", "storag", "studi", "substanti", "system", "util", "coffman", "jr", "ryan", "jr"], "word_count": {"dynam": 2, "effici": 1, "examin": 1, "experi": 1, "fix": 2, "gaussian": 1, "increas": 1, "justifi": 1, "local": 1, "mathemat": 1, "mean": 1, "model": 3, "multiprogram": 1, "oper": 1, "partit": 3, "procedur": 1, "process": 1, "program": 1, "provid": 1, "requir": 1, "shown": 1, "stationari": 1, "storag": 4, "studi": 1, "substanti": 1, "system": 1, "util": 1, "coffman": 1, "jr": 1, "ryan": 1}}, "2375": {"id": "2375", "title": "A Comparative Analysis of Disk Scheduling Policies", "abstract": "Five well-known scheduling policies for movable head disks are compared using the performance  criteria of expected seek time (system oriented)and expected waiting time (individual I/O request oriented).   Both analytical and simulation results are obtained.  The variance of waiting time is introduced as  another meaningful measure of performance, showing possible discrimination against individual requests.   Then the choice of a utility function to measure total performance including system oriented and individual  request oriented measures is described.  Such a function allows one to differentiate among the scheduling  policies over a wide range of input loading conditions.  The selection and implementation of a maximum  performance two-policy algorithm are discussed.", "authors": "Teorey, T. J. Pinkerton, T. B.", "words_pool": ["algorithm", "analysi", "analyt", "choic", "compar", "compar", "condit", "criteria", "differenti", "discrimin", "discuss", "disk", "disk", "expect", "function", "head", "implement", "includ", "individu", "input", "introduc", "known", "load", "maximum", "meaning", "measur", "measur", "movabl", "obtain", "orient", "perform", "polici", "polici", "rang", "request", "request", "result", "schedul", "seek", "select", "show", "simul", "system", "time", "total", "util", "varianc", "wait", "wide", "teorey", "pinkerton"], "word_count": {"algorithm": 1, "analysi": 1, "analyt": 1, "choic": 1, "compar": 1, "condit": 1, "criteria": 1, "differenti": 1, "discrimin": 1, "discuss": 1, "disk": 1, "expect": 2, "function": 2, "head": 1, "implement": 1, "includ": 1, "individu": 3, "input": 1, "introduc": 1, "known": 1, "load": 1, "maximum": 1, "meaning": 1, "measur": 3, "movabl": 1, "obtain": 1, "orient": 4, "perform": 4, "polici": 3, "rang": 1, "request": 3, "result": 1, "schedul": 2, "seek": 1, "select": 1, "show": 1, "simul": 1, "system": 2, "time": 3, "total": 1, "util": 1, "varianc": 1, "wait": 2, "wide": 1, "teorey": 1, "pinkerton": 1}}, "2376": {"id": "2376", "title": "Synchronization of Communicating Processes", "abstract": "Formalization of a well-defined synchronization mechanism can be used to prove that concurrently  running processes of a system communicate correctly.  This is demonstrated for a system consisting of  many sending processes which deposit messages in a buffer and many receiving processes which remove messages  from that buffer.  The formal description of the synchronization mechanism makes it very easy to prove  that the buffer will neither overflow nor underflow, that senders and receivers will never operate on  the same message frame in the buffer nor will they run into a deadlock.", "authors": "Habermann, A. N.", "words_pool": ["buffer", "commun", "commun", "concurr", "consist", "correctli", "deadlock", "defin", "demonstr", "deposit", "descript", "easi", "formal", "formal", "frame", "make", "mechan", "messag", "messag", "oper", "overflow", "process", "prove", "receiv", "receiv", "remov", "run", "run", "sender", "send", "synchron", "system", "underflow", "habermann"], "word_count": {"buffer": 4, "commun": 1, "concurr": 1, "consist": 1, "correctli": 1, "deadlock": 1, "defin": 1, "demonstr": 1, "deposit": 1, "descript": 1, "easi": 1, "formal": 2, "frame": 1, "make": 1, "mechan": 2, "messag": 3, "oper": 1, "overflow": 1, "process": 3, "prove": 2, "receiv": 2, "remov": 1, "run": 2, "sender": 1, "send": 1, "synchron": 2, "system": 2, "underflow": 1, "habermann": 1}}, "2377": {"id": "2377", "title": "A Hardware Architecture for Implementing Protection Rings", "abstract": "Protection of computations and information is an important aspect of a computer utility.  In  a system which uses segmentation as a memory addressing scheme, protection can be achieved in part by  associating concentric rings of decreasing access privilege with a computation.  This paper describes  hardware processor mechanisms for implementing these rings of protection.  The mechanisms for implementing  these rings of protection. The mechanisms allow cross-ring calls and subsequent returns to occur without  trapping to the supervisor.  Automatic hardware validation of references across ring boundaries is also  performed.  Thus, a call by a user procedure to a protected subsystem (including the supervisor) is identical  to a call to a companion user procedure.  The mechanisms of passing and referencing arguments are the  same in both cases as well.", "authors": "Schroeder, M. D. Saltzer, J. H.", "words_pool": ["access", "achiev", "address", "allow", "architectur", "argument", "aspect", "associ", "automat", "boundari", "call", "call", "case", "companion", "comput", "comput", "comput", "concentr", "cross", "decreas", "describ", "hardwar", "ident", "implement", "import", "includ", "inform", "mechan", "memori", "occur", "paper", "part", "pass", "perform", "privileg", "procedur", "processor", "protect", "protect", "refer", "referenc", "ring", "ring", "scheme", "segment", "subsequ", "subsystem", "supervisor", "system", "trap", "user", "util", "valid", "schroeder", "saltzer"], "word_count": {"access": 1, "achiev": 1, "address": 1, "allow": 1, "architectur": 1, "argument": 1, "aspect": 1, "associ": 1, "automat": 1, "boundari": 1, "call": 3, "case": 1, "companion": 1, "comput": 3, "concentr": 1, "cross": 1, "decreas": 1, "describ": 1, "hardwar": 2, "ident": 1, "implement": 2, "import": 1, "includ": 1, "inform": 1, "mechan": 4, "memori": 1, "occur": 1, "paper": 1, "part": 1, "pass": 1, "perform": 1, "privileg": 1, "procedur": 2, "processor": 1, "protect": 5, "refer": 1, "referenc": 1, "ring": 5, "scheme": 1, "segment": 1, "subsequ": 1, "subsystem": 1, "supervisor": 2, "system": 1, "trap": 1, "user": 2, "util": 1, "valid": 1, "schroeder": 1, "saltzer": 1}}, "2378": {"id": "2378", "title": "An Operating System Based on the Concept of a Supervisory Computer", "abstract": "An operating system which is organized as a small supervisor and a set of independent processes  are described.  The supervisor handles I/O with external devices-the file and directory system-schedules  active processes and manages memory, handle errors, and provides a small set of primitive functions which  it will execute for a process.  A process is able to specify a request for a complicated action on the  part of the supervisor (usually a wait on the occurrence of a compound event in the system) by combining  these primitives into a \"supervisory computer program.\"  The part of the supervisor which executes these  programs may be viewed as a software implemented \"supervisory computer.\"  The paper develops these concepts  in detail, outlines the remainder of the supervisor, and discusses some of the advantages of this approach.", "authors": "Gaines, R. S.", "words_pool": ["abl", "action", "activ", "advantag", "approach", "base", "combin", "complic", "compound", "comput", "concept", "concept", "detail", "develop", "devic", "directori", "discuss", "error", "event", "execut", "execut", "extern", "function", "handl", "handl", "implement", "independ", "manag", "memori", "occurr", "oper", "organ", "outlin", "paper", "part", "primit", "primit", "process", "process", "program", "program", "remaind", "request", "schedul", "set", "small", "softwar", "supervisor", "supervisori", "system", "view", "wait", "gain"], "word_count": {"abl": 1, "action": 1, "activ": 1, "advantag": 1, "approach": 1, "base": 1, "combin": 1, "complic": 1, "compound": 1, "comput": 2, "concept": 1, "detail": 1, "develop": 1, "devic": 1, "directori": 1, "discuss": 1, "error": 1, "event": 1, "execut": 2, "extern": 1, "function": 1, "handl": 2, "implement": 1, "independ": 1, "manag": 1, "memori": 1, "occurr": 1, "oper": 1, "organ": 1, "outlin": 1, "paper": 1, "part": 2, "primit": 2, "process": 4, "program": 2, "remaind": 1, "request": 1, "schedul": 1, "set": 2, "small": 2, "softwar": 1, "supervisor": 5, "supervisori": 2, "system": 3, "view": 1, "wait": 1, "gain": 1}}, "2379": {"id": "2379", "title": "The Design of the Venus Operating System", "abstract": "The Venus Operating System is an experimental multiprogramming system which supports five or  six concurrent users on a small computer.  The system was produced to test the effect of machine architecture  on complexity of software.  The system is defined by a combination of microprograms and software.  The  microprogram defines a machine with some unusual architectural feature; the software exploits these features  to define the operating system as simply as possible.  In this paper the development of the system is  described, with particular emphasis on the principles which guided the design.", "authors": "Liskov, B. H.", "words_pool": ["architectur", "architectur", "combin", "complex", "comput", "concurr", "defin", "defin", "defin", "design", "develop", "effect", "emphasi", "experiment", "exploit", "featur", "featur", "guid", "machin", "microprogram", "microprogram", "multiprogram", "oper", "paper", "principl", "produc", "simpli", "small", "softwar", "support", "system", "test", "unusu", "user", "venu", "liskov"], "word_count": {"architectur": 2, "combin": 1, "complex": 1, "comput": 1, "concurr": 1, "defin": 3, "design": 1, "develop": 1, "effect": 1, "emphasi": 1, "experiment": 1, "exploit": 1, "featur": 2, "guid": 1, "machin": 2, "microprogram": 2, "multiprogram": 1, "oper": 2, "paper": 1, "principl": 1, "produc": 1, "simpli": 1, "small": 1, "softwar": 3, "support": 1, "system": 6, "test": 1, "unusu": 1, "user": 1, "venu": 1, "liskov": 1}}, "2380": {"id": "2380", "title": "TENEX, a Paged Time Sharing System for the PDP-10", "abstract": "TENEX is a new time sharing system implemented on DEC PDP-10 augmented by special paging hardware  developed at BBN.  This report specifies a set of goals which are important for any time sharing system.   It describes how the TENEX design and implementation achieve these goals.  These include specifications  for a powerful multiprocess large memory virtual machine, intimate terminal interaction, comprehensive  uniform file and I/O capabilities, and clean flexible system structure.  Although the implementation  described here required some compromise to achieve a system operational within six months of hardware  checkout, TENEX has met its major goals and provided reliable service at several sites and through the  ARPA network.", "authors": "Bobrow, D. G. Burchfiel, J. D. Murphy, D. L. Tomlinson, R. S. Beranek, B.", "words_pool": ["achiev", "arpa", "augment", "bbn", "capabl", "checkout", "clean", "comprehens", "compromis", "dec", "describ", "design", "develop", "flexibl", "goal", "hardwar", "implement", "implement", "import", "includ", "interact", "intim", "larg", "machin", "major", "memori", "met", "month", "multiprocess", "network", "oper", "page", "page", "pdp", "power", "provid", "reliabl", "report", "requir", "servic", "set", "share", "site", "special", "specif", "specifi", "structur", "system", "tenex", "termin", "time", "uniform", "virtual", "bobrow", "burchfiel", "murphi", "tomlinson", "beranek"], "word_count": {"achiev": 2, "arpa": 1, "augment": 1, "bbn": 1, "capabl": 1, "checkout": 1, "clean": 1, "comprehens": 1, "compromis": 1, "dec": 1, "describ": 1, "design": 1, "develop": 1, "flexibl": 1, "goal": 3, "hardwar": 2, "implement": 3, "import": 1, "includ": 1, "interact": 1, "intim": 1, "larg": 1, "machin": 1, "major": 1, "memori": 1, "met": 1, "month": 1, "multiprocess": 1, "network": 1, "oper": 1, "page": 1, "pdp": 1, "power": 1, "provid": 1, "reliabl": 1, "report": 1, "requir": 1, "servic": 1, "set": 1, "share": 2, "site": 1, "special": 1, "specif": 1, "specifi": 1, "structur": 1, "system": 4, "tenex": 3, "termin": 1, "time": 2, "uniform": 1, "virtual": 1, "bobrow": 1, "burchfiel": 1, "murphi": 1, "tomlinson": 1, "beranek": 1}}, "2381": {"id": "2381", "title": "Average Binary Search Length for Dense Ordered Lists (Corrigendum)", "authors": "Flores, I. Madpis, G.", "words_pool": ["averag", "binari", "corrigendum", "dens", "length", "list", "order", "search", "flore", "madpi"], "word_count": {"averag": 1, "binari": 1, "corrigendum": 1, "dens": 1, "length": 1, "list": 1, "order": 1, "search": 1, "flore": 1, "madpi": 1}}, "2382": {"id": "2382", "title": "Reconstruction of Pictures from Their Projections (Corrigendum)", "authors": "Gordon, R. Herman, G. T.", "words_pool": ["corrigendum", "pictur", "project", "reconstruct", "gordon", "herman"], "word_count": {"corrigendum": 1, "pictur": 1, "project": 1, "reconstruct": 1, "gordon": 1, "herman": 1}}, "2383": {"id": "2383", "title": "Music and Computer Composition", "abstract": "The problem discussed is that of simulating human composition of Western popular music by computer  and some relevant theories of music and harmony are given.  Problems with this kind of program and several  schemes that are known not to work are discussed.  Several previous computer compositions are discussed,  including the ILLIAC Suite.  A program to generate short melody fragments was written to simulate some  of the aspects of human composition.  Five samples of its output are presented and discussed.  It was  discovered that although the fragments show many of the characteristics of popular melodies, they have  a strangely alien sound.  It is theorized that this is because the relevant probabilities which would  discriminate against unfamiliar sequences were not used.", "authors": "Moorer, J. A.", "words_pool": ["alien", "aspect", "characterist", "composit", "composit", "comput", "discov", "discrimin", "discuss", "fragment", "gener", "harmoni", "human", "illiac", "includ", "kind", "known", "melodi", "melodi", "music", "output", "popular", "present", "previou", "probabl", "problem", "problem", "program", "relev", "sampl", "scheme", "sequenc", "short", "show", "simul", "simul", "sound", "strang", "suit", "theori", "theoriz", "unfamiliar", "western", "work", "written", "moorer"], "word_count": {"alien": 1, "aspect": 1, "characterist": 1, "composit": 3, "comput": 2, "discov": 1, "discrimin": 1, "discuss": 4, "fragment": 2, "gener": 1, "harmoni": 1, "human": 2, "illiac": 1, "includ": 1, "kind": 1, "known": 1, "melodi": 2, "music": 2, "output": 1, "popular": 2, "present": 1, "previou": 1, "probabl": 1, "problem": 2, "program": 2, "relev": 2, "sampl": 1, "scheme": 1, "sequenc": 1, "short": 1, "show": 1, "simul": 2, "sound": 1, "strang": 1, "suit": 1, "theori": 1, "theoriz": 1, "unfamiliar": 1, "western": 1, "work": 1, "written": 1, "moorer": 1}}, "2384": {"id": "2384", "title": "Hidden-Line Plotting Program [J6] (Algorithm A420)", "authors": "Williamson, H.", "words_pool": ["a420", "algorithm", "hidden", "j6", "line", "plot", "program", "williamson"], "word_count": {"a420": 1, "algorithm": 1, "hidden": 1, "j6": 1, "line": 1, "plot": 1, "program": 1, "williamson": 1}}, "2385": {"id": "2385", "title": "Zeros of a Complex Polynomial [C2] (Algorithm A419)", "authors": "Jenkins, M. A. Traub, J. F.", "words_pool": ["a419", "algorithm", "c2", "complex", "polynomi", "zero", "jenkin", "traub"], "word_count": {"a419": 1, "algorithm": 1, "c2": 1, "complex": 1, "polynomi": 1, "zero": 1, "jenkin": 1, "traub": 1}}, "2386": {"id": "2386", "title": "Dynamic Microprogramming: Processor Organization and Programming (Corrigendum)", "authors": "Tucker, A. B.", "words_pool": ["corrigendum", "dynam", "microprogram", "organ", "processor", "program", "tucker"], "word_count": {"corrigendum": 1, "dynam": 1, "microprogram": 1, "organ": 1, "processor": 1, "program": 1, "tucker": 1}}, "2387": {"id": "2387", "title": "Maximum Computing Power and Cost Factors in the Centralization Problem", "abstract": "A simple analysis of some computer-economic factors involved in comparing multimachine installations  versus large single machine installations is given, and a mathematical model is derived to assist policy  decisions.", "authors": "Oldehoeft, A. E. Halstead, M. H.", "words_pool": ["analysi", "assist", "central", "compar", "comput", "comput", "cost", "decis", "deriv", "econom", "factor", "instal", "involv", "larg", "machin", "mathemat", "maximum", "model", "multimachin", "polici", "power", "problem", "simpl", "singl", "versu", "oldehoeft", "halstead"], "word_count": {"analysi": 1, "assist": 1, "central": 1, "compar": 1, "comput": 1, "cost": 1, "decis": 1, "deriv": 1, "econom": 1, "factor": 1, "instal": 2, "involv": 1, "larg": 1, "machin": 1, "mathemat": 1, "maximum": 1, "model": 1, "multimachin": 1, "polici": 1, "power": 1, "problem": 1, "simpl": 1, "singl": 1, "versu": 1, "oldehoeft": 1, "halstead": 1}}, "2388": {"id": "2388", "title": "Optimizing Binary Trees Grown With a Sorting Algorithm", "abstract": "Items can be retrieved from binary trees grown with a form of the Algorithm Quicksort in an  average time proportional to log n, where n is the number of items in the tree.  The binary trees grown  by this algorithm sometimes have some branches longer than others; therefore, it is possible to reduce  the average retrieval time by restructuring the tree to make the branches as uniform in length as possible.   An algorithm to do this is presented.  The use of this algorithm is discussed, and it is compared with  another which restructures the tree after each new item is added.", "authors": "Martin, W. A. Ness, D. N.", "words_pool": ["ad", "algorithm", "averag", "binari", "branch", "compar", "discuss", "form", "grown", "item", "item", "length", "log", "longer", "make", "number", "optim", "present", "proport", "quicksort", "reduc", "restructur", "restructur", "retriev", "retriev", "sort", "time", "tree", "tree", "uniform", "martin", "ness"], "word_count": {"ad": 1, "algorithm": 4, "averag": 2, "binari": 2, "branch": 2, "compar": 1, "discuss": 1, "form": 1, "grown": 2, "item": 3, "length": 1, "log": 1, "longer": 1, "make": 1, "number": 1, "optim": 1, "present": 1, "proport": 1, "quicksort": 1, "reduc": 1, "restructur": 2, "retriev": 2, "sort": 1, "time": 2, "tree": 5, "uniform": 1, "martin": 1, "ness": 1}}, "2389": {"id": "2389", "title": "Preliminary Report on a System for General Space Planning", "abstract": "A computer language and a set of programs within that language are described which allow the  formulating and solving of a class of space planning problems.  The language is an extension of Algol  and includes means to represent spaces and objects, to manipulate them, and to test the resulting arrangements  according to a variety of constraints.  The algorithms used to solve problems expressed in this language  rely on heuristic programming.  Both the language and the search algorithms are detailed.", "authors": "Eastman, C. M.", "words_pool": ["accord", "algol", "algorithm", "allow", "arrang", "class", "comput", "constraint", "detail", "express", "extens", "formul", "gener", "heurist", "includ", "languag", "manipul", "mean", "object", "plan", "preliminari", "problem", "program", "program", "reli", "report", "repres", "result", "search", "set", "solv", "solv", "space", "space", "system", "test", "varieti", "eastman"], "word_count": {"accord": 1, "algol": 1, "algorithm": 2, "allow": 1, "arrang": 1, "class": 1, "comput": 1, "constraint": 1, "detail": 1, "express": 1, "extens": 1, "formul": 1, "gener": 1, "heurist": 1, "includ": 1, "languag": 5, "manipul": 1, "mean": 1, "object": 1, "plan": 1, "preliminari": 1, "problem": 2, "program": 2, "reli": 1, "report": 1, "repres": 1, "result": 1, "search": 1, "set": 1, "solv": 2, "space": 2, "system": 1, "test": 1, "varieti": 1, "eastman": 1}}, "2390": {"id": "2390", "title": "A Proposal for a Computer-Based Interactive Scientific Community", "abstract": "Because of the problems created by the explosion of papers in the mathematical sciences and  the drawbacks that this places on research, it is suggested that a tree of all mathematical results and  terminology be maintained in a multiterminal computer system.  Users of the system can store in the computer  an updated file of their current knowledge, and on selecting a paper to read, they can obtain from the  computer the minimum subtree of theorems required to bring them from what they already know to the background  knowledge which the paper assumes.  Under certain conditions, means are also provided for the contribution  of useful comments by the readers of a work and for interaction between commentators and with the author.   This paper describes how the system can be organized and the role required of readers, writers, and  commentators.", "authors": "Pager, D.", "words_pool": ["assum", "author", "background", "base", "bring", "comment", "comment", "commun", "comput", "condit", "contribut", "creat", "describ", "drawback", "explos", "interact", "interact", "know", "knowledg", "maintain", "mathemat", "mean", "minimum", "multitermin", "obtain", "organ", "paper", "paper", "place", "problem", "propos", "provid", "read", "reader", "requir", "research", "result", "role", "scienc", "scientif", "select", "store", "subtre", "suggest", "system", "terminolog", "theorem", "tree", "updat", "user", "work", "writer", "pager"], "word_count": {"assum": 1, "author": 1, "background": 1, "base": 1, "bring": 1, "comment": 3, "commun": 1, "comput": 3, "condit": 1, "contribut": 1, "creat": 1, "describ": 1, "drawback": 1, "explos": 1, "interact": 1, "know": 1, "knowledg": 2, "maintain": 1, "mathemat": 2, "mean": 1, "minimum": 1, "multitermin": 1, "obtain": 1, "organ": 1, "paper": 4, "place": 1, "problem": 1, "propos": 1, "provid": 1, "read": 1, "reader": 2, "requir": 2, "research": 1, "result": 1, "role": 1, "scienc": 1, "scientif": 1, "select": 1, "store": 1, "subtre": 1, "suggest": 1, "system": 3, "terminolog": 1, "theorem": 1, "tree": 1, "updat": 1, "user": 1, "work": 1, "writer": 1, "pager": 1}}, "2391": {"id": "2391", "title": "Unitary Symmetric Polynomials [Z] (Algorithm R391)", "authors": "Schrack, G. F.", "words_pool": ["algorithm", "polynomi", "r391", "symmetr", "unitari", "schrack"], "word_count": {"algorithm": 1, "polynomi": 1, "r391": 1, "symmetr": 1, "unitari": 1, "schrack": 1}}, "2392": {"id": "2392", "title": "In-Situ Transposition of a Rectangular Matrix [F1] (Algorithm C380)", "authors": "Macleod, I. D. G.", "words_pool": ["algorithm", "c380", "f1", "matrix", "rectangular", "situ", "transposit", "macleod"], "word_count": {"algorithm": 1, "c380": 1, "f1": 1, "matrix": 1, "rectangular": 1, "situ": 1, "transposit": 1, "macleod": 1}}, "2393": {"id": "2393", "title": "Calculation of Fourier Integrals [D1] (Algorithm A418)", "authors": "Einarsson, B.", "words_pool": ["a418", "algorithm", "calcul", "d1", "fourier", "integr", "einarsson"], "word_count": {"a418": 1, "algorithm": 1, "calcul": 1, "d1": 1, "fourier": 1, "integr": 1, "einarsson": 1}}, "2394": {"id": "2394", "title": "Ordering +-f(+-f(+-f(...+-f(x)..))) When f(x) Is Positive Monotonic", "authors": "Salzer, H. E.", "words_pool": ["monoton", "order", "posit", "salzer"], "word_count": {"monoton": 1, "order": 1, "posit": 1, "salzer": 1}}, "2395": {"id": "2395", "title": "Quadratic Programming for Nonlinear Regression", "abstract": "A quadratic programming algorithm is described for use with the magnified diagonal method of  nonlinear regression with linear constraints.  The regression method is published in JACM, July 1970.", "authors": "Shrager, R. I.", "words_pool": ["algorithm", "constraint", "diagon", "jacm", "juli", "linear", "magnifi", "method", "nonlinear", "program", "publish", "quadrat", "regress", "shrager"], "word_count": {"algorithm": 1, "constraint": 1, "diagon": 1, "jacm": 1, "juli": 1, "linear": 1, "magnifi": 1, "method": 2, "nonlinear": 1, "program": 1, "publish": 1, "quadrat": 1, "regress": 2, "shrager": 1}}, "2396": {"id": "2396", "title": "MUSE: A Model To Understand Simple English", "abstract": "MUSE is a computer model for natural language processing, based on a semantic memory network  like that of Quillian's TLC.  MUSE, from a Model to Understand Simple English, processes English sentences  of unrestricted content but somewhat restricted format.  The model first applies syntactic analysis to  eliminate some interpretations and then employs a simplified semantic intersection procedure to find  a valid interpretation of the input.  While the semantic processing is similar to TLC's, the syntactic  component includes the early use of parse trees and special purpose rules.  The \"relational triple\" notation  used during interpretation of input is compatible with MUSE's memory structures, allowing direct verification  of familiar concepts and the addition of new ones.  MUSE also has a repertoire of actions, which range  from editing and reporting the contents of its own memory to an indirect form of question answering.   Examples are presented to demonstrate how the model interprets text, resolves ambiguities, adds information  to memory, generalizes from examples and performs various actions.", "authors": "McCalla, G. I. Sampson, J. R.", "words_pool": ["action", "addit", "add", "allow", "ambigu", "analysi", "answer", "appli", "base", "compat", "compon", "comput", "concept", "content", "content", "demonstr", "direct", "earli", "edit", "elimin", "employ", "english", "exampl", "familiar", "find", "form", "format", "gener", "includ", "indirect", "inform", "input", "interpret", "interpret", "interpret", "intersect", "languag", "memori", "model", "muse", "natur", "network", "notat", "pars", "perform", "present", "procedur", "process", "process", "purpos", "question", "quillian", "rang", "relat", "repertoir", "report", "resolv", "restrict", "rule", "semant", "sentenc", "similar", "simpl", "simplifi", "special", "structur", "syntact", "text", "tlc", "tree", "tripl", "understand", "unrestrict", "valid", "verif", "mccalla", "sampson"], "word_count": {"action": 2, "addit": 1, "add": 1, "allow": 1, "ambigu": 1, "analysi": 1, "answer": 1, "appli": 1, "base": 1, "compat": 1, "compon": 1, "comput": 1, "concept": 1, "content": 2, "demonstr": 1, "direct": 1, "earli": 1, "edit": 1, "elimin": 1, "employ": 1, "english": 2, "exampl": 2, "familiar": 1, "find": 1, "form": 1, "format": 1, "gener": 1, "includ": 1, "indirect": 1, "inform": 1, "input": 2, "interpret": 4, "intersect": 1, "languag": 1, "memori": 4, "model": 4, "muse": 4, "natur": 1, "network": 1, "notat": 1, "pars": 1, "perform": 1, "present": 1, "procedur": 1, "process": 3, "purpos": 1, "question": 1, "quillian": 1, "rang": 1, "relat": 1, "repertoir": 1, "report": 1, "resolv": 1, "restrict": 1, "rule": 1, "semant": 3, "sentenc": 1, "similar": 1, "simpl": 1, "simplifi": 1, "special": 1, "structur": 1, "syntact": 2, "text": 1, "tlc": 2, "tree": 1, "tripl": 1, "understand": 1, "unrestrict": 1, "valid": 1, "verif": 1, "mccalla": 1, "sampson": 1}}, "2397": {"id": "2397", "title": "Optimizing the Polyphase Sort (Corrigendum)", "authors": "Shell, D. L.", "words_pool": ["corrigendum", "optim", "polyphas", "sort", "shell"], "word_count": {"corrigendum": 1, "optim": 1, "polyphas": 1, "sort": 1, "shell": 1}}, "2398": {"id": "2398", "title": "Teacher/Student Authored CAI Using the NEWBASIC System", "abstract": "The pedagogical advantages of a general purpose interactive system called NEWBASIC/CATALYST  are discussed.  NEWBASIC/CATALYSTincorporates an advanced implementation of BASIC, system-level interactive  features, and a general capability for extension through user oriented function attachment,  Application  of this last feature to provide a flexible CAI scan capability is illustrated.  An example of interaction  at the system level shows how students can mix the advantages of independent or \"solo\" mode computing  with those of guided or \"dual\" mode interaction.  Preliminary experience with the system in an urban  secondary school setting is discussed.", "authors": "Dwyer, T. A.", "words_pool": ["advanc", "advantag", "applic", "attach", "author", "basic", "cai", "call", "capabl", "catalyst", "catalystincorpor", "comput", "discuss", "dual", "experi", "extens", "featur", "featur", "flexibl", "function", "gener", "guid", "illustr", "implement", "independ", "interact", "interact", "level", "mix", "mode", "newbas", "orient", "pedagog", "preliminari", "provid", "purpos", "scan", "school", "secondari", "set", "show", "solo", "student", "student", "system", "teacher", "urban", "user", "dwyer"], "word_count": {"advanc": 1, "advantag": 2, "applic": 1, "attach": 1, "author": 1, "basic": 1, "cai": 1, "call": 1, "capabl": 2, "catalyst": 1, "catalystincorpor": 1, "comput": 1, "discuss": 2, "dual": 1, "experi": 1, "extens": 1, "featur": 2, "flexibl": 1, "function": 1, "gener": 2, "guid": 1, "illustr": 1, "implement": 1, "independ": 1, "interact": 4, "level": 2, "mix": 1, "mode": 2, "newbas": 2, "orient": 1, "pedagog": 1, "preliminari": 1, "provid": 1, "purpos": 1, "scan": 1, "school": 1, "secondari": 1, "set": 1, "show": 1, "solo": 1, "student": 1, "system": 4, "teacher": 1, "urban": 1, "user": 1, "dwyer": 1}}, "2399": {"id": "2399", "title": "A CRT Editing System", "abstract": "A test-editing and manipulation program is described.  The program operates from low-cost cathode-ray  tube entry and display stations with keyboard and 13 function buttons. Applications, potential economy  of operation, and some aspects of implementation are discussed.", "authors": "Irons, E. T. Djorup, F. M.", "words_pool": ["applic", "aspect", "button", "cathod", "cost", "crt", "discuss", "display", "economi", "edit", "entri", "function", "implement", "keyboard", "low", "manipul", "oper", "oper", "potenti", "program", "ray", "station", "system", "test", "tube", "iron", "djorup"], "word_count": {"applic": 1, "aspect": 1, "button": 1, "cathod": 1, "cost": 1, "crt": 1, "discuss": 1, "display": 1, "economi": 1, "edit": 1, "entri": 1, "function": 1, "implement": 1, "keyboard": 1, "low": 1, "manipul": 1, "oper": 2, "potenti": 1, "program": 2, "ray": 1, "station": 1, "system": 1, "test": 1, "tube": 1, "iron": 1, "djorup": 1}}, "2400": {"id": "2400", "title": "Use of the Hough Transformation ToDetect Lines and Curves in Pictures", "abstract": "Hough has proposed an interesting and computationally efficient procedure for detecting lines  in pictures.  This paper points out that the use of angle-radius rather than slope-intercept parameters  simplifies the computation further.  It also shows how the method can be used for more general curve  fitting, and gives alternative interpretations that explain the source of its efficiency.", "authors": "Duda, R. O. Hart, P. E.", "words_pool": ["altern", "angl", "comput", "comput", "curv", "curv", "detect", "effici", "effici", "explain", "fit", "gener", "hough", "intercept", "interest", "interpret", "line", "method", "paper", "paramet", "pictur", "point", "procedur", "propos", "radiu", "show", "simplifi", "slope", "sourc", "todetect", "transform", "duda", "hart"], "word_count": {"altern": 1, "angl": 1, "comput": 2, "curv": 1, "detect": 1, "effici": 2, "explain": 1, "fit": 1, "gener": 1, "hough": 1, "intercept": 1, "interest": 1, "interpret": 1, "line": 1, "method": 1, "paper": 1, "paramet": 1, "pictur": 1, "point": 1, "procedur": 1, "propos": 1, "radiu": 1, "show": 1, "simplifi": 1, "slope": 1, "sourc": 1, "todetect": 1, "transform": 1, "duda": 1, "hart": 1}}, "2401": {"id": "2401", "title": "On Shrinking Binary Picture Patterns", "abstract": "A parallel processing algorithm for shrinking binary patterns to obtain single isolated elements,  one for each pattern, is presented.  This procedure may be used for counting patterns on a matrix, and  a hardware implementation of the algorithm using large scale integrated technology is envisioned.  The  principal features of this method are the very small window employed (two-by-two elements), the parallel  nature of the process, and the possibility of shrinking any pattern, regardless of the complexity of  its configuration.  Problems regarding merging and disconnection of patterns during the process as well  as the determination of the maximum number of steps necessary to obtain a single isolated element from  a pattern, are reviewed and discussed.  An analogy with a neural network description, in terms of McCulloch-Pitts  \"neurons\" is presented.", "authors": "Levialdi, S.", "words_pool": ["algorithm", "analog", "binari", "complex", "configur", "count", "descript", "determin", "disconnect", "discuss", "element", "element", "employ", "envis", "featur", "hardwar", "implement", "integr", "isol", "larg", "matrix", "maximum", "mcculloch", "merg", "method", "natur", "network", "neural", "neuron", "number", "obtain", "parallel", "pattern", "pattern", "pictur", "pitt", "possibl", "present", "princip", "problem", "procedur", "process", "process", "regard", "regardless", "review", "scale", "shrink", "singl", "small", "step", "technolog", "term", "window", "levialdi"], "word_count": {"algorithm": 2, "analog": 1, "binari": 1, "complex": 1, "configur": 1, "count": 1, "descript": 1, "determin": 1, "disconnect": 1, "discuss": 1, "element": 3, "employ": 1, "envis": 1, "featur": 1, "hardwar": 1, "implement": 1, "integr": 1, "isol": 2, "larg": 1, "matrix": 1, "maximum": 1, "mcculloch": 1, "merg": 1, "method": 1, "natur": 1, "network": 1, "neural": 1, "neuron": 1, "number": 1, "obtain": 2, "parallel": 2, "pattern": 6, "pictur": 1, "pitt": 1, "possibl": 1, "present": 2, "princip": 1, "problem": 1, "procedur": 1, "process": 3, "regard": 1, "regardless": 1, "review": 1, "scale": 1, "shrink": 2, "singl": 2, "small": 1, "step": 1, "technolog": 1, "term": 1, "window": 1, "levialdi": 1}}, "2402": {"id": "2402", "title": "Pictorial Pattern Recognition and the Phase Problem of X-ray Crystallography", "abstract": "The availability of interactive, three-dimensional, computer graphics systems coupled to powerful  digital computers encourages the development of algorithms adapted to this environment.  Pictorial pattern  recognition techniques make possible a number of approaches to X-ray structure determination based on  molecular model building, i.e. the use of chemical information to frame \"structural hypotheses\" which  can computationally be tested and refined by reference to the experimental data.  Application of standard  pattern recognition algorithms is hindered by the fact that the cross-correlation between a model and  the correct structure cannot be computed because of a fundamental incompleteness in the measured data.   However, it is possible to compute an upper bound to such a cross-correlation.  A simple example demonstrates  that this information can be the basis of a technique for structure determination that can make effective  use of an interactive graphics system. Model building by cross-correlations has intrinsic advantages  over usual crystallographic techniques based on the autocorrelation or Patterson function, especially  for large structures.  This is significant, for crystallography of biological macromolecules hasbeen  and will continue to be a field of intense interest.", "authors": "Lesk, A. M.", "words_pool": ["adapt", "advantag", "algorithm", "applic", "approach", "autocorrel", "avail", "base", "basi", "biolog", "bound", "build", "chemic", "comput", "comput", "comput", "comput", "comput", "continu", "correct", "correl", "correl", "coupl", "cross", "crystallograph", "crystallographi", "data", "demonstr", "determin", "develop", "digit", "dimension", "effect", "encourag", "environ", "especi", "experiment", "fact", "field", "frame", "function", "fundament", "graphic", "hasbeen", "hinder", "hypothes", "incomplet", "inform", "intens", "interact", "interest", "intrins", "larg", "macromolecul", "make", "measur", "model", "molecular", "number", "pattern", "patterson", "phase", "pictori", "power", "problem", "ray", "recognit", "refer", "refin", "signific", "simpl", "standard", "structur", "structur", "structur", "system", "system", "techniqu", "techniqu", "test", "upper", "usual", "lesk"], "word_count": {"adapt": 1, "advantag": 1, "algorithm": 2, "applic": 1, "approach": 1, "autocorrel": 1, "avail": 1, "base": 2, "basi": 1, "biolog": 1, "bound": 1, "build": 2, "chemic": 1, "comput": 5, "continu": 1, "correct": 1, "correl": 3, "coupl": 1, "cross": 3, "crystallograph": 1, "crystallographi": 1, "data": 2, "demonstr": 1, "determin": 2, "develop": 1, "digit": 1, "dimension": 1, "effect": 1, "encourag": 1, "environ": 1, "especi": 1, "experiment": 1, "fact": 1, "field": 1, "frame": 1, "function": 1, "fundament": 1, "graphic": 2, "hasbeen": 1, "hinder": 1, "hypothes": 1, "incomplet": 1, "inform": 2, "intens": 1, "interact": 2, "interest": 1, "intrins": 1, "larg": 1, "macromolecul": 1, "make": 2, "measur": 1, "model": 3, "molecular": 1, "number": 1, "pattern": 2, "patterson": 1, "phase": 1, "pictori": 1, "power": 1, "problem": 1, "ray": 1, "recognit": 2, "refer": 1, "refin": 1, "signific": 1, "simpl": 1, "standard": 1, "structur": 5, "system": 2, "techniqu": 3, "test": 1, "upper": 1, "usual": 1, "lesk": 1}}, "2403": {"id": "2403", "title": "Procedures for Natural Spline Interpolation [E1] (Algorithm A472)", "authors": "Herriot, J. G.", "words_pool": ["a472", "algorithm", "e1", "interpol", "natur", "procedur", "spline", "herriot"], "word_count": {"a472": 1, "algorithm": 1, "e1": 1, "interpol": 1, "natur": 1, "procedur": 1, "spline": 1, "herriot": 1}}, "2404": {"id": "2404", "title": "Exponential Integrals [S13] (Algorithm A471)", "authors": "Gautschi, W.", "words_pool": ["a471", "algorithm", "exponenti", "integr", "s13", "gautschi"], "word_count": {"a471": 1, "algorithm": 1, "exponenti": 1, "integr": 1, "s13": 1, "gautschi": 1}}, "2405": {"id": "2405", "title": "Linear Systems with Almost Tridiagonal Matrix [F4] (Algorithm A470)", "authors": "Kubicek, M.", "words_pool": ["a470", "algorithm", "f4", "linear", "matrix", "system", "tridiagon", "kubicek"], "word_count": {"a470": 1, "algorithm": 1, "f4": 1, "linear": 1, "matrix": 1, "system": 1, "tridiagon": 1, "kubicek": 1}}, "2406": {"id": "2406", "title": "A Data Definition and Mapping Language", "abstract": "A data definition language i sa declarative computer language for specifying data structures.   Most data definition languages concentrate on the declaration of logical data structures with little  concern for how these structures are physically realized on a computer system.  However, the need for  data definition languages which describe both the logical and physical aspects of data is increasingly  apparent.  Such languages will be a key systems, as well as in advanced data management systems and distributed  data bases.  This paper reviews past work in the data definition language for describing both logical  and physical aspects of data.  Applications of these \"generalized\" data definition languages are also  discussed.", "authors": "Sibley, E. H. Taylor, R. W.", "words_pool": ["advanc", "appar", "applic", "aspect", "base", "comput", "concentr", "concern", "data", "declar", "declar", "definit", "describ", "describ", "discuss", "distribut", "gener", "increasingli", "key", "languag", "languag", "logic", "manag", "map", "need", "paper", "past", "physic", "physic", "realiz", "review", "sa", "structur", "system", "system", "work", "sibley", "taylor"], "word_count": {"advanc": 1, "appar": 1, "applic": 1, "aspect": 2, "base": 1, "comput": 2, "concentr": 1, "concern": 1, "data": 11, "declar": 2, "definit": 5, "describ": 2, "discuss": 1, "distribut": 1, "gener": 1, "increasingli": 1, "key": 1, "languag": 7, "logic": 3, "manag": 1, "map": 1, "need": 1, "paper": 1, "past": 1, "physic": 3, "realiz": 1, "review": 1, "sa": 1, "structur": 3, "system": 3, "work": 1, "sibley": 1, "taylor": 1}}, "2407": {"id": "2407", "title": "Curriculum Recommendations for Undergraduate Programs in Information Systems", "abstract": "The need for education related to information systems in organizations is discussed, and a  curriculum is proposed for an undergraduate program.  Material necessary for such programs is identified,  and courses incorporating it are specified.Detailed course descriptions are presented.  Program organization  and a problems of implementation are discussed.", "authors": "Couger, J. D.", "words_pool": ["cours", "cours", "curriculum", "descript", "detail", "discuss", "educ", "identifi", "implement", "incorpor", "inform", "materi", "need", "organ", "organ", "present", "problem", "program", "program", "propos", "recommend", "relat", "system", "undergradu", "couger"], "word_count": {"cours": 2, "curriculum": 1, "descript": 1, "detail": 1, "discuss": 2, "educ": 1, "identifi": 1, "implement": 1, "incorpor": 1, "inform": 1, "materi": 1, "need": 1, "organ": 2, "present": 1, "problem": 1, "program": 3, "propos": 1, "recommend": 1, "relat": 1, "system": 1, "undergradu": 1, "couger": 1}}, "2408": {"id": "2408", "title": "Solving the Biharmonic Equation in a Square: A Direct Versus a Semidirect Method", "abstract": "Two methods for solving the biharmonic equation are compared.  One method is direct, using  eigenvalue-eigenvector decomposition.  The other method is iterative, solving a Poisson equation directly  at each iteration.", "authors": "Ehrlich, L. W.", "words_pool": ["biharmon", "compar", "decomposit", "direct", "directli", "eigenvalu", "eigenvector", "equat", "iter", "iter", "method", "method", "poisson", "semidirect", "solv", "squar", "versu", "ehrlich"], "word_count": {"biharmon": 1, "compar": 1, "decomposit": 1, "direct": 1, "directli": 1, "eigenvalu": 1, "eigenvector": 1, "equat": 2, "iter": 2, "method": 3, "poisson": 1, "semidirect": 1, "solv": 2, "squar": 1, "versu": 1, "ehrlich": 1}}, "2409": {"id": "2409", "title": "An Algorithm for the Approximate Solution of Wiener-Hopf Integral Equations", "abstract": "An explicit approximate solution is given for an equation.  Where it is assumed that the classical  Wiener-Hopf technique may be applied.  It is furthermore assumed that Fourier transforms are known explicitly.   The approximate solution depends on two positive parameters.", "authors": "Stenger, F.", "words_pool": ["algorithm", "appli", "approxim", "assum", "classic", "depend", "equat", "equat", "explicit", "explicitli", "fourier", "hopf", "integr", "known", "paramet", "posit", "solut", "techniqu", "transform", "wiener", "stenger"], "word_count": {"algorithm": 1, "appli": 1, "approxim": 2, "assum": 2, "classic": 1, "depend": 1, "equat": 1, "explicit": 1, "explicitli": 1, "fourier": 1, "hopf": 1, "integr": 1, "known": 1, "paramet": 1, "posit": 1, "solut": 2, "techniqu": 1, "transform": 1, "wiener": 1, "stenger": 1}}, "2410": {"id": "2410", "title": "A Recurrence Scheme for Converting from One Orthogonal Expansion into Another", "abstract": "A generalization of a scheme of Hamming for converting a polynomial Pn(x) into a Chebyshev  series is combined with a recurrence scheme of Clenshaw for summing any finite series whose terms satisfy  a three-term recurrence formula.", "authors": "Salzer, H. E.", "words_pool": ["chebyshev", "clenshaw", "combin", "convert", "expans", "finit", "formula", "gener", "ham", "orthogon", "pn", "polynomi", "recurr", "satisfi", "scheme", "seri", "sum", "term", "term", "salzer"], "word_count": {"chebyshev": 1, "clenshaw": 1, "combin": 1, "convert": 1, "expans": 1, "finit": 1, "formula": 1, "gener": 1, "ham": 1, "orthogon": 1, "pn": 1, "polynomi": 1, "recurr": 2, "satisfi": 1, "scheme": 2, "seri": 2, "sum": 1, "term": 2, "salzer": 1}}, "2411": {"id": "2411", "title": "Tree-Structured Programs", "authors": "Wegner, E.", "words_pool": ["program", "structur", "tree", "wegner"], "word_count": {"program": 1, "structur": 1, "tree": 1, "wegner": 1}}, "2412": {"id": "2412", "title": "Comment on Brent's Scatter Storage Algorithm", "authors": "Feldman, J. A. Low, J. R.", "words_pool": ["algorithm", "brent", "comment", "scatter", "storag", "feldman", "low"], "word_count": {"algorithm": 1, "brent": 1, "comment": 1, "scatter": 1, "storag": 1, "feldman": 1, "low": 1}}, "2413": {"id": "2413", "title": "A Note on Subexpression Ordering in the Execution of Arithmetic Expressions", "abstract": "A counterexample to the supposed optimality of an algorithm for generating schedules for trees  of tasks with unequal execution times is presented.  A comparison with the \"critical path\" heuristic  is discussed.", "authors": "Denning, P. J. Graham, G. S.", "words_pool": ["algorithm", "arithmet", "comparison", "counterexampl", "critic", "discuss", "execut", "express", "gener", "heurist", "note", "optim", "order", "path", "present", "schedul", "subexpress", "suppos", "task", "time", "tree", "unequ", "den", "graham"], "word_count": {"algorithm": 1, "arithmet": 1, "comparison": 1, "counterexampl": 1, "critic": 1, "discuss": 1, "execut": 1, "express": 1, "gener": 1, "heurist": 1, "note": 1, "optim": 1, "order": 1, "path": 1, "present": 1, "schedul": 1, "subexpress": 1, "suppos": 1, "task": 1, "time": 1, "tree": 1, "unequ": 1, "den": 1, "graham": 1}}, "2414": {"id": "2414", "title": "Arithmetic Overa Finite Field [A1] (Algorithm A469)", "authors": "Lam, C. McKay, J.", "words_pool": ["a1", "a469", "algorithm", "arithmet", "field", "finit", "overa", "lam", "mckay"], "word_count": {"a1": 1, "a469": 1, "algorithm": 1, "arithmet": 1, "field": 1, "finit": 1, "overa": 1, "lam": 1, "mckay": 1}}, "2415": {"id": "2415", "title": "Algorithm for Automatic Numerical Integration Over a Finite Interval [D1] (Algorithm A468)", "authors": "Patterson, T. N. L.", "words_pool": ["a468", "algorithm", "automat", "d1", "finit", "integr", "interv", "numer", "patterson"], "word_count": {"a468": 1, "algorithm": 2, "automat": 1, "d1": 1, "finit": 1, "integr": 1, "interv": 1, "numer": 1, "patterson": 1}}, "2416": {"id": "2416", "title": "Matrix Transposition in Place [F1] (Algorithm A467)", "authors": "Brenner, N.", "words_pool": ["a467", "algorithm", "f1", "matrix", "place", "transposit", "brenner"], "word_count": {"a467": 1, "algorithm": 1, "f1": 1, "matrix": 1, "place": 1, "transposit": 1, "brenner": 1}}, "2417": {"id": "2417", "title": "Four Combinatorial Algorithms [G6] (Algorithm A466)", "authors": "Ehrlich, G.", "words_pool": ["a466", "algorithm", "algorithm", "combinatori", "g6", "ehrlich"], "word_count": {"a466": 1, "algorithm": 2, "combinatori": 1, "g6": 1, "ehrlich": 1}}, "2418": {"id": "2418", "title": "Student's t Frequency [S14] (Algorithm A465)", "authors": "Hill, G. W.", "words_pool": ["a465", "algorithm", "frequenc", "s14", "student", "hill"], "word_count": {"a465": 1, "algorithm": 1, "frequenc": 1, "s14": 1, "student": 1, "hill": 1}}, "2419": {"id": "2419", "title": "Eigenvalues of a Real, Symmetric, Tridiagonal Matrix [F2] (Algorithm A464)", "authors": "Reinsch, C. H.", "words_pool": ["a464", "algorithm", "eigenvalu", "f2", "matrix", "real", "symmetr", "tridiagon", "reinsch"], "word_count": {"a464": 1, "algorithm": 1, "eigenvalu": 1, "f2": 1, "matrix": 1, "real": 1, "symmetr": 1, "tridiagon": 1, "reinsch": 1}}, "2420": {"id": "2420", "title": "Experiments with an Automatic Theorem-Prover HavingPartial Ordering Inference Rules", "abstract": "Automatic theorem-provers need to be made much more efficient.  With this in mind, Slagle has  shown how the axioms for partial ordering can be replaced by built-in inference rules when using a particular  theorem-proving algorithm based upon hyper-resolution and paramodulation.  The new rules embody the transitivity  of partial orderings and the close relationship between  predicates.  A program has been developed using  a modified version of these rules.  This new theorem-prover has been found to be very powerful for solving  problems involving partial orderings.  This paper presents a detailed description of the program and  a comprehensive account of the experiments that have been performed with it.", "authors": "Slagle, J. R. Norton, L. M.", "words_pool": ["account", "algorithm", "automat", "axiom", "base", "built", "close", "comprehens", "descript", "detail", "develop", "effici", "embodi", "experi", "found", "havingparti", "hyper", "infer", "involv", "made", "mind", "modifi", "need", "order", "order", "paper", "paramodul", "partial", "perform", "power", "predic", "present", "problem", "program", "prover", "prover", "prove", "relationship", "replac", "resolut", "rule", "shown", "slagl", "solv", "theorem", "transit", "version", "slagl", "norton"], "word_count": {"account": 1, "algorithm": 1, "automat": 1, "axiom": 1, "base": 1, "built": 1, "close": 1, "comprehens": 1, "descript": 1, "detail": 1, "develop": 1, "effici": 1, "embodi": 1, "experi": 1, "found": 1, "havingparti": 1, "hyper": 1, "infer": 1, "involv": 1, "made": 1, "mind": 1, "modifi": 1, "need": 1, "order": 3, "paper": 1, "paramodul": 1, "partial": 3, "perform": 1, "power": 1, "predic": 1, "present": 1, "problem": 1, "program": 2, "prover": 2, "prove": 1, "relationship": 1, "replac": 1, "resolut": 1, "rule": 3, "shown": 1, "slagl": 1, "solv": 1, "theorem": 3, "transit": 1, "version": 1, "norton": 1}}, "2421": {"id": "2421", "title": "A Scan Conversion Algorithm with Reduced Storage Requirements", "abstract": "Most graphics systems using a raster scan output device (CRT or hardcopy) maintain a display  file in the XY or random scan format.  Scan converters, hardware or software, must be provided to translate  the picture description from the XY format to the raster format.  Published scan conversion algorithms  which are fast will reserve a buffer area large enough to accommodate the entire screen.  On the other  hand, those which use a small buffer area are slow because they require multiple passes through the XY  display file.  The scan conversion algorithm described here uses a linked list data structure to process  the lines of the drawing in strips corresponding to groups of scan lines.  A relatively small primary  memory buffer area is used to accumulate the binary image for a group of scan lines.  When this portion  of the drawing has been plotted, the buffer is reused for the next portion.  Because of the list processing  procedures used, only a single pass through the XY display file is required when generating the binary  image and only a slight increase in execution time over the fully buffered core results.  Results slow  that storage requirements can be reduced by more than 80 percent while causing less than a 10 percent  increase in execution time.", "authors": "Jordan, B. W. Jr. Barrett, R. C.", "words_pool": ["accommod", "accumul", "algorithm", "algorithm", "area", "binari", "buffer", "buffer", "caus", "convers", "convert", "core", "crt", "data", "descript", "devic", "display", "draw", "entir", "execut", "fast", "format", "fulli", "gener", "graphic", "group", "group", "hand", "hardcopi", "hardwar", "imag", "increas", "larg", "line", "link", "list", "maintain", "memori", "multipl", "output", "pass", "pass", "percent", "pictur", "plot", "portion", "primari", "procedur", "process", "process", "provid", "publish", "random", "raster", "reduc", "requir", "requir", "requir", "reserv", "result", "reus", "scan", "screen", "singl", "slight", "slow", "small", "softwar", "storag", "strip", "structur", "system", "time", "translat", "xy", "jordan", "jr", "barrett"], "word_count": {"accommod": 1, "accumul": 1, "algorithm": 2, "area": 3, "binari": 2, "buffer": 5, "caus": 1, "convers": 2, "convert": 1, "core": 1, "crt": 1, "data": 1, "descript": 1, "devic": 1, "display": 3, "draw": 2, "entir": 1, "execut": 2, "fast": 1, "format": 3, "fulli": 1, "gener": 1, "graphic": 1, "group": 2, "hand": 1, "hardcopi": 1, "hardwar": 1, "imag": 2, "increas": 2, "larg": 1, "line": 3, "link": 1, "list": 2, "maintain": 1, "memori": 1, "multipl": 1, "output": 1, "pass": 2, "percent": 2, "pictur": 1, "plot": 1, "portion": 2, "primari": 1, "procedur": 1, "process": 2, "provid": 1, "publish": 1, "random": 1, "raster": 2, "reduc": 1, "requir": 3, "reserv": 1, "result": 2, "reus": 1, "scan": 7, "screen": 1, "singl": 1, "slight": 1, "slow": 2, "small": 2, "softwar": 1, "storag": 1, "strip": 1, "structur": 1, "system": 1, "time": 2, "translat": 1, "xy": 4, "jordan": 1, "jr": 1, "barrett": 1}}, "2422": {"id": "2422", "title": "Adaptive Correction of Program Statements (Corrigendum)", "authors": "James, E. B. Partridge, D. P.", "words_pool": ["adapt", "correct", "corrigendum", "program", "statement", "jame", "partridg"], "word_count": {"adapt": 1, "correct": 1, "corrigendum": 1, "program": 1, "statement": 1, "jame": 1, "partridg": 1}}, "2423": {"id": "2423", "title": "A Parser-Generating System for Constructing Compressed Compilers", "abstract": "This paper describes a parser-generating system (PGS) currently in use on the CDC-6500 computer  at Purdue University.  The PGS is a Fortran-coded compiler.  In the input translation grammar, each BNF  syntactic rule corresponds to a (possibly empty) \"code generator\" realizable as an assembly language,  Fortran or Algol, subroutine that is called whenever that syntactic rule is applied in the parse of a  program.  Typical one-pass compilers constructed by the PGS translate source programs at speeds approaching  14,000 cards per minute.  For an XPL compiler, the parser program and its tables currently occupy 288  words of 60-bit core memory of which 140 words are parsing table entries and 82 words are links to code  generators.", "authors": "Mickunas, M. D. Schneider, V. B.", "words_pool": ["algol", "appli", "approach", "assembl", "bit", "bnf", "call", "card", "cdc", "code", "code", "compil", "compil", "compress", "comput", "construct", "construct", "core", "correspond", "describ", "empti", "entri", "fortran", "gener", "gener", "gener", "grammar", "input", "languag", "link", "memori", "minut", "occupi", "paper", "pars", "parser", "pars", "pass", "pg", "possibl", "program", "program", "purdu", "realiz", "rule", "sourc", "speed", "subroutin", "syntact", "system", "tabl", "tabl", "translat", "translat", "typic", "univers", "word", "xpl", "mickuna", "schneider"], "word_count": {"algol": 1, "appli": 1, "approach": 1, "assembl": 1, "bit": 1, "bnf": 1, "call": 1, "card": 1, "cdc": 1, "code": 3, "compil": 3, "compress": 1, "comput": 1, "construct": 1, "core": 1, "correspond": 1, "describ": 1, "empti": 1, "entri": 1, "fortran": 2, "gener": 3, "grammar": 1, "input": 1, "languag": 1, "link": 1, "memori": 1, "minut": 1, "occupi": 1, "paper": 1, "pars": 2, "parser": 2, "pass": 1, "pg": 3, "possibl": 1, "program": 3, "purdu": 1, "realiz": 1, "rule": 2, "sourc": 1, "speed": 1, "subroutin": 1, "syntact": 2, "system": 1, "tabl": 2, "translat": 2, "typic": 1, "univers": 1, "word": 3, "xpl": 1, "mickuna": 1, "schneider": 1}}, "2424": {"id": "2424", "title": "Dynamic Verification of Operating System Decisions", "abstract": "Dynamic verification of a decision implies that every time the decision is made there is a  consistency check performed on the decision using independent hardware and software.  The dynamic verification  of operating system decisions is used on the PRIME system being designed and constructed at the University  of California, Berkeley.  PRIME is an experimental time-sharing which is to have the properties of continuous  availability, data privacy, and cost effectiveness.  The technique of dynamic verification allows the  construction of an operating system which does not make certain decisions improperly even in the presence  of a single hardware or software fault.  Furthermore, multiple faults lead to unreliable operation only  if the faults happen to reinforce each other.  On PRIME, dynamic verification is used to ensure that  one user's information cannot become available to another user gratuitously even in the presence of a  single hardware or software fault.the amount of additional hardware and software required for dynamic  verification can be modest.", "authors": "Fabry, R. S.", "words_pool": ["addit", "amount", "avail", "berkeley", "california", "check", "consist", "construct", "construct", "continu", "cost", "data", "decis", "decis", "design", "dynam", "effect", "ensur", "experiment", "fault", "fault", "gratuit", "happen", "hardwar", "impli", "improperli", "independ", "inform", "lead", "made", "make", "modest", "multipl", "oper", "oper", "perform", "presenc", "prime", "privaci", "properti", "reinforc", "requir", "share", "singl", "softwar", "system", "techniqu", "time", "univers", "unreli", "user", "verif", "fabri"], "word_count": {"addit": 1, "amount": 1, "avail": 1, "berkeley": 1, "california": 1, "check": 1, "consist": 1, "construct": 2, "continu": 1, "cost": 1, "data": 1, "decis": 5, "design": 1, "dynam": 5, "effect": 1, "ensur": 1, "experiment": 1, "fault": 4, "gratuit": 1, "happen": 1, "hardwar": 4, "impli": 1, "improperli": 1, "independ": 1, "inform": 1, "lead": 1, "made": 1, "make": 1, "modest": 1, "multipl": 1, "oper": 3, "perform": 1, "presenc": 2, "prime": 3, "privaci": 1, "properti": 1, "reinforc": 1, "requir": 1, "share": 1, "singl": 2, "softwar": 4, "system": 3, "techniqu": 1, "time": 2, "univers": 1, "unreli": 1, "user": 2, "verif": 5, "fabri": 1}}, "2425": {"id": "2425", "title": "The Programmer as Navigator", "authors": "Bachman, C. W.", "words_pool": ["navig", "programm", "bachman"], "word_count": {"navig": 1, "programm": 1, "bachman": 1}}, "2426": {"id": "2426", "title": "Algorithms SCALE1, SCALE2, and SCALE3 for Determination of Scales on Computer Generated Plots  [J6] (Algorithm A463)", "authors": "Lewart, C. R.", "words_pool": ["a463", "algorithm", "algorithm", "comput", "determin", "gener", "j6", "plot", "scale1", "scale2", "scale3", "scale", "lewart"], "word_count": {"a463": 1, "algorithm": 2, "comput": 1, "determin": 1, "gener": 1, "j6": 1, "plot": 1, "scale1": 1, "scale2": 1, "scale3": 1, "scale": 1, "lewart": 1}}, "2427": {"id": "2427", "title": "Bivariate Normal Distribution [S15] (Algorithm A462)", "authors": "Donnelly,T. G.", "words_pool": ["a462", "algorithm", "bivari", "distribut", "normal", "s15", "donnelli"], "word_count": {"a462": 1, "algorithm": 1, "bivari": 1, "distribut": 1, "normal": 1, "s15": 1, "donnelli": 1}}, "2428": {"id": "2428", "title": "Cubic Spline Solutions to a Class of Functional Differential Equations [D2] (Algorithm A461)", "authors": "Burkowski, F. J. Hoskins, W. D.", "words_pool": ["a461", "algorithm", "class", "cubic", "d2", "differenti", "equat", "function", "solut", "spline", "burkowski", "hoskin"], "word_count": {"a461": 1, "algorithm": 1, "class": 1, "cubic": 1, "d2": 1, "differenti": 1, "equat": 1, "function": 1, "solut": 1, "spline": 1, "burkowski": 1, "hoskin": 1}}, "2429": {"id": "2429", "title": "Calculation of Optimum Parameters for Alternating Direction Implicit Procedures [D3] (Algorithm  A460)", "authors": "Saylor, P. E. Sebastian, J. D.", "words_pool": ["a460", "algorithm", "altern", "calcul", "d3", "direct", "implicit", "optimum", "paramet", "procedur", "saylor", "sebastian"], "word_count": {"a460": 1, "algorithm": 1, "altern": 1, "calcul": 1, "d3": 1, "direct": 1, "implicit": 1, "optimum": 1, "paramet": 1, "procedur": 1, "saylor": 1, "sebastian": 1}}, "2430": {"id": "2430", "title": "The Elementary Circuits of a Graph [H] (Algorithm A459)", "authors": "Syslo,M. M.", "words_pool": ["a459", "algorithm", "circuit", "elementari", "graph", "syslo"], "word_count": {"a459": 1, "algorithm": 1, "circuit": 1, "elementari": 1, "graph": 1, "syslo": 1}}, "2431": {"id": "2431", "title": "Discrete Linear L1 Approximation by interval Linear Programming [E2] (Algorithm A458)", "authors": "Robers, P. D. Robers, S. S.", "words_pool": ["a458", "algorithm", "approxim", "discret", "e2", "interv", "l1", "linear", "program", "rober", "rober"], "word_count": {"a458": 1, "algorithm": 1, "approxim": 1, "discret": 1, "e2": 1, "interv": 1, "l1": 1, "linear": 2, "program": 1, "rober": 1}}, "2432": {"id": "2432", "title": "Addendum to a Multiple-Precision Division Algorithm", "authors": "Mifsud, C. J. Bohlen, M. J.", "words_pool": ["addendum", "algorithm", "divis", "multipl", "precis", "mifsud", "bohlen"], "word_count": {"addendum": 1, "algorithm": 1, "divis": 1, "multipl": 1, "precis": 1, "mifsud": 1, "bohlen": 1}}, "2433": {"id": "2433", "title": "Control Structures in Illiac IV Fortran", "abstract": "As part of an effort to design and implement a Fortran compiler on the ILLIAC IV, an extended  Fortran, called IVTRAN, has been developed.  This language provides a means of expressing data and control  structures suitable for exploiting ILLIAC IV parallelism.  This paper reviews the hardware characteristics  of the ILLIAC and singles out unconventional features which could be expected to influence language (and  compiler) design.  The implications of these features for data layout and algorithm structure are discussed,  and the conclusion is drawn that data allocation rather than code structuring is the crucial ILLIAC optimization  problem.  A satisfactory method of data allocation is then presented.  Language structures to utilize  this storage method and express parallel algorithms are described.", "authors": "Millstein, R. E.", "words_pool": ["algorithm", "algorithm", "alloc", "call", "characterist", "code", "compil", "conclus", "control", "crucial", "data", "design", "develop", "discuss", "drawn", "effort", "expect", "exploit", "express", "express", "extend", "featur", "fortran", "hardwar", "illiac", "implement", "implic", "influenc", "iv", "ivtran", "languag", "layout", "mean", "method", "optim", "paper", "parallel", "parallel", "part", "present", "problem", "review", "satisfactori", "singl", "storag", "structur", "structur", "structur", "suitabl", "unconvent", "util", "millstein"], "word_count": {"algorithm": 2, "alloc": 2, "call": 1, "characterist": 1, "code": 1, "compil": 2, "conclus": 1, "control": 1, "crucial": 1, "data": 4, "design": 2, "develop": 1, "discuss": 1, "drawn": 1, "effort": 1, "expect": 1, "exploit": 1, "express": 2, "extend": 1, "featur": 2, "fortran": 2, "hardwar": 1, "illiac": 4, "implement": 1, "implic": 1, "influenc": 1, "iv": 2, "ivtran": 1, "languag": 3, "layout": 1, "mean": 1, "method": 2, "optim": 1, "paper": 1, "parallel": 2, "part": 1, "present": 1, "problem": 1, "review": 1, "satisfactori": 1, "singl": 1, "storag": 1, "structur": 4, "suitabl": 1, "unconvent": 1, "util": 1, "millstein": 1}}, "2434": {"id": "2434", "title": "Using Page Residency To Select the Working Set Parameter", "abstract": "Denning's method for selecting the working set parameter, which uses interreference intervals,  is examined.  Several omissions in his model are noted, and new assumptions are introduced to overcome  these omissions.  Using this modified model, Dening's results on page residency are rederived and reconsidered  for selecting the working set parameter.", "authors": "Prieve, B. G.", "words_pool": ["assumpt", "dene", "den", "examin", "interrefer", "interv", "introduc", "method", "model", "modifi", "note", "omiss", "overcom", "page", "paramet", "reconsid", "rederiv", "resid", "result", "select", "select", "set", "work", "priev"], "word_count": {"assumpt": 1, "dene": 1, "den": 1, "examin": 1, "interrefer": 1, "interv": 1, "introduc": 1, "method": 1, "model": 2, "modifi": 1, "note": 1, "omiss": 2, "overcom": 1, "page": 1, "paramet": 2, "reconsid": 1, "rederiv": 1, "resid": 1, "result": 1, "select": 2, "set": 2, "work": 2, "priev": 1}}, "2435": {"id": "2435", "title": "A Class of Dynamic Memory Allocation Algorithms", "abstract": "Anew dynamic memory allocation algorithm, the Fibonacci system, is introduced.  This algorithm  is similar to, but seems to have certain advantages over, the \"buddy\" system.  A generalization is mentioned  which includes both of these systems as special cases.", "authors": "Hirschberg, D. S.", "words_pool": ["advantag", "algorithm", "algorithm", "alloc", "anew", "buddi", "case", "class", "dynam", "fibonacci", "gener", "includ", "introduc", "memori", "mention", "similar", "special", "system", "system", "hirschberg"], "word_count": {"advantag": 1, "algorithm": 2, "alloc": 1, "anew": 1, "buddi": 1, "case": 1, "class": 1, "dynam": 1, "fibonacci": 1, "gener": 1, "includ": 1, "introduc": 1, "memori": 1, "mention": 1, "similar": 1, "special": 1, "system": 3, "hirschberg": 1}}, "2436": {"id": "2436", "title": "A Note on the Confinement Problem", "abstract": "This note explores the problem of confining a program during its execution so that it cannot  transmit information to any other program except its caller.  A set of examples attempts to stake out  the boundaries of the problem.  Necessary conditions for a solution are stated and informally justified.", "authors": "Lampson, B. W.", "words_pool": ["attempt", "boundari", "caller", "condit", "confin", "confin", "exampl", "execut", "explor", "inform", "inform", "justifi", "note", "problem", "program", "set", "solut", "stake", "state", "transmit", "lampson"], "word_count": {"attempt": 1, "boundari": 1, "caller": 1, "condit": 1, "confin": 1, "exampl": 1, "execut": 1, "explor": 1, "inform": 2, "justifi": 1, "note": 1, "problem": 2, "program": 2, "set": 1, "solut": 1, "stake": 1, "state": 1, "transmit": 1, "lampson": 1}}, "2437": {"id": "2437", "title": "General Performance Analysis of Key-to-Address Transformation Methods Using an Abstract File  Concept", "abstract": "This paper presents a new approach to the analysis of performance of the various key-to-address  transformation methods.  In this approach the keys in a file are assumed to have been selected from the  key space according to a certain probabilistic selection algorithm.  All files with the same number of  keys selected from this key space will be suitably weighted in accordance with the algorithm, and the  average performance of the transformation methods on these files will be used as the potential of these  methods.  Using this analysis, methods with the same overall performance can be classified and key distributions  partial to certain transformations can be identified.  All this can be done analytically.  The approach  is applied to a group of transformation methods using files whose keys are selected randomly.", "authors": "Lum, V. Y.", "words_pool": ["abstract", "accord", "accord", "address", "algorithm", "analysi", "analyt", "appli", "approach", "assum", "averag", "classifi", "concept", "distribut", "gener", "group", "identifi", "key", "key", "method", "number", "paper", "partial", "perform", "potenti", "present", "probabilist", "randomli", "select", "select", "space", "suitabl", "transform", "transform", "weight", "lum"], "word_count": {"abstract": 1, "accord": 2, "address": 1, "algorithm": 2, "analysi": 2, "analyt": 1, "appli": 1, "approach": 3, "assum": 1, "averag": 1, "classifi": 1, "concept": 1, "distribut": 1, "gener": 1, "group": 1, "identifi": 1, "key": 7, "method": 5, "number": 1, "paper": 1, "partial": 1, "perform": 3, "potenti": 1, "present": 1, "probabilist": 1, "randomli": 1, "select": 4, "space": 2, "suitabl": 1, "transform": 4, "weight": 1, "lum": 1}}, "2438": {"id": "2438", "title": "A Model and Stack Implementation of Multiple Environments", "abstract": "Many control and access environment structures require that storage for a procedure activation  exist at times when control is not nested within the procedure activated.  This is straightforward to  implement by dynamic storage allocation with linked blocks for each activation, but rather expensive  in both time and space.  This paper presents an implementation technique using a single stack to hold  procedure activation storage which allows retention of that storage for durations not necessarily tied  to control flow.  The technique has the property that, in the simple case,it runs identically to the  usual automatic stack allocation and deallocation procedure.  Applications of this technique to multitasking,  coroutines, backtracking, label-valued variables, and functional arguments are discussed.  In the initial  model, a single real processor is assumed, and the implementation assumes multiple-processes coordinate  by passing control explicitly to one another.  A multiprocessor implementation requires only a few changes  to the basic technique, as described.", "authors": "Bobrow, D. G. Wegbreit, B.", "words_pool": ["access", "activ", "activ", "alloc", "applic", "argument", "assum", "assum", "automat", "backtrack", "basic", "block", "case", "control", "coordin", "coroutin", "dealloc", "discuss", "durat", "dynam", "environ", "environ", "exist", "expens", "explicitli", "flow", "function", "hold", "ident", "implement", "implement", "initi", "label", "link", "model", "multipl", "multiprocessor", "multitask", "necessarili", "nest", "paper", "pass", "present", "procedur", "process", "processor", "properti", "real", "requir", "requir", "retent", "run", "simpl", "singl", "space", "stack", "storag", "straightforward", "structur", "techniqu", "tie", "time", "time", "usual", "valu", "variabl", "bobrow", "wegbreit"], "word_count": {"access": 1, "activ": 4, "alloc": 2, "applic": 1, "argument": 1, "assum": 2, "automat": 1, "backtrack": 1, "basic": 1, "block": 1, "case": 1, "control": 4, "coordin": 1, "coroutin": 1, "dealloc": 1, "discuss": 1, "durat": 1, "dynam": 1, "environ": 1, "exist": 1, "expens": 1, "explicitli": 1, "flow": 1, "function": 1, "hold": 1, "ident": 1, "implement": 4, "initi": 1, "label": 1, "link": 1, "model": 1, "multipl": 1, "multiprocessor": 1, "multitask": 1, "necessarili": 1, "nest": 1, "paper": 1, "pass": 1, "present": 1, "procedur": 4, "process": 1, "processor": 1, "properti": 1, "real": 1, "requir": 2, "retent": 1, "run": 1, "simpl": 1, "singl": 2, "space": 1, "stack": 2, "storag": 4, "straightforward": 1, "structur": 1, "techniqu": 4, "tie": 1, "time": 2, "usual": 1, "valu": 1, "variabl": 1, "bobrow": 1, "wegbreit": 1}}, "2439": {"id": "2439", "title": "Multiple Terminals Under User Program Control in a Time-Sharing Environment", "abstract": "User-written programs on the Dartmouth Time-Sharing system can communicate with many remote  terminals simultaneously and can control the interactions between these terminals.  Such programs can  be written using standard input and output instructions in any language available on the system.  This  paper describes how this multiple-terminal facility was implemented without requiring any changes in  the system executive or in any of the system's compilers or interpreters.", "authors": "McGeachie, J. S.", "words_pool": ["commun", "compil", "control", "dartmouth", "describ", "environ", "execut", "facil", "implement", "input", "instruct", "interact", "interpret", "languag", "multipl", "output", "paper", "program", "program", "remot", "requir", "share", "simultan", "standard", "system", "termin", "termin", "time", "user", "written", "mcgeachi"], "word_count": {"commun": 1, "compil": 1, "control": 1, "dartmouth": 1, "describ": 1, "environ": 1, "execut": 1, "facil": 1, "implement": 1, "input": 1, "instruct": 1, "interact": 1, "interpret": 1, "languag": 1, "multipl": 1, "output": 1, "paper": 1, "program": 2, "remot": 1, "requir": 1, "share": 1, "simultan": 1, "standard": 1, "system": 4, "termin": 3, "time": 1, "user": 1, "written": 2, "mcgeachi": 1}}, "2440": {"id": "2440", "title": "Localization of the Roots of a Polynomial (Algorithm R429)", "authors": "Driessen, H. B. Hunt, E. W. LeM.", "words_pool": ["algorithm", "local", "polynomi", "r429", "root", "driessen", "hunt", "lem"], "word_count": {"algorithm": 1, "local": 1, "polynomi": 1, "r429": 1, "root": 1, "driessen": 1, "hunt": 1, "lem": 1}}, "2441": {"id": "2441", "title": "Hidden-Line Plotting Program (Algorithm R420)", "authors": "Williamson, H.", "words_pool": ["algorithm", "hidden", "line", "plot", "program", "r420", "williamson"], "word_count": {"algorithm": 1, "hidden": 1, "line": 1, "plot": 1, "program": 1, "r420": 1, "williamson": 1}}, "2442": {"id": "2442", "title": "A Sparse Matrix Package (Algorithm R408)", "authors": "Lawrence, E. E.", "words_pool": ["algorithm", "matrix", "packag", "r408", "spars", "lawrenc"], "word_count": {"algorithm": 1, "matrix": 1, "packag": 1, "r408": 1, "spars": 1, "lawrenc": 1}}, "2443": {"id": "2443", "title": "Generation of Permutations in Lexicographic Order (Algorithm R323)", "authors": "Roy, M. K.", "words_pool": ["algorithm", "gener", "lexicograph", "order", "permut", "r323", "roy"], "word_count": {"algorithm": 1, "gener": 1, "lexicograph": 1, "order": 1, "permut": 1, "r323": 1, "roy": 1}}, "2444": {"id": "2444", "title": "Finding All Cliques of an Undirected Graph (Algorithm A457)", "authors": "Bron, C. Kerbosch, J.", "words_pool": ["a457", "algorithm", "cliqu", "find", "graph", "undirect", "bron", "kerbosch"], "word_count": {"a457": 1, "algorithm": 1, "cliqu": 1, "find": 1, "graph": 1, "undirect": 1, "bron": 1, "kerbosch": 1}}, "2445": {"id": "2445", "title": "Routing Problem (Algorithm A456)", "authors": "Fencl, Z.", "words_pool": ["a456", "algorithm", "problem", "rout", "fencl"], "word_count": {"a456": 1, "algorithm": 1, "problem": 1, "rout": 1, "fencl": 1}}, "2446": {"id": "2446", "title": "Analysis of Skew Representations of the Symmetric Group (Algorithm A455)", "authors": "Hunter, D. B. Williams, J. M.", "words_pool": ["a455", "algorithm", "analysi", "group", "represent", "skew", "symmetr", "hunter", "william"], "word_count": {"a455": 1, "algorithm": 1, "analysi": 1, "group": 1, "represent": 1, "skew": 1, "symmetr": 1, "hunter": 1, "william": 1}}, "2447": {"id": "2447", "title": "Sard Kernels for Certain Bivariate Cubatures", "abstract": "An error analysis for some bivariate cubatures is given.  The remainders are obtained by the  use of Sard kernels.  Numerical results and computer graphs are given for some of the kernel functions.", "authors": "Barnhill, R. E. Pilcher, D. T.", "words_pool": ["analysi", "bivari", "comput", "cubatur", "error", "function", "graph", "kernel", "kernel", "numer", "obtain", "remaind", "result", "sard", "barnhil", "pilcher"], "word_count": {"analysi": 1, "bivari": 1, "comput": 1, "cubatur": 1, "error": 1, "function": 1, "graph": 1, "kernel": 2, "numer": 1, "obtain": 1, "remaind": 1, "result": 1, "sard": 1, "barnhil": 1, "pilcher": 1}}, "2448": {"id": "2448", "title": "Reversible Execution", "authors": "Zelkowitz, M. V.", "words_pool": ["execut", "revers", "zelkowitz"], "word_count": {"execut": 1, "revers": 1, "zelkowitz": 1}}, "2449": {"id": "2449", "title": "A Simple Technique for Structured Variable Lookup", "abstract": "A simple technique for the symbol-table lookup of structured variables based on simple automata  theory is presented. The technique offers a deterministic solution to a problem which is currently handled  in a nondeterministic manner in PL/I and COBOL compilers.", "authors": "Gates, G. W. Poplawski, D. A.", "words_pool": ["automata", "base", "cobol", "compil", "determinist", "handl", "lookup", "manner", "nondeterminist", "offer", "pl", "present", "problem", "simpl", "solut", "structur", "symbol", "tabl", "techniqu", "theori", "variabl", "variabl", "gate", "poplawski"], "word_count": {"automata": 1, "base": 1, "cobol": 1, "compil": 1, "determinist": 1, "handl": 1, "lookup": 1, "manner": 1, "nondeterminist": 1, "offer": 1, "pl": 1, "present": 1, "problem": 1, "simpl": 2, "solut": 1, "structur": 1, "symbol": 1, "tabl": 1, "techniqu": 2, "theori": 1, "variabl": 1, "gate": 1, "poplawski": 1}}, "2450": {"id": "2450", "title": "Empirical Working Set Behavior", "abstract": "The working set model for program behavior has been proposed in recent years as a basis for  the design of scheduling and paging algorithms.  Although the words \"working set\" are now commonly encountered  in the literature dealing with resource allocation, there is a dearth of published data on program measurements,  in the hope that workers in the field might find experimental evidence upon which to substantiate and  base theoretical work.", "authors": "Rodriguez-Rosell, J.", "words_pool": ["algorithm", "alloc", "base", "basi", "behavior", "commonli", "data", "deal", "dearth", "design", "empir", "encount", "evid", "experiment", "field", "find", "hope", "literatur", "measur", "model", "page", "program", "propos", "publish", "recent", "resourc", "schedul", "set", "substanti", "theoret", "word", "work", "worker", "work", "year", "rodriguez", "rosel"], "word_count": {"algorithm": 1, "alloc": 1, "base": 1, "basi": 1, "behavior": 1, "commonli": 1, "data": 1, "deal": 1, "dearth": 1, "design": 1, "empir": 1, "encount": 1, "evid": 1, "experiment": 1, "field": 1, "find": 1, "hope": 1, "literatur": 1, "measur": 1, "model": 1, "page": 1, "program": 2, "propos": 1, "publish": 1, "recent": 1, "resourc": 1, "schedul": 1, "set": 2, "substanti": 1, "theoret": 1, "word": 1, "work": 3, "worker": 1, "year": 1, "rodriguez": 1, "rosel": 1}}, "2451": {"id": "2451", "title": "Design of Tree Structures for Efficient Querying", "abstract": "A standard information retrieval operation is to determine which records in a data collection  satisfy a given query expressed in terms of data values.  The process of locating the desired responses  can be represented by a tree search model.  This paper poses an optimization problem in the design of  such trees to serve a well-specified application. The problem is academic in the sense that ordinarily  the optimal tree cannot be implemented by means of practical techniques.  On the other hand, it is potentially  useful for the comparison it affords between observed performance and that of an intuitively attractive  ideal search procedure.  As a practical application of such a model this paper considers the design of  a novel tree search scheme based on a bit vector representation of data and shows that essentially the  same algorithm can be used to design either an ideal search tree or a bit-vector tree.  An experimental  study of a small formatted file illustrates the concepts.", "authors": "Casey, R. G.", "words_pool": ["academ", "afford", "algorithm", "applic", "attract", "base", "bit", "collect", "comparison", "concept", "consid", "data", "design", "desir", "determin", "effici", "essenti", "experiment", "express", "format", "hand", "ideal", "illustr", "implement", "inform", "intuit", "locat", "mean", "model", "observ", "oper", "optim", "optim", "ordinarili", "paper", "perform", "pose", "potenti", "practic", "problem", "procedur", "process", "queri", "queri", "record", "represent", "repres", "respons", "retriev", "satisfi", "scheme", "search", "sens", "serv", "show", "small", "standard", "structur", "studi", "techniqu", "term", "tree", "tree", "valu", "vector", "casey"], "word_count": {"academ": 1, "afford": 1, "algorithm": 1, "applic": 2, "attract": 1, "base": 1, "bit": 2, "collect": 1, "comparison": 1, "concept": 1, "consid": 1, "data": 3, "design": 3, "desir": 1, "determin": 1, "effici": 1, "essenti": 1, "experiment": 1, "express": 1, "format": 1, "hand": 1, "ideal": 2, "illustr": 1, "implement": 1, "inform": 1, "intuit": 1, "locat": 1, "mean": 1, "model": 2, "observ": 1, "oper": 1, "optim": 2, "ordinarili": 1, "paper": 2, "perform": 1, "pose": 1, "potenti": 1, "practic": 2, "problem": 2, "procedur": 1, "process": 1, "queri": 1, "record": 1, "represent": 1, "repres": 1, "respons": 1, "retriev": 1, "satisfi": 1, "scheme": 1, "search": 4, "sens": 1, "serv": 1, "show": 1, "small": 1, "standard": 1, "structur": 1, "studi": 1, "techniqu": 1, "term": 1, "tree": 6, "valu": 1, "vector": 2, "casey": 1}}, "2452": {"id": "2452", "title": "Evaluation and Selection of File Organization-A Model and System", "abstract": "This work first discusses the factors that affect file (data base) organization performance,  an elusive subject, and then presents a methodology, a model and a programmed system to estimate primarily  total storage costs and average access time of several file organizations, given a specific data base,  query characterization and device-related specifications.  Based on these estimates, an appropriate file  structure may be selected for the specific situation.  The system is a convenient tool to study file  structures and to facilitate as much as possible the process of data base structure design and evaluation.", "authors": "Cardenas, A. F.", "words_pool": ["access", "affect", "averag", "base", "base", "character", "conveni", "cost", "data", "design", "devic", "discuss", "elus", "estim", "estim", "evalu", "facilit", "factor", "methodolog", "model", "organ", "organ", "perform", "present", "primarili", "process", "program", "queri", "relat", "select", "select", "situat", "specif", "specif", "storag", "structur", "structur", "studi", "subject", "system", "time", "tool", "total", "work", "cardena"], "word_count": {"access": 1, "affect": 1, "averag": 1, "base": 4, "character": 1, "conveni": 1, "cost": 1, "data": 3, "design": 1, "devic": 1, "discuss": 1, "elus": 1, "estim": 2, "evalu": 1, "facilit": 1, "factor": 1, "methodolog": 1, "model": 1, "organ": 2, "perform": 1, "present": 1, "primarili": 1, "process": 1, "program": 1, "queri": 1, "relat": 1, "select": 1, "situat": 1, "specif": 3, "storag": 1, "structur": 3, "studi": 1, "subject": 1, "system": 2, "time": 1, "tool": 1, "total": 1, "work": 1, "cardena": 1}}, "2453": {"id": "2453", "title": "Information Theory Applied to the Conversion of Decision Tables to Computer Programs", "abstract": "Using ideas from information theory, this paper develops a heuristic algorithm that converts  a limited entry decision table to a tree structured computer program with near minimum average processing  time.  The method is applicable to any limited entry decision table and does not require that actions  have single rules or that the cost of testing conditions be equal.  It is thus more general than the  previously published heuristic algorithms.  Compared to the optimal algorithm of Reinwald and Soland,  this algorithm is easy to code and takes a much smaller translation time; it is thus felt that it is  more useful in practice.  The algorithm is well suited for manual conversion of decision tables to flowcharts.", "authors": "Ganapathy, S. Rajaraman, V.", "words_pool": ["action", "algorithm", "algorithm", "applic", "appli", "averag", "code", "compar", "comput", "condit", "convers", "convert", "cost", "decis", "develop", "easi", "entri", "equal", "felt", "flowchart", "gener", "heurist", "idea", "inform", "limit", "method", "minimum", "optim", "paper", "practic", "previous", "process", "program", "program", "publish", "reinwald", "requir", "rule", "singl", "smaller", "soland", "structur", "suit", "tabl", "tabl", "take", "test", "theori", "time", "translat", "tree", "ganapathi", "rajaraman"], "word_count": {"action": 1, "algorithm": 5, "applic": 1, "appli": 1, "averag": 1, "code": 1, "compar": 1, "comput": 1, "condit": 1, "convers": 1, "convert": 1, "cost": 1, "decis": 3, "develop": 1, "easi": 1, "entri": 2, "equal": 1, "felt": 1, "flowchart": 1, "gener": 1, "heurist": 2, "idea": 1, "inform": 1, "limit": 2, "method": 1, "minimum": 1, "optim": 1, "paper": 1, "practic": 1, "previous": 1, "process": 1, "program": 1, "publish": 1, "reinwald": 1, "requir": 1, "rule": 1, "singl": 1, "smaller": 1, "soland": 1, "structur": 1, "suit": 1, "tabl": 3, "take": 1, "test": 1, "theori": 1, "time": 2, "translat": 1, "tree": 1, "ganapathi": 1, "rajaraman": 1}}, "2454": {"id": "2454", "title": "Computational Algorithms for Closed Queueing Networks with Exponential Servers", "abstract": "Methods are presented for computing the equilibrium distribution of customers in closed queueing  networks with exponential servers.  Expressions for various marginal distributions are also derived.   The computational algorithms are based on two-dimensional iterative techniques which are highly efficient  and quite simple to implement.  Implementation considerations such as storage allocation strategies and  order of evaluation are examined in some detail.", "authors": "Buzen, J. P.", "words_pool": ["algorithm", "alloc", "base", "close", "comput", "comput", "consider", "custom", "deriv", "detail", "dimension", "distribut", "distribut", "effici", "equilibrium", "evalu", "examin", "exponenti", "express", "highli", "implement", "implement", "iter", "margin", "method", "network", "order", "present", "queue", "server", "simpl", "storag", "strategi", "techniqu", "buzen"], "word_count": {"algorithm": 1, "alloc": 1, "base": 1, "close": 1, "comput": 2, "consider": 1, "custom": 1, "deriv": 1, "detail": 1, "dimension": 1, "distribut": 2, "effici": 1, "equilibrium": 1, "evalu": 1, "examin": 1, "exponenti": 1, "express": 1, "highli": 1, "implement": 2, "iter": 1, "margin": 1, "method": 1, "network": 1, "order": 1, "present": 1, "queue": 1, "server": 1, "simpl": 1, "storag": 1, "strategi": 1, "techniqu": 1, "buzen": 1}}, "2455": {"id": "2455", "title": "A Generalization of AVL Trees", "abstract": "A generalization of AVL trees is proposed in which imbalances up to (triangle shape) is a small  integer.  An experiment is performed to compare these trees with standard AVL trees and with balanced  trees on the basis of mean retrieval time, of amount of restructuring expected, and on the worst case  of retrieval time.  It is shown that, by permitting imbalances of up to five units, the retrieval time  is increased a small amount while the amount of restructuring required is decreased by a factor of ten.   A few theoretical results are derived, including the correction of an earlier paper, and are duly compared  with the experimental data.  Reasonably good correspondence is found.", "authors": "Foster, C. C.", "words_pool": ["amount", "avl", "balanc", "basi", "case", "compar", "compar", "correct", "correspond", "data", "decreas", "deriv", "duli", "earlier", "expect", "experi", "experiment", "factor", "found", "gener", "good", "imbal", "includ", "increas", "integ", "mean", "paper", "perform", "permit", "propos", "reason", "requir", "restructur", "result", "retriev", "shape", "shown", "small", "standard", "ten", "theoret", "time", "tree", "triangl", "unit", "worst", "foster"], "word_count": {"amount": 3, "avl": 2, "balanc": 1, "basi": 1, "case": 1, "compar": 2, "correct": 1, "correspond": 1, "data": 1, "decreas": 1, "deriv": 1, "duli": 1, "earlier": 1, "expect": 1, "experi": 1, "experiment": 1, "factor": 1, "found": 1, "gener": 1, "good": 1, "imbal": 2, "includ": 1, "increas": 1, "integ": 1, "mean": 1, "paper": 1, "perform": 1, "permit": 1, "propos": 1, "reason": 1, "requir": 1, "restructur": 2, "result": 1, "retriev": 3, "shape": 1, "shown": 1, "small": 2, "standard": 1, "ten": 1, "theoret": 1, "time": 3, "tree": 4, "triangl": 1, "unit": 1, "worst": 1, "foster": 1}}, "2456": {"id": "2456", "title": "On the Capabilities of While, Repeat, and Exit Statements", "abstract": "A well-formed program is defined as a program in which loops and if statements are properly  nested and can be entered only at their beginning.  A corresponding definition is given for a well-formed  flowchart.  It is shown that a program is well formed if and only if it can be written with if, repeat,  and multi-level exit statements for sequence control.  It is also shown that if,while, and repeat statements  with single-level exit do not suffice.  It is also shown that any flowcharts can be converted to a well-formed  flowchart by node splitting.  Practical implications are discussed.", "authors": "Peterson, W. W. Kasami, T. Tokura, N.", "words_pool": ["begin", "capabl", "control", "convert", "defin", "definit", "discuss", "enter", "exit", "flowchart", "flowchart", "form", "implic", "level", "loop", "multi", "nest", "node", "practic", "program", "properli", "repeat", "sequenc", "shown", "singl", "split", "statement", "suffic", "written", "peterson", "kasami", "tokura"], "word_count": {"begin": 1, "capabl": 1, "control": 1, "convert": 1, "defin": 1, "definit": 1, "discuss": 1, "enter": 1, "exit": 2, "flowchart": 3, "form": 4, "implic": 1, "level": 2, "loop": 1, "multi": 1, "nest": 1, "node": 1, "practic": 1, "program": 3, "properli": 1, "repeat": 2, "sequenc": 1, "shown": 3, "singl": 1, "split": 1, "statement": 3, "suffic": 1, "written": 1, "peterson": 1, "kasami": 1, "tokura": 1}}, "2457": {"id": "2457", "title": "Inductive Methodsfor Proving Properties of Programs", "abstract": "There are two main purposes in this paper: first, clarification and extension of known results  about computation of recursive programs, with emphasis on the difference between the theoretical and  practical approaches; second, presentation and examination of various known methods for proving properties  of recursive programs.  Discussed in detail are two powerful inductive methods computational induction  and structural induction, including examples of their applications.", "authors": "Manna, Z. Nes, S. Vuillemin, J.", "words_pool": ["applic", "approach", "clarif", "comput", "comput", "detail", "differ", "discuss", "emphasi", "examin", "exampl", "extens", "includ", "induct", "induct", "known", "main", "method", "methodsfor", "paper", "power", "practic", "present", "program", "properti", "prove", "purpos", "recurs", "result", "structur", "theoret", "manna", "ne", "vuillemin"], "word_count": {"applic": 1, "approach": 1, "clarif": 1, "comput": 2, "detail": 1, "differ": 1, "discuss": 1, "emphasi": 1, "examin": 1, "exampl": 1, "extens": 1, "includ": 1, "induct": 3, "known": 2, "main": 1, "method": 2, "methodsfor": 1, "paper": 1, "power": 1, "practic": 1, "present": 1, "program": 2, "properti": 1, "prove": 1, "purpos": 1, "recurs": 2, "result": 1, "structur": 1, "theoret": 1, "manna": 1, "ne": 1, "vuillemin": 1}}, "2458": {"id": "2458", "title": "Localization of the Roots of a Polynomial (Algorithm R429)", "authors": "Williams, E. J.", "words_pool": ["algorithm", "local", "polynomi", "r429", "root", "william"], "word_count": {"algorithm": 1, "local": 1, "polynomi": 1, "r429": 1, "root": 1, "william": 1}}, "2459": {"id": "2459", "title": "Hu-Tucker Minimum Redundancy Alphabetic Coding Method (Algorithm R428)", "authors": "Byrne, J. G.", "words_pool": ["algorithm", "alphabet", "code", "hu", "method", "minimum", "r428", "redund", "tucker", "byrn"], "word_count": {"algorithm": 1, "alphabet": 1, "code": 1, "hu": 1, "method": 1, "minimum": 1, "r428": 1, "redund": 1, "tucker": 1, "byrn": 1}}, "2460": {"id": "2460", "title": "Clenshaw-Curtis Quadrature (Algorithm R424)", "authors": "Good, A. J.", "words_pool": ["algorithm", "clenshaw", "curti", "quadratur", "r424", "good"], "word_count": {"algorithm": 1, "clenshaw": 1, "curti": 1, "quadratur": 1, "r424": 1, "good": 1}}, "2461": {"id": "2461", "title": "Graph Plotter (Algorithm R412)", "authors": "Watkins, R. P.", "words_pool": ["algorithm", "graph", "plotter", "r412", "watkin"], "word_count": {"algorithm": 1, "graph": 1, "plotter": 1, "r412": 1, "watkin": 1}}, "2462": {"id": "2462", "title": "An Efficient Prime Number Generator (Algorithm R357)", "authors": "DeMorgan, R. M.", "words_pool": ["algorithm", "effici", "gener", "number", "prime", "r357", "demorgan"], "word_count": {"algorithm": 1, "effici": 1, "gener": 1, "number": 1, "prime": 1, "r357": 1, "demorgan": 1}}, "2463": {"id": "2463", "title": "Complex Gamma Function (Algorithm R404,C404)", "authors": "Andrejkova, G. Vinar, J.", "words_pool": ["algorithm", "c404", "complex", "function", "gamma", "r404", "andrejkova", "vinar"], "word_count": {"algorithm": 1, "c404": 1, "complex": 1, "function": 1, "gamma": 1, "r404": 1, "andrejkova": 1, "vinar": 1}}, "2464": {"id": "2464", "title": "The Complex Method for Constrained Optimization [E4] (Algorithm A454)", "authors": "Richardson, J. A. Kuester, J. L.", "words_pool": ["a454", "algorithm", "complex", "constrain", "e4", "method", "optim", "richardson", "kuester"], "word_count": {"a454": 1, "algorithm": 1, "complex": 1, "constrain": 1, "e4": 1, "method": 1, "optim": 1, "richardson": 1, "kuester": 1}}, "2465": {"id": "2465", "title": "Gaussian Quadrature formulas for Bromwich's Integral [D1] (Algorithm A453)", "authors": "Piessens, R.", "words_pool": ["a453", "algorithm", "bromwich", "d1", "formula", "gaussian", "integr", "quadratur", "piessen"], "word_count": {"a453": 1, "algorithm": 1, "bromwich": 1, "d1": 1, "formula": 1, "gaussian": 1, "integr": 1, "quadratur": 1, "piessen": 1}}, "2466": {"id": "2466", "title": "Enumerating Combinations of m Out of n Objects [G6] (Algorithm A452)", "authors": "Liu, C. N Tang, D. T.", "words_pool": ["a452", "algorithm", "combin", "enumer", "g6", "object", "liu", "tang"], "word_count": {"a452": 1, "algorithm": 1, "combin": 1, "enumer": 1, "g6": 1, "object": 1, "liu": 1, "tang": 1}}, "2467": {"id": "2467", "title": "Chi-Square quantiles [G1] (Algorithm A451)", "authors": "Goldstein, R. B.", "words_pool": ["a451", "algorithm", "chi", "g1", "quantil", "squar", "goldstein"], "word_count": {"a451": 1, "algorithm": 1, "chi": 1, "g1": 1, "quantil": 1, "squar": 1, "goldstein": 1}}, "2468": {"id": "2468", "title": "Rosenbrock Function Minimization [E4] (Algorithm A450)", "authors": "Machura, M. Mulawa, A.", "words_pool": ["a450", "algorithm", "e4", "function", "minim", "rosenbrock", "machura", "mulawa"], "word_count": {"a450": 1, "algorithm": 1, "e4": 1, "function": 1, "minim": 1, "rosenbrock": 1, "machura": 1, "mulawa": 1}}, "2469": {"id": "2469", "title": "Petri Nets and Speed Independent design", "abstract": "Petri nets are investigated as one method of modeling speed independent asynchronous circuits.   A study of circuit realizations of Petri nets leads to a demonstration of their usefulness in modeling  speed independent operation.  This usefulness is emphasized by the design of a speed independent processor  from modules developed in the investigation of Petri net implementation.", "authors": "Misunas, D.", "words_pool": ["asynchron", "circuit", "circuit", "demonstr", "design", "develop", "emphas", "implement", "independ", "investig", "investig", "lead", "method", "model", "modul", "net", "net", "oper", "petri", "processor", "realiz", "speed", "studi", "use", "misuna"], "word_count": {"asynchron": 1, "circuit": 2, "demonstr": 1, "design": 1, "develop": 1, "emphas": 1, "implement": 1, "independ": 3, "investig": 2, "lead": 1, "method": 1, "model": 2, "modul": 1, "net": 3, "oper": 1, "petri": 3, "processor": 1, "realiz": 1, "speed": 3, "studi": 1, "use": 2, "misuna": 1}}, "2470": {"id": "2470", "title": "Fen-An Axiomatic Basis for Program Semantics", "abstract": "A formal system is presented which abstracts the notions of data item, function, and relation.   It is argued that the system is more suitable than set theory (or its derivatives) for the concise and  accurate description of program semantics.  It is shown how the system can be used to build composite  data types out of simper ones with the operations of rowing, structuring, and uniting.  It is also demonstrated  that completely new primitive types can be introduced into languages through the mechanism of singleton  data types.  Both deterministic and nondeterministic functions are shown to be definable in the system.   It is described how the local environment can be modeled as a data item and how imperative statements  can be considered functions on the environment.  The nature of recursive functions is briefly discussed,  and a technique is presented by which they can be introduced into the system.  The technique is contrasted  with the use of the paradoxical combinator, Y.  The questions of local and global environments and of  various modes of function calling and parameter passing are touched upon. The theory is applied to the  proof of several elementary theorems concerning the semantics of the assignment, conditional, and iterative  statements.  An appendix is included which presents in detail the formal system governing webs and fen,  the abstractions used informally in the body of the paper.", "authors": "MacLennan, B. J.", "words_pool": ["abstract", "abstract", "accur", "appendix", "appli", "argu", "assign", "axiomat", "basi", "bodi", "briefli", "build", "call", "combin", "complet", "composit", "concern", "concis", "condit", "consid", "contrast", "data", "defin", "demonstr", "deriv", "descript", "detail", "determinist", "discuss", "elementari", "environ", "environ", "fen", "formal", "function", "function", "global", "govern", "imper", "includ", "inform", "introduc", "item", "iter", "languag", "local", "mechan", "model", "mode", "natur", "nondeterminist", "notion", "oper", "paper", "paradox", "paramet", "pass", "present", "present", "primit", "program", "proof", "question", "recurs", "relat", "row", "semant", "set", "shown", "simper", "singleton", "statement", "structur", "suitabl", "system", "techniqu", "theorem", "theori", "touch", "type", "unit", "web", "maclennan"], "word_count": {"abstract": 2, "accur": 1, "appendix": 1, "appli": 1, "argu": 1, "assign": 1, "axiomat": 1, "basi": 1, "bodi": 1, "briefli": 1, "build": 1, "call": 1, "combin": 1, "complet": 1, "composit": 1, "concern": 1, "concis": 1, "condit": 1, "consid": 1, "contrast": 1, "data": 4, "defin": 1, "demonstr": 1, "deriv": 1, "descript": 1, "detail": 1, "determinist": 1, "discuss": 1, "elementari": 1, "environ": 3, "fen": 1, "formal": 2, "function": 5, "global": 1, "govern": 1, "imper": 1, "includ": 1, "inform": 1, "introduc": 2, "item": 2, "iter": 1, "languag": 1, "local": 2, "mechan": 1, "model": 1, "mode": 1, "natur": 1, "nondeterminist": 1, "notion": 1, "oper": 1, "paper": 1, "paradox": 1, "paramet": 1, "pass": 1, "present": 3, "primit": 1, "program": 1, "proof": 1, "question": 1, "recurs": 1, "relat": 1, "row": 1, "semant": 2, "set": 1, "shown": 2, "simper": 1, "singleton": 1, "statement": 2, "structur": 1, "suitabl": 1, "system": 6, "techniqu": 2, "theorem": 1, "theori": 2, "touch": 1, "type": 3, "unit": 1, "web": 1, "maclennan": 1}}, "2471": {"id": "2471", "title": "A Learning Program Which Plays Partnership Dominoes", "abstract": "A learning program has been written is BASIC to play four-player partnership dominoes.  Because  dominoes is a game of incomplete information, the program uses somewhat different principles of artificial  intelligence from those used in programs for games of complete information, such as checkers, chess,  and go.  The program was constructed to use a \"strategy signature table\" which classifies board situations  through the interactions of game parameters. Each entry in the table contains adaptively determined  weights indicating the advi sability of various strategies.  Once chosen, a strategy then employs probability  analysis and linear polynomial evaluation to choose a move.  Our program wins approximately two-thirds  of its games in tournament situations, and has defeated championship players.", "authors": "Smith, M. H.", "words_pool": ["adapt", "advi", "analysi", "approxim", "artifici", "basic", "board", "championship", "checker", "chess", "choos", "chosen", "classifi", "complet", "construct", "defeat", "determin", "domino", "employ", "entri", "evalu", "game", "game", "incomplet", "indic", "inform", "intellig", "interact", "learn", "linear", "move", "paramet", "partnership", "play", "player", "player", "play", "polynomi", "principl", "probabl", "program", "program", "sabil", "signatur", "situat", "strategi", "strategi", "tabl", "third", "tournament", "weight", "win", "written", "smith"], "word_count": {"adapt": 1, "advi": 1, "analysi": 1, "approxim": 1, "artifici": 1, "basic": 1, "board": 1, "championship": 1, "checker": 1, "chess": 1, "choos": 1, "chosen": 1, "classifi": 1, "complet": 1, "construct": 1, "defeat": 1, "determin": 1, "domino": 2, "employ": 1, "entri": 1, "evalu": 1, "game": 4, "incomplet": 1, "indic": 1, "inform": 2, "intellig": 1, "interact": 1, "learn": 1, "linear": 1, "move": 1, "paramet": 1, "partnership": 1, "play": 1, "player": 2, "polynomi": 1, "principl": 1, "probabl": 1, "program": 5, "sabil": 1, "signatur": 1, "situat": 2, "strategi": 3, "tabl": 2, "third": 1, "tournament": 1, "weight": 1, "win": 1, "written": 1, "smith": 1}}, "2472": {"id": "2472", "title": "Minimal spanning Tree (Algorithm R422)", "authors": "Kernighan, B. W.", "words_pool": ["algorithm", "minim", "r422", "span", "tree", "kernighan"], "word_count": {"algorithm": 1, "minim": 1, "r422": 1, "span": 1, "tree": 1, "kernighan": 1}}, "2473": {"id": "2473", "title": "Hidden-Line Plotting Program (Algorithm R420)", "authors": "Macleod, I. D. G. Collins, A. M.", "words_pool": ["algorithm", "hidden", "line", "plot", "program", "r420", "macleod", "collin"], "word_count": {"algorithm": 1, "hidden": 1, "line": 1, "plot": 1, "program": 1, "r420": 1, "macleod": 1, "collin": 1}}, "2474": {"id": "2474", "title": "DIFSUB for Solution of Ordinary Differential Equations (Algorithm C407)", "authors": "Nikolai, P. J.", "words_pool": ["algorithm", "c407", "differenti", "difsub", "equat", "ordinari", "solut", "nikolai"], "word_count": {"algorithm": 1, "c407": 1, "differenti": 1, "difsub": 1, "equat": 1, "ordinari": 1, "solut": 1, "nikolai": 1}}, "2475": {"id": "2475", "title": "Solution of Linear Programming Problems in 0-1 Variables [H1] (Algorithm A449)", "authors": "Fiala, F.", "words_pool": ["a449", "algorithm", "h1", "linear", "problem", "program", "solut", "variabl", "fiala"], "word_count": {"a449": 1, "algorithm": 1, "h1": 1, "linear": 1, "problem": 1, "program": 1, "solut": 1, "variabl": 1, "fiala": 1}}, "2476": {"id": "2476", "title": "Equivalence Between AND/OR Graphs and Context-Free Grammars", "authors": "Hall, P. A. V.", "words_pool": ["context", "equival", "free", "grammar", "graph", "hall"], "word_count": {"context": 1, "equival": 1, "free": 1, "grammar": 1, "graph": 1, "hall": 1}}, "2477": {"id": "2477", "title": "Multiple Exits from a Loop Without the GOTO", "authors": "Bochmann, G. V.", "words_pool": ["exit", "goto", "loop", "multipl", "bochmann"], "word_count": {"exit": 1, "goto": 1, "loop": 1, "multipl": 1, "bochmann": 1}}, "2478": {"id": "2478", "title": "Computer Science-Seminars for Undergraduates", "authors": "Kandel, A.", "words_pool": ["comput", "scienc", "seminar", "undergradu", "kandel"], "word_count": {"comput": 1, "scienc": 1, "seminar": 1, "undergradu": 1, "kandel": 1}}, "2479": {"id": "2479", "title": "Curriculum Recommendations for Graduate Professional Programs in Information Systems: Recommended  Addendum on Information Systems Administration", "abstract": "An addendum to the Report of the ACM Curriculum Committee on Computer Education for Management  is proposed. The proposed addendum is to include in the curriculum a course on Information Systems administration.  It is important for two reasons: (1) the systems designer must understand the administrative framework  in which he must operate to work effectively, and (2) an important objective of the curriculum recommendations  is to prepare the future manager of the computer activity.  It is felt that the importance of these two  reasons justifies the addition of the recommended course.  The course is outlined in the format of the  original report.", "authors": "McFarlan, F. W. Nolan, R. L.", "words_pool": ["acm", "activ", "addendum", "addit", "administr", "administr", "committe", "comput", "cours", "curriculum", "design", "educ", "effect", "felt", "format", "framework", "futur", "graduat", "import", "import", "includ", "inform", "justifi", "manag", "manag", "object", "oper", "origin", "outlin", "prepar", "profession", "program", "propos", "reason", "recommend", "recommend", "report", "system", "understand", "work", "mcfarlan", "nolan"], "word_count": {"acm": 1, "activ": 1, "addendum": 2, "addit": 1, "administr": 2, "committe": 1, "comput": 2, "cours": 3, "curriculum": 3, "design": 1, "educ": 1, "effect": 1, "felt": 1, "format": 1, "framework": 1, "futur": 1, "graduat": 1, "import": 3, "includ": 1, "inform": 1, "justifi": 1, "manag": 2, "object": 1, "oper": 1, "origin": 1, "outlin": 1, "prepar": 1, "profession": 1, "program": 1, "propos": 2, "reason": 2, "recommend": 2, "report": 2, "system": 2, "understand": 1, "work": 1, "mcfarlan": 1, "nolan": 1}}, "2480": {"id": "2480", "title": "Teaching \"About Programming\"", "abstract": "This paper presents the goals and organization of a course about programming designed to provide  entering students in a graduate program with a cultural enrichment in their professional lives.  The  students are expected to have taken at least two programming courses prior to this one and, therefore,  to be familiar with at least two programming languages, both as students and users.  Teaching someone  how to program is similar to teaching him to play a musical instrument: neither skill can be taught-they  must be learned.  However, the teacher still serves several vital purposes: to present a set of rules  for producing well-formed utterances; to offer numerous demonstrations of his own skill; and to function  as an involved critic.  Finally, the teacher is the source of information about the process in which  the student is involved.", "authors": "Rosin, R. F.", "words_pool": ["cours", "cours", "critic", "cultur", "demonstr", "design", "enrich", "enter", "expect", "familiar", "final", "form", "function", "goal", "graduat", "inform", "instrument", "involv", "languag", "learn", "live", "music", "numer", "offer", "organ", "paper", "play", "present", "present", "prior", "process", "produc", "profession", "program", "program", "provid", "purpos", "rule", "serv", "set", "similar", "skill", "sourc", "student", "student", "taught", "teacher", "teach", "user", "utter", "vital", "rosin"], "word_count": {"cours": 2, "critic": 1, "cultur": 1, "demonstr": 1, "design": 1, "enrich": 1, "enter": 1, "expect": 1, "familiar": 1, "final": 1, "form": 1, "function": 1, "goal": 1, "graduat": 1, "inform": 1, "instrument": 1, "involv": 2, "languag": 1, "learn": 1, "live": 1, "music": 1, "numer": 1, "offer": 1, "organ": 1, "paper": 1, "play": 1, "present": 2, "prior": 1, "process": 1, "produc": 1, "profession": 1, "program": 5, "provid": 1, "purpos": 1, "rule": 1, "serv": 1, "set": 1, "similar": 1, "skill": 2, "sourc": 1, "student": 4, "taught": 1, "teacher": 2, "teach": 2, "user": 1, "utter": 1, "vital": 1, "rosin": 1}}, "2481": {"id": "2481", "title": "The Distribution of a Program in Primary and Fast Buffer Storage", "abstract": "A virtual memory computer system with a fast buffer (cache) memory between primary memory and  the central processing unit is considered.  The optimal distribution of a program between the buffer  and primary memory is studied using the program's lifetime function.  Expressions for the distribution  of a program which maximizes the useful fraction of the cost-time integral of primary and fast buffer  storage are obtained for swapping and nonswapping buffer management policies.", "authors": "Gelenbe, E.", "words_pool": ["buffer", "cach", "central", "comput", "consid", "cost", "distribut", "express", "fast", "fraction", "function", "integr", "lifetim", "manag", "maxim", "memori", "nonswap", "obtain", "optim", "polici", "primari", "process", "program", "storag", "studi", "swap", "system", "time", "unit", "virtual", "gelenb"], "word_count": {"buffer": 4, "cach": 1, "central": 1, "comput": 1, "consid": 1, "cost": 1, "distribut": 2, "express": 1, "fast": 2, "fraction": 1, "function": 1, "integr": 1, "lifetim": 1, "manag": 1, "maxim": 1, "memori": 4, "nonswap": 1, "obtain": 1, "optim": 1, "polici": 1, "primari": 3, "process": 1, "program": 3, "storag": 1, "studi": 1, "swap": 1, "system": 1, "time": 1, "unit": 1, "virtual": 1, "gelenb": 1}}, "2482": {"id": "2482", "title": "Mixed Solutions for the Deadlock Problem", "abstract": "Mixtures of detection, avoidance, and prevention provide more effective and practical solutions  to the deadlock problem than any one of these alone.  The individual techniques can be tailored for subproblems  of resource allocation and still operate together to prevent deadlocks.  This paper presents a method,  based on the concept of the hierarchical operating system, for constructing appropriate mixtures and  suggests appropriate subsystems for the most frequently occurring resource allocation problems", "authors": "Howard, J. H. Jr.", "words_pool": ["alloc", "avoid", "base", "concept", "construct", "deadlock", "deadlock", "detect", "effect", "frequent", "hierarch", "individu", "method", "mix", "mixtur", "occur", "oper", "oper", "paper", "practic", "present", "prevent", "prevent", "problem", "problem", "provid", "resourc", "solut", "subproblem", "subsystem", "suggest", "system", "tailor", "techniqu", "howard", "jr"], "word_count": {"alloc": 2, "avoid": 1, "base": 1, "concept": 1, "construct": 1, "deadlock": 2, "detect": 1, "effect": 1, "frequent": 1, "hierarch": 1, "individu": 1, "method": 1, "mix": 1, "mixtur": 2, "occur": 1, "oper": 2, "paper": 1, "practic": 1, "present": 1, "prevent": 2, "problem": 2, "provid": 1, "resourc": 2, "solut": 1, "subproblem": 1, "subsystem": 1, "suggest": 1, "system": 1, "tailor": 1, "techniqu": 1, "howard": 1, "jr": 1}}, "2483": {"id": "2483", "title": "COKO III: The Cooper-Koz Chess Program", "abstract": "COKO III is a chess player written entirely in Fortran.  On the IBM 360-65, COKO III plays  a minimal chess game at the rate of .2 sec cpu time per move, with a level close to lower chess club  play.  A selective tree searching procedure controlled by tactical chess logistics allows a deployment  of multiple minimal game calculations to achieve some optimal move selection.  The tree searching algorithms  are the heart of COKO's effectiveness, yet they are conceptually simple.  In addition, an interesting  phenomenon called a tree searching catastrophe has plagued COKO's entire development just as it troubles  a human player.  Standard exponential growth is curbed to a large extent by the definition and trimming  of the Fischer set.  A clear distinction between tree pruning and selective tree searching is also made.   Representation of the chess environment is described along with a strategical preanalysis procedure  that maps the Lasker regions.  Specific chess algorithms are described which could be used as a command  structure by anyone desiring to do some chess program experimentation.  A comparison is made of some  mysterious actions of human players and COKO III.", "authors": "Kozdrowicki, E. W. Cooper, D. W.", "words_pool": ["achiev", "action", "addit", "algorithm", "calcul", "call", "catastroph", "chess", "clear", "close", "club", "coko", "command", "comparison", "conceptu", "control", "cooper", "cpu", "curb", "definit", "deploy", "desir", "develop", "distinct", "effect", "entir", "entir", "environ", "experiment", "exponenti", "extent", "fischer", "fortran", "game", "growth", "heart", "human", "ibm", "iii", "interest", "koz", "larg", "lasker", "level", "logist", "lower", "made", "map", "minim", "move", "multipl", "mysteri", "optim", "phenomenon", "plagu", "play", "player", "player", "play", "preanalysi", "procedur", "program", "prune", "rate", "region", "represent", "search", "sec", "select", "select", "set", "simpl", "specif", "standard", "strateg", "structur", "tactic", "time", "tree", "trim", "troubl", "written", "kozdrowicki", "cooper"], "word_count": {"achiev": 1, "action": 1, "addit": 1, "algorithm": 2, "calcul": 1, "call": 1, "catastroph": 1, "chess": 7, "clear": 1, "close": 1, "club": 1, "coko": 5, "command": 1, "comparison": 1, "conceptu": 1, "control": 1, "cooper": 1, "cpu": 1, "curb": 1, "definit": 1, "deploy": 1, "desir": 1, "develop": 1, "distinct": 1, "effect": 1, "entir": 2, "environ": 1, "experiment": 1, "exponenti": 1, "extent": 1, "fischer": 1, "fortran": 1, "game": 2, "growth": 1, "heart": 1, "human": 2, "ibm": 1, "iii": 3, "interest": 1, "koz": 1, "larg": 1, "lasker": 1, "level": 1, "logist": 1, "lower": 1, "made": 2, "map": 1, "minim": 2, "move": 2, "multipl": 1, "mysteri": 1, "optim": 1, "phenomenon": 1, "plagu": 1, "play": 2, "player": 3, "preanalysi": 1, "procedur": 2, "program": 1, "prune": 1, "rate": 1, "region": 1, "represent": 1, "search": 4, "sec": 1, "select": 3, "set": 1, "simpl": 1, "specif": 1, "standard": 1, "strateg": 1, "structur": 1, "tactic": 1, "time": 1, "tree": 5, "trim": 1, "troubl": 1, "written": 1, "kozdrowicki": 1}}, "2484": {"id": "2484", "title": "A Note on Information Organization and Storage", "abstract": "Since the logical structure of a data base can be represented by a tree or graph, it is quite  natural for us to view the process of designing a data base as that of constructing a tree or a graph.   A general method for constructing such a tree or a graph is provided.  There are three important elements  in this general construction method; namely, a set of binary relations, an algorithm for constructing  subsets of a set, and an algorithm for selecting an element from the given set of objects.  The use of  different relations and algorithms results in different information structures, as list, tree, ring,  etc.  Thus the problem of information organization and storage is reduced to that of defining relations  and formulating algorithms under a given set of constraints.  The results presented may be valuable to  designers as useful design concepts, and may serve as a basis for developing a formal theory on the subject.", "authors": "Huang, J. C.", "words_pool": ["algorithm", "algorithm", "base", "basi", "binari", "concept", "constraint", "construct", "construct", "data", "defin", "design", "design", "design", "develop", "element", "element", "formal", "formul", "gener", "graph", "import", "inform", "list", "logic", "method", "natur", "note", "object", "organ", "present", "problem", "process", "provid", "reduc", "relat", "repres", "result", "ring", "select", "serv", "set", "storag", "structur", "structur", "subject", "subset", "theori", "tree", "valuabl", "view", "huang"], "word_count": {"algorithm": 4, "base": 2, "basi": 1, "binari": 1, "concept": 1, "constraint": 1, "construct": 4, "data": 2, "defin": 1, "design": 3, "develop": 1, "element": 2, "formal": 1, "formul": 1, "gener": 2, "graph": 3, "import": 1, "inform": 2, "list": 1, "logic": 1, "method": 2, "natur": 1, "note": 1, "object": 1, "organ": 1, "present": 1, "problem": 1, "process": 1, "provid": 1, "reduc": 1, "relat": 3, "repres": 1, "result": 2, "ring": 1, "select": 1, "serv": 1, "set": 4, "storag": 1, "structur": 2, "subject": 1, "subset": 1, "theori": 1, "tree": 4, "valuabl": 1, "view": 1, "huang": 1}}, "2485": {"id": "2485", "title": "Managing the Computer Resource: A Stage Hypothesis", "abstract": "Based on the study of expenditures for data processing, a descriptive stage hypothesis is presented.   It is suggested that the planning, organizing, and controlling activities associated with managing the  computer resource will change in character over a period of time, and will evolve in patterns roughly  correlated to four stages of the computer budget: Stage I (computer acquisition), Stage II (intense system  development), Stage III (proliferation of controls), and Stage IV (user/service orientation).  Each stage  is described and related to individual tasks for managing the computer resource.", "authors": "Nolan, R. L.", "words_pool": ["acquisit", "activ", "base", "budget", "chang", "charact", "comput", "control", "control", "correl", "data", "descript", "develop", "evolv", "expenditur", "hypothesi", "ii", "iii", "individu", "intens", "iv", "manag", "organ", "orient", "pattern", "period", "plan", "present", "process", "prolifer", "relat", "resourc", "roughli", "servic", "stage", "stage", "studi", "suggest", "system", "task", "time", "user", "nolan"], "word_count": {"acquisit": 1, "activ": 1, "base": 1, "budget": 1, "chang": 1, "charact": 1, "comput": 4, "control": 2, "correl": 1, "data": 1, "descript": 1, "develop": 1, "evolv": 1, "expenditur": 1, "hypothesi": 1, "ii": 1, "iii": 1, "individu": 1, "intens": 1, "iv": 1, "manag": 2, "organ": 1, "orient": 1, "pattern": 1, "period": 1, "plan": 1, "present": 1, "process": 1, "prolifer": 1, "relat": 1, "resourc": 2, "roughli": 1, "servic": 1, "stage": 7, "studi": 1, "suggest": 1, "system": 1, "task": 1, "time": 1, "user": 1, "nolan": 1}}, "2486": {"id": "2486", "title": "Computer Photocomposition of Technical Text", "abstract": "In computer assisted typesetting by means of photocomposition, special problems arise in highly  technical material such as mathematical formulas.  New solutions to several of these problems have been  devised in the information system of the American Institute of Physics.  They include: the representation  of special characters (foreign alphabets, mathematical symbols, etc.) not available on input keyboards  or on the photocomposer; the generation of such symbols, e.g. by overprinting; the precise positioning  of accent marks (floating diacritics); line breaks, i.e. words or formulas placed partly at the end of  one line and partly at the beginning of the next; and certain aspects of error correction.", "authors": "Alt, F. L. Yuni Kirk, J.", "words_pool": ["accent", "alphabet", "american", "aris", "aspect", "assist", "begin", "break", "charact", "comput", "correct", "devis", "diacrit", "end", "error", "float", "foreign", "formula", "gener", "highli", "includ", "inform", "input", "institut", "keyboard", "line", "mark", "materi", "mathemat", "mean", "overprint", "partli", "photocompos", "photocomposit", "physic", "posit", "precis", "problem", "represent", "solut", "special", "symbol", "system", "technic", "text", "typeset", "word", "alt", "yuni", "kirk"], "word_count": {"accent": 1, "alphabet": 1, "american": 1, "aris": 1, "aspect": 1, "assist": 1, "begin": 1, "break": 1, "charact": 1, "comput": 1, "correct": 1, "devis": 1, "diacrit": 1, "end": 1, "error": 1, "float": 1, "foreign": 1, "formula": 2, "gener": 1, "highli": 1, "includ": 1, "inform": 1, "input": 1, "institut": 1, "keyboard": 1, "line": 2, "mark": 1, "materi": 1, "mathemat": 2, "mean": 1, "overprint": 1, "partli": 2, "photocompos": 1, "photocomposit": 1, "physic": 1, "posit": 1, "precis": 1, "problem": 2, "represent": 1, "solut": 1, "special": 2, "symbol": 2, "system": 1, "technic": 1, "text": 1, "typeset": 1, "word": 1, "alt": 1, "yuni": 1, "kirk": 1}}, "2487": {"id": "2487", "title": "Cubic Spline solutions to Fourth-order Boundary Value Problems", "abstract": "The cubic spline approximation to the fourth-order differential equation y''''+p(x)y''+q(x)y'+r(x)y=t(x)  is shown to reduce to the solution of a five-term recurrence relationship.  For some special cases the  approximation is shown to be simply related to a finite difference representation with a local truncation  error of order (y/720)delta^8.", "authors": "Hoskins, W. D.", "words_pool": ["approxim", "boundari", "case", "cubic", "delta", "differ", "differenti", "equat", "error", "finit", "fourth", "local", "order", "problem", "recurr", "reduc", "relat", "relationship", "represent", "shown", "simpli", "solut", "solut", "special", "spline", "term", "truncat", "hoskin"], "word_count": {"approxim": 2, "boundari": 1, "case": 1, "cubic": 1, "delta": 1, "differ": 1, "differenti": 1, "equat": 1, "error": 1, "finit": 1, "fourth": 1, "local": 1, "order": 2, "problem": 1, "recurr": 1, "reduc": 1, "relat": 1, "relationship": 1, "represent": 1, "shown": 2, "simpli": 1, "solut": 1, "special": 1, "spline": 1, "term": 1, "truncat": 1, "hoskin": 1}}, "2488": {"id": "2488", "title": "Least Squares Piecewise Cubic Curve Fitting", "abstract": "The matrices involved in a linear least squares formulation are determined for the problem  of fitting piecewise cubic functions, those possessing a continuous derivative, to arrays of planar data.", "authors": "Ferguson, J. Staley, P. A.", "words_pool": ["array", "continu", "cubic", "curv", "data", "deriv", "determin", "fit", "formul", "function", "involv", "linear", "matric", "piecewis", "planar", "possess", "problem", "squar", "ferguson", "staley"], "word_count": {"array": 1, "continu": 1, "cubic": 1, "curv": 1, "data": 1, "deriv": 1, "determin": 1, "fit": 1, "formul": 1, "function": 1, "involv": 1, "linear": 1, "matric": 1, "piecewis": 1, "planar": 1, "possess": 1, "problem": 1, "squar": 1, "ferguson": 1, "staley": 1}}, "2489": {"id": "2489", "title": "Number of Multiply-Restricted Partitions [A1] (Algorithm A448)", "authors": "Beyer, T. Swinehart, D. F.", "words_pool": ["a1", "a448", "algorithm", "multipli", "number", "partit", "restrict", "beyer", "swinehart"], "word_count": {"a1": 1, "a448": 1, "algorithm": 1, "multipli": 1, "number": 1, "partit": 1, "restrict": 1, "beyer": 1, "swinehart": 1}}, "2490": {"id": "2490", "title": "Efficient Algorithms for Graph Manipulation [H] (Algorithm A447)", "abstract": "Efficient algorithms are presented for partitioning a graph into connected components, biconnected  components and simple paths.  The algorithm for partitioning of a graph into simple paths is iterative  and each iteration produces a new path between two vertices already on paths.  (The start vertex can  be specified dynamically.)  If V is the number of vertices and E is the number of edges, each algorithm  requires time and space proportional to max (V,E) when executed on a random access computer.", "authors": "Hopcroft, J. Tarjan, R.", "words_pool": ["a447", "access", "algorithm", "algorithm", "biconnect", "compon", "comput", "connect", "dynam", "edg", "effici", "execut", "graph", "iter", "iter", "manipul", "max", "number", "partit", "path", "path", "present", "produc", "proport", "random", "requir", "simpl", "space", "start", "time", "vertex", "vertic", "hopcroft", "tarjan"], "word_count": {"a447": 1, "access": 1, "algorithm": 3, "biconnect": 1, "compon": 2, "comput": 1, "connect": 1, "dynam": 1, "edg": 1, "effici": 1, "execut": 1, "graph": 2, "iter": 2, "manipul": 1, "max": 1, "number": 2, "partit": 2, "path": 4, "present": 1, "produc": 1, "proport": 1, "random": 1, "requir": 1, "simpl": 2, "space": 1, "start": 1, "time": 1, "vertex": 1, "vertic": 2, "hopcroft": 1, "tarjan": 1}}, "2491": {"id": "2491", "title": "Threaded Code", "abstract": "The concept of \"threaded code\" is presented as an alternative to machine language code.  Hardware  and software realizations of it are given.  In software it is realized as interpretive code not needing  an interpreter.  Extensions and optimizations are mentioned.", "authors": "Bell, J. R.", "words_pool": ["altern", "code", "concept", "extens", "hardwar", "interpret", "interpret", "languag", "machin", "mention", "need", "optim", "present", "realiz", "realiz", "softwar", "thread", "bell"], "word_count": {"altern": 1, "code": 3, "concept": 1, "extens": 1, "hardwar": 1, "interpret": 2, "languag": 1, "machin": 1, "mention": 1, "need": 1, "optim": 1, "present": 1, "realiz": 2, "softwar": 2, "thread": 1, "bell": 1}}, "2492": {"id": "2492", "title": "The Development of Decision Tables via Parsing of Complex Decision Situations", "abstract": "A new parsing technique is proposed which allows parsing based only on syntactical characteristics  of the decision problem.  It requires a description of the problem in decision grid chart format and  allows the development of decision tables within defined limits by avoiding, or at least minimizing,  repetition of conditions and actions in the resulting tables.", "authors": "Strunz, H.", "words_pool": ["action", "avoid", "base", "characterist", "chart", "complex", "condit", "decis", "defin", "descript", "develop", "format", "grid", "limit", "minim", "pars", "problem", "propos", "repetit", "requir", "result", "situat", "syntact", "tabl", "techniqu", "strunz"], "word_count": {"action": 1, "avoid": 1, "base": 1, "characterist": 1, "chart": 1, "complex": 1, "condit": 1, "decis": 3, "defin": 1, "descript": 1, "develop": 1, "format": 1, "grid": 1, "limit": 1, "minim": 1, "pars": 2, "problem": 2, "propos": 1, "repetit": 1, "requir": 1, "result": 1, "situat": 1, "syntact": 1, "tabl": 2, "techniqu": 1, "strunz": 1}}, "2493": {"id": "2493", "title": "Optimum Data Base Reorganization Points", "abstract": "In certain data base organization schemes the cost per access may increase due to structural  inefficiencies caused by updates.  By reorganizing the data base the cost per access may be reduced.   However, the high cost of a reorganization prohibits frequent reorganizations.  This paper examines  strategies for selecting the optimum reorganization points.", "authors": "Shneiderman, B.", "words_pool": ["access", "base", "caus", "cost", "data", "due", "examin", "frequent", "high", "increas", "ineffici", "optimum", "organ", "paper", "point", "prohibit", "reduc", "reorgan", "reorgan", "reorgan", "scheme", "select", "strategi", "structur", "updat", "shneiderman"], "word_count": {"access": 2, "base": 2, "caus": 1, "cost": 3, "data": 2, "due": 1, "examin": 1, "frequent": 1, "high": 1, "increas": 1, "ineffici": 1, "optimum": 1, "organ": 1, "paper": 1, "point": 1, "prohibit": 1, "reduc": 1, "reorgan": 4, "scheme": 1, "select": 1, "strategi": 1, "structur": 1, "updat": 1, "shneiderman": 1}}, "2494": {"id": "2494", "title": "A Computer Generated Aid for Cluster Analysis", "abstract": "A computer generated graphic method, which can be used in conjunction with any hierarchical  scheme of cluster analysis, is described and illustrated.  The graphic principle used is the representation  of the elements of a data matrix of similarities or dissimilarities by computer printed symbols (of character  overstrikes) of various shades of darkness, where a dark symbol corresponds to a small dissimilarity.   The plots, applied to a data matrix before clustering and to the rearranged matrix after clustering,  show at a glance whether clustering brought forth any distinctive clusters.  A well-known set of data  consisting of the correlations of 24 psychological tests is used to illustrate the comparison of groupings  by four methods of factor analysis and two methods of cluster analysis.", "authors": "Ling, R. F.", "words_pool": ["aid", "analysi", "appli", "brought", "charact", "cluster", "cluster", "cluster", "comparison", "comput", "conjunct", "consist", "correl", "correspond", "dark", "dark", "data", "dissimilar", "dissimilar", "distinct", "element", "factor", "gener", "glanc", "graphic", "group", "hierarch", "illustr", "illustr", "known", "matrix", "method", "method", "overstrik", "plot", "principl", "print", "psycholog", "rearrang", "represent", "scheme", "set", "shade", "show", "similar", "small", "symbol", "symbol", "test", "ling"], "word_count": {"aid": 1, "analysi": 3, "appli": 1, "brought": 1, "charact": 1, "cluster": 6, "comparison": 1, "comput": 2, "conjunct": 1, "consist": 1, "correl": 1, "correspond": 1, "dark": 2, "data": 3, "dissimilar": 2, "distinct": 1, "element": 1, "factor": 1, "gener": 1, "glanc": 1, "graphic": 2, "group": 1, "hierarch": 1, "illustr": 2, "known": 1, "matrix": 3, "method": 3, "overstrik": 1, "plot": 1, "principl": 1, "print": 1, "psycholog": 1, "rearrang": 1, "represent": 1, "scheme": 1, "set": 1, "shade": 1, "show": 1, "similar": 1, "small": 1, "symbol": 2, "test": 1, "ling": 1}}, "2495": {"id": "2495", "title": "Adapting Optimal Code Generation for Arithmetic Expressions to the Instruction Sets Available  on Present-Day Computers", "authors": "Stockhausen, P. F.", "words_pool": ["adapt", "arithmet", "code", "comput", "day", "express", "gener", "instruct", "optim", "present", "set", "stockhausen"], "word_count": {"adapt": 1, "arithmet": 1, "code": 1, "comput": 1, "day": 1, "express": 1, "gener": 1, "instruct": 1, "optim": 1, "present": 1, "set": 1, "stockhausen": 1}}, "2496": {"id": "2496", "title": "On the Near-Optimality of the Shortest-Latency-Time-First Drum Scheduling Discipline", "abstract": "For computer systems in which it is practical to determine the instantaneous drum position,  a popular discipline for determining the sequence in which the records are to be accessed is the so-called  shortest-latency-time-first, SLTF, discipline.  When a collection of varying-length records is to be  accessed from specified drum positions, it is known that the SLTF discipline does not necessarily minimize  the drum latency time.  However, we show that the total time to access the entire collection for any  SLTF schedule is never as much as a drum revolution longer than a minimum latency schedule.", "authors": "Stone, H. S. Fuller, S.  H.", "words_pool": ["access", "access", "call", "collect", "comput", "determin", "determin", "disciplin", "drum", "entir", "instantan", "known", "latenc", "length", "longer", "minim", "minimum", "necessarili", "optim", "popular", "posit", "posit", "practic", "record", "revolut", "schedul", "schedul", "sequenc", "shortest", "show", "sltf", "system", "time", "total", "vari", "stone", "fuller"], "word_count": {"access": 3, "call": 1, "collect": 2, "comput": 1, "determin": 2, "disciplin": 3, "drum": 4, "entir": 1, "instantan": 1, "known": 1, "latenc": 3, "length": 1, "longer": 1, "minim": 1, "minimum": 1, "necessarili": 1, "optim": 1, "popular": 1, "posit": 2, "practic": 1, "record": 2, "revolut": 1, "schedul": 2, "sequenc": 1, "shortest": 1, "show": 1, "sltf": 3, "system": 1, "time": 3, "total": 1, "vari": 1, "stone": 1, "fuller": 1}}, "2497": {"id": "2497", "title": "Synchronizing Processors with Memory-Content-Generated Interrupts", "abstract": "Implementations of the \"Lock-Unlock\" method of synchronizing processors in a multiprocessor  system usually require uninterruptable, memory-pause type instructions.  An interlock scheme called read-interlock,  which does not require memory-pause instructions, has been developed for a dual DEC PDP-10 system with  real-time requirements.  The read-interlock method does require a special\"read-interlock\" instruction  in the repertoire of the processors and a special \"read-interlock\" cycle in the repertoire of the memory  modules.  When a processor examines a \"lock\" (a memory location) with a read-interlock instruction, it  will be interrupted if the lock was already set; examining a lock immediately sets it if it was not already  set (this event sequence is a read-interlock cycle).  Writing into a lock clears it.  Having the processor  interrupted upon encountering a set lock instead of branching is advantageous if the branch would have  resulted in an effective interrupt.", "authors": "Hill, J. C.", "words_pool": ["advantag", "branch", "branch", "call", "clear", "content", "cycl", "dec", "develop", "dual", "effect", "encount", "event", "examin", "examin", "gener", "immedi", "implement", "instruct", "instruct", "interlock", "interrupt", "interrupt", "interrupt", "locat", "lock", "memori", "method", "modul", "multiprocessor", "paus", "pdp", "processor", "processor", "read", "real", "repertoir", "requir", "requir", "result", "scheme", "sequenc", "set", "set", "special", "synchron", "system", "time", "type", "uninterrupt", "unlock", "write", "hill"], "word_count": {"advantag": 1, "branch": 2, "call": 1, "clear": 1, "content": 1, "cycl": 2, "dec": 1, "develop": 1, "dual": 1, "effect": 1, "encount": 1, "event": 1, "examin": 2, "gener": 1, "immedi": 1, "implement": 1, "instruct": 4, "interlock": 7, "interrupt": 3, "locat": 1, "lock": 6, "memori": 4, "method": 2, "modul": 1, "multiprocessor": 1, "paus": 2, "pdp": 1, "processor": 4, "read": 6, "real": 1, "repertoir": 2, "requir": 4, "result": 1, "scheme": 1, "sequenc": 1, "set": 4, "special": 2, "synchron": 1, "system": 2, "time": 1, "type": 1, "uninterrupt": 1, "unlock": 1, "write": 1, "hill": 1}}, "2498": {"id": "2498", "title": "Minimizing Wasted Space in Partitioned Segmentation", "abstract": "A paged virtual memory system using a finite number of page sizes is considered.  Two algorithms  for assigning pages to segments are discussed.  Both of these algorithm are simple to implement.  The  problem of choosing the page sizes to minimize the expected value of total wasted space in internal fragmentation  and in a page table, per segment, is then solved for a probability density function of segment size which  may be expressed as a convex combination of Erlang densities.", "authors": "Gelenbe, E.", "words_pool": ["algorithm", "algorithm", "assign", "choos", "combin", "consid", "convex", "densiti", "densiti", "discuss", "erlang", "expect", "express", "finit", "fragment", "function", "implement", "intern", "memori", "minim", "minim", "number", "page", "page", "page", "partit", "probabl", "problem", "segment", "segment", "segment", "simpl", "size", "size", "solv", "space", "system", "tabl", "total", "virtual", "wast", "gelenb"], "word_count": {"algorithm": 2, "assign": 1, "choos": 1, "combin": 1, "consid": 1, "convex": 1, "densiti": 2, "discuss": 1, "erlang": 1, "expect": 1, "express": 1, "finit": 1, "fragment": 1, "function": 1, "implement": 1, "intern": 1, "memori": 1, "minim": 1, "number": 1, "page": 5, "partit": 1, "probabl": 1, "problem": 1, "segment": 3, "simpl": 1, "size": 3, "solv": 1, "space": 1, "system": 1, "tabl": 1, "total": 1, "virtual": 1, "wast": 1, "gelenb": 1}}, "2499": {"id": "2499", "title": "Efficient Multiprogramming Resource Allocation and Accounting", "abstract": "Although sometimes thought of as only a component of time-sharing operation, multiprogramming  can involve broader questions of resource allocation, since fairness is not required to meet a response  criterion.  In a multiprogrammed system, it may serve maximal resource use to be unfair, for example  by holding an input/output channel idle for a program while it completes a small amount of processor  usage, enabling further use of the channel.  Several applications of this principle are given, and it  is suggested that a multiprogramming executive might dynamically adjust its allocation algorithms to  gain efficiency.  Allocation of resources is closely connected to accounting for those resources, raising  the problems of repeatability, minimal uncharged overhead, and relative weighting of charges for dependent  resources.  Since weightings may depend on allocation algorithms, these are not arbitrary accounting  parameters.  Often the only repeatable accounting is one which omits an extensive overhead will be paid,  and should multiprogramming prove efficient, overcharges will result.  Multiprogramming turns on allocation  of the memory resource essential to control of other resources.  The general suggestions for allocation  and accounting are applied to this question, and some details provided for the case of a monitor which  controls a virtual-memory machine.", "authors": "Hamlet, R. G.", "words_pool": ["account", "adjust", "algorithm", "alloc", "amount", "applic", "appli", "arbitrari", "broader", "case", "channel", "charg", "close", "complet", "compon", "connect", "control", "control", "criterion", "depend", "depend", "detail", "dynam", "effici", "effici", "enabl", "essenti", "execut", "extens", "fair", "gain", "gener", "hold", "idl", "input", "involv", "machin", "maxim", "meet", "memori", "minim", "monitor", "multiprogram", "multiprogram", "omit", "oper", "output", "overcharg", "overhead", "paid", "paramet", "principl", "problem", "processor", "program", "prove", "provid", "question", "question", "rais", "rel", "repeat", "repeat", "requir", "resourc", "resourc", "respons", "result", "serv", "share", "small", "suggest", "suggest", "system", "thought", "time", "turn", "uncharg", "unfair", "usag", "virtual", "weight", "weight", "hamlet"], "word_count": {"account": 4, "adjust": 1, "algorithm": 2, "alloc": 6, "amount": 1, "applic": 1, "appli": 1, "arbitrari": 1, "broader": 1, "case": 1, "channel": 2, "charg": 1, "close": 1, "complet": 1, "compon": 1, "connect": 1, "control": 2, "criterion": 1, "depend": 2, "detail": 1, "dynam": 1, "effici": 2, "enabl": 1, "essenti": 1, "execut": 1, "extens": 1, "fair": 1, "gain": 1, "gener": 1, "hold": 1, "idl": 1, "input": 1, "involv": 1, "machin": 1, "maxim": 1, "meet": 1, "memori": 2, "minim": 1, "monitor": 1, "multiprogram": 5, "omit": 1, "oper": 1, "output": 1, "overcharg": 1, "overhead": 2, "paid": 1, "paramet": 1, "principl": 1, "problem": 1, "processor": 1, "program": 1, "prove": 1, "provid": 1, "question": 2, "rais": 1, "rel": 1, "repeat": 2, "requir": 1, "resourc": 7, "respons": 1, "result": 1, "serv": 1, "share": 1, "small": 1, "suggest": 2, "system": 1, "thought": 1, "time": 1, "turn": 1, "uncharg": 1, "unfair": 1, "usag": 1, "virtual": 1, "weight": 2, "hamlet": 1}}, "2500": {"id": "2500", "title": "A Practical Approach to Managing Resources and Avoiding Deadlocks", "abstract": "Resource scheduling and allocation can be expensive with regard to time and space in multiprogramming  or time-sharing environments involving large numbers of tasks and resources with conflicting requirements.   Detection and/or prevention of deadlocks can require massive amounts of additional overhead if efficient  usage of resources is to be maintained.  A resource management program is described which uses linked  lists along with other techniques to overcome a large portion of this overhead.  The program, which is  currently running as part of a large scale general purpose operating system, keeps resources relatively  active but does not detect or prevent all deadlocks in its implemented state.  Certain changes, which  would permit more comprehensive levels of deadlock prevention/detection at additional cost, have not  been incorporated in the running system due to the infrequency of deadlock situations.", "authors": "Frailey, D. J.", "words_pool": ["activ", "addit", "alloc", "amount", "approach", "avoid", "comprehens", "conflict", "cost", "deadlock", "deadlock", "detect", "detect", "due", "effici", "environ", "expens", "gener", "implement", "incorpor", "infrequ", "involv", "keep", "larg", "level", "link", "list", "maintain", "manag", "manag", "massiv", "multiprogram", "number", "oper", "overcom", "overhead", "part", "permit", "portion", "practic", "prevent", "prevent", "program", "purpos", "regard", "requir", "requir", "resourc", "resourc", "run", "scale", "schedul", "share", "situat", "space", "state", "system", "task", "techniqu", "time", "usag", "frailey"], "word_count": {"activ": 1, "addit": 2, "alloc": 1, "amount": 1, "approach": 1, "avoid": 1, "comprehens": 1, "conflict": 1, "cost": 1, "deadlock": 4, "detect": 3, "due": 1, "effici": 1, "environ": 1, "expens": 1, "gener": 1, "implement": 1, "incorpor": 1, "infrequ": 1, "involv": 1, "keep": 1, "larg": 3, "level": 1, "link": 1, "list": 1, "maintain": 1, "manag": 1, "massiv": 1, "multiprogram": 1, "number": 1, "oper": 1, "overcom": 1, "overhead": 2, "part": 1, "permit": 1, "portion": 1, "practic": 1, "prevent": 3, "program": 2, "purpos": 1, "regard": 1, "requir": 2, "resourc": 5, "run": 2, "scale": 1, "schedul": 1, "share": 1, "situat": 1, "space": 1, "state": 1, "system": 2, "task": 1, "techniqu": 1, "time": 2, "usag": 1, "frailey": 1}}, "2501": {"id": "2501", "title": "WYLBUR: An Interactive Text Editing and Remote Job Entry System", "abstract": "WYLBUR is a comprehensive system for manipulating all kinds of text, such as computer programs,  letters, and manuscripts, using typewriter terminals connected to a computer.  It has facilities for  remote job entry and retrieval as well as facilities for text alignment and justification.  A powerful  method for addressing text by content is provided.  This paper describes the external appearance of WYLBUR  as well as its internal structure.  A short description of the major features of ORVYL, a general purpose  time-sharing system which operates in conjunction with WYLBUR, is also included.", "authors": "Fajman, R. Borgelt, J.", "words_pool": ["address", "align", "appear", "comprehens", "comput", "conjunct", "connect", "content", "describ", "descript", "edit", "entri", "extern", "facil", "featur", "gener", "includ", "interact", "intern", "job", "justif", "kind", "letter", "major", "manipul", "manuscript", "method", "oper", "orvyl", "paper", "power", "program", "provid", "purpos", "remot", "retriev", "share", "short", "structur", "system", "termin", "text", "time", "typewrit", "wylbur", "fajman", "borgelt"], "word_count": {"address": 1, "align": 1, "appear": 1, "comprehens": 1, "comput": 2, "conjunct": 1, "connect": 1, "content": 1, "describ": 1, "descript": 1, "edit": 1, "entri": 1, "extern": 1, "facil": 2, "featur": 1, "gener": 1, "includ": 1, "interact": 1, "intern": 1, "job": 1, "justif": 1, "kind": 1, "letter": 1, "major": 1, "manipul": 1, "manuscript": 1, "method": 1, "oper": 1, "orvyl": 1, "paper": 1, "power": 1, "program": 1, "provid": 1, "purpos": 1, "remot": 1, "retriev": 1, "share": 1, "short": 1, "structur": 1, "system": 2, "termin": 1, "text": 3, "time": 1, "typewrit": 1, "wylbur": 3, "fajman": 1, "borgelt": 1}}, "2502": {"id": "2502", "title": "A Comment on the Practical Aspects of Computer Science Education", "authors": "Estell, R. G.", "words_pool": ["aspect", "comment", "comput", "educ", "practic", "scienc", "estel"], "word_count": {"aspect": 1, "comment": 1, "comput": 1, "educ": 1, "practic": 1, "scienc": 1, "estel": 1}}, "2503": {"id": "2503", "title": "Another Comment on Computer Music", "authors": "Wexelblat, R. L.", "words_pool": ["comment", "comput", "music", "wexelblat"], "word_count": {"comment": 1, "comput": 1, "music": 1, "wexelblat": 1}}, "2504": {"id": "2504", "title": "Concerning Music and Computer Composition in Computational Linguistics", "authors": "McMorrow, C. H.", "words_pool": ["composit", "comput", "comput", "concern", "linguist", "music", "mcmorrow"], "word_count": {"composit": 1, "comput": 2, "concern": 1, "linguist": 1, "music": 1, "mcmorrow": 1}}, "2505": {"id": "2505", "title": "Reflection-Free Permutations, Rosary Permutations, and Adjacent Transposition Algorithms", "authors": "Roy, M. K.", "words_pool": ["adjac", "algorithm", "free", "permut", "reflect", "rosari", "transposit", "roy"], "word_count": {"adjac": 1, "algorithm": 1, "free": 1, "permut": 2, "reflect": 1, "rosari": 1, "transposit": 1, "roy": 1}}, "2506": {"id": "2506", "title": "A Sparse Matrix Package (Algorithm R408)", "authors": "Sale, R. H. J.", "words_pool": ["algorithm", "matrix", "packag", "r408", "spars", "sale"], "word_count": {"algorithm": 1, "matrix": 1, "packag": 1, "r408": 1, "spars": 1, "sale": 1}}, "2507": {"id": "2507", "title": "Exact Solution of Linear Equations Using Residue Arithmetic (Algorithm R406)", "authors": "Howell, J.", "words_pool": ["algorithm", "arithmet", "equat", "exact", "linear", "r406", "residu", "solut", "howel"], "word_count": {"algorithm": 1, "arithmet": 1, "equat": 1, "exact": 1, "linear": 1, "r406": 1, "residu": 1, "solut": 1, "howel": 1}}, "2508": {"id": "2508", "title": "Increasing the Efficiency of Quicksort (Algorithm R402)", "authors": "Wheeler, R. E.", "words_pool": ["algorithm", "effici", "increas", "quicksort", "r402", "wheeler"], "word_count": {"algorithm": 1, "effici": 1, "increas": 1, "quicksort": 1, "r402": 1, "wheeler": 1}}, "2509": {"id": "2509", "title": "Minit Algorithm for Linear Programming (Algorithm R333)", "authors": "Obradovic, D.", "words_pool": ["algorithm", "linear", "minit", "program", "r333", "obradov"], "word_count": {"algorithm": 2, "linear": 1, "minit": 1, "program": 1, "r333": 1, "obradov": 1}}, "2510": {"id": "2510", "title": "Minit Algorithm for Linear Programming (Algorithm R333)", "authors": "Holmgren, B. Obradovic, D. Kolm, A.", "words_pool": ["algorithm", "linear", "minit", "program", "r333", "holmgren", "obradov", "kolm"], "word_count": {"algorithm": 2, "linear": 1, "minit": 1, "program": 1, "r333": 1, "holmgren": 1, "obradov": 1, "kolm": 1}}, "2511": {"id": "2511", "title": "Maxflow (Algorithm R324)", "authors": "Bayer, G.", "words_pool": ["algorithm", "maxflow", "r324", "bayer"], "word_count": {"algorithm": 1, "maxflow": 1, "r324": 1, "bayer": 1}}, "2512": {"id": "2512", "title": "Coulomb Wave Functions (Algorithm R300)", "authors": "Vos, H.", "words_pool": ["algorithm", "coulomb", "function", "r300", "wave", "vo"], "word_count": {"algorithm": 1, "coulomb": 1, "function": 1, "r300": 1, "wave": 1, "vo": 1}}, "2513": {"id": "2513", "title": "A Nonrecursive List Moving Algorithm", "abstract": "An efficient, nonrecursive algorithm is given for moving any LISP-type list.  In particular,  the algorithm requires no storage other than the new nodes into which the list is to be moved, and no  additional bits per node for marking; the algorithm runs in time proportional to the number of nodes  in the list.  The original list structure is destroyed as it is moved.", "authors": "Reingold, E. M.", "words_pool": ["addit", "algorithm", "bit", "destroy", "effici", "lisp", "list", "mark", "move", "move", "node", "node", "nonrecurs", "number", "origin", "proport", "requir", "run", "storag", "structur", "time", "type", "reingold"], "word_count": {"addit": 1, "algorithm": 3, "bit": 1, "destroy": 1, "effici": 1, "lisp": 1, "list": 4, "mark": 1, "move": 3, "node": 3, "nonrecurs": 1, "number": 1, "origin": 1, "proport": 1, "requir": 1, "run": 1, "storag": 1, "structur": 1, "time": 1, "type": 1, "reingold": 1}}, "2514": {"id": "2514", "title": "An Array Grammar Programming System", "abstract": "A package of Fortran programs has been developed that permits a user to interactively design  and test array grammars.  The user can control the rule selection procedure in a derivation or parse,  using weighted programming matrices; he also has a choice of instance selection schemes (raster,random,  parallel).  Examples are given involving array languages consisting of simple geometrical patterns, as  well as a language of \"neuron pictures.\"", "authors": "Mercer, A. Rosenfeld, A.", "words_pool": ["array", "choic", "consist", "control", "deriv", "design", "develop", "exampl", "fortran", "geometr", "grammar", "grammar", "instanc", "interact", "involv", "languag", "languag", "matric", "neuron", "packag", "parallel", "pars", "pattern", "permit", "pictur", "procedur", "program", "program", "random", "raster", "rule", "scheme", "select", "simpl", "system", "test", "user", "weight", "mercer", "rosenfeld"], "word_count": {"array": 2, "choic": 1, "consist": 1, "control": 1, "deriv": 1, "design": 1, "develop": 1, "exampl": 1, "fortran": 1, "geometr": 1, "grammar": 1, "instanc": 1, "interact": 1, "involv": 1, "languag": 2, "matric": 1, "neuron": 1, "packag": 1, "parallel": 1, "pars": 1, "pattern": 1, "permit": 1, "pictur": 1, "procedur": 1, "program": 2, "random": 1, "raster": 1, "rule": 1, "scheme": 1, "select": 2, "simpl": 1, "system": 1, "test": 1, "user": 2, "weight": 1, "mercer": 1, "rosenfeld": 1}}, "2515": {"id": "2515", "title": "Minimal Event-Node Network of Project Precedence Relations", "abstract": "A procedure for constructing a minimal event-node network to represent a set of precedence  relations without parallel activities is presented.  A minimal event-node network is an event-node network  in which both the number of nodes and the number of arcs are the minima to preserve the given precedence  relations Counterexamples are given to show that the algorithm presented by A. C. Fisher, J. S. Liebman,  and G. L. Nemhauser (1968) produces event-node networks which are not minimal.  Since our procedure includes  the set-covering problem, the time required may grow exponentially with the number of given activities.", "authors": "Corneil, D. G. Gotlieb, C. C. Lee, Y. M.", "words_pool": ["activ", "algorithm", "arc", "construct", "counterexampl", "cover", "event", "exponenti", "fisher", "grow", "includ", "liebman", "minima", "minim", "nemhaus", "network", "network", "node", "node", "number", "parallel", "preced", "present", "preserv", "problem", "procedur", "produc", "project", "relat", "repres", "requir", "set", "show", "time", "corneil", "gotlieb", "lee"], "word_count": {"activ": 2, "algorithm": 1, "arc": 1, "construct": 1, "counterexampl": 1, "cover": 1, "event": 4, "exponenti": 1, "fisher": 1, "grow": 1, "includ": 1, "liebman": 1, "minima": 1, "minim": 3, "nemhaus": 1, "network": 4, "node": 5, "number": 3, "parallel": 1, "preced": 2, "present": 2, "preserv": 1, "problem": 1, "procedur": 2, "produc": 1, "project": 1, "relat": 2, "repres": 1, "requir": 1, "set": 2, "show": 1, "time": 1, "corneil": 1, "gotlieb": 1, "lee": 1}}, "2516": {"id": "2516", "title": "Hierarchical Storage in Information Retrieval", "abstract": "A probabilistic analysis is employed to determine the effect of hierarchical storage organizations  on information retrieval operations.  The data storage hardware is assumed to consist on n-levels of  linearly connected memory hardware with increasing data access times and increasing data storage capabilities.   A system might, for example, consist of fast semiconductor memory, computer core memory, extended core  storage, disk memory, and data cells.  Equations are derived to predict the effect of such a system on  data access times using sequential files, random access files, and structured files employing multiple-hierarchical  linked lists.", "authors": "Salasin, J.", "words_pool": ["access", "analysi", "assum", "capabl", "cell", "comput", "connect", "consist", "core", "data", "deriv", "determin", "disk", "effect", "employ", "employ", "equat", "extend", "fast", "hardwar", "hierarch", "increas", "inform", "level", "linearli", "link", "list", "memori", "multipl", "oper", "organ", "predict", "probabilist", "random", "retriev", "semiconductor", "sequenti", "storag", "structur", "system", "time", "salasin"], "word_count": {"access": 3, "analysi": 1, "assum": 1, "capabl": 1, "cell": 1, "comput": 1, "connect": 1, "consist": 2, "core": 2, "data": 5, "deriv": 1, "determin": 1, "disk": 1, "effect": 2, "employ": 2, "equat": 1, "extend": 1, "fast": 1, "hardwar": 2, "hierarch": 2, "increas": 2, "inform": 1, "level": 1, "linearli": 1, "link": 1, "list": 1, "memori": 4, "multipl": 1, "oper": 1, "organ": 1, "predict": 1, "probabilist": 1, "random": 1, "retriev": 1, "semiconductor": 1, "sequenti": 1, "storag": 4, "structur": 1, "system": 2, "time": 2, "salasin": 1}}, "2517": {"id": "2517", "title": "Some Comments on the Use of Ambiguous Decision Tables and Their Conversion to Computer Programs", "abstract": "This paper comments upon recently published work on decision table translation using methods  similar to the rule-mask technique.  The applicability of these methods under various possible conventions  on overall table meaning is discussed, and it is argued that there is a place both for the multi-rule  and the single-rule (or action set) convention in decision tale usage.", "authors": "King, P. J. H. Johnson, R. G.", "words_pool": ["action", "ambigu", "applic", "argu", "comment", "comput", "convent", "convent", "convers", "decis", "discuss", "mask", "mean", "method", "multi", "paper", "place", "program", "publish", "recent", "rule", "set", "similar", "singl", "tabl", "tabl", "tale", "techniqu", "translat", "usag", "work", "king", "johnson"], "word_count": {"action": 1, "ambigu": 1, "applic": 1, "argu": 1, "comment": 1, "comput": 1, "convent": 2, "convers": 1, "decis": 2, "discuss": 1, "mask": 1, "mean": 1, "method": 2, "multi": 1, "paper": 1, "place": 1, "program": 1, "publish": 1, "recent": 1, "rule": 3, "set": 1, "similar": 1, "singl": 1, "tabl": 2, "tale": 1, "techniqu": 1, "translat": 1, "usag": 1, "work": 1, "king": 1, "johnson": 1}}, "2518": {"id": "2518", "title": "Programming by Questionnaire: An Effective Way To Use Decision Tables", "abstract": "Programming by questionnaire combines aspects of decision table programming and general purpose  programming by using decision tables to construct an application program through the selection of certain  source statements from a predefined file.  It is proposed that programming by questionnairies a useful  compromise between general and special purpose programming for a significant class of large scale problems.   The elements of the approach are discussed an existing application is described.", "authors": "Low, D. W.", "words_pool": ["applic", "approach", "aspect", "class", "combin", "compromis", "construct", "decis", "discuss", "effect", "element", "exist", "gener", "larg", "predefin", "problem", "program", "program", "propos", "purpos", "questionnair", "questionnairi", "scale", "select", "signific", "sourc", "special", "statement", "tabl", "tabl", "low"], "word_count": {"applic": 2, "approach": 1, "aspect": 1, "class": 1, "combin": 1, "compromis": 1, "construct": 1, "decis": 2, "discuss": 1, "effect": 1, "element": 1, "exist": 1, "gener": 2, "larg": 1, "predefin": 1, "problem": 1, "program": 6, "propos": 1, "purpos": 2, "questionnair": 1, "questionnairi": 1, "scale": 1, "select": 1, "signific": 1, "sourc": 1, "special": 1, "statement": 1, "tabl": 2, "low": 1}}, "2519": {"id": "2519", "title": "On the Problem of Communicating Complex Information", "abstract": "The nature of the difficulty involved in communicating mathematical results between scientists  using a computer based information retrieval system is examined.  The problem is analyzed in terms of  psychological and information-processing processes, and what turns out to be a vicious circle of effects  is described.  These include ways of augmenting written natural language by various notational and linguistic  devices, the exhibition of the structure inherent in the information we are communicating, and a sophisticated  interactive system controlled by computer.", "authors": "Pager, D.", "words_pool": ["analyz", "augment", "base", "circl", "commun", "complex", "comput", "control", "devic", "difficulti", "effect", "examin", "exhibit", "includ", "inform", "inher", "interact", "involv", "languag", "linguist", "mathemat", "natur", "natur", "notat", "problem", "process", "process", "psycholog", "result", "retriev", "scientist", "sophist", "structur", "system", "term", "turn", "viciou", "way", "written", "pager"], "word_count": {"analyz": 1, "augment": 1, "base": 1, "circl": 1, "commun": 2, "complex": 1, "comput": 2, "control": 1, "devic": 1, "difficulti": 1, "effect": 1, "examin": 1, "exhibit": 1, "includ": 1, "inform": 3, "inher": 1, "interact": 1, "involv": 1, "languag": 1, "linguist": 1, "mathemat": 1, "natur": 2, "notat": 1, "problem": 1, "process": 2, "psycholog": 1, "result": 1, "retriev": 1, "scientist": 1, "sophist": 1, "structur": 1, "system": 2, "term": 1, "turn": 1, "viciou": 1, "way": 1, "written": 1, "pager": 1}}, "2520": {"id": "2520", "title": "Greatest Common Divisor of n Integers and Multipliers (Algorithm C386)", "authors": "Ragland, L. C. Good, D. I.", "words_pool": ["algorithm", "c386", "common", "divisor", "greatest", "integ", "multipli", "ragland", "good"], "word_count": {"algorithm": 1, "c386": 1, "common": 1, "divisor": 1, "greatest": 1, "integ": 1, "multipli": 1, "ragland": 1, "good": 1}}, "2521": {"id": "2521", "title": "Ten Subroutines for the Manipulation of Chebyshev Series [C1] (Algorithm A446)", "authors": "Broucke, R.", "words_pool": ["a446", "algorithm", "c1", "chebyshev", "manipul", "seri", "subroutin", "ten", "brouck"], "word_count": {"a446": 1, "algorithm": 1, "c1": 1, "chebyshev": 1, "manipul": 1, "seri": 1, "subroutin": 1, "ten": 1, "brouck": 1}}, "2522": {"id": "2522", "title": "The Design, Implementation, and Evaluation of a Working Set Dispatcher", "abstract": "The behavior of a computer system is largely dependent upon the algorithms employed to allocate  the system resources to the processes competing for them.  Recent research in time-sharing paging systems  has developed the working set model for program behavior, and are source allocation strategy based on  this model has been proposed.  Two implementations along these principles have been reported, but it  seems that in neither case have further results been announced.  This report discusses the design and  implementation of a dispatcher based on the working set principle, presents data to permit analysis of  its behavior, and indicates future directions of research on methods of controlling a computer system.", "authors": "Rodriguez-Rosell, J. Dupuy, J. P.", "words_pool": ["algorithm", "alloc", "alloc", "analysi", "announc", "base", "behavior", "case", "compet", "comput", "control", "data", "depend", "design", "develop", "direct", "discuss", "dispatch", "employ", "evalu", "futur", "implement", "implement", "larg", "method", "model", "page", "permit", "present", "principl", "principl", "process", "program", "propos", "recent", "report", "report", "research", "resourc", "result", "set", "share", "sourc", "strategi", "system", "system", "time", "work", "rodriguez", "rosel", "dupuy"], "word_count": {"algorithm": 1, "alloc": 2, "analysi": 1, "announc": 1, "base": 2, "behavior": 3, "case": 1, "compet": 1, "comput": 2, "control": 1, "data": 1, "depend": 1, "design": 1, "develop": 1, "direct": 1, "discuss": 1, "dispatch": 1, "employ": 1, "evalu": 1, "futur": 1, "implement": 2, "larg": 1, "method": 1, "model": 2, "page": 1, "permit": 1, "present": 1, "principl": 2, "process": 1, "program": 1, "propos": 1, "recent": 1, "report": 2, "research": 2, "resourc": 1, "result": 1, "set": 2, "share": 1, "sourc": 1, "strategi": 1, "system": 4, "time": 1, "work": 2, "rodriguez": 1, "rosel": 1, "dupuy": 1}}, "2523": {"id": "2523", "title": "A Region Coloring Technique for Scene Analysis", "abstract": "A method of converting a picture into a \"cartoon\" or \"map\" whose regions correspond to differently  textured regions is described.  Texture edges in the picture are detected, and solid regions surrounded  by these (usually broken) edges are \"colored in\" using a propagation process.  The resulting map is cleaned  by comparing the region colors with the textures of the corresponding regions in the picture, and also  by merging some regions with others according to criteria based on topology and size.  The method has  been applied to the construction of cloud cover maps from cloud cover pictures obtained by satellites.", "authors": "Strong III, J. P. Rosenfeld, A.", "words_pool": ["accord", "analysi", "appli", "base", "broken", "cartoon", "clean", "cloud", "color", "color", "color", "compar", "construct", "convert", "correspond", "cover", "criteria", "detect", "differ", "edg", "map", "map", "merg", "method", "obtain", "pictur", "pictur", "process", "propag", "region", "region", "result", "satellit", "scene", "size", "solid", "surround", "techniqu", "textur", "textur", "textur", "topolog", "strong", "iii", "rosenfeld"], "word_count": {"accord": 1, "analysi": 1, "appli": 1, "base": 1, "broken": 1, "cartoon": 1, "clean": 1, "cloud": 2, "color": 2, "compar": 1, "construct": 1, "convert": 1, "correspond": 1, "cover": 2, "criteria": 1, "detect": 1, "differ": 1, "edg": 2, "map": 3, "merg": 1, "method": 2, "obtain": 1, "pictur": 4, "process": 1, "propag": 1, "region": 6, "result": 1, "satellit": 1, "scene": 1, "size": 1, "solid": 1, "surround": 1, "techniqu": 1, "textur": 3, "topolog": 1, "strong": 1, "iii": 1, "rosenfeld": 1}}, "2524": {"id": "2524", "title": "Some Approaches to Best-Match File Searching", "abstract": "The problem of searching the set of keys in a file to find a key which is closest to a given  query key is discussed.  After \"closest,\" in terms of a metric on the the key space, is suitably defined,  three file structures are presented together with their corresponding search algorithms, which are intended  to reduce the number of comparisons required to achieve the desired result. These methods are derived  using certain inequalities satisfied by metrics and by graph-theoretic concepts.  Some empirical results  are presented which compare the efficiency of the methods.", "authors": "Burkhard, W. A. Keller, R. M.", "words_pool": ["achiev", "algorithm", "approach", "closest", "compar", "comparison", "concept", "defin", "deriv", "desir", "discuss", "effici", "empir", "find", "graph", "inequ", "intend", "key", "key", "match", "method", "metric", "metric", "number", "present", "problem", "queri", "reduc", "requir", "result", "result", "satisfi", "search", "search", "set", "space", "structur", "suitabl", "term", "theoret", "burkhard", "keller"], "word_count": {"achiev": 1, "algorithm": 1, "approach": 1, "closest": 2, "compar": 1, "comparison": 1, "concept": 1, "defin": 1, "deriv": 1, "desir": 1, "discuss": 1, "effici": 1, "empir": 1, "find": 1, "graph": 1, "inequ": 1, "intend": 1, "key": 4, "match": 1, "method": 2, "metric": 2, "number": 1, "present": 2, "problem": 1, "queri": 1, "reduc": 1, "requir": 1, "result": 2, "satisfi": 1, "search": 2, "set": 1, "space": 1, "structur": 1, "suitabl": 1, "term": 1, "theoret": 1, "burkhard": 1, "keller": 1}}, "2525": {"id": "2525", "title": "A Statistical Study of the Accuracy of Floating Point Number Systems", "abstract": "This paper presents the statistical results of tests of the accuracy of certain arithmetic  systems in evaluating sums, products and inner products, and analytic error estimates for some of the  computations.  The arithmetic systems studied are 6-digit hexadecimal and 22-digit binary floating point  number representations combined with the usual chop and round modes of arithmetic with various numbers  of guard digits, and with a modified round mode with guard digits.  In a certain sense, arithmetic systems  differing only in their use of binary or hexadecimal number representations are shown to be approximately  statistically equivalent inaccuracy.  Further, the usual round mode with guard digits is shown to be  statistically superior in accuracy to the usual chop mode in all cases save one.  The modified round  mode is found to be superior to the chop mode in all cases.", "authors": "Kuki, H. Cody, W. J.", "words_pool": ["accuraci", "analyt", "approxim", "arithmet", "binari", "case", "chop", "combin", "comput", "differ", "digit", "digit", "equival", "error", "estim", "evalu", "float", "found", "guard", "hexadecim", "inaccuraci", "mode", "mode", "modifi", "number", "number", "paper", "point", "present", "product", "represent", "result", "round", "save", "sens", "shown", "statist", "statist", "studi", "studi", "sum", "superior", "system", "test", "usual", "kuki", "codi"], "word_count": {"accuraci": 2, "analyt": 1, "approxim": 1, "arithmet": 4, "binari": 2, "case": 2, "chop": 3, "combin": 1, "comput": 1, "differ": 1, "digit": 5, "equival": 1, "error": 1, "estim": 1, "evalu": 1, "float": 1, "found": 1, "guard": 3, "hexadecim": 2, "inaccuraci": 1, "mode": 6, "modifi": 2, "number": 3, "paper": 1, "point": 1, "present": 1, "product": 2, "represent": 2, "result": 1, "round": 4, "save": 1, "sens": 1, "shown": 2, "statist": 3, "studi": 1, "sum": 1, "superior": 2, "system": 3, "test": 1, "usual": 3, "kuki": 1, "codi": 1}}, "2526": {"id": "2526", "title": "Asymmetric Memory Hierarchies", "abstract": "A study is presented of some of the system implications of memory hierarchies in which the  backing or secondary store has a very small read time, relative of both the time required for writing  and to the read time of conventional backing storage devices. Several analytic models are introduced,  and it is shown that such hierarchies may operate in ways which differ from those of more conventional  hierarchies.  In particular, it is shown that it may not be necessary to multiprogram in such a situation.   In the past, backing storage devices have been roughly symmetric with respect to their read and write  times.  This situation may not continue, as several devices are currently under development which may  have a very small read-time/write-time ratio.  This study places particular emphasis on one such system-the  RCA read/write holographic optical memory.", "authors": "Williams, J.G.", "words_pool": ["analyt", "asymmetr", "back", "continu", "convent", "develop", "devic", "differ", "emphasi", "hierarchi", "holograph", "implic", "introduc", "memori", "model", "multiprogram", "oper", "optic", "past", "place", "present", "ratio", "rca", "read", "rel", "requir", "respect", "roughli", "secondari", "shown", "situat", "small", "storag", "store", "studi", "symmetr", "system", "time", "time", "way", "write", "write", "william"], "word_count": {"analyt": 1, "asymmetr": 1, "back": 3, "continu": 1, "convent": 2, "develop": 1, "devic": 3, "differ": 1, "emphasi": 1, "hierarchi": 3, "holograph": 1, "implic": 1, "introduc": 1, "memori": 2, "model": 1, "multiprogram": 1, "oper": 1, "optic": 1, "past": 1, "place": 1, "present": 1, "ratio": 1, "rca": 1, "read": 5, "rel": 1, "requir": 1, "respect": 1, "roughli": 1, "secondari": 1, "shown": 2, "situat": 2, "small": 2, "storag": 2, "store": 1, "studi": 2, "symmetr": 1, "system": 2, "time": 6, "way": 1, "write": 4, "william": 1}}, "2527": {"id": "2527", "title": "Implementation of High Level Language Machine", "abstract": "Computing machines which directly execute the statements of a high level language have been  proposed in the past.  This report describes the actual implementation of such a machine: it is a computer  whose \"machine language\" is APL.  The machine is fully operational and correctly executes almost all  of the APL operations on scalars, vectors, and arrays.  The machine automatically allocates memory, executes  statements, calls functions, converts numbers from one type to another, checks subscripts, and automatically  detects many types of programmer errors.", "authors": "Hassitt, A. Lageschulte, J. W. Lyon, L. E.", "words_pool": ["actual", "alloc", "apl", "array", "call", "check", "comput", "comput", "convert", "correctli", "describ", "detect", "directli", "error", "execut", "execut", "fulli", "function", "high", "implement", "languag", "level", "machin", "machin", "memori", "number", "oper", "oper", "past", "programm", "propos", "report", "scalar", "statement", "subscript", "type", "type", "vector", "hassitt", "lageschult", "lyon"], "word_count": {"actual": 1, "alloc": 1, "apl": 2, "array": 1, "call": 1, "check": 1, "comput": 2, "convert": 1, "correctli": 1, "describ": 1, "detect": 1, "directli": 1, "error": 1, "execut": 3, "fulli": 1, "function": 1, "high": 1, "implement": 1, "languag": 2, "level": 1, "machin": 5, "memori": 1, "number": 1, "oper": 2, "past": 1, "programm": 1, "propos": 1, "report": 1, "scalar": 1, "statement": 2, "subscript": 1, "type": 2, "vector": 1, "hassitt": 1, "lageschult": 1, "lyon": 1}}, "2528": {"id": "2528", "title": "Binary Pattern Reconstruction from Projections [Z] (Algorithm R445)", "authors": "Lau, J.", "words_pool": ["algorithm", "binari", "pattern", "project", "r445", "reconstruct", "lau"], "word_count": {"algorithm": 1, "binari": 1, "pattern": 1, "project": 1, "r445": 1, "reconstruct": 1, "lau": 1}}, "2529": {"id": "2529", "title": "Binary Pattern Reconstruction from Projections [Z] (Algorithm A445)", "authors": "Chang, S.", "words_pool": ["a445", "algorithm", "binari", "pattern", "project", "reconstruct", "chang"], "word_count": {"a445": 1, "algorithm": 1, "binari": 1, "pattern": 1, "project": 1, "reconstruct": 1, "chang": 1}}, "2530": {"id": "2530", "title": "An Algorithm for Extracting Phrases in a Space-Optimal Fashion [Z] (Algorithm A444)", "authors": "Wagner, R. A.", "words_pool": ["a444", "algorithm", "extract", "fashion", "optim", "phrase", "space", "wagner"], "word_count": {"a444": 1, "algorithm": 2, "extract": 1, "fashion": 1, "optim": 1, "phrase": 1, "space": 1, "wagner": 1}}, "2531": {"id": "2531", "title": "Graduate Education: The Ph.D. Glut", "authors": "Payne, W. H.", "words_pool": ["educ", "glut", "graduat", "ph", "payn"], "word_count": {"educ": 1, "glut": 1, "graduat": 1, "ph": 1, "payn": 1}}, "2532": {"id": "2532", "title": "On Harrison's Substring Testing Technique", "authors": "Bookstein, A.", "words_pool": ["harrison", "substr", "techniqu", "test", "bookstein"], "word_count": {"harrison": 1, "substr": 1, "techniqu": 1, "test": 1, "bookstein": 1}}, "2533": {"id": "2533", "title": "Gray Code and the +- Sign Sequence when +-f (+-f(+-f(...+-f(x)...))) Is Ordered", "authors": "Salzer, H. E.", "words_pool": ["code", "gray", "order", "sequenc", "sign", "salzer"], "word_count": {"code": 1, "gray": 1, "order": 1, "sequenc": 1, "sign": 1, "salzer": 1}}, "2534": {"id": "2534", "title": "Design and Implementation of a Diagnostic Compiler for PL/I", "abstract": "PL/C is a compiler for a dialect for PL/I.  The design objective was to provide a maximum degree  of diagnostic assistance in a batch processing environment.  For the most part this assistance is implicit  and is provided automatically by the compiler. The most remarkable characteristic of PL/C is its perseverance-it  completes translation of every program submitted and continues execution until a user-established error  limit is reached. This requires that the compiler repair errors encountered during both translation  and execution, and the design of PL/C is dominated by this consideration.  PL/C also introduces several  explicit user-controlled facilities for program testing.  To accommodate these extensions to PL/I without  abandoning compatibility with IBM compiler PL/C permits \"pseudo comments\"-constructions whose contents  can optionally be considered either source test or comment.  In spite of the diagnostic effort PL/C is  a fast and efficient processor.  It effectively demonstrates that compilers can provide better diagnostic  assistance than is customarily offered, even when a sophisticated source language is employed, and that  this assistance need not be prohibitively costly.", "authors": "Conway, R. W. Wilcox, T. R.", "words_pool": ["abandon", "accommod", "assist", "batch", "characterist", "comment", "comment", "compat", "compil", "compil", "complet", "consider", "consid", "construct", "content", "continu", "control", "costli", "customarili", "degre", "demonstr", "design", "diagnost", "dialect", "domin", "effect", "effici", "effort", "employ", "encount", "environ", "error", "error", "establish", "execut", "explicit", "extens", "facil", "fast", "ibm", "implement", "implicit", "introduc", "languag", "limit", "maximum", "need", "object", "offer", "option", "part", "permit", "persever", "pl", "process", "processor", "program", "prohibit", "provid", "provid", "pseudo", "reach", "remark", "repair", "requir", "sophist", "sourc", "spite", "submit", "test", "test", "translat", "user", "conway", "wilcox"], "word_count": {"abandon": 1, "accommod": 1, "assist": 4, "batch": 1, "characterist": 1, "comment": 2, "compat": 1, "compil": 5, "complet": 1, "consider": 1, "consid": 1, "construct": 1, "content": 1, "continu": 1, "control": 1, "costli": 1, "customarili": 1, "degre": 1, "demonstr": 1, "design": 2, "diagnost": 3, "dialect": 1, "domin": 1, "effect": 1, "effici": 1, "effort": 1, "employ": 1, "encount": 1, "environ": 1, "error": 2, "establish": 1, "execut": 2, "explicit": 1, "extens": 1, "facil": 1, "fast": 1, "ibm": 1, "implement": 1, "implicit": 1, "introduc": 1, "languag": 1, "limit": 1, "maximum": 1, "need": 1, "object": 1, "offer": 1, "option": 1, "part": 1, "permit": 1, "persever": 1, "pl": 8, "process": 1, "processor": 1, "program": 2, "prohibit": 1, "provid": 3, "pseudo": 1, "reach": 1, "remark": 1, "repair": 1, "requir": 1, "sophist": 1, "sourc": 2, "spite": 1, "submit": 1, "test": 2, "translat": 2, "user": 2, "conway": 1, "wilcox": 1}}, "2535": {"id": "2535", "title": "The Effects of Multiplexing on a Computer-Communications System", "abstract": "A study is made of the way in which asynchronous time division multiplexing changes the stochastic  nature of the arrival process from a user to the computer and, consequently, affects the performance  of a time-shared computer-communications system.  It is concluded that while, for certain values of system  parameters, there is noticeable improvement in the performance of the computer (model), in the sense  that time-shared scheduling delays are reduced, these improvements are offset by the transmission delays  imposed by multiplexing so that there may be little or no change in the computer-communications system  performance.  Analytical and simulation results are based on the model of the computer-communications  system being an M/D/1 queue (the multiplexor) in tandem with a single exponential server (the computer).   Analytical results include a general description of the output process of an M/D/1 queue and the conditions  under which this output process is approximately Poisson.", "authors": "Pack, C. D.", "words_pool": ["affect", "analyt", "approxim", "arriv", "asynchron", "base", "chang", "commun", "comput", "conclud", "condit", "delay", "descript", "divis", "effect", "exponenti", "gener", "impos", "improv", "improv", "includ", "made", "model", "multiplex", "multiplexor", "natur", "notic", "offset", "output", "paramet", "perform", "poisson", "process", "queue", "reduc", "result", "schedul", "sens", "server", "share", "simul", "singl", "stochast", "studi", "system", "tandem", "time", "transmiss", "user", "valu", "pack"], "word_count": {"affect": 1, "analyt": 2, "approxim": 1, "arriv": 1, "asynchron": 1, "base": 1, "chang": 1, "commun": 3, "comput": 6, "conclud": 1, "condit": 1, "delay": 2, "descript": 1, "divis": 1, "effect": 1, "exponenti": 1, "gener": 1, "impos": 1, "improv": 2, "includ": 1, "made": 1, "model": 2, "multiplex": 2, "multiplexor": 1, "natur": 1, "notic": 1, "offset": 1, "output": 2, "paramet": 1, "perform": 3, "poisson": 1, "process": 3, "queue": 2, "reduc": 1, "result": 2, "schedul": 1, "sens": 1, "server": 1, "share": 2, "simul": 1, "singl": 1, "stochast": 1, "studi": 1, "system": 4, "tandem": 1, "time": 3, "transmiss": 1, "user": 1, "valu": 1, "pack": 1}}, "2536": {"id": "2536", "title": "Telecommunications Using a Front-End Minicomputer", "abstract": "The use of a front-end minicomputer to provide varied remote terminal access to a large scale  computer is considered.  The problems of embedding telecommunications I/O within an operating system  are discussed, and it is shown how the decentralization of intelligence acquired by front-end processing  vastly simplifies the problem.  A specific implementation is discussed with emphasis on the main processor-minicomputer  link, the hardware-software implementation, the effect of the main processor operating system, and an  assessment of the advantages over a hard wired line controller.", "authors": "Feinroth, Y. Franceschini, E. Goldstein, M.", "words_pool": ["access", "acquir", "advantag", "assess", "comput", "consid", "control", "decentr", "discuss", "effect", "embed", "emphasi", "end", "front", "hard", "hardwar", "implement", "intellig", "larg", "line", "link", "main", "minicomput", "oper", "problem", "problem", "process", "processor", "provid", "remot", "scale", "shown", "simplifi", "softwar", "specif", "system", "telecommun", "termin", "vari", "vastli", "wire", "feinroth", "franceschini", "goldstein"], "word_count": {"access": 1, "acquir": 1, "advantag": 1, "assess": 1, "comput": 1, "consid": 1, "control": 1, "decentr": 1, "discuss": 2, "effect": 1, "embed": 1, "emphasi": 1, "end": 2, "front": 2, "hard": 1, "hardwar": 1, "implement": 2, "intellig": 1, "larg": 1, "line": 1, "link": 1, "main": 2, "minicomput": 2, "oper": 2, "problem": 2, "process": 1, "processor": 2, "provid": 1, "remot": 1, "scale": 1, "shown": 1, "simplifi": 1, "softwar": 1, "specif": 1, "system": 2, "telecommun": 1, "termin": 1, "vari": 1, "vastli": 1, "wire": 1, "feinroth": 1, "franceschini": 1, "goldstein": 1}}, "2537": {"id": "2537", "title": "Common Phrases and Minimum-Space Text Storage", "abstract": "A method for saving storage space for text strings, such as compiler diagnostic messages, is  described.  The method relies on hand selection of a set of text strings which are common to one or more  messages.  These phrases are then stored only once.  The storage technique gives rise to a mathematical  optimization problem: determine how each message should use the available phrases to minimize its storage  requirement.  This problem is nontrivial when phrases which overlap exist.  However, a dynamic programming  algorithm is presented which solves the problem in time which grows linearly with the number of characters  in the text.  Algorithm 444 applies to this paper.", "authors": "Wagner, R. A.", "words_pool": ["algorithm", "appli", "charact", "common", "compil", "determin", "diagnost", "dynam", "exist", "grow", "hand", "linearli", "mathemat", "messag", "messag", "method", "minim", "minimum", "nontrivi", "number", "optim", "overlap", "paper", "phrase", "present", "problem", "program", "reli", "requir", "rise", "save", "select", "set", "solv", "space", "storag", "store", "string", "techniqu", "text", "time", "wagner"], "word_count": {"algorithm": 2, "appli": 1, "charact": 1, "common": 1, "compil": 1, "determin": 1, "diagnost": 1, "dynam": 1, "exist": 1, "grow": 1, "hand": 1, "linearli": 1, "mathemat": 1, "messag": 3, "method": 2, "minim": 1, "minimum": 1, "nontrivi": 1, "number": 1, "optim": 1, "overlap": 1, "paper": 1, "phrase": 3, "present": 1, "problem": 3, "program": 1, "reli": 1, "requir": 1, "rise": 1, "save": 1, "select": 1, "set": 1, "solv": 1, "space": 1, "storag": 3, "store": 1, "string": 2, "techniqu": 1, "text": 3, "time": 1, "wagner": 1}}, "2538": {"id": "2538", "title": "A Computer Science Course Program for Small Colleges", "abstract": "The ACM Subcommittee on Small College Programs of the Committee on Curriculum in Computer Science  (CCCS) was appointed in 1969 to consider the unique problems of small colleges and universities, and  to make recommendations regarding computer science programs at such schools.  This report, authorized  by both the subcommittee and (CCCS), supplies a set of recommendations for courses and necessary resources.   Implementation problems are discussed, specifically within the constraints of limited faculty and for  the purposes of satisfying a wide variety of objectives.  Detailed description of four courses are given;  suggestions are made for more advanced work; and an extensive library list is included.", "authors": "Austing, R. H. Engel, G. L.", "words_pool": ["acm", "advanc", "appoint", "author", "ccc", "colleg", "colleg", "committe", "comput", "consid", "constraint", "cours", "cours", "curriculum", "descript", "detail", "discuss", "extens", "faculti", "implement", "includ", "librari", "limit", "list", "made", "make", "object", "problem", "program", "program", "purpos", "recommend", "regard", "report", "resourc", "satisfi", "school", "scienc", "set", "small", "specif", "subcommitte", "suggest", "suppli", "uniqu", "univers", "varieti", "wide", "work", "aust", "engel"], "word_count": {"acm": 1, "advanc": 1, "appoint": 1, "author": 1, "ccc": 2, "colleg": 2, "committe": 1, "comput": 2, "consid": 1, "constraint": 1, "cours": 2, "curriculum": 1, "descript": 1, "detail": 1, "discuss": 1, "extens": 1, "faculti": 1, "implement": 1, "includ": 1, "librari": 1, "limit": 1, "list": 1, "made": 1, "make": 1, "object": 1, "problem": 2, "program": 2, "purpos": 1, "recommend": 2, "regard": 1, "report": 1, "resourc": 1, "satisfi": 1, "school": 1, "scienc": 2, "set": 1, "small": 2, "specif": 1, "subcommitte": 2, "suggest": 1, "suppli": 1, "uniqu": 1, "univers": 1, "varieti": 1, "wide": 1, "work": 1, "aust": 1, "engel": 1}}, "2539": {"id": "2539", "title": "Solution of the Transcendental Equation w*exp(w)=x [C5] (Algorithm A443)", "authors": "Fritsch, F. N. Shafer, R. E. Crowley,W. P.", "words_pool": ["a443", "algorithm", "c5", "equat", "exp", "solut", "transcendent", "fritsch", "shafer", "crowley"], "word_count": {"a443": 1, "algorithm": 1, "c5": 1, "equat": 1, "exp": 1, "solut": 1, "transcendent": 1, "fritsch": 1, "shafer": 1, "crowley": 1}}, "2540": {"id": "2540", "title": "Properties of the Working Set Model (Corrigendum)", "authors": "Denning, P. J. Schwartz, S. C.", "words_pool": ["corrigendum", "model", "properti", "set", "work", "den", "schwartz"], "word_count": {"corrigendum": 1, "model": 1, "properti": 1, "set": 1, "work": 1, "den": 1, "schwartz": 1}}, "2541": {"id": "2541", "title": "An Overview of the ISPL Computer System Design", "abstract": "This paper explores the advantages of the concurrent design of the language, operating system,  and machine (via microcode) to create an interactive programming laboratory.  It describes the synergistic  effect that the freedom to move and alter features from one of these domains to another has had on the  design of this system (which has not been implemented).  This freedom simplified both incremental compilation  and the system's addressing structure, and centralized the communication mechanisms enabling the construction  of hierarchical subsystems.  It also suggested an important new concept for operating systems: separation  of the scheduling from the maintenance functions in resource allocation. This separation enables incorporation  of new scheduling algorithms (decision of what to do) without endangering the system integration (correctly  performing the scheduling decisions).", "authors": "Balzer, R. M.", "words_pool": ["address", "advantag", "algorithm", "alloc", "alter", "central", "commun", "compil", "comput", "concept", "concurr", "construct", "correctli", "creat", "decis", "decis", "describ", "design", "domain", "effect", "enabl", "enabl", "endang", "explor", "featur", "freedom", "function", "hierarch", "implement", "import", "incorpor", "increment", "integr", "interact", "ispl", "laboratori", "languag", "machin", "mainten", "mechan", "microcod", "move", "oper", "overview", "paper", "perform", "program", "resourc", "schedul", "separ", "simplifi", "structur", "subsystem", "suggest", "synergist", "system", "system", "balzer"], "word_count": {"address": 1, "advantag": 1, "algorithm": 1, "alloc": 1, "alter": 1, "central": 1, "commun": 1, "compil": 1, "comput": 1, "concept": 1, "concurr": 1, "construct": 1, "correctli": 1, "creat": 1, "decis": 2, "describ": 1, "design": 2, "domain": 1, "effect": 1, "enabl": 2, "endang": 1, "explor": 1, "featur": 1, "freedom": 2, "function": 1, "hierarch": 1, "implement": 1, "import": 1, "incorpor": 1, "increment": 1, "integr": 1, "interact": 1, "ispl": 1, "laboratori": 1, "languag": 1, "machin": 1, "mainten": 1, "mechan": 1, "microcod": 1, "move": 1, "oper": 2, "overview": 1, "paper": 1, "perform": 1, "program": 1, "resourc": 1, "schedul": 3, "separ": 2, "simplifi": 1, "structur": 1, "subsystem": 1, "suggest": 1, "synergist": 1, "system": 5, "balzer": 1}}, "2542": {"id": "2542", "title": "A Software Design and Evaluation System", "abstract": "A critical failure of current software system design and implementation methodology is that  the performance of a proposed design is not evaluated before it is actually implemented.  In this paper  the reasons for this failure are explored, and a new methodology which overcomes many of the difficulties  is proposed.  A system which integrates performance evaluation with design and implementation is described.   This system is based on a simple, high level language which is used to describe the evolving system  at all stages of its development.  The source language description is used as direct input to performance  analysis and simulation routines.  Using the performance information obtained from these routines as  feedback, the problems which adversely affect performance are detected early enough so that they can  be corrected without costly major reimplementation of the proposed system.", "authors": "Graham, R. M. Clancy, G. J. Jr. DeVaney, D. B.", "words_pool": ["actual", "advers", "affect", "analysi", "base", "correct", "costli", "critic", "describ", "descript", "design", "detect", "develop", "difficulti", "direct", "earli", "evalu", "evalu", "evolv", "explor", "failur", "feedback", "high", "implement", "implement", "inform", "input", "integr", "languag", "level", "major", "methodolog", "obtain", "overcom", "paper", "perform", "problem", "propos", "reason", "reimplement", "routin", "simpl", "simul", "softwar", "sourc", "stage", "system", "graham", "clanci", "jr", "devaney"], "word_count": {"actual": 1, "advers": 1, "affect": 1, "analysi": 1, "base": 1, "correct": 1, "costli": 1, "critic": 1, "describ": 1, "descript": 1, "design": 3, "detect": 1, "develop": 1, "difficulti": 1, "direct": 1, "earli": 1, "evalu": 2, "evolv": 1, "explor": 1, "failur": 2, "feedback": 1, "high": 1, "implement": 3, "inform": 1, "input": 1, "integr": 1, "languag": 2, "level": 1, "major": 1, "methodolog": 2, "obtain": 1, "overcom": 1, "paper": 1, "perform": 5, "problem": 1, "propos": 3, "reason": 1, "reimplement": 1, "routin": 2, "simpl": 1, "simul": 1, "softwar": 1, "sourc": 1, "stage": 1, "system": 5, "graham": 1, "clanci": 1, "jr": 1, "devaney": 1}}, "2543": {"id": "2543", "title": "Reducing the Retrieval Time of Scatter Storage Techniques", "abstract": "A new method for entering and retrieving information in a hash table is described.  The method  is intended to be efficient if most entries are looked up several times.  The expected number of probes  to look up an entry, predicted theoretically and verified by Monte Carlo experiments, is considerably  less than for other comparable methods if the table is nearly full.  An example of a possible Fortran  implementation is given.", "authors": "Brent, R. P.", "words_pool": ["carlo", "compar", "consider", "effici", "enter", "entri", "entri", "expect", "experi", "fortran", "full", "hash", "implement", "inform", "intend", "look", "look", "method", "method", "mont", "nearli", "number", "predict", "probe", "reduc", "retriev", "retriev", "scatter", "storag", "tabl", "techniqu", "theoret", "time", "time", "verifi", "brent"], "word_count": {"carlo": 1, "compar": 1, "consider": 1, "effici": 1, "enter": 1, "entri": 2, "expect": 1, "experi": 1, "fortran": 1, "full": 1, "hash": 1, "implement": 1, "inform": 1, "intend": 1, "look": 2, "method": 3, "mont": 1, "nearli": 1, "number": 1, "predict": 1, "probe": 1, "reduc": 1, "retriev": 1, "scatter": 1, "storag": 1, "tabl": 2, "techniqu": 1, "theoret": 1, "time": 1, "verifi": 1, "brent": 1}}, "2544": {"id": "2544", "title": "Automatic Error bounds for Simple Zeros of Analytic Functions", "abstract": "The Cauchy-Ostrowski theorem on convergence of Newton iterates for an analytic function in  one variable is extended to include computational errors using complex interval arithmetic. Several numerical  examples are given for polynomials with real and complex roots and one example for the Bessel function  of the first kind.", "authors": "Rokne, J.", "words_pool": ["analyt", "arithmet", "automat", "bessel", "bound", "cauchi", "complex", "comput", "converg", "error", "error", "exampl", "extend", "function", "function", "includ", "interv", "iter", "kind", "newton", "numer", "ostrowski", "polynomi", "real", "root", "simpl", "theorem", "variabl", "zero", "rokn"], "word_count": {"analyt": 1, "arithmet": 1, "automat": 1, "bessel": 1, "bound": 1, "cauchi": 1, "complex": 2, "comput": 1, "converg": 1, "error": 1, "exampl": 1, "extend": 1, "function": 2, "includ": 1, "interv": 1, "iter": 1, "kind": 1, "newton": 1, "numer": 1, "ostrowski": 1, "polynomi": 1, "real": 1, "root": 1, "simpl": 1, "theorem": 1, "variabl": 1, "zero": 1, "rokn": 1}}, "2545": {"id": "2545", "title": "A Theory of Discrete Patterns and Their Implementation in SNOBOL4", "abstract": "The notion of a discrete pattern is formalized and certain properties deduced.  A pattern is  shown to be a generalization of a formal language.  Algorithms for implementing the kinds of patterns  in SNOBOL4 are given.  The general approach is to create, in-so-far as possible, a bottom-up parse from  a top-down specification.", "authors": "Gimpel, J. F.", "words_pool": ["algorithm", "approach", "bottom", "creat", "deduc", "discret", "formal", "formal", "gener", "gener", "implement", "implement", "kind", "languag", "notion", "pars", "pattern", "pattern", "properti", "shown", "snobol4", "specif", "theori", "top", "gimpel"], "word_count": {"algorithm": 1, "approach": 1, "bottom": 1, "creat": 1, "deduc": 1, "discret": 1, "formal": 2, "gener": 2, "implement": 1, "kind": 1, "languag": 1, "notion": 1, "pars": 1, "pattern": 3, "properti": 1, "shown": 1, "snobol4": 1, "specif": 1, "theori": 1, "top": 1, "gimpel": 1}}, "2546": {"id": "2546", "title": "The Use of Grammatical Inference for Designing Programming Languages", "abstract": "Both in designing a new programming language and in extending an existing language, the designer  is faced with the problem of deriving a \"natural\" grammar for the language.  We are proposing an interactive  approach to the grammar design problem wherein the designer presents a sample of sentences and structures  as input to a grammatical inference algorithm.  The algorithm then constructs a grammar which is a reasonable  generalization of the examples submitted by the designer.  The implementation is presently restricted  to a subclass of operator precedence grammars, but a second algorithm is outlined which applies to a  larger class of context-free grammars.", "authors": "Crespi-Reghizzi, S. Melkanoff, M. A. Lichten, L.", "words_pool": ["algorithm", "appli", "approach", "class", "construct", "context", "deriv", "design", "design", "design", "exampl", "exist", "extend", "face", "free", "gener", "grammar", "grammar", "grammat", "implement", "infer", "input", "interact", "languag", "languag", "larger", "natur", "oper", "outlin", "preced", "present", "present", "problem", "program", "propos", "reason", "restrict", "sampl", "sentenc", "structur", "subclass", "submit", "crespi", "reghizzi", "melkanoff", "lichten"], "word_count": {"algorithm": 3, "appli": 1, "approach": 1, "class": 1, "construct": 1, "context": 1, "deriv": 1, "design": 5, "exampl": 1, "exist": 1, "extend": 1, "face": 1, "free": 1, "gener": 1, "grammar": 5, "grammat": 1, "implement": 1, "infer": 1, "input": 1, "interact": 1, "languag": 3, "larger": 1, "natur": 1, "oper": 1, "outlin": 1, "preced": 1, "present": 2, "problem": 2, "program": 1, "propos": 1, "reason": 1, "restrict": 1, "sampl": 1, "sentenc": 1, "structur": 1, "subclass": 1, "submit": 1, "crespi": 1, "reghizzi": 1, "melkanoff": 1, "lichten": 1}}, "2547": {"id": "2547", "title": "Representation of Contours ad Regions for Efficient Computer Search", "abstract": "A novel computer-searchable representation for the three basic pictorial features, contour  maps, region coverage, and line structures, is described.  The representation, which has practical storage  requirements, provides a rapid mean of searching large files for data associated with geometric position  as well as with attribute value.  An application of this representation to handling terrain information  illustrates its utility.  The algebraic properties of the data structure make it computationally easy  to determine whether a point lies within a closed boundary; compute the area contained by a closed boundary;  generate the closed boundary representing the union or intersection of two closed boundaries; and determine  the neighboring boundaries to a point and the minimum distances between them and the point.", "authors": "Merrill, R. D.", "words_pool": ["ad", "algebra", "applic", "area", "attribut", "basic", "boundari", "boundari", "close", "comput", "comput", "comput", "contain", "contour", "contour", "coverag", "data", "determin", "distanc", "easi", "effici", "featur", "gener", "geometr", "handl", "illustr", "inform", "intersect", "larg", "lie", "line", "make", "map", "mean", "minimum", "neighbor", "pictori", "point", "posit", "practic", "properti", "rapid", "region", "region", "represent", "repres", "requir", "search", "searchabl", "search", "storag", "structur", "structur", "terrain", "union", "util", "merril"], "word_count": {"ad": 1, "algebra": 1, "applic": 1, "area": 1, "attribut": 1, "basic": 1, "boundari": 5, "close": 4, "comput": 3, "contain": 1, "contour": 1, "coverag": 1, "data": 2, "determin": 2, "distanc": 1, "easi": 1, "effici": 1, "featur": 1, "gener": 1, "geometr": 1, "handl": 1, "illustr": 1, "inform": 1, "intersect": 1, "larg": 1, "lie": 1, "line": 1, "make": 1, "map": 1, "mean": 1, "minimum": 1, "neighbor": 1, "pictori": 1, "point": 3, "posit": 1, "practic": 1, "properti": 1, "rapid": 1, "region": 1, "represent": 3, "repres": 1, "requir": 1, "search": 1, "searchabl": 1, "storag": 1, "structur": 2, "terrain": 1, "union": 1, "util": 1, "merril": 1}}, "2548": {"id": "2548", "title": "Normal Deviate [S14] (Algorithm A442)", "authors": "Hill, G. W. Davis, A. W.", "words_pool": ["a442", "algorithm", "deviat", "normal", "s14", "hill", "davi"], "word_count": {"a442": 1, "algorithm": 1, "deviat": 1, "normal": 1, "s14": 1, "hill": 1, "davi": 1}}, "2549": {"id": "2549", "title": "Random Deviates from the Dipole Distribution [G5] (Algorithm A441)", "authors": "Knop, R. E.", "words_pool": ["a441", "algorithm", "deviat", "dipol", "distribut", "g5", "random", "knop"], "word_count": {"a441": 1, "algorithm": 1, "deviat": 1, "dipol": 1, "distribut": 1, "g5": 1, "random": 1, "knop": 1}}, "2550": {"id": "2550", "title": "A Multidimensional Monte Carlo Quadrature with Adaptive Stratified Sampling [D1] (Algorithm A440)", "authors": "Gallaher, L. J.", "words_pool": ["a440", "adapt", "algorithm", "carlo", "d1", "mont", "multidimension", "quadratur", "sampl", "stratifi", "gallah"], "word_count": {"a440": 1, "adapt": 1, "algorithm": 1, "carlo": 1, "d1": 1, "mont": 1, "multidimension": 1, "quadratur": 1, "sampl": 1, "stratifi": 1, "gallah": 1}}, "2551": {"id": "2551", "title": "Mutual Recursion in Algol 60 Using Restricted Compilers", "authors": "Atkins,M. S.", "words_pool": ["algol", "compil", "mutual", "recurs", "restrict", "atkin"], "word_count": {"algol": 1, "compil": 1, "mutual": 1, "recurs": 1, "restrict": 1, "atkin": 1}}, "2552": {"id": "2552", "title": "A Note on When To Chain Overflow Items Within a Direct-Access Table", "authors": "Bays, C.", "words_pool": ["access", "chain", "direct", "item", "note", "overflow", "tabl", "bay"], "word_count": {"access": 1, "chain": 1, "direct": 1, "item": 1, "note": 1, "overflow": 1, "tabl": 1, "bay": 1}}, "2553": {"id": "2553", "title": "The Practical Aspect of Computer Science Education-Discussion", "authors": "Blount, S. E.", "words_pool": ["aspect", "comput", "discuss", "educ", "practic", "scienc", "blount"], "word_count": {"aspect": 1, "comput": 1, "discuss": 1, "educ": 1, "practic": 1, "scienc": 1, "blount": 1}}, "2554": {"id": "2554", "title": "Reduction of a Band-Symmetric Generalized Eigenvalue Problem", "abstract": "An algorithm is described for reducing the generalized eigenvalue problem Ax = lambda Bx to  an ordinary problem, in case A and B are symmetric band matrices with B positive definite.  If n is the  order of the matrix and m the bandwidth, the matrices A and B are partitioned into m-by-m blocks; and  the algorithm is described in terms of these blocks.  The algorithm reduces the generalized problem to  an ordinary eigenvalue problem for a symmetric band matrix C whose bandwidth is the same as A and B.   The algorithm is similar to those of Rutishauser and Schwartz for the reduction of symmetric matrices  to band form.  The calculation C requires order mn^2 operation.  The round-off error in the calculation  of C is of the same order as the sum of the errors at each of the n/m steps of the algorithm, the latter  errors being largely determined by the condition of B with respect to inversion.", "authors": "Crawford, C. R.", "words_pool": ["algorithm", "ax", "band", "bandwidth", "block", "bx", "calcul", "case", "condit", "definit", "determin", "eigenvalu", "error", "error", "form", "gener", "invers", "lambda", "larg", "matric", "matrix", "mn", "oper", "order", "ordinari", "partit", "posit", "problem", "reduc", "reduc", "reduct", "requir", "respect", "round", "rutishaus", "schwartz", "similar", "step", "sum", "symmetr", "term", "crawford"], "word_count": {"algorithm": 5, "ax": 1, "band": 3, "bandwidth": 2, "block": 2, "bx": 1, "calcul": 2, "case": 1, "condit": 1, "definit": 1, "determin": 1, "eigenvalu": 2, "error": 3, "form": 1, "gener": 2, "invers": 1, "lambda": 1, "larg": 1, "matric": 3, "matrix": 2, "mn": 1, "oper": 1, "order": 3, "ordinari": 2, "partit": 1, "posit": 1, "problem": 4, "reduc": 2, "reduct": 1, "requir": 1, "respect": 1, "round": 1, "rutishaus": 1, "schwartz": 1, "similar": 1, "step": 1, "sum": 1, "symmetr": 3, "term": 1, "crawford": 1}}, "2555": {"id": "2555", "title": "Variable-Precision Exponentiation", "abstract": "A previous paper presented an efficient algorithm, called the Recomputation Algorithm, for  evaluating a rational expression to within any desired tolerance on a computer which performs variable-precision  arithmetic operations.  The Recomputation Algorithm can be applied to expressions involving any variable-precision  operations having O(10^(-p) + SUM{|Ei|}) error bounds, where p denotes the operation's precision and  Ei denotes the error in the operation's ith argument.  This paper presents an efficient variable-precision  exponential operation with an error bound of the above order.  Other operations such as log, sin, and  cos, which have simple series expansions, can be handled similarly.", "authors": "Richman, P. L.", "words_pool": ["algorithm", "appli", "argument", "arithmet", "bound", "bound", "call", "comput", "co", "denot", "desir", "effici", "ei", "error", "evalu", "expans", "exponenti", "exponenti", "express", "express", "handl", "involv", "ith", "log", "oper", "oper", "order", "paper", "perform", "precis", "present", "present", "previou", "ration", "recomput", "seri", "similarli", "simpl", "sin", "sum", "toler", "variabl", "richman"], "word_count": {"algorithm": 3, "appli": 1, "argument": 1, "arithmet": 1, "bound": 2, "call": 1, "comput": 1, "co": 1, "denot": 2, "desir": 1, "effici": 2, "ei": 2, "error": 3, "evalu": 1, "expans": 1, "exponenti": 1, "express": 2, "handl": 1, "involv": 1, "ith": 1, "log": 1, "oper": 6, "order": 1, "paper": 2, "perform": 1, "precis": 4, "present": 2, "previou": 1, "ration": 1, "recomput": 2, "seri": 1, "similarli": 1, "simpl": 1, "sin": 1, "sum": 1, "toler": 1, "variabl": 3, "richman": 1}}, "2556": {"id": "2556", "title": "Adaptive Correction of Program Statements", "abstract": "A method of analyzing statements in a programming language which can tolerate a considerable  inaccuracy in their specification is proposed. This method involves principles at present mainly confined  to studies in the area of artificial intelligence such as feature extraction, approximate tree matching,  and strategy improvement by feedback from the matching process.  A pilot program incorporating the principles  is described and preliminary operating results are presented.  A final section surveys further principles  which are currently being investigated.", "authors": "James, E. B. Partridge, D. P.", "words_pool": ["adapt", "analyz", "approxim", "area", "artifici", "confin", "consider", "correct", "extract", "featur", "feedback", "final", "improv", "inaccuraci", "incorpor", "intellig", "investig", "involv", "languag", "mainli", "match", "method", "oper", "pilot", "preliminari", "present", "present", "principl", "process", "program", "program", "propos", "result", "section", "specif", "statement", "strategi", "studi", "survey", "toler", "tree", "jame", "partridg"], "word_count": {"adapt": 1, "analyz": 1, "approxim": 1, "area": 1, "artifici": 1, "confin": 1, "consider": 1, "correct": 1, "extract": 1, "featur": 1, "feedback": 1, "final": 1, "improv": 1, "inaccuraci": 1, "incorpor": 1, "intellig": 1, "investig": 1, "involv": 1, "languag": 1, "mainli": 1, "match": 2, "method": 2, "oper": 1, "pilot": 1, "preliminari": 1, "present": 2, "principl": 3, "process": 1, "program": 2, "propos": 1, "result": 1, "section": 1, "specif": 1, "statement": 1, "strategi": 1, "studi": 1, "survey": 1, "toler": 1, "tree": 1, "jame": 1, "partridg": 1}}, "2557": {"id": "2557", "title": "On the Time Required for a Sequence of Matrix Products", "abstract": "This paper discusses the multiplication of conformable sequences of row vectors, column vectors,  and square matrices.  The minimum time required to evaluate such products on ordinary serial computers  as well as parallel computers is discussed.  Algorithms are presented which properly parse such matrix  sequences subject to the constraints of the machine organization.", "authors": "Muraoka, Y. Kuck, D. J.", "words_pool": ["algorithm", "column", "comput", "conform", "constraint", "discuss", "discuss", "evalu", "machin", "matric", "matrix", "minimum", "multipl", "ordinari", "organ", "paper", "parallel", "pars", "present", "product", "properli", "requir", "row", "sequenc", "sequenc", "serial", "squar", "subject", "time", "vector", "muraoka", "kuck"], "word_count": {"algorithm": 1, "column": 1, "comput": 2, "conform": 1, "constraint": 1, "discuss": 2, "evalu": 1, "machin": 1, "matric": 1, "matrix": 1, "minimum": 1, "multipl": 1, "ordinari": 1, "organ": 1, "paper": 1, "parallel": 1, "pars": 1, "present": 1, "product": 1, "properli": 1, "requir": 1, "row": 1, "sequenc": 2, "serial": 1, "squar": 1, "subject": 1, "time": 1, "vector": 2, "muraoka": 1, "kuck": 1}}, "2558": {"id": "2558", "title": "Protection in Programming Languages", "abstract": "Linguistic mechanisms which can be used to protect one subprogram from another's malfunctioning  are described.  Function-producing functions and various type-tagging schemes are considered.  An attempt  is made to distinguish between access limitation and authentication.", "authors": "Morris, J. H. Jr.", "words_pool": ["access", "attempt", "authent", "consid", "distinguish", "function", "function", "languag", "limit", "linguist", "made", "malfunct", "mechan", "produc", "program", "protect", "protect", "scheme", "subprogram", "tag", "type", "morri", "jr"], "word_count": {"access": 1, "attempt": 1, "authent": 1, "consid": 1, "distinguish": 1, "function": 2, "languag": 1, "limit": 1, "linguist": 1, "made": 1, "malfunct": 1, "mechan": 1, "produc": 1, "program": 1, "protect": 1, "scheme": 1, "subprogram": 1, "tag": 1, "type": 1, "morri": 1, "jr": 1}}, "2559": {"id": "2559", "title": "The Reallocation of Hash-Coded Tables", "abstract": "When the space allocation for a hash-coded table is altered, the table entries must be rescattered  over the new space.  A technique for accomplishing this rescattering is presented.  The technique is  independent of both the length of the table and the hashing function used, and can be utilized in conjunction  with a linear reallocation of the table being rescattered.  Moreover, it can be used to eliminate previously  flagged deletions from any hash-coded table, or to change from one hashing method to another.  The efficiency  of the technique is discussed and theoretical statistics are given.", "authors": "Bays, C.", "words_pool": ["accomplish", "alloc", "alter", "chang", "code", "conjunct", "delet", "discuss", "effici", "elimin", "entri", "flag", "function", "hash", "hash", "independ", "length", "linear", "method", "present", "previous", "realloc", "rescatt", "rescatt", "space", "statist", "tabl", "tabl", "techniqu", "theoret", "util", "bay"], "word_count": {"accomplish": 1, "alloc": 1, "alter": 1, "chang": 1, "code": 2, "conjunct": 1, "delet": 1, "discuss": 1, "effici": 1, "elimin": 1, "entri": 1, "flag": 1, "function": 1, "hash": 4, "independ": 1, "length": 1, "linear": 1, "method": 1, "present": 1, "previous": 1, "realloc": 1, "rescatt": 3, "space": 2, "statist": 1, "tabl": 5, "techniqu": 3, "theoret": 1, "util": 1, "bay": 1}}, "2560": {"id": "2560", "title": "A Queuing Model of a Multiprogrammed Computer with a Two-Level Storage System", "abstract": "The results are presented of an analysis of a probabilistic model of a multiprogrammed computer  system with a two-level storage system in which there is sequential dependency of accesses between the  devices.  Expressions are obtained for the long-run probability that both the CPU and each of the storage  devices are busy.  Some numerical results are given which quantify the gains in CPU utilization obtainable  by multiprogramming in the presence of this type of storage system.", "authors": "Shedler, G. S.", "words_pool": ["access", "analysi", "busi", "comput", "cpu", "depend", "devic", "express", "gain", "level", "long", "model", "multiprogram", "multiprogram", "numer", "obtain", "obtain", "presenc", "present", "probabilist", "probabl", "quantifi", "queu", "result", "run", "sequenti", "storag", "system", "type", "util", "shedler"], "word_count": {"access": 1, "analysi": 1, "busi": 1, "comput": 1, "cpu": 2, "depend": 1, "devic": 2, "express": 1, "gain": 1, "level": 1, "long": 1, "model": 1, "multiprogram": 2, "numer": 1, "obtain": 2, "presenc": 1, "present": 1, "probabilist": 1, "probabl": 1, "quantifi": 1, "queu": 1, "result": 2, "run": 1, "sequenti": 1, "storag": 3, "system": 3, "type": 1, "util": 1, "shedler": 1}}, "2561": {"id": "2561", "title": "A Heuristic Approach to Inductive Inference in Fact Retrieval Systems", "abstract": "Heuristic procedures are presented which have been developed to perform inferences by generalizing  from available information.  The procedures make use of a similarity structure which is imposed on the  data base using nonnumerical clustering algorithms.  They are implemented in a model fact retrieval system  which uses a formal query language and a property-list data structure.  A program of experiments is described  wherein the procedures are used with test data bases which are altered by deleting part of the data and  by purposely introducing false data.  It is found that the system can infer the correct response under  a variety of conditions involving incomplete and inconsistent data.", "authors": "Skinner, C. W.", "words_pool": ["algorithm", "alter", "approach", "base", "base", "cluster", "condit", "correct", "data", "delet", "develop", "experi", "fact", "fals", "formal", "found", "gener", "heurist", "implement", "impos", "incomplet", "inconsist", "induct", "infer", "infer", "infer", "inform", "introduc", "involv", "languag", "list", "make", "model", "nonnumer", "part", "perform", "present", "procedur", "program", "properti", "purpos", "queri", "respons", "retriev", "similar", "structur", "system", "system", "test", "varieti", "skinner"], "word_count": {"algorithm": 1, "alter": 1, "approach": 1, "base": 2, "cluster": 1, "condit": 1, "correct": 1, "data": 6, "delet": 1, "develop": 1, "experi": 1, "fact": 1, "fals": 1, "formal": 1, "found": 1, "gener": 1, "heurist": 1, "implement": 1, "impos": 1, "incomplet": 1, "inconsist": 1, "induct": 1, "infer": 2, "inform": 1, "introduc": 1, "involv": 1, "languag": 1, "list": 1, "make": 1, "model": 1, "nonnumer": 1, "part": 1, "perform": 1, "present": 1, "procedur": 3, "program": 1, "properti": 1, "purpos": 1, "queri": 1, "respons": 1, "retriev": 1, "similar": 1, "structur": 2, "system": 2, "test": 1, "varieti": 1, "skinner": 1}}, "2562": {"id": "2562", "title": "Routing Problem (Algorithm R456)", "authors": "Tesch, G.", "words_pool": ["algorithm", "problem", "r456", "rout", "tesch"], "word_count": {"algorithm": 1, "problem": 1, "r456": 1, "rout": 1, "tesch": 1}}, "2563": {"id": "2563", "title": "Merge Sort Algorithm (R426)", "authors": "Bron, C.", "words_pool": ["algorithm", "merg", "r426", "sort", "bron"], "word_count": {"algorithm": 1, "merg": 1, "r426": 1, "sort": 1, "bron": 1}}, "2564": {"id": "2564", "title": "Hidden-Line Plotting Program (Algorithm R420)", "authors": "Ellis, T. M. R.", "words_pool": ["algorithm", "hidden", "line", "plot", "program", "r420", "elli"], "word_count": {"algorithm": 1, "hidden": 1, "line": 1, "plot": 1, "program": 1, "r420": 1, "elli": 1}}, "2565": {"id": "2565", "title": "A Gaussian Pseudo-Random Number Generator (Algorithm 488)", "authors": "Brent, R. P.", "words_pool": ["algorithm", "gaussian", "gener", "number", "pseudo", "random", "brent"], "word_count": {"algorithm": 1, "gaussian": 1, "gener": 1, "number": 1, "pseudo": 1, "random": 1, "brent": 1}}, "2566": {"id": "2566", "title": "Exact Cumulative Distribution of the Kolmogorov-Smirnov Statistic for Small Samples (Algorithm  A487)", "authors": "Pomeranz, J.", "words_pool": ["a487", "algorithm", "cumul", "distribut", "exact", "kolmogorov", "sampl", "small", "smirnov", "statist", "pomeranz"], "word_count": {"a487": 1, "algorithm": 1, "cumul": 1, "distribut": 1, "exact": 1, "kolmogorov": 1, "sampl": 1, "small": 1, "smirnov": 1, "statist": 1, "pomeranz": 1}}, "2567": {"id": "2567", "title": "An Exponential Method for the Solution of Systems of Ordinary Differential Equations", "abstract": "An explicit, coupled, single-step method for the numerical solution of initial value problems  for systems of ordinary differential equations is presented.  The method was designed to be general purpose  in nature but to be especially efficient when dealing with stiff systems of differential equations.   It is, in general, second order except for the case of a linear system with constant coefficients and  linear forcing terms; in that case, the method is third order.  It has been implemented and put to routine  usage in biological applications-where stiffness frequently appears-with favorable results.  When compared  to a standard fourth order Runge-Kutta implementation, computation time required by this method has ranged  from comparable for certain nonstiff problems to better than two orders of magnitude faster for some  highly stiff systems.", "authors": "Chu, S. C. Berman, M.", "words_pool": ["appear", "applic", "biolog", "case", "coeffici", "compar", "compar", "comput", "constant", "coupl", "deal", "design", "differenti", "effici", "equat", "especi", "explicit", "exponenti", "faster", "favor", "forc", "fourth", "frequent", "gener", "highli", "implement", "implement", "initi", "kutta", "linear", "magnitud", "method", "natur", "nonstiff", "numer", "order", "order", "ordinari", "present", "problem", "purpos", "put", "rang", "requir", "result", "routin", "rung", "singl", "solut", "standard", "step", "stiff", "stiff", "system", "system", "term", "time", "usag", "chu", "berman"], "word_count": {"appear": 1, "applic": 1, "biolog": 1, "case": 2, "coeffici": 1, "compar": 2, "comput": 1, "constant": 1, "coupl": 1, "deal": 1, "design": 1, "differenti": 2, "effici": 1, "equat": 2, "especi": 1, "explicit": 1, "exponenti": 1, "faster": 1, "favor": 1, "forc": 1, "fourth": 1, "frequent": 1, "gener": 2, "highli": 1, "implement": 2, "initi": 1, "kutta": 1, "linear": 2, "magnitud": 1, "method": 4, "natur": 1, "nonstiff": 1, "numer": 1, "order": 4, "ordinari": 1, "present": 1, "problem": 2, "purpos": 1, "put": 1, "rang": 1, "requir": 1, "result": 1, "routin": 1, "rung": 1, "singl": 1, "solut": 1, "standard": 1, "step": 1, "stiff": 3, "system": 4, "term": 1, "time": 1, "usag": 1, "chu": 1, "berman": 1}}, "2568": {"id": "2568", "title": "A Graph Formulation of a School Scheduling Algorithm", "abstract": "The problem classically titled \"The Examination Schedule Problem\" takes various forms in the  literature.  Most of these formulations can be presented in the terminology of classical Network Theory.   One such formulation is:  Given a nondirected network, partition its nodes into a minimal number of  subsets such that no two members of the same subset are connected by anarc.  An obvious lower limit  to this number is the size of the largest strongly connected subgraph.  Kirchgassner proved that an upper  limit is this size plus one.  One logical extension of the previous work is the introduction of variable  length examinations where W(I) is the number of periods for exam I.  The object of this paper is to generalize  the definition of largest strongly connected subgraph to include the weighting of nodes, to present an  approximate algorithm which usually finds the largest strongly connected subgraph, and to discuss the  application of this algorithm to the solution of school scheduling and exam scheduling problems.", "authors": "Salazar, A. Oakford, R. V.", "words_pool": ["algorithm", "anarc", "applic", "approxim", "classic", "classic", "connect", "definit", "discuss", "exam", "examin", "examin", "extens", "find", "form", "formul", "formul", "gener", "graph", "includ", "introduct", "kirchgassn", "largest", "length", "limit", "literatur", "logic", "lower", "member", "minim", "network", "node", "nondirect", "number", "object", "obviou", "paper", "partit", "period", "present", "present", "previou", "problem", "problem", "prove", "schedul", "schedul", "school", "size", "solut", "strongli", "subgraph", "subset", "subset", "take", "terminolog", "theori", "titl", "upper", "variabl", "weight", "work", "salazar", "oakford"], "word_count": {"algorithm": 2, "anarc": 1, "applic": 1, "approxim": 1, "classic": 2, "connect": 4, "definit": 1, "discuss": 1, "exam": 2, "examin": 2, "extens": 1, "find": 1, "form": 1, "formul": 2, "gener": 1, "graph": 1, "includ": 1, "introduct": 1, "kirchgassn": 1, "largest": 3, "length": 1, "limit": 2, "literatur": 1, "logic": 1, "lower": 1, "member": 1, "minim": 1, "network": 2, "node": 2, "nondirect": 1, "number": 3, "object": 1, "obviou": 1, "paper": 1, "partit": 1, "period": 1, "present": 2, "previou": 1, "problem": 3, "prove": 1, "schedul": 3, "school": 1, "size": 2, "solut": 1, "strongli": 3, "subgraph": 3, "subset": 2, "take": 1, "terminolog": 1, "theori": 1, "titl": 1, "upper": 1, "variabl": 1, "weight": 1, "work": 1, "salazar": 1, "oakford": 1}}, "2569": {"id": "2569", "title": "Computer Generation of Gamma Random Variates with Non-integral Shape Parameters", "abstract": "When the shape parameter, a, is integral, generating gamma random variables with a digital  computer is straightforward.  There is no simple method for generating gamma random variates with non-integral  shape parameters.  A common procedure is to approximately generate such random variables by use of the  so-called probability switch method.  Another procedure, which is exact, is due to Johnk.  This paper  presents a rejection method for exactly generating gamma random variables when a is greater than 1.   The efficiency of the rejection method is shown to be better than the efficiency of Johnk's method.   The paper concludes that when a is non-integral the following mix of procedures yields the best combination  of accuracy and efficiency: (1) when a is less than 1, use Johnk's method; (2) when 1 is less than a  and a is less than 5, use the rejection method; (3) when a is greater than 5, use the probability switch  method.", "authors": "Wallace, N. D.", "words_pool": ["accuraci", "approxim", "call", "combin", "common", "comput", "conclud", "digit", "due", "effici", "exact", "exactli", "gamma", "gener", "gener", "gener", "greater", "integr", "johnk", "method", "mix", "non", "paper", "paramet", "paramet", "present", "probabl", "procedur", "procedur", "random", "reject", "shape", "shown", "simpl", "straightforward", "switch", "variabl", "variat", "yield", "wallac"], "word_count": {"accuraci": 1, "approxim": 1, "call": 1, "combin": 1, "common": 1, "comput": 1, "conclud": 1, "digit": 1, "due": 1, "effici": 3, "exact": 1, "exactli": 1, "gamma": 3, "gener": 4, "greater": 2, "integr": 3, "johnk": 3, "method": 8, "mix": 1, "non": 2, "paper": 2, "paramet": 2, "present": 1, "probabl": 2, "procedur": 3, "random": 4, "reject": 3, "shape": 2, "shown": 1, "simpl": 1, "straightforward": 1, "switch": 2, "variabl": 3, "variat": 1, "yield": 1, "wallac": 1}}, "2570": {"id": "2570", "title": "A Comparison of List Schedules for Parallel Processing Systems", "abstract": "The problem of scheduling two or more processors to minimize the execution time of a program  which consists of a set of partially ordered tasks is studied.  Cases where task execution times are  deterministic and others in which execution times are random variables are analyzed.  It is shown that  different algorithms suggested in the literature vary significantly in execution time and that the B-schedule  of Coffman and Graham is near-optimal.  A dynamic programming solution for the case in which execution  times are random variables is presented.", "authors": "Adam, T. L. Chandy, K. M. Dickson, J. R.", "words_pool": ["algorithm", "analyz", "case", "case", "coffman", "comparison", "consist", "determinist", "dynam", "execut", "graham", "list", "literatur", "minim", "optim", "order", "parallel", "partial", "present", "problem", "process", "processor", "program", "program", "random", "schedul", "schedul", "schedul", "set", "shown", "significantli", "solut", "studi", "suggest", "system", "task", "task", "time", "time", "variabl", "vari", "adam", "chandi", "dickson"], "word_count": {"algorithm": 1, "analyz": 1, "case": 2, "coffman": 1, "comparison": 1, "consist": 1, "determinist": 1, "dynam": 1, "execut": 5, "graham": 1, "list": 1, "literatur": 1, "minim": 1, "optim": 1, "order": 1, "parallel": 1, "partial": 1, "present": 1, "problem": 1, "process": 1, "processor": 1, "program": 2, "random": 2, "schedul": 2, "set": 1, "shown": 1, "significantli": 1, "solut": 1, "studi": 1, "suggest": 1, "system": 1, "task": 2, "time": 5, "variabl": 2, "vari": 1, "adam": 1, "chandi": 1, "dickson": 1}}, "2571": {"id": "2571", "title": "An Analytic Model of the Hasp Execution Task Monitor", "abstract": "The HASP Execution Task Monitor periodically rearranges the OS/360 dispatching chain to give  tasks preemptive execution priority in inverse order to that of their cpu utilization history.  The effect  is to keep the I/O bound tasks active and to prevent cpu bound tasks from locking out other tasks.  This  paper develops a simple model of the Execution Task Monitor and employs it to study the effectiveness  of the monitor in improving system performance.  A modified strategy monitor control is investigated  for the case of task execution in a memory hierarchy of varying speeds.", "authors": "Strauss, J. C.", "words_pool": ["activ", "analyt", "bound", "case", "chain", "control", "cpu", "develop", "dispatch", "effect", "effect", "employ", "execut", "give", "hasp", "hierarchi", "histori", "improv", "invers", "investig", "lock", "memori", "model", "modifi", "monitor", "order", "os", "paper", "perform", "period", "preemptiv", "prevent", "prioriti", "rearrang", "simpl", "speed", "strategi", "studi", "system", "task", "task", "util", "vari", "strauss"], "word_count": {"activ": 1, "analyt": 1, "bound": 2, "case": 1, "chain": 1, "control": 1, "cpu": 2, "develop": 1, "dispatch": 1, "effect": 2, "employ": 1, "execut": 4, "give": 1, "hasp": 1, "hierarchi": 1, "histori": 1, "improv": 1, "invers": 1, "investig": 1, "lock": 1, "memori": 1, "model": 1, "modifi": 1, "monitor": 4, "order": 1, "os": 1, "paper": 1, "perform": 1, "period": 1, "preemptiv": 1, "prevent": 1, "prioriti": 1, "rearrang": 1, "simpl": 1, "speed": 1, "strategi": 1, "studi": 1, "system": 1, "task": 7, "util": 1, "vari": 1, "strauss": 1}}, "2572": {"id": "2572", "title": "Arguments for a Moratorium on the Construction of a Community Information Utility", "abstract": "In this article the author urges a prudent and decentralized approach to the question of the  design and desirability of computerized community information utilities.  Before accepting the inevitability  and desirability of this or any technology, we should: (1) be sure of the feasibility (internally and  externally) of what is proposed; (2) project and perhaps wait for changes in complementary techniques;  (3) evaluate current and projected supplementary techniques; (4) establish the existence of demand for  what is proposed; (5) take steps to involve a representative group of ultimate users in systems design,  and (6) carefully think through possible side effects on man and his world view.  Current proposals for  community information utilities are examined in this framework, and the conclusion is drawn that society  is not yet in a position to justify either the construction of an information utility in a prototype  community or the acceptance of a policy in favor of its widespread implementation.", "authors": "Press, L. I.", "words_pool": ["accept", "accept", "approach", "argument", "articl", "author", "care", "commun", "complementari", "computer", "conclus", "construct", "decentr", "demand", "design", "desir", "drawn", "effect", "establish", "evalu", "examin", "exist", "extern", "favor", "feasibl", "framework", "group", "implement", "inevit", "inform", "intern", "involv", "justifi", "man", "moratorium", "polici", "posit", "project", "project", "propos", "propos", "prototyp", "prudent", "question", "repres", "side", "societi", "step", "supplementari", "sure", "system", "take", "techniqu", "technolog", "think", "ultim", "urg", "user", "util", "util", "view", "wait", "widespread", "world", "press"], "word_count": {"accept": 2, "approach": 1, "argument": 1, "articl": 1, "author": 1, "care": 1, "commun": 3, "complementari": 1, "computer": 1, "conclus": 1, "construct": 1, "decentr": 1, "demand": 1, "design": 2, "desir": 2, "drawn": 1, "effect": 1, "establish": 1, "evalu": 1, "examin": 1, "exist": 1, "extern": 1, "favor": 1, "feasibl": 1, "framework": 1, "group": 1, "implement": 1, "inevit": 1, "inform": 3, "intern": 1, "involv": 1, "justifi": 1, "man": 1, "moratorium": 1, "polici": 1, "posit": 1, "project": 2, "propos": 3, "prototyp": 1, "prudent": 1, "question": 1, "repres": 1, "side": 1, "societi": 1, "step": 1, "supplementari": 1, "sure": 1, "system": 1, "take": 1, "techniqu": 2, "technolog": 1, "think": 1, "ultim": 1, "urg": 1, "user": 1, "util": 3, "view": 1, "wait": 1, "widespread": 1, "world": 1, "press": 1}}, "2573": {"id": "2573", "title": "Computer Programming as an Art", "authors": "Knuth, D. E.", "words_pool": ["art", "comput", "program", "knuth"], "word_count": {"art": 1, "comput": 1, "program": 1, "knuth": 1}}, "2574": {"id": "2574", "title": "Multiple Exists from a Loop Using Neither GO TO nor Labels", "authors": "Evans, R. V.", "words_pool": ["exist", "label", "loop", "multipl", "evan"], "word_count": {"exist": 1, "label": 1, "loop": 1, "multipl": 1, "evan": 1}}, "2575": {"id": "2575", "title": "The Best-Match Problem in Document Retrieval", "authors": "Van Rijsbergen, C. J.", "words_pool": ["document", "match", "problem", "retriev", "van", "rijsbergen"], "word_count": {"document": 1, "match": 1, "problem": 1, "retriev": 1, "van": 1, "rijsbergen": 1}}, "2576": {"id": "2576", "title": "A Simple Technique for Representing Strings in Fortran IV", "authors": "Hanson, D. R.", "words_pool": ["fortran", "iv", "repres", "simpl", "string", "techniqu", "hanson"], "word_count": {"fortran": 1, "iv": 1, "repres": 1, "simpl": 1, "string": 1, "techniqu": 1, "hanson": 1}}, "2577": {"id": "2577", "title": "An On-Site Data Management System Application in Field Archaeology", "authors": "Brown, J. A. Werner, B.", "words_pool": ["applic", "archaeolog", "data", "field", "manag", "site", "system", "brown", "werner"], "word_count": {"applic": 1, "archaeolog": 1, "data": 1, "field": 1, "manag": 1, "site": 1, "system": 1, "brown": 1, "werner": 1}}, "2578": {"id": "2578", "title": "Self-stabilizing Systems in Spite of Distributed Control", "authors": "Dijkstra, E. W.", "words_pool": ["control", "distribut", "spite", "stabil", "system", "dijkstra"], "word_count": {"control": 1, "distribut": 1, "spite": 1, "stabil": 1, "system": 1, "dijkstra": 1}}, "2579": {"id": "2579", "title": "Register Allocation Via Usage Counts", "abstract": "This paper introduces the notion of usage counts, shows how usage counts can be developed by  algorithms that eliminate redundant computations, and describes how usage counts can provide the basis  for register allocation.  The paper compares register allocation based on usage counts to other commonly  used register allocation techniques, and presents evidence which shows that the usage count technique  is significantly better than these other techniques.", "authors": "Freiburghouse, R. A.", "words_pool": ["algorithm", "alloc", "base", "basi", "commonli", "compar", "comput", "count", "count", "describ", "develop", "elimin", "evid", "introduc", "notion", "paper", "present", "provid", "redund", "regist", "show", "significantli", "techniqu", "techniqu", "usag", "freiburghous"], "word_count": {"algorithm": 1, "alloc": 3, "base": 1, "basi": 1, "commonli": 1, "compar": 1, "comput": 1, "count": 5, "describ": 1, "develop": 1, "elimin": 1, "evid": 1, "introduc": 1, "notion": 1, "paper": 2, "present": 1, "provid": 1, "redund": 1, "regist": 3, "show": 2, "significantli": 1, "techniqu": 3, "usag": 5, "freiburghous": 1}}, "2580": {"id": "2580", "title": "A Method for Composing Simple Traditional Music by Computer", "abstract": "A method is described for composing musical rounds by computer.  This method uses some music  theory plus additional heuristics.  Fundamental to the method is a set of productions together with sets  of applicability rules and weight rules which operate on the productions deciding when and to what extent  they are available for use.  Several rounds generated by the computer implementation of the method are  presented.  Generally, the resultant music sounds mediocre to the professional although usually pleasing  to the layman.  It appears that full-blown music theory is not needed for rounds--all the hardware required  for structural levels is not necessary for these pieces.  The author has tried to address both musicians  and computer scientists.", "authors": "Rader, G. M.", "words_pool": ["addit", "address", "appear", "applic", "author", "blown", "compos", "comput", "decid", "extent", "full", "fundament", "gener", "gener", "hardwar", "heurist", "implement", "layman", "level", "mediocr", "method", "music", "music", "musician", "need", "oper", "piec", "pleas", "present", "product", "profession", "requir", "result", "round", "rule", "scientist", "set", "set", "simpl", "sound", "structur", "theori", "tradit", "tri", "weight", "rader"], "word_count": {"addit": 1, "address": 1, "appear": 1, "applic": 1, "author": 1, "blown": 1, "compos": 1, "comput": 3, "decid": 1, "extent": 1, "full": 1, "fundament": 1, "gener": 2, "hardwar": 1, "heurist": 1, "implement": 1, "layman": 1, "level": 1, "mediocr": 1, "method": 4, "music": 4, "musician": 1, "need": 1, "oper": 1, "piec": 1, "pleas": 1, "present": 1, "product": 2, "profession": 1, "requir": 1, "result": 1, "round": 3, "rule": 2, "scientist": 1, "set": 2, "simpl": 1, "sound": 1, "structur": 1, "theori": 2, "tradit": 1, "tri": 1, "weight": 1, "rader": 1}}, "2581": {"id": "2581", "title": "A Locally-Organized Parser for Spoken Input", "abstract": "This paper describes LPARS, a locally-organized parsing system, designed for use in a continuous  speech recognizer.  LPARS processes a string of phonemes which contains ambiguity and error. The system  is locally-organized in the sense that it builds local parse structures from reliable word candidates  recognized anywhere in an input utterance.  These local structures are used as \"islands of reliability\"  to guide the search for more highly garbled words which might complete the utterance.", "authors": "Miller, P. L.", "words_pool": ["ambigu", "build", "candid", "complet", "continu", "describ", "design", "error", "garbl", "guid", "highli", "input", "island", "local", "local", "lpar", "organ", "paper", "pars", "parser", "pars", "phonem", "process", "recogn", "recogn", "reliabl", "reliabl", "search", "sens", "speech", "spoken", "string", "structur", "system", "utter", "word", "word", "miller"], "word_count": {"ambigu": 1, "build": 1, "candid": 1, "complet": 1, "continu": 1, "describ": 1, "design": 1, "error": 1, "garbl": 1, "guid": 1, "highli": 1, "input": 1, "island": 1, "local": 4, "lpar": 2, "organ": 2, "paper": 1, "pars": 2, "parser": 1, "phonem": 1, "process": 1, "recogn": 2, "reliabl": 2, "search": 1, "sens": 1, "speech": 1, "spoken": 1, "string": 1, "structur": 2, "system": 2, "utter": 2, "word": 2, "miller": 1}}, "2582": {"id": "2582", "title": "Improving Locality by Critical Working Sets", "abstract": "A new approach to program locality improvement via restructuring is described.  The method  is particularly suited to those systems where primary memory is managed according to a working set strategy.   It is based on the concept of critical working set, a working set which does not contain the next memory  reference.  The data the method operates upon are extracted from a trace of the program to be restructured.   It is shown that, except in some special cases, the method is not optimum.  However, the experimental  results obtained by using the method to restructure an interactive text editor and the file system module  of an operating system have shown its substantial superiority over the other methods proposed in the  literature.", "authors": "Ferrari, D.", "words_pool": ["accord", "approach", "base", "case", "concept", "critic", "data", "editor", "experiment", "extract", "improv", "improv", "interact", "literatur", "local", "manag", "memori", "method", "method", "modul", "obtain", "oper", "oper", "optimum", "primari", "program", "propos", "refer", "restructur", "restructur", "restructur", "result", "set", "set", "shown", "special", "strategi", "substanti", "suit", "superior", "system", "system", "text", "trace", "work", "ferrari"], "word_count": {"accord": 1, "approach": 1, "base": 1, "case": 1, "concept": 1, "critic": 1, "data": 1, "editor": 1, "experiment": 1, "extract": 1, "improv": 1, "interact": 1, "literatur": 1, "local": 1, "manag": 1, "memori": 2, "method": 5, "modul": 1, "obtain": 1, "oper": 2, "optimum": 1, "primari": 1, "program": 2, "propos": 1, "refer": 1, "restructur": 3, "result": 1, "set": 3, "shown": 2, "special": 1, "strategi": 1, "substanti": 1, "suit": 1, "superior": 1, "system": 3, "text": 1, "trace": 1, "work": 3, "ferrari": 1}}, "2583": {"id": "2583", "title": "Guidelines for Humanizing Computerized Information Systems: A Report from Stanley House", "authors": "Sterling, T. D.", "words_pool": ["computer", "guidelin", "hous", "human", "inform", "report", "stanley", "system", "sterl"], "word_count": {"computer": 1, "guidelin": 1, "hous": 1, "human": 1, "inform": 1, "report": 1, "stanley": 1, "system": 1, "sterl": 1}}, "2584": {"id": "2584", "title": "Enumerating Full-Time Programmers", "abstract": "Data from the 1970 Census and the Department of Labor's Area Wage Surveys are used to derive  estimates of the number of full-time programmers employed during the years 1969 through 1973.  The 1973  figure of 180,000 is considerably less than suggested in earlier reports.  It is recommended that educational  administrators consider whether the many courses aimed at training programmers are justified on a vocational  basis.", "authors": "Gilchrist, B. Weber, R. E.", "words_pool": ["administr", "aim", "area", "basi", "censu", "consid", "consider", "cours", "data", "depart", "deriv", "earlier", "educ", "employ", "enumer", "estim", "figur", "full", "justifi", "labor", "number", "programm", "recommend", "report", "suggest", "survey", "time", "train", "vocat", "wage", "year", "gilchrist", "weber"], "word_count": {"administr": 1, "aim": 1, "area": 1, "basi": 1, "censu": 1, "consid": 1, "consider": 1, "cours": 1, "data": 1, "depart": 1, "deriv": 1, "earlier": 1, "educ": 1, "employ": 1, "enumer": 1, "estim": 1, "figur": 1, "full": 1, "justifi": 1, "labor": 1, "number": 1, "programm": 2, "recommend": 1, "report": 1, "suggest": 1, "survey": 1, "time": 1, "train": 1, "vocat": 1, "wage": 1, "year": 1, "gilchrist": 1, "weber": 1}}, "2585": {"id": "2585", "title": "Efficient Implementation of a Variable Projection Algorithm for Nonlinear Least Squares Problems  (Errata)", "authors": "Krogh, F. T.", "words_pool": ["algorithm", "effici", "errata", "implement", "nonlinear", "problem", "project", "squar", "variabl", "krogh"], "word_count": {"algorithm": 1, "effici": 1, "errata": 1, "implement": 1, "nonlinear": 1, "problem": 1, "project": 1, "squar": 1, "variabl": 1, "krogh": 1}}, "2586": {"id": "2586", "title": "Adapting Optimal Code Generation for Arithmetic Expressions to the Instruction Sets Available  on Present-Day Computers (Errata)", "authors": "Stockhausen, P. F.", "words_pool": ["adapt", "arithmet", "code", "comput", "day", "errata", "express", "gener", "instruct", "optim", "present", "set", "stockhausen"], "word_count": {"adapt": 1, "arithmet": 1, "code": 1, "comput": 1, "day": 1, "errata": 1, "express": 1, "gener": 1, "instruct": 1, "optim": 1, "present": 1, "set": 1, "stockhausen": 1}}, "2587": {"id": "2587", "title": "On the Construction of a Representative Synthetic Workload (Errata)", "authors": "Sreenivarsan, K. Kleinman, A. J.", "words_pool": ["construct", "errata", "repres", "synthet", "workload", "sreenivarsan", "kleinman"], "word_count": {"construct": 1, "errata": 1, "repres": 1, "synthet": 1, "workload": 1, "sreenivarsan": 1, "kleinman": 1}}, "2588": {"id": "2588", "title": "Rosenbrock Function Minimization (Algorithm R450)", "authors": "Klemes, J. Klemsa, J.", "words_pool": ["algorithm", "function", "minim", "r450", "rosenbrock", "kleme", "klemsa"], "word_count": {"algorithm": 1, "function": 1, "minim": 1, "r450": 1, "rosenbrock": 1, "kleme": 1, "klemsa": 1}}, "2589": {"id": "2589", "title": "A Computer Routine for Quadratic and Linear Programming Problems (Algorithm R431)", "authors": "Proll, L. G.", "words_pool": ["algorithm", "comput", "linear", "problem", "program", "quadrat", "r431", "routin", "proll"], "word_count": {"algorithm": 1, "comput": 1, "linear": 1, "problem": 1, "program": 1, "quadrat": 1, "r431": 1, "routin": 1, "proll": 1}}, "2590": {"id": "2590", "title": "Hypergeometric (Algorithm C191)", "authors": "Kopelaar, H.", "words_pool": ["algorithm", "c191", "hypergeometr", "kopelaar"], "word_count": {"algorithm": 1, "c191": 1, "hypergeometr": 1, "kopelaar": 1}}, "2591": {"id": "2591", "title": "Numerical Inversion of Laplace Transform (Algorithm A486)", "authors": "Veillon, F.", "words_pool": ["a486", "algorithm", "invers", "laplac", "numer", "transform", "veillon"], "word_count": {"a486": 1, "algorithm": 1, "invers": 1, "laplac": 1, "numer": 1, "transform": 1, "veillon": 1}}, "2592": {"id": "2592", "title": "On Generation of Test Problems for Linear Programming Codes", "abstract": "Users of linear programming computer codes have realized the necessity of evaluating the capacity,  effectiveness, and accuracy of the solutions provided by such codes.  Large scale linear programming  codes at most installations are assumed to be generating correct solutions without ever having been \"bench-marked\"  by test problems with known solutions.  The reason for this failure to adequately test the codes is that  rarely are there large problems with known solutions readily available.  This paper presents a theoretical  justification and an illustrative implementation of a method for generating linear programming test problems  with known solutions.  The method permits the generation of test problems that are of arbitrary size  and have a wide range of numerical characteristics.", "authors": "Charnes, A. Raike, W. M. Stutz, J. D. Walters, A. S.", "words_pool": ["accuraci", "adequ", "arbitrari", "assum", "bench", "capac", "characterist", "code", "comput", "correct", "effect", "evalu", "failur", "gener", "gener", "illustr", "implement", "instal", "justif", "known", "larg", "linear", "mark", "method", "necess", "numer", "paper", "permit", "present", "problem", "program", "provid", "rang", "rare", "readili", "realiz", "reason", "scale", "size", "solut", "test", "theoret", "user", "wide", "charn", "raik", "stutz", "walter"], "word_count": {"accuraci": 1, "adequ": 1, "arbitrari": 1, "assum": 1, "bench": 1, "capac": 1, "characterist": 1, "code": 4, "comput": 1, "correct": 1, "effect": 1, "evalu": 1, "failur": 1, "gener": 3, "illustr": 1, "implement": 1, "instal": 1, "justif": 1, "known": 3, "larg": 2, "linear": 3, "mark": 1, "method": 2, "necess": 1, "numer": 1, "paper": 1, "permit": 1, "present": 1, "problem": 4, "program": 3, "provid": 1, "rang": 1, "rare": 1, "readili": 1, "realiz": 1, "reason": 1, "scale": 1, "size": 1, "solut": 5, "test": 4, "theoret": 1, "user": 1, "wide": 1, "charn": 1, "raik": 1, "stutz": 1, "walter": 1}}, "2593": {"id": "2593", "title": "A Back-end Computer for Data Base Management", "abstract": "It is proposed that the data base management function be placed on a dedicated back-end computer  which accepts commands (in a relatively high level language such as the CODASYL Data Base Task Group,  April 1971 Report) from a host computer, accesses the data base on secondary storage, and returns results.   The advantages of such a configuration are discussed.  An experimental implementation, called the experimental  Data Management System, XDMS, is described and certain conclusions about the back-end approach are drawn  from this implementation.", "authors": "Canaday, R. H. Harrison, R. D. Ivie, E. L. Ryder, J. L. Wehr, L. A.", "words_pool": ["accept", "access", "advantag", "approach", "april", "back", "base", "call", "codasyl", "command", "comput", "conclus", "configur", "data", "dedic", "discuss", "drawn", "end", "experiment", "function", "group", "high", "host", "implement", "languag", "level", "manag", "propos", "report", "result", "secondari", "storag", "system", "task", "xdm", "canaday", "harrison", "ivi", "ryder", "wehr"], "word_count": {"accept": 1, "access": 1, "advantag": 1, "approach": 1, "april": 1, "back": 2, "base": 3, "call": 1, "codasyl": 1, "command": 1, "comput": 2, "conclus": 1, "configur": 1, "data": 4, "dedic": 1, "discuss": 1, "drawn": 1, "end": 2, "experiment": 2, "function": 1, "group": 1, "high": 1, "host": 1, "implement": 2, "languag": 1, "level": 1, "manag": 2, "propos": 1, "report": 1, "result": 1, "secondari": 1, "storag": 1, "system": 1, "task": 1, "xdm": 1, "canaday": 1, "harrison": 1, "ivi": 1, "ryder": 1, "wehr": 1}}, "2594": {"id": "2594", "title": "Structured Data Structures", "abstract": "Programming systems which permit arbitrary linked list structures enable the user to create  complicated structures without sufficient protection.  Deletions can result in unreachable data elements,  and there is no guarantee that additions will be performed properly.  To remedy this situation, this  paper proposes a gauge which provides for the creation of a restricted class of data structures but ensures  the correctness of the program.  This is accomplished by an explicit structure declaration facility,  a restriction on the permissible operations, and execution-time checks.", "authors": "Shneiderman, B. Scheuermann, P.", "words_pool": ["accomplish", "addit", "arbitrari", "check", "class", "complic", "correct", "creat", "creation", "data", "declar", "delet", "element", "enabl", "ensur", "execut", "explicit", "facil", "gaug", "guarante", "link", "list", "oper", "paper", "perform", "permiss", "permit", "program", "program", "properli", "propos", "protect", "remedi", "restrict", "restrict", "result", "situat", "structur", "structur", "structur", "suffici", "system", "time", "unreach", "user", "shneiderman", "scheuermann"], "word_count": {"accomplish": 1, "addit": 1, "arbitrari": 1, "check": 1, "class": 1, "complic": 1, "correct": 1, "creat": 1, "creation": 1, "data": 2, "declar": 1, "delet": 1, "element": 1, "enabl": 1, "ensur": 1, "execut": 1, "explicit": 1, "facil": 1, "gaug": 1, "guarante": 1, "link": 1, "list": 1, "oper": 1, "paper": 1, "perform": 1, "permiss": 1, "permit": 1, "program": 2, "properli": 1, "propos": 1, "protect": 1, "remedi": 1, "restrict": 2, "result": 1, "situat": 1, "structur": 4, "suffici": 1, "system": 1, "time": 1, "unreach": 1, "user": 1, "shneiderman": 1, "scheuermann": 1}}, "2595": {"id": "2595", "title": "A Note on the Calculation Working Set Size", "abstract": "Finite-length reference string of arbitrary structure are considered, and an exact expression  for average working set size in terms of \"corrected\" interreference interval statistics is derived.   An example is discussed; upper and lower bounds are obtained; and the average working set size function  is shown to be efficiently obtained for a set of page sizes, in a single pass of the reference string.   This work follows the developments of a paper by Denning and Schwartz, who consider infinite-length  reference strings which satisfy certain statistical properties and who derive an expression relating  the asymptotic average working set size to the asymptotic missing page rate function under working set  replacement.", "authors": "Slutz, D. R. Traiger, I. L.", "words_pool": ["arbitrari", "asymptot", "averag", "bound", "calcul", "consid", "consid", "correct", "den", "deriv", "deriv", "develop", "discuss", "effici", "exact", "express", "finit", "follow", "function", "infinit", "interrefer", "interv", "length", "lower", "miss", "note", "obtain", "page", "paper", "pass", "properti", "rate", "refer", "relat", "replac", "satisfi", "schwartz", "set", "shown", "singl", "size", "size", "statist", "statist", "string", "string", "structur", "term", "upper", "work", "work", "slutz", "traiger"], "word_count": {"arbitrari": 1, "asymptot": 2, "averag": 3, "bound": 1, "calcul": 1, "consid": 2, "correct": 1, "den": 1, "deriv": 2, "develop": 1, "discuss": 1, "effici": 1, "exact": 1, "express": 2, "finit": 1, "follow": 1, "function": 2, "infinit": 1, "interrefer": 1, "interv": 1, "length": 2, "lower": 1, "miss": 1, "note": 1, "obtain": 2, "page": 2, "paper": 1, "pass": 1, "properti": 1, "rate": 1, "refer": 3, "relat": 1, "replac": 1, "satisfi": 1, "schwartz": 1, "set": 5, "shown": 1, "singl": 1, "size": 4, "statist": 2, "string": 3, "structur": 1, "term": 1, "upper": 1, "work": 5, "slutz": 1, "traiger": 1}}, "2596": {"id": "2596", "title": "A Weighted Buddy Method for Dynamic Storage Allocation", "abstract": "An extension of the buddy method, called the weighted buddy method, for dynamic storage allocation  is presented.  The weighted buddy method allows block sizes of 2^k and 3(2^k), whereas the original buddy  method allowed only block sizes of 2^k. This extension is achieved at an additional cost of only two  bits per block.  Simulation results are presented which compare this method with the buddy method.  These  results indicate that for a uniform request distribution, the buddy system has less total memory fragmentation  than the weighted buddy algorithm.  However, the total fragmentation is smaller for the weighted buddy  method when the requests are for exponentially distributed block sizes.", "authors": "Shen, K. K. Peterson, J. L.", "words_pool": ["achiev", "addit", "algorithm", "alloc", "allow", "bit", "block", "buddi", "call", "compar", "cost", "distribut", "distribut", "dynam", "exponenti", "extens", "fragment", "memori", "method", "origin", "present", "request", "request", "result", "simul", "size", "smaller", "storag", "system", "total", "uniform", "weight", "shen", "peterson"], "word_count": {"achiev": 1, "addit": 1, "algorithm": 1, "alloc": 1, "allow": 1, "bit": 1, "block": 4, "buddi": 8, "call": 1, "compar": 1, "cost": 1, "distribut": 2, "dynam": 1, "exponenti": 1, "extens": 2, "fragment": 2, "memori": 1, "method": 7, "origin": 1, "present": 2, "request": 2, "result": 2, "simul": 1, "size": 3, "smaller": 1, "storag": 1, "system": 1, "total": 2, "uniform": 1, "weight": 4, "shen": 1, "peterson": 1}}, "2597": {"id": "2597", "title": "Monitors: An Operating System Structuring Concept", "abstract": "This paper develops Brinch-Hansen's concept of a monitor as a method of structuring an operating  system.  It introduces a form of synchronization, describes a possible method of implementation in terms  of semaphores and gives a suitable proof rule.  Illustrative examples include a single resource scheduler,  a bounded buffer, an alarm clock, a buffer pool, a disk head optimizer, and a version of the problem  of readers and writers.", "authors": "Hoare, C. A. R.", "words_pool": ["alarm", "bound", "brinch", "buffer", "clock", "concept", "describ", "develop", "disk", "exampl", "form", "hansen", "head", "illustr", "implement", "includ", "introduc", "method", "monitor", "monitor", "oper", "optim", "paper", "pool", "problem", "proof", "reader", "resourc", "rule", "schedul", "semaphor", "singl", "structur", "suitabl", "synchron", "system", "term", "version", "writer", "hoar"], "word_count": {"alarm": 1, "bound": 1, "brinch": 1, "buffer": 2, "clock": 1, "concept": 1, "describ": 1, "develop": 1, "disk": 1, "exampl": 1, "form": 1, "hansen": 1, "head": 1, "illustr": 1, "implement": 1, "includ": 1, "introduc": 1, "method": 2, "monitor": 1, "oper": 1, "optim": 1, "paper": 1, "pool": 1, "problem": 1, "proof": 1, "reader": 1, "resourc": 1, "rule": 1, "schedul": 1, "semaphor": 1, "singl": 1, "structur": 1, "suitabl": 1, "synchron": 1, "system": 1, "term": 1, "version": 1, "writer": 1, "hoar": 1}}, "2598": {"id": "2598", "title": "Extending the Information Theory Approach to Converting Limited-Entry Decision Tables to Computer  Programs", "abstract": "This paper modifies an earlier algorithm for converting decision tables into flowcharts which  minimize subsequent execution time when compiled into a computer program.  The algorithms considered  in this paper perform limited search and, accordingly, do not necessarily result in globally optimal  solutions.  However, the greater search effort needed to obtain a globally optimal solution for complex  decision tables is usually not justified by sufficient savings in execution time.  There is an analogy  between the problem of converting decision tables into efficient flowcharts and the well-understood problem  in information theory of noiseless coding.  The results of the noiseless coding literature are used to  explore the limitations of algorithms used to solve the decision table problem.  The analogy between  the two problems is also used to develop improvements to the information algorithm in extending the depth  of search under certain conditions and in proposing additional conditions to be added to the decision  table.  Finally, the information algorithm is compared with an algorithm proposed in a recent paper by  Verhelst.", "authors": "Shwayder, K.", "words_pool": ["ad", "addit", "algorithm", "algorithm", "analog", "approach", "code", "compar", "compil", "complex", "comput", "condit", "consid", "convert", "decis", "depth", "develop", "earlier", "effici", "effort", "entri", "execut", "explor", "extend", "final", "flowchart", "global", "greater", "improv", "inform", "justifi", "limit", "limit", "literatur", "minim", "modifi", "necessarili", "need", "noiseless", "obtain", "optim", "paper", "perform", "problem", "problem", "program", "program", "propos", "propos", "recent", "result", "result", "save", "search", "solut", "solut", "solv", "subsequ", "suffici", "tabl", "tabl", "theori", "time", "understood", "verhelst", "shwayder"], "word_count": {"ad": 1, "addit": 1, "algorithm": 6, "analog": 2, "approach": 1, "code": 2, "compar": 1, "compil": 1, "complex": 1, "comput": 1, "condit": 2, "consid": 1, "convert": 2, "decis": 5, "depth": 1, "develop": 1, "earlier": 1, "effici": 1, "effort": 1, "entri": 1, "execut": 2, "explor": 1, "extend": 1, "final": 1, "flowchart": 2, "global": 2, "greater": 1, "improv": 1, "inform": 3, "justifi": 1, "limit": 2, "literatur": 1, "minim": 1, "modifi": 1, "necessarili": 1, "need": 1, "noiseless": 2, "obtain": 1, "optim": 2, "paper": 3, "perform": 1, "problem": 4, "program": 1, "propos": 2, "recent": 1, "result": 2, "save": 1, "search": 3, "solut": 2, "solv": 1, "subsequ": 1, "suffici": 1, "tabl": 5, "theori": 1, "time": 2, "understood": 1, "verhelst": 1, "shwayder": 1}}, "2599": {"id": "2599", "title": "First Order Approximation to the Optimum Checkpoint Interval", "authors": "Young, J. W.", "words_pool": ["approxim", "checkpoint", "interv", "optimum", "order", "young"], "word_count": {"approxim": 1, "checkpoint": 1, "interv": 1, "optimum": 1, "order": 1, "young": 1}}, "2600": {"id": "2600", "title": "Computation of g-Splines via a Factorization Method [E2] (Algorithm A485)", "authors": "Eidson, H. D. Schumaker, L. L.", "words_pool": ["a485", "algorithm", "comput", "e2", "factor", "method", "spline", "eidson", "schumak"], "word_count": {"a485": 1, "algorithm": 1, "comput": 1, "e2": 1, "factor": 1, "method": 1, "spline": 1, "eidson": 1, "schumak": 1}}, "2601": {"id": "2601", "title": "Evaluation of the Modified Bessel Functions K0(Z) and K1(Z) for Complex Arguments [S17] (Algorithm  A484)", "authors": "Burrell, K. H.", "words_pool": ["a484", "algorithm", "argument", "bessel", "complex", "evalu", "function", "k0", "k1", "modifi", "s17", "burrel"], "word_count": {"a484": 1, "algorithm": 1, "argument": 1, "bessel": 1, "complex": 1, "evalu": 1, "function": 1, "k0": 1, "k1": 1, "modifi": 1, "s17": 1, "burrel": 1}}, "2602": {"id": "2602", "title": "Masked Three-Dimensional Plot Program with Rotations [J6] (Algorithm A483)", "authors": "Watkins, S. L.", "words_pool": ["a483", "algorithm", "dimension", "j6", "mask", "plot", "program", "rotat", "watkin"], "word_count": {"a483": 1, "algorithm": 1, "dimension": 1, "j6": 1, "mask": 1, "plot": 1, "program": 1, "rotat": 1, "watkin": 1}}, "2603": {"id": "2603", "title": "The Equivalence of Reducing Transition Languages and Deterministic Languages", "abstract": "The class of reducing transition languages introduced by Eickel, Paul, Bauer, and Samelson  was shown by Morris to be a proper superclass of the simple precedence languages.  In this paper this  result is extended, showing that, in fact, the first class is equivalent to the class of deterministic  context free languages.", "authors": "Schkolnick, M.", "words_pool": ["bauer", "class", "context", "determinist", "eickel", "equival", "equival", "extend", "fact", "free", "introduc", "languag", "morri", "paper", "paul", "preced", "proper", "reduc", "result", "samelson", "show", "shown", "simpl", "superclass", "transit", "schkolnick"], "word_count": {"bauer": 1, "class": 3, "context": 1, "determinist": 1, "eickel": 1, "equival": 1, "extend": 1, "fact": 1, "free": 1, "introduc": 1, "languag": 3, "morri": 1, "paper": 1, "paul": 1, "preced": 1, "proper": 1, "reduc": 1, "result": 1, "samelson": 1, "show": 1, "shown": 1, "simpl": 1, "superclass": 1, "transit": 1, "schkolnick": 1}}, "2604": {"id": "2604", "title": "An Interactive Graphic Display for Region Partitioning by Linear Programming", "abstract": "Using linear programming, an interactive graphic display system has been implemented to solve  the region design problem of partitioning a region into N nonoverlapping subregions in such a way that  their areas are in specified proportions and that the total cost of servicing them is a minimum.  In  a conversational manner, a user can easily obtain different partitionings by specifying and modifying  the boundary, the service centers' locations, the area proportions, and the cost functions.  Examples  are included.", "authors": "Cheung, T.", "words_pool": ["area", "area", "boundari", "center", "convers", "cost", "design", "display", "easili", "exampl", "function", "graphic", "implement", "includ", "interact", "linear", "locat", "manner", "minimum", "modifi", "nonoverlap", "obtain", "partit", "partit", "problem", "program", "proport", "region", "servic", "servic", "solv", "subregion", "system", "total", "user", "cheung"], "word_count": {"area": 2, "boundari": 1, "center": 1, "convers": 1, "cost": 2, "design": 1, "display": 1, "easili": 1, "exampl": 1, "function": 1, "graphic": 1, "implement": 1, "includ": 1, "interact": 1, "linear": 1, "locat": 1, "manner": 1, "minimum": 1, "modifi": 1, "nonoverlap": 1, "obtain": 1, "partit": 2, "problem": 1, "program": 1, "proport": 2, "region": 2, "servic": 2, "solv": 1, "subregion": 1, "system": 1, "total": 1, "user": 1, "cheung": 1}}, "2605": {"id": "2605", "title": "A Precise Numerical Analysis Program", "abstract": "A description is given of a program for computing the solution to a small number of standard  numerical analysis problems to any specified accuracy, up to a limit of 2000 correct decimal places.   Each computed number is bounded in an interval with a multiple precision midpoint.  Arithmetic operations  involving these numbers are executed according to interval arithmetic concepts, with non-significant  digits automatically discarded.  Details are supplied of problem specification and problem computation.", "authors": "Aberth, O.", "words_pool": ["accord", "accuraci", "analysi", "arithmet", "bound", "comput", "comput", "comput", "concept", "correct", "decim", "descript", "detail", "digit", "discard", "execut", "interv", "involv", "limit", "midpoint", "multipl", "non", "number", "number", "numer", "oper", "place", "precis", "precis", "problem", "problem", "program", "signific", "small", "solut", "specif", "standard", "suppli", "aberth"], "word_count": {"accord": 1, "accuraci": 1, "analysi": 1, "arithmet": 2, "bound": 1, "comput": 3, "concept": 1, "correct": 1, "decim": 1, "descript": 1, "detail": 1, "digit": 1, "discard": 1, "execut": 1, "interv": 2, "involv": 1, "limit": 1, "midpoint": 1, "multipl": 1, "non": 1, "number": 3, "numer": 1, "oper": 1, "place": 1, "precis": 1, "problem": 3, "program": 1, "signific": 1, "small": 1, "solut": 1, "specif": 1, "standard": 1, "suppli": 1, "aberth": 1}}, "2606": {"id": "2606", "title": "A New Integration Algorithm for Ordinary Differential Equations Based on Continued Fraction Approximations", "abstract": "A new integration algorithm is found, and an implementation is compared with other programmed  algorithms.  The new algorithm is a step-by-step procedure for solving the initial value problem in ordinary  differential equations.  It is designed to approximate poles of small integer order in the solutions  of the differential equations by continued fractions obtained by manipulating the sums of truncated Taylor  series expansions.  The new method is compared with Gragg-Bulirsh-Stoer, and the Taylor series method.   The Taylor series method and the new method are shown to be superior in speed and accuracy, while the  new method is shown to be most superior when the solution is required near a singularity.  The new method  can finally be seen to pass automatically through singularities where all the other methods which are  discussed will have failed.", "authors": "Willers, I. M.", "words_pool": ["accuraci", "algorithm", "algorithm", "approxim", "approxim", "base", "bulirsh", "compar", "continu", "design", "differenti", "discuss", "equat", "expans", "fail", "final", "found", "fraction", "fraction", "gragg", "implement", "initi", "integ", "integr", "manipul", "method", "method", "obtain", "order", "ordinari", "pass", "pole", "problem", "procedur", "program", "requir", "seen", "seri", "shown", "singular", "singular", "small", "solut", "solut", "solv", "speed", "step", "stoer", "sum", "superior", "taylor", "truncat", "willer"], "word_count": {"accuraci": 1, "algorithm": 3, "approxim": 1, "base": 1, "bulirsh": 1, "compar": 2, "continu": 1, "design": 1, "differenti": 2, "discuss": 1, "equat": 2, "expans": 1, "fail": 1, "final": 1, "found": 1, "fraction": 1, "gragg": 1, "implement": 1, "initi": 1, "integ": 1, "integr": 1, "manipul": 1, "method": 7, "obtain": 1, "order": 1, "ordinari": 1, "pass": 1, "pole": 1, "problem": 1, "procedur": 1, "program": 1, "requir": 1, "seen": 1, "seri": 3, "shown": 2, "singular": 2, "small": 1, "solut": 2, "solv": 1, "speed": 1, "step": 2, "stoer": 1, "sum": 1, "superior": 2, "taylor": 3, "truncat": 1, "willer": 1}}, "2607": {"id": "2607", "title": "A Problem-List of Issues Concerning Computers and Public Policy", "authors": "ACM Committee", "words_pool": ["comput", "concern", "issu", "list", "polici", "problem", "public", "acm", "committe"], "word_count": {"comput": 1, "concern": 1, "issu": 1, "list": 1, "polici": 1, "problem": 1, "public": 1, "acm": 1, "committe": 1}}, "2608": {"id": "2608", "title": "Recurrence Relations for the Fresnel Integral and Similar Integrals", "authors": "Acton, F. S.", "words_pool": ["fresnel", "integr", "integr", "recurr", "relat", "similar", "acton"], "word_count": {"fresnel": 1, "integr": 2, "recurr": 1, "relat": 1, "similar": 1, "acton": 1}}, "2609": {"id": "2609", "title": "Interpolation with Rounded Ramp Functions", "abstract": "A new interpolation function is introduced.  It has infinitely many continuous derivatives  and is a composition of ramp functions with smoothed bends called Rounded Ramp Functions.  How the interpolation  function can be extended to more than one variable is shown.  An efficient Fortran program is given by  which the interpolation function can be obtained for a given point set.", "authors": "Lagerlof, R. O. E.", "words_pool": ["bend", "call", "composit", "continu", "deriv", "effici", "extend", "fortran", "function", "function", "infinit", "interpol", "introduc", "obtain", "point", "program", "ramp", "round", "set", "shown", "smooth", "variabl", "lagerlof"], "word_count": {"bend": 1, "call": 1, "composit": 1, "continu": 1, "deriv": 1, "effici": 1, "extend": 1, "fortran": 1, "function": 5, "infinit": 1, "interpol": 3, "introduc": 1, "obtain": 1, "point": 1, "program": 1, "ramp": 2, "round": 1, "set": 1, "shown": 1, "smooth": 1, "variabl": 1, "lagerlof": 1}}, "2610": {"id": "2610", "title": "Gauss Harmonic Interpolation Formulas", "abstract": "Let R be an open, bounded, simply connected region in the (x,y)-plane and let (x*,y*) be a  point in R.  Assuming R is starlike with respect to (x*,y*), we discuss a method for computing Gauss  harmonic interpolation formulas for R and the point (x*,y*).  Such formulas approximate a harmonic function  at (x*,y*) in terms of a linear combination of its values at certain selected points on the boundary  of R.  Such formulas are useful for approximating the solution of the Dirichlet problem for R.", "authors": "Stroud, A. H.", "words_pool": ["approxim", "approxim", "assum", "boundari", "bound", "combin", "comput", "connect", "dirichlet", "discuss", "formula", "function", "gauss", "harmon", "interpol", "let", "linear", "method", "open", "plane", "point", "point", "problem", "region", "respect", "select", "simpli", "solut", "starlik", "term", "valu", "stroud"], "word_count": {"approxim": 2, "assum": 1, "boundari": 1, "bound": 1, "combin": 1, "comput": 1, "connect": 1, "dirichlet": 1, "discuss": 1, "formula": 3, "function": 1, "gauss": 1, "harmon": 2, "interpol": 1, "let": 2, "linear": 1, "method": 1, "open": 1, "plane": 1, "point": 3, "problem": 1, "region": 1, "respect": 1, "select": 1, "simpli": 1, "solut": 1, "starlik": 1, "term": 1, "valu": 1, "stroud": 1}}, "2611": {"id": "2611", "title": "The Complex Method for Constrained Optimization (Algorithm R454)", "authors": "Shere, K. D.", "words_pool": ["algorithm", "complex", "constrain", "method", "optim", "r454", "shere"], "word_count": {"algorithm": 1, "complex": 1, "constrain": 1, "method": 1, "optim": 1, "r454": 1, "shere": 1}}, "2612": {"id": "2612", "title": "Rosenbrock Function Minimization (Algorithm R450)", "authors": "Bultheel, A.", "words_pool": ["algorithm", "function", "minim", "r450", "rosenbrock", "bultheel"], "word_count": {"algorithm": 1, "function": 1, "minim": 1, "r450": 1, "rosenbrock": 1, "bultheel": 1}}, "2613": {"id": "2613", "title": "Transitivity Sets [G7] (Algorithm A482)", "authors": "McKay, J. Regener, E.", "words_pool": ["a482", "algorithm", "g7", "set", "transit", "mckay", "regen"], "word_count": {"a482": 1, "algorithm": 1, "g7": 1, "set": 1, "transit": 1, "mckay": 1, "regen": 1}}, "2614": {"id": "2614", "title": "Arrow to Precedence Network Transformation [H] (Algorithm A481)", "authors": "Crandall, K. C.", "words_pool": ["a481", "algorithm", "arrow", "network", "preced", "transform", "crandal"], "word_count": {"a481": 1, "algorithm": 1, "arrow": 1, "network": 1, "preced": 1, "transform": 1, "crandal": 1}}, "2615": {"id": "2615", "title": "Procedures for computing Smoothing and Interpolating Natural Splines [E1] (Algorithm A480)", "authors": "Lyche, T. Schumaker, L. L.", "words_pool": ["a480", "algorithm", "comput", "e1", "interpol", "natur", "procedur", "smooth", "spline", "lych", "schumak"], "word_count": {"a480": 1, "algorithm": 1, "comput": 1, "e1": 1, "interpol": 1, "natur": 1, "procedur": 1, "smooth": 1, "spline": 1, "lych": 1, "schumak": 1}}, "2616": {"id": "2616", "title": "On the Conversion of Programs to Decision Tables: Method and Objectives", "abstract": "The problems of converting programs to decision tables are investigated.  Objectives of these  conversions are mainly program debugging and optimization in practice.  Extensions to the theory of computation  and computability are suggested.", "authors": "Cavouras, J. C.", "words_pool": ["comput", "comput", "convers", "convers", "convert", "debug", "decis", "extens", "investig", "mainli", "method", "object", "optim", "practic", "problem", "program", "program", "suggest", "tabl", "theori", "cavoura"], "word_count": {"comput": 2, "convers": 1, "convert": 1, "debug": 1, "decis": 1, "extens": 1, "investig": 1, "mainli": 1, "method": 1, "object": 1, "optim": 1, "practic": 1, "problem": 1, "program": 2, "suggest": 1, "tabl": 1, "theori": 1, "cavoura": 1}}, "2617": {"id": "2617", "title": "A Note on Subexpression Ordering in the Evaluation of Arithmetic Expressions", "authors": "Denning, P. J. Graham, G. S.", "words_pool": ["arithmet", "evalu", "express", "note", "order", "subexpress", "den", "graham"], "word_count": {"arithmet": 1, "evalu": 1, "express": 1, "note": 1, "order": 1, "subexpress": 1, "den": 1, "graham": 1}}, "2618": {"id": "2618", "title": "A New Solution of Dijkstra's Concurrent Programming Problem", "abstract": "A simple solution to the mutual exclusion problem is presented which allows the system to continue  to operate despite the failure of any individual component.", "authors": "Lamport, L.", "words_pool": ["compon", "concurr", "continu", "despit", "dijkstra", "exclus", "failur", "individu", "mutual", "oper", "present", "problem", "program", "simpl", "solut", "system", "lamport"], "word_count": {"compon": 1, "concurr": 1, "continu": 1, "despit": 1, "dijkstra": 1, "exclus": 1, "failur": 1, "individu": 1, "mutual": 1, "oper": 1, "present": 1, "problem": 1, "program": 1, "simpl": 1, "solut": 1, "system": 1, "lamport": 1}}, "2619": {"id": "2619", "title": "Graph Coloring Conditions for the Existence of Solutions to the Timetable Problem", "abstract": "A necessary and sufficient condition is presented for the existence of a solution to the Gotlieb  class-teacher timetable problem.  Several relationships are established between the class-teacher timetable  problem and graphs with preconditions.  These preconditions place additional restrictions on the coloration  of a graph.  The preconditions correspond to the unavailability constraints and preassigned meetings  in the class-teacher timetable problem.  Using some recent results that convert graphs with preconditions  to graphs without them, it is shown that the existence of a coloration of a graph is the required necessary  and sufficient condition.", "authors": "Neufeld, G. A. Tartar, J.", "words_pool": ["addit", "class", "color", "color", "condit", "condit", "constraint", "convert", "correspond", "establish", "exist", "gotlieb", "graph", "graph", "meet", "place", "preassign", "precondit", "present", "problem", "recent", "relationship", "requir", "restrict", "result", "shown", "solut", "solut", "suffici", "teacher", "timet", "unavail", "neufeld", "tartar"], "word_count": {"addit": 1, "class": 3, "color": 2, "condit": 2, "constraint": 1, "convert": 1, "correspond": 1, "establish": 1, "exist": 2, "gotlieb": 1, "graph": 5, "meet": 1, "place": 1, "preassign": 1, "precondit": 4, "present": 1, "problem": 3, "recent": 1, "relationship": 1, "requir": 1, "restrict": 1, "result": 1, "shown": 1, "solut": 1, "suffici": 2, "teacher": 3, "timet": 3, "unavail": 1, "neufeld": 1, "tartar": 1}}, "2620": {"id": "2620", "title": "Execution Time Requirements for Encipherment Programs", "abstract": "Although encipherment has often been discussed as a means to protect computer data, its costs  are not well established.  Five experiments were conducted to measure the cpu time on a CDC 6400 required  by additive ciphers programmed both in assembly language and in Fortran: a \"null transformation\" to measure  the time to move data without encipherment; encipherment with one-word key; encipherment with a 125-word  key; double key encipherment; and encipherment using a pseudo random key.  The results were analyzed  for consistency over 100 runs, and the effects of constant and intermittent errors were considered.   Timing rates for assembly language encipherment ranged from 498,800 characters per second for a pseudo  random key cipher to 2,092,000 characters per second for a constant one-word key cipher.  The latter  is almost equivalent to the rate required simply to move data without encipherment.  Fortran tests required  over four times as much cpu time.  This paper introduces the idea on enciphering time coefficient the  ratio of enciphering time to the time taken to fetch and store data without encipherment.", "authors": "Friedman, T. D. offman, L. J.", "words_pool": ["addit", "analyz", "assembl", "cdc", "charact", "cipher", "cipher", "coeffici", "comput", "conduct", "consid", "consist", "constant", "cost", "cpu", "data", "discuss", "doubl", "effect", "enciph", "encipher", "equival", "error", "establish", "execut", "experi", "fetch", "fortran", "idea", "intermitt", "introduc", "key", "languag", "mean", "measur", "move", "null", "paper", "program", "program", "protect", "pseudo", "random", "rang", "rate", "rate", "ratio", "requir", "requir", "result", "run", "simpli", "store", "test", "time", "time", "time", "transform", "word", "friedman", "offman"], "word_count": {"addit": 1, "analyz": 1, "assembl": 2, "cdc": 1, "charact": 2, "cipher": 3, "coeffici": 1, "comput": 1, "conduct": 1, "consid": 1, "consist": 1, "constant": 2, "cost": 1, "cpu": 2, "data": 4, "discuss": 1, "doubl": 1, "effect": 1, "enciph": 2, "encipher": 9, "equival": 1, "error": 1, "establish": 1, "execut": 1, "experi": 1, "fetch": 1, "fortran": 2, "idea": 1, "intermitt": 1, "introduc": 1, "key": 6, "languag": 2, "mean": 1, "measur": 2, "move": 2, "null": 1, "paper": 1, "program": 1, "protect": 1, "pseudo": 2, "random": 2, "rang": 1, "rate": 2, "ratio": 1, "requir": 3, "result": 1, "run": 1, "simpli": 1, "store": 1, "test": 1, "time": 8, "transform": 1, "word": 3, "friedman": 1, "offman": 1}}, "2621": {"id": "2621", "title": "A High Security Log-in Procedure", "abstract": "The protection of time sharing systems from unauthorized users is often achieved by the use  of passwords.  By using one-way ciphers to code the passwords, the risks involved with storing the passwords  in the computer can be avoided.  We discuss the selection of a suitable one-way cipher and suggest that  for this purpose polynomials over a prime modulus are superior to one-way ciphers derived from Sannon  codes.", "authors": "Purdy, G. B.", "words_pool": ["achiev", "avoid", "cipher", "cipher", "code", "code", "comput", "deriv", "discuss", "high", "involv", "log", "modulu", "password", "polynomi", "prime", "procedur", "protect", "purpos", "risk", "sannon", "secur", "select", "share", "store", "suggest", "suitabl", "superior", "system", "time", "unauthor", "user", "purdi"], "word_count": {"achiev": 1, "avoid": 1, "cipher": 3, "code": 2, "comput": 1, "deriv": 1, "discuss": 1, "high": 1, "involv": 1, "log": 1, "modulu": 1, "password": 3, "polynomi": 1, "prime": 1, "procedur": 1, "protect": 1, "purpos": 1, "risk": 1, "sannon": 1, "secur": 1, "select": 1, "share": 1, "store": 1, "suggest": 1, "suitabl": 1, "superior": 1, "system": 1, "time": 1, "unauthor": 1, "user": 1, "purdi": 1}}, "2622": {"id": "2622", "title": "A User Authentication Scheme Not Requiring Secrecy in the Computer", "abstract": "In many computer operating systems a user authenticates himself by entering a secret password  known solely to himself and the system.  The system compares this password with one recorded in a Password  Table which is available to only the authentication program.  The integrity of the system depends on  keeping the table secret.  In this paper a password scheme is presented which does not require secrecy  in the computer.    All aspects of the system, including all relevant code and data bases, may be known  by anyone attempting to intrude.  The scheme is based on using a function H which the would-be intruder  is unable to invert.  This function is applied to the user's password and the result compared to a table  entry, a match being interpreted as authentication of the user.  The intruder may know all about H and  have access to the table, but he can penetrate the system only if he can invert H to determine an input  that produces a given output.  This paper discusses issues surrounding selection of a suitable H.  Two  different plausible arguments are given that penetration would be exceedingly difficult, and it is then  argued that more rigorous results are unlikely.  Finally, some human engineering problems relating to  the scheme are discussed.", "authors": "Evans, A. Jr. Kantrowitz, W. Weiss, E.", "words_pool": ["access", "appli", "argu", "argument", "aspect", "attempt", "authent", "authent", "base", "base", "code", "compar", "compar", "comput", "data", "depend", "determin", "difficult", "discuss", "discuss", "engin", "enter", "entri", "exceedingli", "final", "function", "human", "includ", "input", "integr", "interpret", "intrud", "intrud", "invert", "issu", "keep", "know", "known", "match", "oper", "output", "paper", "password", "penetr", "penetr", "plausibl", "present", "problem", "produc", "program", "record", "relat", "relev", "requir", "requir", "result", "result", "rigor", "scheme", "secreci", "secret", "select", "sole", "suitabl", "surround", "system", "system", "tabl", "unabl", "unlik", "user", "evan", "jr", "kantrowitz", "weiss"], "word_count": {"access": 1, "appli": 1, "argu": 1, "argument": 1, "aspect": 1, "attempt": 1, "authent": 3, "base": 2, "code": 1, "compar": 2, "comput": 2, "data": 1, "depend": 1, "determin": 1, "difficult": 1, "discuss": 2, "engin": 1, "enter": 1, "entri": 1, "exceedingli": 1, "final": 1, "function": 2, "human": 1, "includ": 1, "input": 1, "integr": 1, "interpret": 1, "intrud": 3, "invert": 2, "issu": 1, "keep": 1, "know": 1, "known": 2, "match": 1, "oper": 1, "output": 1, "paper": 2, "password": 5, "penetr": 2, "plausibl": 1, "present": 1, "problem": 1, "produc": 1, "program": 1, "record": 1, "relat": 1, "relev": 1, "requir": 1, "result": 2, "rigor": 1, "scheme": 3, "secreci": 1, "secret": 2, "select": 1, "sole": 1, "suitabl": 1, "surround": 1, "system": 6, "tabl": 4, "unabl": 1, "unlik": 1, "user": 3, "evan": 1, "jr": 1, "kantrowitz": 1, "weiss": 1}}, "2623": {"id": "2623", "title": "A New Technique for Compression and Storage of Data", "abstract": "The widespread tendency toward storage of large programs and blocks off text has produced a  need for efficient methods of compressing and storing data.  This paper describes techniques that can,  in most cases, decrease storage size by a factor of from two to four.  The techniques involve special  handling of leading and trailing blanks, and the encoding of other symbols in groups of fixed size as  unique fixed point numbers.  The efficiency of the system is considered and pertinent statistics are  given and compared with statistics for other information coding techniques.", "authors": "Hahn, B.", "words_pool": ["blank", "block", "case", "code", "compar", "compress", "compress", "consid", "data", "decreas", "describ", "effici", "effici", "encod", "factor", "fix", "group", "handl", "inform", "involv", "larg", "lead", "method", "need", "number", "paper", "pertin", "point", "produc", "program", "size", "special", "statist", "storag", "store", "symbol", "system", "techniqu", "techniqu", "tendenc", "text", "trail", "uniqu", "widespread", "hahn"], "word_count": {"blank": 1, "block": 1, "case": 1, "code": 1, "compar": 1, "compress": 1, "consid": 1, "data": 1, "decreas": 1, "describ": 1, "effici": 2, "encod": 1, "factor": 1, "fix": 2, "group": 1, "handl": 1, "inform": 1, "involv": 1, "larg": 1, "lead": 1, "method": 1, "need": 1, "number": 1, "paper": 1, "pertin": 1, "point": 1, "produc": 1, "program": 1, "size": 2, "special": 1, "statist": 2, "storag": 2, "store": 1, "symbol": 1, "system": 1, "techniqu": 3, "tendenc": 1, "text": 1, "trail": 1, "uniqu": 1, "widespread": 1, "hahn": 1}}, "2624": {"id": "2624", "title": "Formal Requirements for Virtualizable Third Generation Architectures", "abstract": "Virtual machine systems have been implemented on a limited number of third generation computer  systems, e.g. CP-67 on the IBM 360/67.  From previous empirical studies, it is known that certain third  generation computer systems, e.g. the DEC PDP-10, cannot support a virtual machine system.  In this paper,  model of a third-generation-like computer system is developed.  Formal techniques are used to derive  precise sufficient conditions to test whether such an architecture can support virtual machines.", "authors": "Popek, G. J. Goldberg, R. P.", "words_pool": ["architectur", "architectur", "comput", "condit", "cp", "dec", "deriv", "develop", "empir", "formal", "gener", "ibm", "implement", "known", "limit", "machin", "machin", "model", "number", "paper", "pdp", "precis", "previou", "requir", "studi", "suffici", "support", "system", "system", "techniqu", "test", "virtual", "virtualiz", "popek", "goldberg"], "word_count": {"architectur": 1, "comput": 3, "condit": 1, "cp": 1, "dec": 1, "deriv": 1, "develop": 1, "empir": 1, "formal": 1, "gener": 3, "ibm": 1, "implement": 1, "known": 1, "limit": 1, "machin": 3, "model": 1, "number": 1, "paper": 1, "pdp": 1, "precis": 1, "previou": 1, "requir": 1, "studi": 1, "suffici": 1, "support": 2, "system": 5, "techniqu": 1, "test": 1, "virtual": 3, "virtualiz": 1, "popek": 1, "goldberg": 1}}, "2625": {"id": "2625", "title": "Capability-Based Addressing", "abstract": "Various addressing schemes making use of segment tables are examined.  The inadequacies of  these schemes when dealing with shared addresses are explained. These inadequacies are traced to the  lack of an efficient absolute address for objects in these systems.  The direct use of a capability as  an address is shown to overcome these difficulties because it provides the needed absolute address.   Implementation of capability-based addressing is discussed.  It is predicted that the use of tags to  identify capabilities will dominate.  A hardware address translation scheme which never requires the  modification of the representation of capabilities is suggested. The scheme uses a main memory hash table  for obtaining a segment's location in main memory given its unique code.  The hash table is avoided for recently accessed segments by means of a set of associative registers.  A computer using capability-based  addressing may be substantially superior to present systems on the basis of protection, simplicity of  programming conventions, and efficient implementation.", "authors": "Fabry, R. S.", "words_pool": ["absolut", "access", "address", "address", "address", "associ", "avoid", "base", "basi", "capabl", "capabl", "code", "comput", "convent", "deal", "difficulti", "direct", "discuss", "domin", "effici", "examin", "explain", "hardwar", "hash", "identifi", "implement", "inadequaci", "lack", "locat", "main", "make", "mean", "memori", "modif", "need", "object", "obtain", "overcom", "predict", "present", "program", "protect", "recent", "regist", "represent", "requir", "scheme", "scheme", "segment", "segment", "set", "share", "shown", "simplic", "substanti", "suggest", "superior", "system", "tabl", "tabl", "tag", "trace", "translat", "uniqu", "fabri"], "word_count": {"absolut": 2, "access": 1, "address": 8, "associ": 1, "avoid": 1, "base": 2, "basi": 1, "capabl": 5, "code": 1, "comput": 1, "convent": 1, "deal": 1, "difficulti": 1, "direct": 1, "discuss": 1, "domin": 1, "effici": 2, "examin": 1, "explain": 1, "hardwar": 1, "hash": 2, "identifi": 1, "implement": 2, "inadequaci": 2, "lack": 1, "locat": 1, "main": 2, "make": 1, "mean": 1, "memori": 2, "modif": 1, "need": 1, "object": 1, "obtain": 1, "overcom": 1, "predict": 1, "present": 1, "program": 1, "protect": 1, "recent": 1, "regist": 1, "represent": 1, "requir": 1, "scheme": 4, "segment": 3, "set": 1, "share": 1, "shown": 1, "simplic": 1, "substanti": 1, "suggest": 1, "superior": 1, "system": 2, "tabl": 3, "tag": 1, "trace": 1, "translat": 1, "uniqu": 1, "fabri": 1}}, "2626": {"id": "2626", "title": "Protection and the Control of Information Sharing in Multics", "abstract": "The design of mechanisms to control the sharing of information in the Multics system is described.   Five design principles help provide insight into the tradeoffs among different possible designs.  The  key mechanisms described include access control lists, hierarchical control of access specifications,  identification and authentication of users, and primary memory protection.  The paper ends with a discussion  of several known weaknesses in the current protection mechanism design.", "authors": "Saltzer, J. H.", "words_pool": ["access", "authent", "control", "design", "design", "discuss", "end", "help", "hierarch", "identif", "includ", "inform", "insight", "key", "known", "list", "mechan", "mechan", "memori", "multic", "paper", "primari", "principl", "protect", "provid", "share", "specif", "system", "tradeoff", "user", "weak", "saltzer"], "word_count": {"access": 2, "authent": 1, "control": 3, "design": 4, "discuss": 1, "end": 1, "help": 1, "hierarch": 1, "identif": 1, "includ": 1, "inform": 1, "insight": 1, "key": 1, "known": 1, "list": 1, "mechan": 3, "memori": 1, "multic": 1, "paper": 1, "primari": 1, "principl": 1, "protect": 2, "provid": 1, "share": 1, "specif": 1, "system": 1, "tradeoff": 1, "user": 1, "weak": 1, "saltzer": 1}}, "2627": {"id": "2627", "title": "Scheduling Independent Tasks to Reduce Mean Finishing Time", "abstract": "Sequencing to minimize mean finishing time (or mean time in system) is not only desirable to  the user, but it also tends to minimize at each point in time the storage required to hold incomplete  tasks.  In this paper a deterministic model of independent tasks is introduced and new results are derived  which extend and generalize the algorithms known for minimizing mean finishing time.  In addition to  presenting and analyzing new algorithms it is shown that the most general mean-finishing-time problem  for independent tasks is polynomial complete, and hence unlikely to admit of a non-enumerative solution", "authors": "Bruno, J. Coffman, E. G. Jr. Sethi, R.", "words_pool": ["addit", "admit", "algorithm", "analyz", "complet", "deriv", "desir", "determinist", "enum", "extend", "finish", "gener", "gener", "hold", "incomplet", "independ", "introduc", "known", "mean", "minim", "minim", "model", "non", "paper", "point", "polynomi", "present", "problem", "reduc", "requir", "result", "schedul", "sequenc", "shown", "solut", "storag", "system", "task", "tend", "time", "unlik", "user", "bruno", "coffman", "jr", "sethi"], "word_count": {"addit": 1, "admit": 1, "algorithm": 2, "analyz": 1, "complet": 1, "deriv": 1, "desir": 1, "determinist": 1, "enum": 1, "extend": 1, "finish": 3, "gener": 2, "hold": 1, "incomplet": 1, "independ": 2, "introduc": 1, "known": 1, "mean": 4, "minim": 3, "model": 1, "non": 1, "paper": 1, "point": 1, "polynomi": 1, "present": 1, "problem": 1, "reduc": 1, "requir": 1, "result": 1, "schedul": 1, "sequenc": 1, "shown": 1, "solut": 1, "storag": 1, "system": 1, "task": 3, "tend": 1, "time": 5, "unlik": 1, "user": 1, "bruno": 1, "coffman": 1, "jr": 1, "sethi": 1}}, "2628": {"id": "2628", "title": "Minimal-Total-Processing Time Drum and Disk Scheduling Disciplines", "abstract": "This article investigates the application of minimal-total-processing-time (MTPT) scheduling  disciplines to rotating storage units when random arrival of requests is allowed.  Fixed-head drum and  moving-head drum and moving-head disk storage units are considered, and emphasis is placed on the relative  merits of the MTPT scheduling discipline with respect to the shortest-latency-time-first (SLTF) scheduling  discipline.  The results of the simulation studies presented show that neither scheduling discipline  is unconditionally superior to the other.  For most fixed-head drum applications, the SLTF discipline  is preferable to MTPT, but for intra-cylinder disk scheduling the MTPT discipline offers a distinct advantage  over the SLTF discipline.  The computational requirements of an algorithm that implements the MTPT scheduling  discipline are shown to be comparable to SLTF algorithms. In both cases, the sorting procedure is the  most time-consuming phase of the algorithm.", "authors": "Fuller, S. H.", "words_pool": ["advantag", "algorithm", "algorithm", "allow", "applic", "applic", "arriv", "articl", "case", "compar", "comput", "consid", "consum", "cylind", "disciplin", "disciplin", "disk", "distinct", "drum", "emphasi", "fix", "head", "implement", "intra", "investig", "latenc", "merit", "minim", "move", "mtpt", "offer", "phase", "prefer", "present", "procedur", "process", "random", "rel", "request", "requir", "respect", "result", "rotat", "schedul", "shortest", "show", "shown", "simul", "sltf", "sort", "storag", "studi", "superior", "time", "total", "uncondit", "unit", "fuller"], "word_count": {"advantag": 1, "algorithm": 3, "allow": 1, "applic": 2, "arriv": 1, "articl": 1, "case": 1, "compar": 1, "comput": 1, "consid": 1, "consum": 1, "cylind": 1, "disciplin": 8, "disk": 2, "distinct": 1, "drum": 3, "emphasi": 1, "fix": 2, "head": 4, "implement": 1, "intra": 1, "investig": 1, "latenc": 1, "merit": 1, "minim": 1, "move": 2, "mtpt": 5, "offer": 1, "phase": 1, "prefer": 1, "present": 1, "procedur": 1, "process": 1, "random": 1, "rel": 1, "request": 1, "requir": 1, "respect": 1, "result": 1, "rotat": 1, "schedul": 6, "shortest": 1, "show": 1, "shown": 1, "simul": 1, "sltf": 4, "sort": 1, "storag": 2, "studi": 1, "superior": 1, "time": 3, "total": 1, "uncondit": 1, "unit": 2, "fuller": 1}}, "2629": {"id": "2629", "title": "his  paper discusses the nature and implementation of the file system and of the user command interface.", "abstract": "UNIX is a general-purpose, multi-user, interactive operating system for the Digital Equipment  Corporation PDP-11/40 and 11/45 computers.  It offers a number of features seldom found even in larger  operating systems, including: (1) a hierarchical file system incorporating demountable volumes; (2) compatible  file, device, and inter-process I/O; (3) the ability to initiate asynchronous processes; (4) system command  language selectable on a per-user basis; and (5) over 100 subsystems including a dozen languages", "authors": "Ritchie, D. M. Thompson, K.", "words_pool": ["abil", "asynchron", "basi", "command", "compat", "comput", "corpor", "demount", "devic", "digit", "discuss", "dozen", "equip", "featur", "found", "gener", "hierarch", "implement", "includ", "incorpor", "initi", "inter", "interact", "interfac", "languag", "languag", "larger", "multi", "natur", "number", "offer", "oper", "paper", "pdp", "process", "process", "purpos", "seldom", "select", "subsystem", "system", "system", "user", "volum", "ritchi", "thompson"], "word_count": {"abil": 1, "asynchron": 1, "basi": 1, "command": 1, "compat": 1, "comput": 1, "corpor": 1, "demount": 1, "devic": 1, "digit": 1, "discuss": 1, "dozen": 1, "equip": 1, "featur": 1, "found": 1, "gener": 1, "hierarch": 1, "implement": 1, "includ": 2, "incorpor": 1, "initi": 1, "inter": 1, "interact": 1, "interfac": 1, "languag": 2, "larger": 1, "multi": 1, "natur": 1, "number": 1, "offer": 1, "oper": 2, "paper": 1, "pdp": 1, "process": 2, "purpos": 1, "seldom": 1, "select": 1, "subsystem": 1, "system": 4, "user": 2, "volum": 1, "ritchi": 1, "thompson": 1}}, "2630": {"id": "2630", "title": "On Computing Sets of Shortest Paths in a Graph", "abstract": "Two algorithms are presented that construct the k shortest paths between every pair of vertices  in a directed graph.  These algorithms generalize the Floyd algorithm and the Dantzig algorithm for finding  the shortest path between every pair of vertices in a directed graph.", "authors": "Minieka, E.", "words_pool": ["algorithm", "algorithm", "comput", "construct", "dantzig", "direct", "find", "floyd", "gener", "graph", "pair", "path", "path", "present", "set", "shortest", "vertic", "minieka"], "word_count": {"algorithm": 4, "comput": 1, "construct": 1, "dantzig": 1, "direct": 2, "find": 1, "floyd": 1, "gener": 1, "graph": 2, "pair": 2, "path": 2, "present": 1, "set": 1, "shortest": 2, "vertic": 2, "minieka": 1}}, "2631": {"id": "2631", "title": "An Information-Theoretic Approach to Text Searching in Direct Access Systems", "abstract": "Using direct access computer files of bibliographic information, an attempt is made to overcome  one of the problems often associated with information retrieval, namely, the maintenance and use of large  dictionaries, the greater part of which is used only infrequently.  A novel method is presented, which  maps the hyperbolic frequency distribution.  This is more suited to implementation on storage devices.   This method treats text as a string of characters rather than words bounded by spaces, and chooses subsets  of strings such that their frequencies of occurrence are more even than those of word types.  The members  of this subset are then used as index keys for retrieval. The rectangular distribution of key frequencies  results in a much simplified file organization and promises considerable cost advantages.", "authors": "Barton, I. J. Creasey, S. E. Lynch, M. F. Snell, M. J.", "words_pool": ["access", "advantag", "approach", "attempt", "bibliograph", "bound", "charact", "choos", "comput", "consider", "cost", "devic", "dictionari", "direct", "distribut", "frequenc", "frequenc", "greater", "hyperbol", "implement", "index", "inform", "infrequ", "key", "key", "larg", "made", "mainten", "map", "member", "method", "occurr", "organ", "overcom", "part", "present", "problem", "promis", "rectangular", "result", "retriev", "search", "simplifi", "space", "storag", "string", "string", "subset", "subset", "suit", "system", "text", "theoret", "treat", "type", "word", "word", "barton", "creasey", "lynch", "snell"], "word_count": {"access": 1, "advantag": 1, "approach": 1, "attempt": 1, "bibliograph": 1, "bound": 1, "charact": 1, "choos": 1, "comput": 1, "consider": 1, "cost": 1, "devic": 1, "dictionari": 1, "direct": 1, "distribut": 2, "frequenc": 3, "greater": 1, "hyperbol": 1, "implement": 1, "index": 1, "inform": 2, "infrequ": 1, "key": 2, "larg": 1, "made": 1, "mainten": 1, "map": 1, "member": 1, "method": 2, "occurr": 1, "organ": 1, "overcom": 1, "part": 1, "present": 1, "problem": 1, "promis": 1, "rectangular": 1, "result": 1, "retriev": 2, "search": 1, "simplifi": 1, "space": 1, "storag": 1, "string": 2, "subset": 2, "suit": 1, "system": 1, "text": 1, "theoret": 1, "treat": 1, "type": 1, "word": 2, "barton": 1, "creasey": 1, "lynch": 1, "snell": 1}}, "2632": {"id": "2632", "title": "HYDRA: The Kernel of a Multiprocessor Operating System", "abstract": "This paper describes the design philosophy of HYDRA-the kernel of an operating system for C.mmp,  the Carnegie-Mellon Multi-Mini-Processor.  This philosophy is realized through the introduction of a  generalized notion of \"resource\", both physical and virtual, called an \"object\".  Mechanisms are presented  for dealing with objects, including the creation of new types, specification of new operations applicable  to a given type, sharing, and protection of any reference to a given object against improper application  of any of the operations defined with respect to that type of object.  The mechanisms provide a coherent  basis for extension of the system in two directions: the introduction of new facilities, and the creation  of highly secure systems.", "authors": "Wulf, W. Cohen, E. Corwin, W. Jones, A. Levin, R. Pierson, C. Pollack, F.", "words_pool": ["applic", "applic", "basi", "call", "carnegi", "coher", "creation", "deal", "defin", "describ", "design", "direct", "extens", "facil", "gener", "highli", "hydra", "improp", "includ", "introduct", "kernel", "mechan", "mellon", "mini", "mmp", "multi", "multiprocessor", "notion", "object", "object", "oper", "oper", "paper", "philosophi", "physic", "present", "processor", "protect", "provid", "realiz", "refer", "resourc", "respect", "secur", "share", "specif", "system", "system", "type", "type", "virtual", "wulf", "cohen", "corwin", "jone", "levin", "pierson", "pollack"], "word_count": {"applic": 2, "basi": 1, "call": 1, "carnegi": 1, "coher": 1, "creation": 2, "deal": 1, "defin": 1, "describ": 1, "design": 1, "direct": 1, "extens": 1, "facil": 1, "gener": 1, "highli": 1, "hydra": 1, "improp": 1, "includ": 1, "introduct": 2, "kernel": 1, "mechan": 2, "mellon": 1, "mini": 1, "mmp": 1, "multi": 1, "multiprocessor": 1, "notion": 1, "object": 4, "oper": 3, "paper": 1, "philosophi": 2, "physic": 1, "present": 1, "processor": 1, "protect": 1, "provid": 1, "realiz": 1, "refer": 1, "resourc": 1, "respect": 1, "secur": 1, "share": 1, "specif": 1, "system": 3, "type": 3, "virtual": 1, "wulf": 1, "cohen": 1, "corwin": 1, "jone": 1, "levin": 1, "pierson": 1, "pollack": 1}}, "2633": {"id": "2633", "title": "Compact Representation of Contour Plots for Phone Line Transmission", "abstract": "Methods for the compact representation of contour plots are described and tested.  These are  intended to reduce the cost of transmitting contour plots over phone lines.  We feel some of these methods  could be used to transmit contour plots over voice grade phone lines.", "authors": "Adams, J. Gary, J.", "words_pool": ["compact", "contour", "cost", "feel", "grade", "intend", "line", "line", "method", "phone", "plot", "reduc", "represent", "test", "transmiss", "transmit", "transmit", "voic", "adam", "gari"], "word_count": {"compact": 1, "contour": 3, "cost": 1, "feel": 1, "grade": 1, "intend": 1, "line": 2, "method": 2, "phone": 2, "plot": 3, "reduc": 1, "represent": 1, "test": 1, "transmiss": 1, "transmit": 2, "voic": 1, "adam": 1, "gari": 1}}, "2634": {"id": "2634", "title": "An Evaluation of Statistical Software in the Social Sciences", "abstract": "Several hundred college and university computer installations now offer various types of statistical  packages for general use.  Among those most widely available are OSIRIS, SPSS, BMD, DATA-TEXT, and TSAR.   In order to provide users with a basis for selection and use, tests were made for each of these systems,  and the results are summarized as to cost and performance.", "authors": "Slysz, W. D.", "words_pool": ["basi", "bmd", "colleg", "comput", "cost", "data", "evalu", "gener", "hundr", "instal", "made", "offer", "order", "osiri", "packag", "perform", "provid", "result", "scienc", "select", "social", "softwar", "spss", "statist", "summar", "system", "test", "text", "tsar", "type", "univers", "user", "wide", "slysz"], "word_count": {"basi": 1, "bmd": 1, "colleg": 1, "comput": 1, "cost": 1, "data": 1, "evalu": 1, "gener": 1, "hundr": 1, "instal": 1, "made": 1, "offer": 1, "order": 1, "osiri": 1, "packag": 1, "perform": 1, "provid": 1, "result": 1, "scienc": 1, "select": 1, "social": 1, "softwar": 1, "spss": 1, "statist": 1, "summar": 1, "system": 1, "test": 1, "text": 1, "tsar": 1, "type": 1, "univers": 1, "user": 1, "wide": 1, "slysz": 1}}, "2635": {"id": "2635", "title": "Exact Probabilities for R X C Contingency Tables (Algorithm R434)", "authors": "Boulton, D. M.", "words_pool": ["algorithm", "conting", "exact", "probabl", "r434", "tabl", "boulton"], "word_count": {"algorithm": 1, "conting": 1, "exact": 1, "probabl": 1, "r434": 1, "tabl": 1, "boulton": 1}}, "2636": {"id": "2636", "title": "Generation of Random Correlated Normal Variables (Algorithm R425)", "authors": "Page, R. L.", "words_pool": ["algorithm", "correl", "gener", "normal", "r425", "random", "variabl", "page"], "word_count": {"algorithm": 1, "correl": 1, "gener": 1, "normal": 1, "r425": 1, "random": 1, "variabl": 1, "page": 1}}, "2637": {"id": "2637", "title": "Hidden-Line Plotting Program (Algorithm R420)", "authors": "Ellis, T. M. R.", "words_pool": ["algorithm", "hidden", "line", "plot", "program", "r420", "elli"], "word_count": {"algorithm": 1, "hidden": 1, "line": 1, "plot": 1, "program": 1, "r420": 1, "elli": 1}}, "2638": {"id": "2638", "title": "Hidden-Line Plotting Program (Algorithm R420)", "authors": "Gaither, B.", "words_pool": ["algorithm", "hidden", "line", "plot", "program", "r420", "gaither"], "word_count": {"algorithm": 1, "hidden": 1, "line": 1, "plot": 1, "program": 1, "r420": 1, "gaither": 1}}, "2639": {"id": "2639", "title": "Calculation of Fourier Integrals (Algorithm R418)", "authors": "Piessens, R.", "words_pool": ["algorithm", "calcul", "fourier", "integr", "r418", "piessen"], "word_count": {"algorithm": 1, "calcul": 1, "fourier": 1, "integr": 1, "r418": 1, "piessen": 1}}, "2640": {"id": "2640", "title": "Modified Havie Integration (Algorithm R400)", "authors": "Piessens, R.", "words_pool": ["algorithm", "havi", "integr", "modifi", "r400", "piessen"], "word_count": {"algorithm": 1, "havi": 1, "integr": 1, "modifi": 1, "r400": 1, "piessen": 1}}, "2641": {"id": "2641", "title": "A Minimal Spanning Tree clustering Method [Z] (Algorithm A479)", "authors": "Page, R. L.", "words_pool": ["a479", "algorithm", "cluster", "method", "minim", "span", "tree", "page"], "word_count": {"a479": 1, "algorithm": 1, "cluster": 1, "method": 1, "minim": 1, "span": 1, "tree": 1, "page": 1}}, "2642": {"id": "2642", "title": "Solution of an Overdetermined System of Equations in the L1 Norm [F4] (Algorithm A478)", "authors": "Barrodale, I. Roberts, F. D. K.", "words_pool": ["a478", "algorithm", "equat", "f4", "l1", "norm", "overdetermin", "solut", "system", "barrodal", "robert"], "word_count": {"a478": 1, "algorithm": 1, "equat": 1, "f4": 1, "l1": 1, "norm": 1, "overdetermin": 1, "solut": 1, "system": 1, "barrodal": 1, "robert": 1}}, "2643": {"id": "2643", "title": "The Minimization of Spatially-Multiplexed Character Sets", "abstract": "The paper describes a technique for compacting character sets in a digital computer while retaining  fast access to individual bits.  It considers the problem of minimizing the storage needed to contain  such tables.  Reduction techniques are developed, and the problem is shown to reduce to a covering problem.", "authors": "Gimpel, J. F.", "words_pool": ["access", "bit", "charact", "compact", "comput", "consid", "cover", "describ", "develop", "digit", "fast", "individu", "minim", "minim", "multiplex", "need", "paper", "problem", "reduc", "reduct", "retain", "set", "shown", "spatial", "storag", "tabl", "techniqu", "techniqu", "gimpel"], "word_count": {"access": 1, "bit": 1, "charact": 1, "compact": 1, "comput": 1, "consid": 1, "cover": 1, "describ": 1, "develop": 1, "digit": 1, "fast": 1, "individu": 1, "minim": 1, "multiplex": 1, "need": 1, "paper": 1, "problem": 3, "reduc": 1, "reduct": 1, "retain": 1, "set": 1, "shown": 1, "spatial": 1, "storag": 1, "tabl": 1, "techniqu": 2, "gimpel": 1}}, "2644": {"id": "2644", "title": "A Theorem-Proving Language for Experimentation", "abstract": "Because of the large number of strategies and inference rules presently under consideration  in automated theorem proving, there is a need for developing a language especially oriented toward automated  theorem proving.  This paper discusses some of the features and instructions of this language.  The use  of this language permits easy extension of automated theorem-proving programs to include new strategies  and/or new inference rules.  Such extend ability will permit general experimentation with the various  alternative systems.", "authors": "Henschen, L. Overbeek, R. Wos, L.", "words_pool": ["abil", "altern", "autom", "consider", "develop", "discuss", "easi", "especi", "experiment", "extend", "extens", "featur", "gener", "includ", "infer", "instruct", "languag", "larg", "need", "number", "orient", "paper", "permit", "permit", "present", "program", "prove", "rule", "strategi", "system", "theorem", "henschen", "overbeek", "wo"], "word_count": {"abil": 1, "altern": 1, "autom": 3, "consider": 1, "develop": 1, "discuss": 1, "easi": 1, "especi": 1, "experiment": 1, "extend": 1, "extens": 1, "featur": 1, "gener": 1, "includ": 1, "infer": 2, "instruct": 1, "languag": 3, "larg": 1, "need": 1, "number": 1, "orient": 1, "paper": 1, "permit": 2, "present": 1, "program": 1, "prove": 3, "rule": 2, "strategi": 2, "system": 1, "theorem": 3, "henschen": 1, "overbeek": 1, "wo": 1}}, "2645": {"id": "2645", "title": "Two Languages for Estimating Program Efficiency", "abstract": "Two languages enabling their users to estimate the efficiency of computer programs are presented.   The program whose efficiency one wishes to estimate is written in the first language, a go-to-less programming  language which includes most of the features of Algol 60.  The second language consists of interactive  commands enabling its users to provide additional information about the program written in the first  language and to output results estimating its efficiency.  Processors for the two languages are also  described.  The first processor is a syntax-directed translator which compiles a program into a symbolic  formula representing the execution time for that program.  The sound processor is a set of procedures  for that program.  The second processor is a set of procedures for algebraic manipulation which can be  called by the user to operate on the formula produced by the first processor.  Examples of the usage  of the two languages are included.  The limitations of the present system, its relation to Knuth's work  on the analysis of algorithms, and some of the directions for further research are also discussed.", "authors": "CCohen, J. Zuckerman, C.", "words_pool": ["addit", "algebra", "algol", "algorithm", "analysi", "call", "command", "compil", "comput", "consist", "direct", "direct", "discuss", "effici", "enabl", "estim", "estim", "exampl", "execut", "featur", "formula", "includ", "includ", "inform", "interact", "knuth", "languag", "languag", "limit", "manipul", "oper", "output", "present", "present", "procedur", "processor", "processor", "produc", "program", "program", "program", "provid", "relat", "repres", "research", "result", "set", "sound", "symbol", "syntax", "system", "time", "translat", "usag", "user", "user", "wish", "work", "written", "ccohen", "zuckerman"], "word_count": {"addit": 1, "algebra": 1, "algol": 1, "algorithm": 1, "analysi": 1, "call": 1, "command": 1, "compil": 1, "comput": 1, "consist": 1, "direct": 2, "discuss": 1, "effici": 3, "enabl": 2, "estim": 3, "exampl": 1, "execut": 1, "featur": 1, "formula": 2, "includ": 2, "inform": 1, "interact": 1, "knuth": 1, "languag": 7, "limit": 1, "manipul": 1, "oper": 1, "output": 1, "present": 2, "procedur": 2, "processor": 5, "produc": 1, "program": 7, "provid": 1, "relat": 1, "repres": 1, "research": 1, "result": 1, "set": 2, "sound": 1, "symbol": 1, "syntax": 1, "system": 1, "time": 1, "translat": 1, "usag": 1, "user": 3, "wish": 1, "work": 1, "written": 2, "ccohen": 1, "zuckerman": 1}}, "2646": {"id": "2646", "title": "A Model for Masking Rotational Latency by Dynamic Disk Allocation", "abstract": "This paper presents the background and algorithms for masking the rotational latency of a disk  or drum.  It discusses the anticipatory input and output of blocks of data to buffer and primary memories  for a mono-programmed computer system.  A basic permutation algorithm and several variations are given.    Because of the anticipatory nature of the I/O scheduling, these algorithms are restricted to classes  of programs with predictable behavior.  While the methods are not restricted to numerical computations,  matrix and partial differential equation methods are typical examples of their use.  It is shown that  latency may be masked using a small amount of buffer memory.  The methods discussed are independent of  the overall size of the data base being considered.", "authors": "Gold, D. E. Kuck, D. J.", "words_pool": ["algorithm", "algorithm", "alloc", "amount", "anticipatori", "background", "base", "basic", "behavior", "block", "buffer", "class", "comput", "comput", "consid", "data", "differenti", "discuss", "discuss", "disk", "drum", "dynam", "equat", "exampl", "independ", "input", "latenc", "mask", "mask", "matrix", "memori", "memori", "method", "model", "mono", "natur", "numer", "output", "paper", "partial", "permut", "predict", "present", "primari", "program", "program", "restrict", "rotat", "schedul", "shown", "size", "small", "system", "typic", "variat", "gold", "kuck"], "word_count": {"algorithm": 3, "alloc": 1, "amount": 1, "anticipatori": 2, "background": 1, "base": 1, "basic": 1, "behavior": 1, "block": 1, "buffer": 2, "class": 1, "comput": 2, "consid": 1, "data": 2, "differenti": 1, "discuss": 2, "disk": 1, "drum": 1, "dynam": 1, "equat": 1, "exampl": 1, "independ": 1, "input": 1, "latenc": 2, "mask": 2, "matrix": 1, "memori": 2, "method": 3, "model": 1, "mono": 1, "natur": 1, "numer": 1, "output": 1, "paper": 1, "partial": 1, "permut": 1, "predict": 1, "present": 1, "primari": 1, "program": 2, "restrict": 2, "rotat": 1, "schedul": 1, "shown": 1, "size": 1, "small": 1, "system": 1, "typic": 1, "variat": 1, "gold": 1, "kuck": 1}}, "2647": {"id": "2647", "title": "More on Algorithms that Reveal Properties of Floating Point Arithmetic Units", "authors": "Gentleman, W. M. Marovich, S. B.", "words_pool": ["algorithm", "arithmet", "float", "point", "properti", "reveal", "unit", "gentleman", "marovich"], "word_count": {"algorithm": 1, "arithmet": 1, "float": 1, "point": 1, "properti": 1, "reveal": 1, "unit": 1, "gentleman": 1, "marovich": 1}}, "2648": {"id": "2648", "title": "A Design for a Number Theory Package with an Optimized Trial Division routine", "abstract": "A number theory package is described which uses doubly linked list structures for storing multiprecise  integers.  The package has been coded in IBM's Basic Assembly Language and makes heavy use of the macro  language and conditional assembly.  An optimally coded trial division routine is also described which  can be used to determine the unique factorization of large integers.", "authors": "Wunderlich, M. C. Selfridge, J. L.", "words_pool": ["assembl", "basic", "code", "condit", "design", "determin", "divis", "doubli", "factor", "heavi", "ibm", "integ", "languag", "larg", "link", "list", "macro", "make", "multiprecis", "number", "optim", "optim", "packag", "routin", "store", "structur", "theori", "trial", "uniqu", "wunderlich", "selfridg"], "word_count": {"assembl": 2, "basic": 1, "code": 2, "condit": 1, "design": 1, "determin": 1, "divis": 1, "doubli": 1, "factor": 1, "heavi": 1, "ibm": 1, "integ": 2, "languag": 2, "larg": 1, "link": 1, "list": 1, "macro": 1, "make": 1, "multiprecis": 1, "number": 1, "optim": 1, "packag": 2, "routin": 1, "store": 1, "structur": 1, "theori": 1, "trial": 1, "uniqu": 1, "wunderlich": 1, "selfridg": 1}}, "2649": {"id": "2649", "title": "On the Distributions of Significant Digits and Roundoff Errors", "abstract": "Generalized logarithmic law is derived for the distribution of the first t significant digits  of a random digital integer.  This result is then used to determine the distribution of the roundoff  errors in floating-point operations, which is a mixture of uniform and reciprocal distributions.", "authors": "Tsao, N.", "words_pool": ["deriv", "determin", "digit", "digit", "distribut", "distribut", "error", "float", "gener", "integ", "law", "logarithm", "mixtur", "oper", "point", "random", "reciproc", "result", "roundoff", "signific", "uniform", "tsao"], "word_count": {"deriv": 1, "determin": 1, "digit": 2, "distribut": 3, "error": 1, "float": 1, "gener": 1, "integ": 1, "law": 1, "logarithm": 1, "mixtur": 1, "oper": 1, "point": 1, "random": 1, "reciproc": 1, "result": 1, "roundoff": 1, "signific": 1, "uniform": 1, "tsao": 1}}, "2650": {"id": "2650", "title": "Order-n Correction for Regular Languages", "abstract": "A method is presented for calculating a string B, belonging to a given regular language L,  which is \"nearest\" (in number of edit operations) to a given input string a.  B is viewed as a reasonable  \"correction\" for the possibly erroneous string a, where a was originally intended to be a string of L.   The calculation of B by the method presented requires time proportional to |a|, the number of characters  in a.  The method should find applications in information retrieval, artificial intelligence, and spelling  correction systems.", "authors": "Wagner, R. A.", "words_pool": ["applic", "artifici", "belong", "calcul", "calcul", "charact", "correct", "edit", "erron", "find", "inform", "input", "intellig", "intend", "languag", "languag", "method", "nearest", "number", "oper", "order", "origin", "possibl", "present", "proport", "reason", "regular", "requir", "retriev", "spell", "string", "system", "time", "view", "wagner"], "word_count": {"applic": 1, "artifici": 1, "belong": 1, "calcul": 2, "charact": 1, "correct": 2, "edit": 1, "erron": 1, "find": 1, "inform": 1, "input": 1, "intellig": 1, "intend": 1, "languag": 1, "method": 3, "nearest": 1, "number": 2, "oper": 1, "order": 1, "origin": 1, "possibl": 1, "present": 2, "proport": 1, "reason": 1, "regular": 1, "requir": 1, "retriev": 1, "spell": 1, "string": 4, "system": 1, "time": 1, "view": 1, "wagner": 1}}, "2651": {"id": "2651", "title": "The Treatment of Data Types in EL1", "abstract": "In constructing a general purpose programming language, a key issue is providing a sufficient  set of data types and associated operations in a manner that permits both natural problem-oriented notation  and efficient implementation.  The EL1 language contains a number of features specifically designed to  simultaneously satisfy both requirements.  The resulting treatment of data types includes provision for  programmer-defined data types data types and generic routines, programmer control over type conversion,  and very flexible data type behavior, in a context that allows efficient compiled code and compact data  representation.", "authors": "Wegbreit, B.", "words_pool": ["behavior", "code", "compact", "compil", "construct", "context", "control", "convers", "data", "defin", "design", "effici", "el1", "featur", "flexibl", "gener", "gener", "implement", "includ", "issu", "key", "languag", "manner", "natur", "notat", "number", "oper", "orient", "permit", "problem", "programm", "program", "provid", "provis", "purpos", "represent", "requir", "result", "routin", "satisfi", "set", "simultan", "specif", "suffici", "treatment", "type", "type", "wegbreit"], "word_count": {"behavior": 1, "code": 1, "compact": 1, "compil": 1, "construct": 1, "context": 1, "control": 1, "convers": 1, "data": 6, "defin": 1, "design": 1, "effici": 2, "el1": 1, "featur": 1, "flexibl": 1, "gener": 2, "implement": 1, "includ": 1, "issu": 1, "key": 1, "languag": 2, "manner": 1, "natur": 1, "notat": 1, "number": 1, "oper": 1, "orient": 1, "permit": 1, "problem": 1, "programm": 2, "program": 1, "provid": 1, "provis": 1, "purpos": 1, "represent": 1, "requir": 1, "result": 1, "routin": 1, "satisfi": 1, "set": 1, "simultan": 1, "specif": 1, "suffici": 1, "treatment": 1, "type": 6, "wegbreit": 1}}, "2652": {"id": "2652", "title": "Reduction of Compilation Costs Through Language Contraction", "abstract": "Programming languages tailored to particular groups of users can often be constructed by removing unwanted features from a general purpose language.  This paper describes the use of simulation techniques  to predict the savings in compilation cost achievable by such an approach.  The results suggest a function  which describes the effect of changes in the power of a language on the compilation cost of an algorithm  expressed in that language: when features not actually used by the algorithm are removed from the language,  the cost of compiling the algorithm decreases moderately, but when features that are needed are removed,  the compilation cost increases sharply.", "authors": "Shaw, M.", "words_pool": ["achiev", "actual", "algorithm", "approach", "compil", "compil", "construct", "contract", "cost", "cost", "decreas", "describ", "effect", "express", "featur", "function", "gener", "group", "increas", "languag", "languag", "moder", "need", "paper", "power", "predict", "program", "purpos", "reduct", "remov", "remov", "result", "save", "sharpli", "simul", "suggest", "tailor", "techniqu", "unwant", "user", "shaw"], "word_count": {"achiev": 1, "actual": 1, "algorithm": 3, "approach": 1, "compil": 4, "construct": 1, "contract": 1, "cost": 4, "decreas": 1, "describ": 2, "effect": 1, "express": 1, "featur": 3, "function": 1, "gener": 1, "group": 1, "increas": 1, "languag": 5, "moder": 1, "need": 1, "paper": 1, "power": 1, "predict": 1, "program": 1, "purpos": 1, "reduct": 1, "remov": 3, "result": 1, "save": 1, "sharpli": 1, "simul": 1, "suggest": 1, "tailor": 1, "techniqu": 1, "unwant": 1, "user": 1, "shaw": 1}}, "2653": {"id": "2653", "title": "Solution of the Transcendental Equation w*exp(x)=x (Algorithm R443)", "authors": "Einarsson, B.", "words_pool": ["algorithm", "equat", "exp", "r443", "solut", "transcendent", "einarsson"], "word_count": {"algorithm": 1, "equat": 1, "exp": 1, "r443": 1, "solut": 1, "transcendent": 1, "einarsson": 1}}, "2654": {"id": "2654", "title": "Generator of Set-Partitions to Exactly R Subsets [G7] (Algorithm A477)", "authors": "Ehrich, G.", "words_pool": ["a477", "algorithm", "exactli", "g7", "gener", "partit", "set", "subset", "ehrich"], "word_count": {"a477": 1, "algorithm": 1, "exactli": 1, "g7": 1, "gener": 1, "partit": 1, "set": 1, "subset": 1, "ehrich": 1}}, "2655": {"id": "2655", "title": "Six Subprograms for Curve Fitting Using Splines Under Tension [E2] (Algorithm A476)", "authors": "Cline, A. K.", "words_pool": ["a476", "algorithm", "curv", "e2", "fit", "spline", "subprogram", "tension", "cline"], "word_count": {"a476": 1, "algorithm": 1, "curv": 1, "e2": 1, "fit": 1, "spline": 1, "subprogram": 1, "tension": 1, "cline": 1}}, "2656": {"id": "2656", "title": "Scalar- and Planar- Valued Curve Fitting Using Splines Under Tension", "abstract": "The spline under tension was introduced by Schweikert in an attempt to imitate cubic splines  but avoid the spurious critical points they induce.  The defining equations are presented here, together  with an efficient method for determining the necessary parameters and computing the resultant spline.   The standard scalar-valued curve fitting problem is discussed, as well as the fitting of open and closed  curves in the plane.  The use of these curves and the importance of the tension in the fitting of contour  lines are mentioned as application.", "authors": "Cline, A. K.", "words_pool": ["applic", "attempt", "avoid", "close", "comput", "contour", "critic", "cubic", "curv", "curv", "defin", "determin", "discuss", "effici", "equat", "fit", "imit", "import", "induc", "introduc", "line", "mention", "method", "open", "paramet", "planar", "plane", "point", "present", "problem", "result", "scalar", "schweikert", "spline", "spline", "spuriou", "standard", "tension", "valu", "cline"], "word_count": {"applic": 1, "attempt": 1, "avoid": 1, "close": 1, "comput": 1, "contour": 1, "critic": 1, "cubic": 1, "curv": 3, "defin": 1, "determin": 1, "discuss": 1, "effici": 1, "equat": 1, "fit": 3, "imit": 1, "import": 1, "induc": 1, "introduc": 1, "line": 1, "mention": 1, "method": 1, "open": 1, "paramet": 1, "planar": 1, "plane": 1, "point": 1, "present": 1, "problem": 1, "result": 1, "scalar": 1, "schweikert": 1, "spline": 3, "spuriou": 1, "standard": 1, "tension": 2, "valu": 1, "cline": 1}}, "2657": {"id": "2657", "title": "An Improved Program-Synthesizing Algorithm and Its Correctness", "abstract": "An improved program-synthesizing algorithm based on the algorithm proposed by Waldinger and  Lee in 1969 is given.  In the old algorithm, the program-synthesizing problem is translated into a theorem-proving  problem, and a program is obtained by analyzing a proof.  For the improved algorithm, the analysis is  not necessary, and a program is obtained as soon as the proof is completed.  This is achieved by using  a modified variable tracing mechanism invented by Green in 1969.  The correctness of the improved algorithm  is also proved; i.e. the program thus obtained always satisfies the specification.", "authors": "Lee, R. C. T. Chang, C. L. Waldinger, R. J.", "words_pool": ["achiev", "algorithm", "analysi", "analyz", "base", "complet", "correct", "green", "improv", "invent", "lee", "mechan", "modifi", "obtain", "problem", "program", "proof", "propos", "prove", "prove", "satisfi", "soon", "specif", "synthes", "theorem", "trace", "translat", "variabl", "walding", "lee", "chang", "walding"], "word_count": {"achiev": 1, "algorithm": 5, "analysi": 1, "analyz": 1, "base": 1, "complet": 1, "correct": 1, "green": 1, "improv": 3, "invent": 1, "lee": 1, "mechan": 1, "modifi": 1, "obtain": 3, "problem": 2, "program": 5, "proof": 2, "propos": 1, "prove": 2, "satisfi": 1, "soon": 1, "specif": 1, "synthes": 2, "theorem": 1, "trace": 1, "translat": 1, "variabl": 1, "walding": 1, "chang": 1}}, "2658": {"id": "2658", "title": "An Alternative Approach to Mutual Recursion in Algol 60 Using Restricted Compilers", "authors": "Balfour, A.", "words_pool": ["algol", "altern", "approach", "compil", "mutual", "recurs", "restrict", "balfour"], "word_count": {"algol": 1, "altern": 1, "approach": 1, "compil": 1, "mutual": 1, "recurs": 1, "restrict": 1, "balfour": 1}}, "2659": {"id": "2659", "title": "Some Remarks on Lookup of Structured Variables", "authors": "Abrahams, P. W.", "words_pool": ["lookup", "remark", "structur", "variabl", "abraham"], "word_count": {"lookup": 1, "remark": 1, "structur": 1, "variabl": 1, "abraham": 1}}, "2660": {"id": "2660", "title": "Addendum to M. L. Patrick Paper", "authors": "Simmons, G. C.", "words_pool": ["addendum", "paper", "patrick", "simmon"], "word_count": {"addendum": 1, "paper": 1, "patrick": 1, "simmon": 1}}, "2661": {"id": "2661", "title": "Ideal Teaching Machines-A Solution to the Pedagogic Language Problem", "authors": "Sterling, T. D. Pollack, S. V.", "words_pool": ["ideal", "languag", "machin", "pedagog", "problem", "solut", "teach", "sterl", "pollack"], "word_count": {"ideal": 1, "languag": 1, "machin": 1, "pedagog": 1, "problem": 1, "solut": 1, "teach": 1, "sterl": 1, "pollack": 1}}, "2662": {"id": "2662", "title": "Graduate Education: The Ph.D. Glut: Response and Rebuttal", "authors": "Freeman, P. Malcolm, M. A. Payne, W. H.", "words_pool": ["educ", "glut", "graduat", "ph", "rebutt", "respons", "freeman", "malcolm", "payn"], "word_count": {"educ": 1, "glut": 1, "graduat": 1, "ph": 1, "rebutt": 1, "respons": 1, "freeman": 1, "malcolm": 1, "payn": 1}}, "2663": {"id": "2663", "title": "A Study of Computer Use in a Graduate School of Business", "authors": "Lucas, H. C. Jr. Montgomery, D. B. Larreche, J. C.", "words_pool": ["busi", "comput", "graduat", "school", "studi", "luca", "jr", "montgomeri", "larrech"], "word_count": {"busi": 1, "comput": 1, "graduat": 1, "school": 1, "studi": 1, "luca": 1, "jr": 1, "montgomeri": 1, "larrech": 1}}, "2664": {"id": "2664", "title": "Parallelism in Tape-Sorting", "abstract": "Two methods for employing parallelism in tape-sorting are presented.  Method A is the natural  way to use parallelism. Method B is new.  Both approximately achieve the goal of reducing the processing  time by a divisor which is the number of processors.", "authors": "Even, S.", "words_pool": ["achiev", "approxim", "divisor", "employ", "goal", "method", "method", "natur", "number", "parallel", "present", "process", "processor", "reduc", "sort", "tape", "time"], "word_count": {"achiev": 1, "approxim": 1, "divisor": 1, "employ": 1, "goal": 1, "method": 3, "natur": 1, "number": 1, "parallel": 2, "present": 1, "process": 1, "processor": 1, "reduc": 1, "sort": 1, "tape": 1, "time": 1}}, "2665": {"id": "2665", "title": "Copying List Structures Using Bounded Workspace", "abstract": "Two new algorithms are presented for list structure copying using bounded workspace.  The first,  of primarily theoretical interest, shows that without cell tag bits the task can be performed in time  n^2.  The second algorithm, assuming one tag bit in each cell, delivers attractive practical speed.   Any noncyclic structure is copied in linear speed, while cyclic structures are copied in average time  less than nlogn.  No foreknowledge of cycle absence is necessary to achieve linear speed.  A variation  of the second algorithm solves an open problem concerning list structure marking.  That result demonstrates  that marking can be done in average time nlogn without the aid of supplemental tag bits or stacks.", "authors": "Lindstrom, G.", "words_pool": ["absenc", "achiev", "aid", "algorithm", "algorithm", "assum", "attract", "averag", "bit", "bit", "bound", "cell", "concern", "copi", "copi", "cycl", "cyclic", "deliv", "demonstr", "foreknowledg", "interest", "linear", "list", "mark", "nlogn", "noncycl", "open", "perform", "practic", "present", "primarili", "problem", "result", "show", "solv", "speed", "stack", "structur", "structur", "supplement", "tag", "task", "theoret", "time", "variat", "workspac", "lindstrom"], "word_count": {"absenc": 1, "achiev": 1, "aid": 1, "algorithm": 3, "assum": 1, "attract": 1, "averag": 2, "bit": 3, "bound": 1, "cell": 2, "concern": 1, "copi": 3, "cycl": 1, "cyclic": 1, "deliv": 1, "demonstr": 1, "foreknowledg": 1, "interest": 1, "linear": 2, "list": 2, "mark": 2, "nlogn": 2, "noncycl": 1, "open": 1, "perform": 1, "practic": 1, "present": 1, "primarili": 1, "problem": 1, "result": 1, "show": 1, "solv": 1, "speed": 3, "stack": 1, "structur": 4, "supplement": 1, "tag": 3, "task": 1, "theoret": 1, "time": 3, "variat": 1, "workspac": 1, "lindstrom": 1}}, "2666": {"id": "2666", "title": "On Lions' Counter Example for Gotlieb's Method for the Construction of School Timetables", "abstract": "The timetable problem is an essentially discrete problem. Although the discrete problem may  have no feasible solution, there may exist a solution to the equivalent continuous problem.  An example  is given, for which the nondiscrete solution can be interpreted as a set of timetables, differing from  week to week, which together satisfy the long-term requirements of the timetable problem.", "authors": "Smith, G. Sefton, I. M.", "words_pool": ["construct", "continu", "counter", "differ", "discret", "equival", "essenti", "exist", "feasibl", "gotlieb", "interpret", "lion", "long", "method", "nondiscret", "problem", "requir", "satisfi", "school", "set", "solut", "term", "timet", "timet", "week", "smith", "sefton"], "word_count": {"construct": 1, "continu": 1, "counter": 1, "differ": 1, "discret": 2, "equival": 1, "essenti": 1, "exist": 1, "feasibl": 1, "gotlieb": 1, "interpret": 1, "lion": 1, "long": 1, "method": 1, "nondiscret": 1, "problem": 5, "requir": 1, "satisfi": 1, "school": 1, "set": 1, "solut": 3, "term": 1, "timet": 3, "week": 2, "smith": 1, "sefton": 1}}, "2667": {"id": "2667", "title": "Execution Characteristics of Programs in a Page-on-Demand System", "abstract": "Data are presented which show the execution characteristics of two types of commonly used programs  in a large-scale, time-shared computer system.  A software monitoring facility built into the supervisor  was used for data collection during normal system operation.  These data were analyzed, and results of  this analysis are presented for a Fortran compiler and an interactive line file editor.  Probability  distribution functions and other data are given for such things as CPU intervals, I/O intervals, and  the number of such intervals during execution.  Empirical distributions are compared with simple theoretical  distributions (exponential, hyperexponential, and geometric).  Other data show paging characteristics  of tasks as a function of the number of pages those tasks have in core.", "authors": "Boyse, J. W.", "words_pool": ["analysi", "analyz", "built", "characterist", "collect", "commonli", "compar", "compil", "comput", "core", "cpu", "data", "demand", "distribut", "distribut", "editor", "empir", "execut", "exponenti", "facil", "fortran", "function", "function", "geometr", "hyperexponenti", "interact", "interv", "larg", "line", "monitor", "normal", "number", "oper", "page", "page", "page", "present", "probabl", "program", "result", "scale", "share", "show", "simpl", "softwar", "supervisor", "system", "task", "theoret", "thing", "time", "type", "boys"], "word_count": {"analysi": 1, "analyz": 1, "built": 1, "characterist": 2, "collect": 1, "commonli": 1, "compar": 1, "compil": 1, "comput": 1, "core": 1, "cpu": 1, "data": 5, "demand": 1, "distribut": 3, "editor": 1, "empir": 1, "execut": 2, "exponenti": 1, "facil": 1, "fortran": 1, "function": 2, "geometr": 1, "hyperexponenti": 1, "interact": 1, "interv": 3, "larg": 1, "line": 1, "monitor": 1, "normal": 1, "number": 2, "oper": 1, "page": 2, "present": 2, "probabl": 1, "program": 1, "result": 1, "scale": 1, "share": 1, "show": 2, "simpl": 1, "softwar": 1, "supervisor": 1, "system": 2, "task": 2, "theoret": 1, "thing": 1, "time": 1, "type": 1, "boys": 1}}, "2668": {"id": "2668", "title": "Computation of Page Fault Probability from Program Transition Diagram", "abstract": "An algorithm is given for calculating page fault probability in a virtual memory system operating  under demand paging with various memory sizes and replacement rules.  A first order Markov model of program  behavior is assumed, and a representation of the system based on memory states, control states, and memory  substates is presented.  The algorithm is general in the sense that the page fault probabilities can  be calculated for nonpredictive replacement rules applied to any program represented by a one-step Markov  chain.  A detailed example is given to illustrate the algorithm for Random and Least Recently Used (LRU)  replacement rules.", "authors": "Franklin, M. A. Gupta, R. K.", "words_pool": ["algorithm", "appli", "assum", "base", "behavior", "calcul", "calcul", "chain", "comput", "control", "demand", "detail", "diagram", "fault", "gener", "illustr", "lru", "markov", "memori", "model", "nonpredict", "oper", "order", "page", "page", "present", "probabl", "probabl", "program", "random", "recent", "replac", "represent", "repres", "rule", "sens", "size", "state", "step", "substat", "system", "transit", "virtual", "franklin", "gupta"], "word_count": {"algorithm": 3, "appli": 1, "assum": 1, "base": 1, "behavior": 1, "calcul": 2, "chain": 1, "comput": 1, "control": 1, "demand": 1, "detail": 1, "diagram": 1, "fault": 2, "gener": 1, "illustr": 1, "lru": 1, "markov": 2, "memori": 4, "model": 1, "nonpredict": 1, "oper": 1, "order": 1, "page": 3, "present": 1, "probabl": 2, "program": 2, "random": 1, "recent": 1, "replac": 3, "represent": 1, "repres": 1, "rule": 3, "sens": 1, "size": 1, "state": 2, "step": 1, "substat": 1, "system": 2, "transit": 1, "virtual": 1, "franklin": 1, "gupta": 1}}, "2669": {"id": "2669", "title": "A Simple Linear Model of Demand Paging Performance", "abstract": "Predicting the performance of a proposed automatically managed multilevel memory system requires  a model of the patterns by which programs refer to the information stored in the memory.  Some recent  experimental measurements on the Multics virtual memory suggest that, for rough approximations, a remarkably  simple program reference model will suffice.  The simple model combines the effect of the information  reference pattern with the effect of the automatic management algorithm to produce a single, composite  statement: the mean number of memory references between paging exceptions increases linearly with the  size of the paging memory.  The resulting model is easy to manipulate, and is applicable to such diverse  problems as choosing an optimum size for a paging memory, arranging for reproducible memory usage charges,  and estimating the amount of core memory sharing.", "authors": "Saltzer, J. H.", "words_pool": ["algorithm", "amount", "applic", "approxim", "arrang", "automat", "charg", "choos", "combin", "composit", "core", "demand", "divers", "easi", "effect", "estim", "except", "experiment", "increas", "inform", "linear", "linearli", "manag", "manag", "manipul", "mean", "measur", "memori", "model", "multic", "multilevel", "number", "optimum", "page", "pattern", "pattern", "perform", "predict", "problem", "produc", "program", "program", "propos", "recent", "refer", "refer", "refer", "remark", "reproduc", "requir", "result", "rough", "share", "simpl", "singl", "size", "statement", "store", "suffic", "suggest", "system", "usag", "virtual", "saltzer"], "word_count": {"algorithm": 1, "amount": 1, "applic": 1, "approxim": 1, "arrang": 1, "automat": 1, "charg": 1, "choos": 1, "combin": 1, "composit": 1, "core": 1, "demand": 1, "divers": 1, "easi": 1, "effect": 2, "estim": 1, "except": 1, "experiment": 1, "increas": 1, "inform": 2, "linear": 1, "linearli": 1, "manag": 2, "manipul": 1, "mean": 1, "measur": 1, "memori": 8, "model": 4, "multic": 1, "multilevel": 1, "number": 1, "optimum": 1, "page": 3, "pattern": 2, "perform": 1, "predict": 1, "problem": 1, "produc": 1, "program": 2, "propos": 1, "recent": 1, "refer": 4, "remark": 1, "reproduc": 1, "requir": 1, "result": 1, "rough": 1, "share": 1, "simpl": 2, "singl": 1, "size": 2, "statement": 1, "store": 1, "suffic": 1, "suggest": 1, "system": 1, "usag": 1, "virtual": 1, "saltzer": 1}}, "2670": {"id": "2670", "title": "Efficient Implementation of a Variable Projection Algorithm for Nonlinear Least Squares Problems", "abstract": "Nonlinear least squares frequently arise for which the variables to be solved for can be separated  into a linear and a nonlinear part.  A variable projection algorithm has been developed recently which  is designed to take advantage of the structure of a problem whose variables separate in this way.  This  paper gives a slightly more efficient and slightly more general version of this algorithm than has appeared  earlier.", "authors": "Krogh, F. T.", "words_pool": ["advantag", "algorithm", "appear", "aris", "design", "develop", "earlier", "effici", "frequent", "gener", "implement", "linear", "nonlinear", "paper", "part", "problem", "problem", "project", "recent", "separ", "separ", "slightli", "solv", "squar", "structur", "take", "variabl", "variabl", "version", "krogh"], "word_count": {"advantag": 1, "algorithm": 2, "appear": 1, "aris": 1, "design": 1, "develop": 1, "earlier": 1, "effici": 1, "frequent": 1, "gener": 1, "implement": 1, "linear": 1, "nonlinear": 2, "paper": 1, "part": 1, "problem": 1, "project": 1, "recent": 1, "separ": 2, "slightli": 2, "solv": 1, "squar": 1, "structur": 1, "take": 1, "variabl": 3, "version": 1, "krogh": 1}}, "2671": {"id": "2671", "title": "A Note on a Combinatorial Problem of Burnett and Coffman", "authors": "Stone, H. S.", "words_pool": ["burnett", "coffman", "combinatori", "note", "problem", "stone"], "word_count": {"burnett": 1, "coffman": 1, "combinatori": 1, "note": 1, "problem": 1, "stone": 1}}, "2672": {"id": "2672", "title": "Emotional Content Considered Dangerous", "authors": "Smoliar, S. W.", "words_pool": ["consid", "content", "danger", "emot", "smoliar"], "word_count": {"consid": 1, "content": 1, "danger": 1, "emot": 1, "smoliar": 1}}, "2673": {"id": "2673", "title": "Quadratic Search for Hash Tables of Size p^n", "authors": "Ackerman, A. F.", "words_pool": ["hash", "quadrat", "search", "size", "tabl", "ackerman"], "word_count": {"hash": 1, "quadrat": 1, "search": 1, "size": 1, "tabl": 1, "ackerman": 1}}, "2674": {"id": "2674", "title": "Scan Conversion Algorithms for a Cell Organized Raster Display", "abstract": "Raster scan computer graphics with \"real time\" character generators have previously been limited  to alphanumeric characters.  A display has been described which extends the capabilities of this organization  to include general graphics.  Two fundamentally different scan conversion algorithms which have been  developed to support this display are presented.  One is most suitable to non-interactive applications  and the other to interactive applications.  The algorithms were implemented in Fortran on the CDC 6400  computer.  Results obtained from the implementations show that the noninteractive algorithms can significantly  reduce display file storage requirements at little cost in execution time over that of a conventional  raster display.  The interactive algorithm can improve response time and reduce storage requirements.", "authors": "Barrett, R. C. Fordan, B. W. Jr.", "words_pool": ["algorithm", "algorithm", "alphanumer", "applic", "capabl", "cdc", "cell", "charact", "charact", "comput", "convent", "convers", "cost", "develop", "display", "execut", "extend", "fortran", "fundament", "gener", "gener", "graphic", "implement", "implement", "improv", "includ", "interact", "limit", "non", "noninteract", "obtain", "organ", "organ", "present", "previous", "raster", "real", "reduc", "requir", "respons", "result", "scan", "show", "significantli", "storag", "suitabl", "support", "time", "barrett", "fordan", "jr"], "word_count": {"algorithm": 4, "alphanumer": 1, "applic": 2, "capabl": 1, "cdc": 1, "cell": 1, "charact": 2, "comput": 2, "convent": 1, "convers": 1, "cost": 1, "develop": 1, "display": 4, "execut": 1, "extend": 1, "fortran": 1, "fundament": 1, "gener": 2, "graphic": 2, "implement": 2, "improv": 1, "includ": 1, "interact": 3, "limit": 1, "non": 1, "noninteract": 1, "obtain": 1, "organ": 1, "present": 1, "previous": 1, "raster": 2, "real": 1, "reduc": 2, "requir": 2, "respons": 1, "result": 1, "scan": 2, "show": 1, "significantli": 1, "storag": 2, "suitabl": 1, "support": 1, "time": 3, "barrett": 1, "fordan": 1, "jr": 1}}, "2675": {"id": "2675", "title": "A Computer Routine for Quadratic and Linear Programming Problems (Algorithm R431)", "authors": "Ravindran, A.", "words_pool": ["algorithm", "comput", "linear", "problem", "program", "quadrat", "r431", "routin", "ravindran"], "word_count": {"algorithm": 1, "comput": 1, "linear": 1, "problem": 1, "program": 1, "quadrat": 1, "r431": 1, "routin": 1, "ravindran": 1}}, "2676": {"id": "2676", "title": "Zeros of a Complex Polynomial (Algorithm R419)", "authors": "Withers, D. H.", "words_pool": ["algorithm", "complex", "polynomi", "r419", "zero", "wither"], "word_count": {"algorithm": 1, "complex": 1, "polynomi": 1, "r419": 1, "zero": 1, "wither": 1}}, "2677": {"id": "2677", "title": "Incomplete Beta Ratio (Algorithm R179)", "authors": "Bosten, N. E. Battiste, E. L.", "words_pool": ["algorithm", "beta", "incomplet", "r179", "ratio", "bosten", "battist"], "word_count": {"algorithm": 1, "beta": 1, "incomplet": 1, "r179": 1, "ratio": 1, "bosten": 1, "battist": 1}}, "2678": {"id": "2678", "title": "Visible Surface Plotting Program [J6] (Algorithm A475)", "authors": "Wright, T.", "words_pool": ["a475", "algorithm", "j6", "plot", "program", "surfac", "visibl", "wright"], "word_count": {"a475": 1, "algorithm": 1, "j6": 1, "plot": 1, "program": 1, "surfac": 1, "visibl": 1, "wright": 1}}, "2679": {"id": "2679", "title": "Some Performance Tests of \"quicksort\" and Descendants", "abstract": "Detailed performance evaluations are presented for six ACM algorithms: quicksort (No. 64),  Shellsort (No. 201), stringsort (No. 207), \"TREESORT3\" (No. 245), quickersort (No. 271), and qsort (No.  402).  Algorithms 271 and 402 are refinements of algorithm 64, and all three are discussed in some detail.   The evidence given here demonstrates that qsort (No. 402) requires many more comparisons than its author  claims.  Of all these algorithms, quickersort requires the fewest comparisons to sort random arrays.", "authors": "Loeser, R.", "words_pool": ["acm", "algorithm", "algorithm", "array", "author", "claim", "comparison", "demonstr", "descend", "detail", "detail", "discuss", "evalu", "evid", "fewest", "perform", "present", "qsort", "quickersort", "quicksort", "random", "refin", "requir", "shellsort", "sort", "stringsort", "test", "treesort3", "loeser"], "word_count": {"acm": 1, "algorithm": 4, "array": 1, "author": 1, "claim": 1, "comparison": 2, "demonstr": 1, "descend": 1, "detail": 2, "discuss": 1, "evalu": 1, "evid": 1, "fewest": 1, "perform": 1, "present": 1, "qsort": 2, "quickersort": 2, "quicksort": 1, "random": 1, "refin": 1, "requir": 2, "shellsort": 1, "sort": 1, "stringsort": 1, "test": 1, "treesort3": 1, "loeser": 1}}, "2680": {"id": "2680", "title": "Optimal Space Allocation on Disk Storage Devices", "abstract": "When the amount of space required for file storage exceeds the amount which can be kept on-line,  decisions must be made as to which files are to be permanently resident and which mountable.  These decisions  will affect the number of mount requests issued to the operators.  This is often a bottleneck in a computing  facility, and reducing the number of mounts thus decreases turnaround time.  An optimization model for  the assignment of files to disk packs, and packs to either resident or nonresident status is presented.   Heuristics are suggested for those cases in which it is inefficient to compute the actual optimum.", "authors": "Morgan, H. L.", "words_pool": ["actual", "affect", "alloc", "amount", "assign", "bottleneck", "case", "comput", "comput", "decis", "decreas", "devic", "disk", "exce", "facil", "heurist", "ineffici", "issu", "line", "made", "model", "mount", "mountabl", "mount", "nonresid", "number", "oper", "optim", "optim", "optimum", "pack", "perman", "present", "reduc", "request", "requir", "resid", "space", "statu", "storag", "suggest", "time", "turnaround", "morgan"], "word_count": {"actual": 1, "affect": 1, "alloc": 1, "amount": 2, "assign": 1, "bottleneck": 1, "case": 1, "comput": 2, "decis": 2, "decreas": 1, "devic": 1, "disk": 1, "exce": 1, "facil": 1, "heurist": 1, "ineffici": 1, "issu": 1, "line": 1, "made": 1, "model": 1, "mount": 2, "mountabl": 1, "nonresid": 1, "number": 2, "oper": 1, "optim": 1, "optimum": 1, "pack": 2, "perman": 1, "present": 1, "reduc": 1, "request": 1, "requir": 1, "resid": 2, "space": 1, "statu": 1, "storag": 1, "suggest": 1, "time": 1, "turnaround": 1, "morgan": 1}}, "2681": {"id": "2681", "title": "Dynamic Memory Repacking", "abstract": "A probabilistic model of a multiprogramming system is exercised in order to determine the conditions  under which the dynamic repacking of main memory is beneficial.  An expression is derived for the maximum  interference that a repacking process may introduce before the original performance of the system is  degraded.  Alternative approaches to repacking are discussed, and the operating conditions that lead  to improved system throughput through repacking are delineated.", "authors": "Balkovich, E. Chiu, W. Presser, L. Wood, R.", "words_pool": ["altern", "approach", "benefici", "condit", "degrad", "delin", "deriv", "determin", "discuss", "dynam", "exercis", "express", "improv", "interfer", "introduc", "lead", "main", "maximum", "memori", "model", "multiprogram", "oper", "order", "origin", "perform", "probabilist", "process", "repack", "system", "throughput", "balkovich", "chiu", "presser", "wood"], "word_count": {"altern": 1, "approach": 1, "benefici": 1, "condit": 2, "degrad": 1, "delin": 1, "deriv": 1, "determin": 1, "discuss": 1, "dynam": 1, "exercis": 1, "express": 1, "improv": 1, "interfer": 1, "introduc": 1, "lead": 1, "main": 1, "maximum": 1, "memori": 1, "model": 1, "multiprogram": 1, "oper": 1, "order": 1, "origin": 1, "perform": 1, "probabilist": 1, "process": 1, "repack": 4, "system": 3, "throughput": 1, "balkovich": 1, "chiu": 1, "presser": 1, "wood": 1}}, "2682": {"id": "2682", "title": "On the Construction of a Representative Synthetic Workload", "abstract": "A general method of constructing a drive workload representative of a real workload is described.  The real workload is characterized by its demands on the various system resources.  These characteristics  of the real workload are obtained from the system accounting data. The characteristics of the drive workload  are determined by matching the joint probability density of the real workload with that of the drive  workload.  The drive workload is realized by using a synthetic program in which the characteristics can  be varied by varying the appropriate parameters. Calibration experiments are conducted to determine expressions  relating the synthetic program parameters with the workload characteristics.  The general method is applied  to the case of two variables, cpu seconds and number of I/O activities; and synthetic workload with 88  jobs is constructed to represent a month's workload consisting of about 6000 jobs.", "authors": "Sreenivasan, K. Kleinman, A. J.", "words_pool": ["account", "activ", "appli", "calibr", "case", "characterist", "character", "conduct", "consist", "construct", "construct", "construct", "cpu", "data", "demand", "densiti", "determin", "determin", "drive", "experi", "express", "gener", "job", "joint", "match", "method", "month", "number", "obtain", "paramet", "probabl", "program", "real", "realiz", "relat", "repres", "repres", "resourc", "second", "synthet", "system", "variabl", "vari", "vari", "workload", "sreenivasan", "kleinman"], "word_count": {"account": 1, "activ": 1, "appli": 1, "calibr": 1, "case": 1, "characterist": 4, "character": 1, "conduct": 1, "consist": 1, "construct": 2, "cpu": 1, "data": 1, "demand": 1, "densiti": 1, "determin": 2, "drive": 4, "experi": 1, "express": 1, "gener": 2, "job": 2, "joint": 1, "match": 1, "method": 2, "month": 1, "number": 1, "obtain": 1, "paramet": 2, "probabl": 1, "program": 2, "real": 4, "realiz": 1, "relat": 1, "repres": 2, "resourc": 1, "second": 1, "synthet": 3, "system": 2, "variabl": 1, "vari": 2, "workload": 11, "sreenivasan": 1, "kleinman": 1}}, "2683": {"id": "2683", "title": "The Synthesis of Loop Predicates", "abstract": "Current methods for mechanical program verification require a complete predicate specification  on each loop.  Because this is tedious and error prone, producing a program with complete, correct predicates  is reasonably difficult and would be facilitated by machine assistance.  This paper discusses techniques  for mechanically synthesizing loop predicates.  Two classes of techniques are considered: (1) heuristic  methods which derive loop predicates from boundary conditions and/or partially specified inductive assertions:  (2) extraction methods which use input predicates and appropriate weak interpretations to obtain certain  classes of loop predicates by an evaluation on the weak interpretation.", "authors": "Wegbreit, B.", "words_pool": ["assert", "assist", "boundari", "class", "complet", "condit", "consid", "correct", "deriv", "difficult", "discuss", "error", "evalu", "extract", "facilit", "heurist", "induct", "input", "interpret", "interpret", "loop", "machin", "mechan", "mechan", "method", "obtain", "paper", "partial", "predic", "predic", "produc", "program", "prone", "reason", "requir", "specif", "synthesi", "synthes", "techniqu", "tediou", "verif", "weak", "wegbreit"], "word_count": {"assert": 1, "assist": 1, "boundari": 1, "class": 2, "complet": 2, "condit": 1, "consid": 1, "correct": 1, "deriv": 1, "difficult": 1, "discuss": 1, "error": 1, "evalu": 1, "extract": 1, "facilit": 1, "heurist": 1, "induct": 1, "input": 1, "interpret": 2, "loop": 4, "machin": 1, "mechan": 2, "method": 3, "obtain": 1, "paper": 1, "partial": 1, "predic": 6, "produc": 1, "program": 2, "prone": 1, "reason": 1, "requir": 1, "specif": 1, "synthesi": 1, "synthes": 1, "techniqu": 2, "tediou": 1, "verif": 1, "weak": 2, "wegbreit": 1}}, "2684": {"id": "2684", "title": "Production Systems: or Can We Do Better than BNF?", "abstract": "Since the development of BNF, the definition of the syntax of programming languages has been  almost universally associated with context-free requirements.  Yet numerous interesting and difficult  issues in syntax stem from the context-sensitive requirements, notably the compatibility between the  declaration of an identifier and its uses, the correspondence between actual and formal parameters, and  issues arising from block structure.  This paper explores the use of a formal notation called Production  Systems in providing a readable and complete formal definition of syntax.  As a practical illustration,  a small but significant subset of PL/I is considered.  A more detailed presentation, as well as the application  to define abstract syntax and translations between languages, is given in a previous paper by the author.", "authors": "Ledgard, H. F.", "words_pool": ["abstract", "actual", "applic", "aris", "author", "block", "bnf", "call", "compat", "complet", "consid", "context", "correspond", "declar", "defin", "definit", "detail", "develop", "difficult", "explor", "formal", "free", "identifi", "illustr", "interest", "issu", "languag", "notabl", "notat", "numer", "paper", "paramet", "pl", "practic", "present", "previou", "product", "program", "provid", "readabl", "requir", "sensit", "signific", "small", "stem", "structur", "subset", "syntax", "system", "translat", "univers", "ledgard"], "word_count": {"abstract": 1, "actual": 1, "applic": 1, "aris": 1, "author": 1, "block": 1, "bnf": 1, "call": 1, "compat": 1, "complet": 1, "consid": 1, "context": 2, "correspond": 1, "declar": 1, "defin": 1, "definit": 2, "detail": 1, "develop": 1, "difficult": 1, "explor": 1, "formal": 3, "free": 1, "identifi": 1, "illustr": 1, "interest": 1, "issu": 2, "languag": 2, "notabl": 1, "notat": 1, "numer": 1, "paper": 2, "paramet": 1, "pl": 1, "practic": 1, "present": 1, "previou": 1, "product": 1, "program": 1, "provid": 1, "readabl": 1, "requir": 2, "sensit": 1, "signific": 1, "small": 1, "stem": 1, "structur": 1, "subset": 1, "syntax": 4, "system": 1, "translat": 1, "univers": 1, "ledgard": 1}}, "2685": {"id": "2685", "title": "The Parallel Execution of DO Loops", "abstract": "Methods are developed for the parallel execution of different iterations of a DO loop.  Both  asynchronous multiprocessor computers and array computers are considered.  Practical application to the  design of compilers for such computers is discussed.", "authors": "Lamport, L.", "words_pool": ["applic", "array", "asynchron", "compil", "comput", "consid", "design", "develop", "discuss", "execut", "iter", "loop", "loop", "method", "multiprocessor", "parallel", "practic", "lamport"], "word_count": {"applic": 1, "array": 1, "asynchron": 1, "compil": 1, "comput": 3, "consid": 1, "design": 1, "develop": 1, "discuss": 1, "execut": 1, "iter": 1, "loop": 1, "method": 1, "multiprocessor": 1, "parallel": 1, "practic": 1, "lamport": 1}}, "2686": {"id": "2686", "title": "An Approximate Method for Generating Asymmetric Random Variables", "abstract": "Tukey's lambda distribution is generalized to provide an algorithm for generating values of  unimodal asymmetric random variables.  This algorithm has the same advantages as the symmetric random  variable generator previously given by the authors, except that the addition of another parameter complicates the problem of finding the parameter values to fit a distribution.", "authors": "Ramberg, J. S. Schmeiser,B. W.", "words_pool": ["addit", "advantag", "algorithm", "approxim", "asymmetr", "author", "complic", "distribut", "find", "fit", "gener", "gener", "gener", "lambda", "method", "paramet", "previous", "problem", "provid", "random", "symmetr", "tukey", "unimod", "valu", "variabl", "variabl", "ramberg", "schmeiser"], "word_count": {"addit": 1, "advantag": 1, "algorithm": 2, "approxim": 1, "asymmetr": 1, "author": 1, "complic": 1, "distribut": 2, "find": 1, "fit": 1, "gener": 3, "lambda": 1, "method": 1, "paramet": 2, "previous": 1, "problem": 1, "provid": 1, "random": 2, "symmetr": 1, "tukey": 1, "unimod": 1, "valu": 2, "variabl": 2, "ramberg": 1, "schmeiser": 1}}, "2687": {"id": "2687", "title": "A Cell Organized Raster Display for Line Drawings", "abstract": "Raster scan computer graphics displays with \"real time\" character generators have previously  been limited to alphanumeric characters.  A display is described which extends the capabilities of this  organization to include general graphics.  The feasibility of such a display is shown by deriving the  minimum number of patterns required in the read only memory of the character generator to synthesize  an arbitrary line.  The synthesis process does not compromise picture quality since the resulting dot  patterns are identical with those of a conventional raster display.  Furthermore, the time constraints  of a raster display are shown to be satisfied for a typical design for very complex line drawings.", "authors": "Jordan, B. W. Jr. Barrett, R. C.", "words_pool": ["alphanumer", "arbitrari", "capabl", "cell", "charact", "charact", "complex", "compromis", "comput", "constraint", "convent", "deriv", "design", "display", "display", "dot", "draw", "extend", "feasibl", "gener", "gener", "gener", "graphic", "ident", "includ", "limit", "line", "memori", "minimum", "number", "organ", "organ", "pattern", "pictur", "previous", "process", "qualiti", "raster", "read", "real", "requir", "result", "satisfi", "scan", "shown", "synthesi", "synthes", "time", "typic", "jordan", "jr", "barrett"], "word_count": {"alphanumer": 1, "arbitrari": 1, "capabl": 1, "cell": 1, "charact": 3, "complex": 1, "compromis": 1, "comput": 1, "constraint": 1, "convent": 1, "deriv": 1, "design": 1, "display": 5, "dot": 1, "draw": 1, "extend": 1, "feasibl": 1, "gener": 3, "graphic": 2, "ident": 1, "includ": 1, "limit": 1, "line": 2, "memori": 1, "minimum": 1, "number": 1, "organ": 1, "pattern": 2, "pictur": 1, "previous": 1, "process": 1, "qualiti": 1, "raster": 3, "read": 1, "real": 1, "requir": 1, "result": 1, "satisfi": 1, "scan": 1, "shown": 2, "synthesi": 1, "synthes": 1, "time": 2, "typic": 1, "jordan": 1, "jr": 1, "barrett": 1}}, "2688": {"id": "2688", "title": "Attribute Based File Organization in a Paged Memory Environment", "abstract": "The high cost of page accessing implies a need for more careful data organization in a paged  memory than is typical of most inverted file and similar approaches to multi-key retrieval.  This article  analyses that cost and proposes a method called multiple key hashing which attempts to minimize it.   Since this approach is not always preferable to inversion, a combined method is described.  The exact  specifications of this combination for a file with given data and traffic characteristics is formulated  as a mathematical program.  The proposed heuristic solution to this program can often improve on a simple  inversion technique by a factor of 2 or 3.", "authors": "Rothnie, J. B. Jr. Lozano, T.", "words_pool": ["access", "analys", "approach", "approach", "articl", "attempt", "attribut", "base", "call", "care", "characterist", "combin", "combin", "cost", "data", "environ", "exact", "factor", "formul", "hash", "heurist", "high", "impli", "improv", "invers", "invert", "key", "mathemat", "memori", "method", "minim", "multi", "multipl", "need", "organ", "page", "page", "prefer", "program", "propos", "propos", "retriev", "similar", "simpl", "solut", "specif", "techniqu", "traffic", "typic", "rothni", "jr", "lozano"], "word_count": {"access": 1, "analys": 1, "approach": 2, "articl": 1, "attempt": 1, "attribut": 1, "base": 1, "call": 1, "care": 1, "characterist": 1, "combin": 2, "cost": 2, "data": 2, "environ": 1, "exact": 1, "factor": 1, "formul": 1, "hash": 1, "heurist": 1, "high": 1, "impli": 1, "improv": 1, "invers": 2, "invert": 1, "key": 2, "mathemat": 1, "memori": 1, "method": 2, "minim": 1, "multi": 1, "multipl": 1, "need": 1, "organ": 1, "page": 2, "prefer": 1, "program": 2, "propos": 2, "retriev": 1, "similar": 1, "simpl": 1, "solut": 1, "specif": 1, "techniqu": 1, "traffic": 1, "typic": 1, "rothni": 1, "jr": 1, "lozano": 1}}, "2689": {"id": "2689", "title": "A CRT Report Generating System", "authors": "Lucas, H. C. Jr.", "words_pool": ["crt", "gener", "report", "system", "luca", "jr"], "word_count": {"crt": 1, "gener": 1, "report": 1, "system": 1, "luca": 1, "jr": 1}}, "2690": {"id": "2690", "title": "A Numbering Systems for Combinations", "authors": "Knott, G. D.", "words_pool": ["combin", "number", "system", "knott"], "word_count": {"combin": 1, "number": 1, "system": 1, "knott": 1}}, "2691": {"id": "2691", "title": "Comments on the Algorithms of Verhelst for the Conversion of Limited-Entry Decision Tables to  Flowcharts", "authors": "King, P. J. H. Johnson, R. G.", "words_pool": ["algorithm", "comment", "convers", "decis", "entri", "flowchart", "limit", "tabl", "verhelst", "king", "johnson"], "word_count": {"algorithm": 1, "comment": 1, "convers": 1, "decis": 1, "entri": 1, "flowchart": 1, "limit": 1, "tabl": 1, "verhelst": 1, "king": 1, "johnson": 1}}, "2692": {"id": "2692", "title": "Reentrant Polygon Clipping", "abstract": "A new family of clipping algorithms is described.  These algorithms are able to clip polygons  against irregular convex plane-faced volumes in three dimensions, removing the parts of the polygon which  lie outside the volume.  In two dimensions the algorithms permit clipping against irregular convex windows.   Polygons to be clipped are represented as an ordered sequence of vertices without repetition of first  and last, in marked contrast to representation as a collection of edges as was heretofore the common  procedure.  Output polygons have an identical format, with new vertices introduced in sequence to describe  any newly-cut edge or edges.  The algorithms easily handle the particularly difficult problem of detecting  that a new vertex may be required at a corner of the clipping window.  The algorithms described achieve  considerable simplicity by clipping separately against each clipping plane or window boundary.  Code  capable of clipping the polygon against a single boundary is reentered to clip against subsequent boundaries.   Each such reentrant stage of clipping need store only two vertex values and may begin its processing  as soon as the first output vertex from the proceeding stage is ready.  Because the same code is reentered  for clipping against subsequent boundaries, clipping against very complex window shapes is practical.   For perspective applications in three dimentions, a six-plane truncated pyramid is chosen as the clipping  volume.  The two additional planes parallel to the projection screen serve to limit the range of depth  preserved through the projection.  A perspective projection method which provides for arbitrary view  angles and depth of field in spite of simple fixed clipping planes is described.  This method is ideal  for subsequent hidden-surface computations.", "authors": "Sutherland, I. E. Hodgman, G. W.", "words_pool": ["abl", "achiev", "addit", "algorithm", "angl", "applic", "arbitrari", "begin", "boundari", "boundari", "capabl", "chosen", "clip", "clip", "clip", "code", "collect", "common", "complex", "comput", "consider", "contrast", "convex", "corner", "cut", "depth", "describ", "detect", "difficult", "dimens", "diment", "easili", "edg", "edg", "face", "famili", "field", "fix", "format", "handl", "heretofor", "hidden", "ideal", "ident", "introduc", "irregular", "lie", "limit", "mark", "method", "need", "newli", "order", "output", "parallel", "part", "permit", "perspect", "plane", "plane", "polygon", "polygon", "practic", "preserv", "problem", "procedur", "proceed", "process", "project", "pyramid", "rang", "readi", "reenter", "reentrant", "remov", "repetit", "represent", "repres", "requir", "screen", "separ", "sequenc", "serv", "shape", "simpl", "simplic", "singl", "soon", "spite", "stage", "store", "subsequ", "surfac", "truncat", "valu", "vertex", "vertic", "view", "volum", "volum", "window", "window", "sutherland", "hodgman"], "word_count": {"abl": 1, "achiev": 1, "addit": 1, "algorithm": 5, "angl": 1, "applic": 1, "arbitrari": 1, "begin": 1, "boundari": 4, "capabl": 1, "chosen": 1, "clip": 14, "code": 2, "collect": 1, "common": 1, "complex": 1, "comput": 1, "consider": 1, "contrast": 1, "convex": 2, "corner": 1, "cut": 1, "depth": 2, "describ": 1, "detect": 1, "difficult": 1, "dimens": 2, "diment": 1, "easili": 1, "edg": 3, "face": 1, "famili": 1, "field": 1, "fix": 1, "format": 1, "handl": 1, "heretofor": 1, "hidden": 1, "ideal": 1, "ident": 1, "introduc": 1, "irregular": 2, "lie": 1, "limit": 1, "mark": 1, "method": 2, "need": 1, "newli": 1, "order": 1, "output": 2, "parallel": 1, "part": 1, "permit": 1, "perspect": 2, "plane": 5, "polygon": 5, "practic": 1, "preserv": 1, "problem": 1, "procedur": 1, "proceed": 1, "process": 1, "project": 3, "pyramid": 1, "rang": 1, "readi": 1, "reenter": 2, "reentrant": 1, "remov": 1, "repetit": 1, "represent": 1, "repres": 1, "requir": 1, "screen": 1, "separ": 1, "sequenc": 2, "serv": 1, "shape": 1, "simpl": 1, "simplic": 1, "singl": 1, "soon": 1, "spite": 1, "stage": 2, "store": 1, "subsequ": 3, "surfac": 1, "truncat": 1, "valu": 1, "vertex": 3, "vertic": 2, "view": 1, "volum": 3, "window": 4, "sutherland": 1, "hodgman": 1}}, "2693": {"id": "2693", "title": "Bivariate Interpolation and Smooth Surface Fitting Based on Local Procedures [E2] (Algorithm  A474)", "authors": "Akima, H.", "words_pool": ["a474", "algorithm", "base", "bivari", "e2", "fit", "interpol", "local", "procedur", "smooth", "surfac", "akima"], "word_count": {"a474": 1, "algorithm": 1, "base": 1, "bivari": 1, "e2": 1, "fit": 1, "interpol": 1, "local": 1, "procedur": 1, "smooth": 1, "surfac": 1, "akima": 1}}, "2694": {"id": "2694", "title": "Computation of Legendre Series Coefficients [C6] (Algorithm A473)", "authors": "Piessens, R.", "words_pool": ["a473", "algorithm", "c6", "coeffici", "comput", "legendr", "seri", "piessen"], "word_count": {"a473": 1, "algorithm": 1, "c6": 1, "coeffici": 1, "comput": 1, "legendr": 1, "seri": 1, "piessen": 1}}, "2695": {"id": "2695", "title": "Tridiagonalization by Permutations", "abstract": "Tridiagonalizing a matrix by similarity transformations is an important computational tool  in numerical linear algebra. Consider the class of sparse matrices which can be tridiagonalized using  only row and corresponding column permutations.  The advantages of using such a transformation include  the absence of round-off errors and improved computation time when compared with standard transformations.   A graph theoretic algorithm which examines an arbitrary n x n matrix and determines whether or not it  can be permuted into tridiagonal form is given.  The algorithm requires no arithmetic while the number  of comparisons, the number of assignments, and the number of increments are linear in n.  This compares  very favorably with standard transformation methods.  If the matrix is permutable into tridiagonal form,  the algorithm gives the explicit tridiagonal form.  Otherwise, early rejection will occur.", "authors": "Gibbs, N. E. Poole, W. G. Jr.", "words_pool": ["absenc", "advantag", "algebra", "algorithm", "arbitrari", "arithmet", "assign", "class", "column", "compar", "compar", "comparison", "comput", "comput", "consid", "determin", "earli", "error", "examin", "explicit", "favor", "form", "graph", "import", "improv", "includ", "increment", "linear", "matric", "matrix", "method", "number", "numer", "occur", "permut", "permut", "permut", "reject", "requir", "round", "row", "similar", "spars", "standard", "theoret", "time", "tool", "transform", "transform", "tridiagon", "tridiagon", "tridiagon", "tridiagon", "gibb", "pool", "jr"], "word_count": {"absenc": 1, "advantag": 1, "algebra": 1, "algorithm": 3, "arbitrari": 1, "arithmet": 1, "assign": 1, "class": 1, "column": 1, "compar": 2, "comparison": 1, "comput": 2, "consid": 1, "determin": 1, "earli": 1, "error": 1, "examin": 1, "explicit": 1, "favor": 1, "form": 3, "graph": 1, "import": 1, "improv": 1, "includ": 1, "increment": 1, "linear": 2, "matric": 1, "matrix": 3, "method": 1, "number": 3, "numer": 1, "occur": 1, "permut": 3, "reject": 1, "requir": 1, "round": 1, "row": 1, "similar": 1, "spars": 1, "standard": 2, "theoret": 1, "time": 1, "tool": 1, "transform": 4, "tridiagon": 5, "gibb": 1, "pool": 1, "jr": 1}}, "2696": {"id": "2696", "title": "A Method of Bivariate Interpolation and Smooth Surface Fitting Based on Local Procedures", "abstract": "A method is designed for interpolating values given at points of a rectangular grid in a plane  by a smooth bivariate function z=z(x,Y).  The interpolating function is a bicubic polynomial in each  cell of the rectangular grid.  Emphasis is an avoiding excessive undulation between given grid points.  The proposed method is an extension of the method of univariate interpolation developed earlier by the  author and is likewise based on local procedures.", "authors": "Akima, H.", "words_pool": ["author", "avoid", "base", "bicub", "bivari", "cell", "design", "develop", "earlier", "emphasi", "excess", "extens", "fit", "function", "grid", "interpol", "interpol", "likewis", "local", "method", "plane", "point", "polynomi", "procedur", "propos", "rectangular", "smooth", "surfac", "undul", "univari", "valu", "akima"], "word_count": {"author": 1, "avoid": 1, "base": 1, "bicub": 1, "bivari": 1, "cell": 1, "design": 1, "develop": 1, "earlier": 1, "emphasi": 1, "excess": 1, "extens": 1, "fit": 1, "function": 2, "grid": 3, "interpol": 3, "likewis": 1, "local": 1, "method": 3, "plane": 1, "point": 2, "polynomi": 1, "procedur": 1, "propos": 1, "rectangular": 2, "smooth": 1, "surfac": 1, "undul": 1, "univari": 1, "valu": 1, "akima": 1}}, "2697": {"id": "2697", "title": "A Fast Method for Solving a Class of Tridiagonal Linear Systems", "abstract": "The solution of linear systems having real, symmetric, diagonally dominant,tridiagonal coefficient  matrices with constant diagonals is considered.  It is proved that the diagonals of the LU decomposition  converges when floating-point precision.  It is also proved that the computed LU decomposition converges  when floating-point arithmetic is used and that the limits of the LU diagonals using floating point are  roughly within machine precision of the limits using real arithmetic.  This fact is exploited to reduce  the number of floating-point operations required to solve a linear system from 8n-7 to 5n+2k-3, where  k is much less than n, the order of the matrix.  If the elements of the subdiagonals and superdiagonals  are 1, then only 4n+2k-3 operations are needed.  The entire LU decomposition takes k words of storage,  and considerable savings in array subscripting are achieved.  Upper and lower bounds on k are obtained  in terms of the ratio of the coefficient matrix diagonal constants and parameters of the floating-point  number system.  Various generalizations of these results are discussed.", "authors": "Malcolm, M. A. Palmer, J.", "words_pool": ["2k", "4n", "5n", "8n", "achiev", "arithmet", "array", "bound", "class", "coeffici", "comput", "consider", "consid", "constant", "constant", "converg", "decomposit", "diagon", "diagon", "diagon", "discuss", "domin", "element", "entir", "exploit", "fact", "fast", "float", "gener", "limit", "linear", "lower", "lu", "machin", "matric", "matrix", "method", "need", "number", "obtain", "oper", "order", "paramet", "point", "precis", "prove", "ratio", "real", "reduc", "requir", "result", "roughli", "save", "solut", "solv", "solv", "storag", "subdiagon", "subscript", "superdiagon", "symmetr", "system", "system", "take", "term", "tridiagon", "upper", "word", "malcolm", "palmer"], "word_count": {"2k": 2, "4n": 1, "5n": 1, "8n": 1, "achiev": 1, "arithmet": 2, "array": 1, "bound": 1, "class": 1, "coeffici": 2, "comput": 1, "consider": 1, "consid": 1, "constant": 2, "converg": 2, "decomposit": 3, "diagon": 5, "discuss": 1, "domin": 1, "element": 1, "entir": 1, "exploit": 1, "fact": 1, "fast": 1, "float": 5, "gener": 1, "limit": 2, "linear": 2, "lower": 1, "lu": 4, "machin": 1, "matric": 1, "matrix": 2, "method": 1, "need": 1, "number": 2, "obtain": 1, "oper": 2, "order": 1, "paramet": 1, "point": 5, "precis": 2, "prove": 2, "ratio": 1, "real": 2, "reduc": 1, "requir": 1, "result": 1, "roughli": 1, "save": 1, "solut": 1, "solv": 1, "storag": 1, "subdiagon": 1, "subscript": 1, "superdiagon": 1, "symmetr": 1, "system": 3, "take": 1, "term": 1, "tridiagon": 1, "upper": 1, "word": 1, "malcolm": 1, "palmer": 1}}, "2698": {"id": "2698", "title": "Syntax-Directed Least-Errors Analysis for Context-Free Languages: A Practical Approach", "abstract": "A least-errors recognizer is developed informally using the well-known recognizer of Earley,  along with elements of Bellman's dynamic programming.  The analyzer takes a general class of context-free  grammars as drivers, and any finite string as input.  Recognition consists of a least-errors count for  a corrected version of the input relative to the driver grammar. The algorithm design emphasizes practical  aspects which help in programming it.", "authors": "Lyon, G.", "words_pool": ["algorithm", "analysi", "analyz", "approach", "aspect", "bellman", "class", "consist", "context", "correct", "count", "design", "develop", "direct", "driver", "driver", "dynam", "earley", "element", "emphas", "error", "finit", "free", "gener", "grammar", "grammar", "help", "inform", "input", "known", "languag", "practic", "program", "recognit", "recogn", "rel", "string", "syntax", "take", "version", "lyon"], "word_count": {"algorithm": 1, "analysi": 1, "analyz": 1, "approach": 1, "aspect": 1, "bellman": 1, "class": 1, "consist": 1, "context": 1, "correct": 1, "count": 1, "design": 1, "develop": 1, "direct": 1, "driver": 2, "dynam": 1, "earley": 1, "element": 1, "emphas": 1, "error": 2, "finit": 1, "free": 1, "gener": 1, "grammar": 2, "help": 1, "inform": 1, "input": 2, "known": 1, "languag": 1, "practic": 1, "program": 2, "recognit": 1, "recogn": 2, "rel": 1, "string": 1, "syntax": 1, "take": 1, "version": 1, "lyon": 1}}, "2699": {"id": "2699", "title": "Automatic Data Structure Choice in a Language of Very High Level", "abstract": "SETL is a set-theoretically oriented language of very high level whose repertoire of semantic  objects includes finite sets, ordered n-tuples, and sets of ordered n-tuples usable as mappings.  This  paper describes the structure of an optimizer for this language.  Among other methods of interest, the  optimizer uses techniques which allow relations of inclusion and membership to be established, the domains  and ranges of (tabulated) mappings to be estimated from above and below, and the single-valuedness of  (tabulated) mappings to be proved.  Once facts of this kind have been established, automatic choice of  data structures becomes possible. The methods employed are based upon, and extend, known techniques of  data flow analysis.", "authors": "Schwartz, J. T.", "words_pool": ["allow", "analysi", "automat", "base", "choic", "data", "describ", "domain", "employ", "establish", "estim", "extend", "fact", "finit", "flow", "high", "includ", "inclus", "interest", "kind", "known", "languag", "level", "map", "membership", "method", "object", "optim", "order", "orient", "paper", "prove", "rang", "relat", "repertoir", "semant", "set", "setl", "set", "singl", "structur", "structur", "tabul", "techniqu", "theoret", "tupl", "usabl", "valued", "schwartz"], "word_count": {"allow": 1, "analysi": 1, "automat": 1, "base": 1, "choic": 1, "data": 2, "describ": 1, "domain": 1, "employ": 1, "establish": 2, "estim": 1, "extend": 1, "fact": 1, "finit": 1, "flow": 1, "high": 1, "includ": 1, "inclus": 1, "interest": 1, "kind": 1, "known": 1, "languag": 2, "level": 1, "map": 3, "membership": 1, "method": 2, "object": 1, "optim": 2, "order": 2, "orient": 1, "paper": 1, "prove": 1, "rang": 1, "relat": 1, "repertoir": 1, "semant": 1, "set": 3, "setl": 1, "singl": 1, "structur": 2, "tabul": 2, "techniqu": 2, "theoret": 1, "tupl": 2, "usabl": 1, "valued": 1, "schwartz": 1}}, "2700": {"id": "2700", "title": "Reduction: A Method of Proving Properties of Parallel Programs", "abstract": "When proving that a parallel program has a given property it is often convenient to assume  that a statement is indivisible, i.e. that the statement cannot be interleaved with the rest of the program.   Here sufficient conditions are obtained to show that the assumption that a statement is indivisible  can be relaxed and still preserve properties such as halting.  Thus correctness proofs of a parallel  system can often be greatly simplified.", "authors": "Lipton, R. J.", "words_pool": ["assum", "assumpt", "condit", "conveni", "correct", "greatli", "halt", "indivis", "interleav", "method", "obtain", "parallel", "preserv", "program", "program", "proof", "properti", "properti", "prove", "reduct", "relax", "rest", "show", "simplifi", "statement", "suffici", "system", "lipton"], "word_count": {"assum": 1, "assumpt": 1, "condit": 1, "conveni": 1, "correct": 1, "greatli": 1, "halt": 1, "indivis": 2, "interleav": 1, "method": 1, "obtain": 1, "parallel": 2, "preserv": 1, "program": 2, "proof": 1, "properti": 2, "prove": 1, "reduct": 1, "relax": 1, "rest": 1, "show": 1, "simplifi": 1, "statement": 3, "suffici": 1, "system": 1, "lipton": 1}}, "2701": {"id": "2701", "title": "A Fast and Usually Linear Algorithm for Global Flow Analysis (Abstract only--Complete paper JACM  23,1 January, 1976)", "abstract": "A new algorithm for global flow analysis on reducible graphs is presented. The algorithm is  shown to treat a very general class of function spaces.  For a graph of e edges, the algorithm has a  worst case time bound of O(e log e) function operations.  It is also shown that in programming terms,  the number of operations is proportional to e plus the number of exits from program loops.  Consequently  a restriction to one-entry one-exit control structures linearity.  The algorithm can be extended to yet  larger classes of function spaces and graphs by relaxing the time bound.  Examples are given of code  improvement problems which can be solved using the algorithm.", "authors": "Graham, S. L. Wegman, M.", "words_pool": ["abstract", "algorithm", "analysi", "bound", "case", "class", "class", "code", "complet", "control", "edg", "entri", "exampl", "exit", "exit", "extend", "fast", "flow", "function", "gener", "global", "graph", "graph", "improv", "jacm", "januari", "larger", "linear", "linear", "log", "loop", "number", "oper", "paper", "present", "problem", "program", "program", "proport", "reduc", "relax", "restrict", "shown", "solv", "space", "structur", "term", "time", "treat", "worst", "graham", "wegman"], "word_count": {"abstract": 1, "algorithm": 5, "analysi": 1, "bound": 2, "case": 1, "class": 2, "code": 1, "complet": 1, "control": 1, "edg": 1, "entri": 1, "exampl": 1, "exit": 2, "extend": 1, "fast": 1, "flow": 1, "function": 3, "gener": 1, "global": 1, "graph": 3, "improv": 1, "jacm": 1, "januari": 1, "larger": 1, "linear": 1, "log": 1, "loop": 1, "number": 2, "oper": 2, "paper": 1, "present": 1, "problem": 1, "program": 2, "proport": 1, "reduc": 1, "relax": 1, "restrict": 1, "shown": 2, "solv": 1, "space": 2, "structur": 1, "term": 1, "time": 2, "treat": 1, "worst": 1, "graham": 1, "wegman": 1}}, "2702": {"id": "2702", "title": "On the Complexity of LR(k) Testing", "abstract": "The problem of determining whether an arbitrary context-free grammar is a member of some easily  parsed subclass of grammars such as the LR(k) grammars is considered.  The time complexity of this problem  is analyzed both when k is considered to be a fixed integer and when k is considered to be a parameter  of the test.  In the first case, it is shown that for every k there exists an O(n(k+2)) algorithm for  testing the LR(k) property, where n is the size of the grammar in question.  On the other hand, if both  k and the subject grammar are problem parameters, then the complexity of the problem depends very strongly  on the representation chosen for k.  More specifically, it is shown that this problem is NP-complete  when k is expressed in unary.  When k is expressed in binary the problem is complete for nondeterministic  exponential time.  These results carry over to many other parameterized classes of grammars, such as  the LL(k), strong LL(k), SLR(k), LC(k), and strong LC(k) grammars.", "authors": "Hunt, H. B. III Szymanski, T. G. Ullman, J. D.", "words_pool": ["algorithm", "analyz", "arbitrari", "binari", "carri", "case", "chosen", "class", "complet", "complex", "consid", "context", "depend", "determin", "easili", "exist", "exponenti", "express", "fix", "free", "grammar", "grammar", "hand", "integ", "lc", "ll", "lr", "member", "nondeterminist", "np", "paramet", "parameter", "paramet", "pars", "problem", "properti", "question", "represent", "result", "shown", "size", "slr", "specif", "strong", "strongli", "subclass", "subject", "test", "test", "time", "unari", "hunt", "iii", "szymanski", "ullman"], "word_count": {"algorithm": 1, "analyz": 1, "arbitrari": 1, "binari": 1, "carri": 1, "case": 1, "chosen": 1, "class": 1, "complet": 2, "complex": 2, "consid": 3, "context": 1, "depend": 1, "determin": 1, "easili": 1, "exist": 1, "exponenti": 1, "express": 2, "fix": 1, "free": 1, "grammar": 7, "hand": 1, "integ": 1, "lc": 2, "ll": 2, "lr": 2, "member": 1, "nondeterminist": 1, "np": 1, "paramet": 2, "parameter": 1, "pars": 1, "problem": 6, "properti": 1, "question": 1, "represent": 1, "result": 1, "shown": 2, "size": 1, "slr": 1, "specif": 1, "strong": 2, "strongli": 1, "subclass": 1, "subject": 1, "test": 2, "time": 2, "unari": 1, "hunt": 1, "iii": 1, "szymanski": 1, "ullman": 1}}, "2703": {"id": "2703", "title": "The Intrinsically Exponential Complexity of the Circularity Problem for Attribute Grammars", "abstract": "Attribute grammars are an extension of context-free grammars devised by Knuth as a mechanism  for including the semantics of a context-free language with the syntax of the language.  The circularity  problem for a grammar is to determine whether the semantics for all possible sentences (programs) in  fact will be well defined.  It is proved that this problem is, in general, computationally intractable.   Specifically, it is shown that any deterministic algorithm which solves the problem must for infinitely  many cases use an exponential amount of time", "authors": "Jazayeri, M. Ogden, W. F. Rounds, W. C.", "words_pool": ["algorithm", "amount", "attribut", "case", "circular", "complex", "comput", "context", "defin", "determin", "determinist", "devis", "exponenti", "extens", "fact", "free", "gener", "grammar", "grammar", "includ", "infinit", "intract", "intrins", "knuth", "languag", "mechan", "problem", "program", "prove", "semant", "sentenc", "shown", "solv", "specif", "syntax", "time", "jazayeri", "ogden", "round"], "word_count": {"algorithm": 1, "amount": 1, "attribut": 1, "case": 1, "circular": 1, "complex": 1, "comput": 1, "context": 2, "defin": 1, "determin": 1, "determinist": 1, "devis": 1, "exponenti": 1, "extens": 1, "fact": 1, "free": 2, "gener": 1, "grammar": 3, "includ": 1, "infinit": 1, "intract": 1, "intrins": 1, "knuth": 1, "languag": 2, "mechan": 1, "problem": 3, "program": 1, "prove": 1, "semant": 2, "sentenc": 1, "shown": 1, "solv": 1, "specif": 1, "syntax": 1, "time": 1, "jazayeri": 1, "ogden": 1, "round": 1}}, "2704": {"id": "2704", "title": "Exception Handling: Issues and a Proposed Notation", "abstract": "This paper defines exception conditions, discusses the requirements exception handling language  features must satisfy, and proposes some new language features for dealing with exceptions in an orderly  and reliable way.  The proposed language features serve to highlight exception handling issues by showing  how deficiencies in current approaches can be remedied.", "authors": "Goodenough, J. B.", "words_pool": ["approach", "condit", "deal", "defici", "defin", "discuss", "except", "except", "featur", "handl", "highlight", "issu", "languag", "notat", "orderli", "paper", "propos", "propos", "reliabl", "remedi", "requir", "satisfi", "serv", "show", "goodenough"], "word_count": {"approach": 1, "condit": 1, "deal": 1, "defici": 1, "defin": 1, "discuss": 1, "except": 4, "featur": 3, "handl": 2, "highlight": 1, "issu": 1, "languag": 3, "notat": 1, "orderli": 1, "paper": 1, "propos": 2, "reliabl": 1, "remedi": 1, "requir": 1, "satisfi": 1, "serv": 1, "show": 1, "goodenough": 1}}, "2705": {"id": "2705", "title": "Programming Languages, Natural Languages, and Mathematics", "abstract": "Some social aspects of programming are illuminated through analogies with similar aspects of  mathematics and natural languages.  The split between pure and applied mathematics is found similarly  in programming. The development of natural languages toward flexion less, word-order based language types  speaks for programming language design based on general, abstract constructs.  By analogy with incidents  of the history of artificial, auxiliary languages it is suggested that Fortran and Cobol will remain  dominant for a long time to come.  The most promising avenues for further work of wide influence are  seen to be high quality program literature (i.e. programs) of general utility and studies of questions  related to program style.", "authors": "Naur, P.", "words_pool": ["abstract", "analog", "analog", "appli", "artifici", "aspect", "auxiliari", "avenu", "base", "cobol", "come", "construct", "design", "develop", "domin", "flexion", "fortran", "found", "gener", "high", "histori", "illumin", "incid", "influenc", "languag", "languag", "literatur", "long", "mathemat", "natur", "order", "program", "program", "program", "promis", "pure", "qualiti", "question", "relat", "remain", "seen", "similar", "similarli", "social", "speak", "split", "studi", "style", "suggest", "time", "type", "util", "wide", "word", "work", "naur"], "word_count": {"abstract": 1, "analog": 2, "appli": 1, "artifici": 1, "aspect": 2, "auxiliari": 1, "avenu": 1, "base": 2, "cobol": 1, "come": 1, "construct": 1, "design": 1, "develop": 1, "domin": 1, "flexion": 1, "fortran": 1, "found": 1, "gener": 2, "high": 1, "histori": 1, "illumin": 1, "incid": 1, "influenc": 1, "languag": 5, "literatur": 1, "long": 1, "mathemat": 2, "natur": 2, "order": 1, "program": 6, "promis": 1, "pure": 1, "qualiti": 1, "question": 1, "relat": 1, "remain": 1, "seen": 1, "similar": 1, "similarli": 1, "social": 1, "speak": 1, "split": 1, "studi": 1, "style": 1, "suggest": 1, "time": 1, "type": 1, "util": 1, "wide": 1, "word": 1, "work": 1, "naur": 1}}, "2706": {"id": "2706", "title": "A Note on the Set Basis Problem Related to the Compaction of Character Sets", "abstract": "This note discusses the reduction of the set basis problem to the clique cover problem.", "authors": "Kou, L. T. Wong, C. K.", "words_pool": ["basi", "charact", "cliqu", "compact", "cover", "discuss", "note", "problem", "reduct", "relat", "set", "set", "kou", "wong"], "word_count": {"basi": 1, "charact": 1, "cliqu": 1, "compact": 1, "cover": 1, "discuss": 1, "note": 1, "problem": 2, "reduct": 1, "relat": 1, "set": 1, "kou": 1, "wong": 1}}, "2707": {"id": "2707", "title": "Backtrack Programming Techniques", "abstract": "The purpose of this paper is twofold.  First, a brief exposition of the general backtrack technique  and its history is given.  Second, it is shown how the use of macros can considerably shorten the computation  time in many cases.  In particular, this technique has allowed the solution of two previously open combinatorial  problems, the computation of new terms in a well-known series, and the substantial reduction in computation  time for the solution to another combinatorial problem.", "authors": "Bitner, J. R. Reingold, E. M.", "words_pool": ["allow", "backtrack", "case", "combinatori", "comput", "consider", "exposit", "gener", "histori", "known", "macro", "open", "paper", "previous", "problem", "problem", "program", "purpos", "reduct", "seri", "shorten", "shown", "solut", "substanti", "techniqu", "techniqu", "term", "time", "twofold", "bitner", "reingold"], "word_count": {"allow": 1, "backtrack": 1, "case": 1, "combinatori": 2, "comput": 3, "consider": 1, "exposit": 1, "gener": 1, "histori": 1, "known": 1, "macro": 1, "open": 1, "paper": 1, "previous": 1, "problem": 2, "program": 1, "purpos": 1, "reduct": 1, "seri": 1, "shorten": 1, "shown": 1, "solut": 2, "substanti": 1, "techniqu": 2, "term": 1, "time": 2, "twofold": 1, "bitner": 1, "reingold": 1}}, "2708": {"id": "2708", "title": "Practical Syntactic Error Recovery", "abstract": "This paper describes a recovery scheme for syntax errors which provides automatically-generated  high quality recovery with good diagnostic information at relatively low cost. Previous recovery techniques  are summarized and empirical comparisons are made.  Suggestions for further research on this topic conclude  the paper.", "authors": "Graham, S. L. Rhodes, S. P.", "words_pool": ["comparison", "conclud", "cost", "describ", "diagnost", "empir", "error", "error", "gener", "good", "high", "inform", "low", "made", "paper", "practic", "previou", "qualiti", "recoveri", "research", "scheme", "suggest", "summar", "syntact", "syntax", "techniqu", "topic", "graham", "rhode"], "word_count": {"comparison": 1, "conclud": 1, "cost": 1, "describ": 1, "diagnost": 1, "empir": 1, "error": 1, "gener": 1, "good": 1, "high": 1, "inform": 1, "low": 1, "made": 1, "paper": 2, "practic": 1, "previou": 1, "qualiti": 1, "recoveri": 3, "research": 1, "scheme": 1, "suggest": 1, "summar": 1, "syntact": 1, "syntax": 1, "techniqu": 1, "topic": 1, "graham": 1, "rhode": 1}}, "2709": {"id": "2709", "title": "A Genealogy of Control Structures", "abstract": "The issue of program control structures has had a history of heated controversy.  To put this  issue on a solid footing, this paper reviews numerous theoretical results on control structures and explores  their practical implications.  The classic result of Bohm and Jacopini on the theoretical completeness  of if-then-else and while-do is discussed. Several recent ideas on control structures are then explored.   These include a review of various other control structures, results on time/space limitations, and theorems  relating the relative power of control structures under notions of equivalence.  In conclusion, the impact  of theoretical results on the practicing programmer and the importance of one-in, one-out control structures  as operational abstractions are discussed.  It is argued further that there is insufficient evidence  to warrant more than if-then-else, while-do, and their variants.", "authors": "Ledgard, H. F. Marcotty, M.", "words_pool": ["abstract", "argu", "bohm", "classic", "complet", "conclus", "control", "controversi", "discuss", "equival", "evid", "explor", "explor", "foot", "genealog", "heat", "histori", "idea", "impact", "implic", "import", "includ", "insuffici", "issu", "jacopini", "limit", "notion", "numer", "oper", "paper", "power", "practic", "practic", "program", "programm", "put", "recent", "relat", "rel", "result", "result", "review", "review", "solid", "space", "structur", "theorem", "theoret", "time", "variant", "warrant", "ledgard", "marcotti"], "word_count": {"abstract": 1, "argu": 1, "bohm": 1, "classic": 1, "complet": 1, "conclus": 1, "control": 6, "controversi": 1, "discuss": 2, "equival": 1, "evid": 1, "explor": 2, "foot": 1, "genealog": 1, "heat": 1, "histori": 1, "idea": 1, "impact": 1, "implic": 1, "import": 1, "includ": 1, "insuffici": 1, "issu": 2, "jacopini": 1, "limit": 1, "notion": 1, "numer": 1, "oper": 1, "paper": 1, "power": 1, "practic": 2, "program": 1, "programm": 1, "put": 1, "recent": 1, "relat": 1, "rel": 1, "result": 4, "review": 2, "solid": 1, "space": 1, "structur": 6, "theorem": 1, "theoret": 3, "time": 1, "variant": 1, "warrant": 1, "ledgard": 1, "marcotti": 1}}, "2710": {"id": "2710", "title": "Specifying Queries as Relational Expressions: The SQUARE Data Sublanguage", "abstract": "This paper presents a data sublanguage called SQUARE, intended for use in ad hoc, interactive  problem solving by non-computer specialists. SQUARE is based on the relational model of data, and is  shown to be relationally complete; however, it avoids the quantifiers and bound variables required by  languages based on the relational calculus.  Facilities for query, insertion, deletion, and update on  tabular data bases are described.  A syntax is given, and suggestions are made for alternative syntaxes,  including a syntax based on English key words for users with limited mathematical background.", "authors": "Boyce, R. F Chamberlin, D. D. King, W. F. III", "words_pool": ["ad", "altern", "avoid", "background", "base", "base", "bound", "calculu", "call", "complet", "comput", "data", "delet", "english", "express", "facil", "hoc", "includ", "insert", "intend", "interact", "key", "languag", "limit", "made", "mathemat", "model", "non", "paper", "present", "problem", "quantifi", "queri", "queri", "relat", "relat", "requir", "shown", "solv", "specialist", "squar", "sublanguag", "suggest", "syntax", "syntax", "tabular", "updat", "user", "variabl", "word", "boyc", "chamberlin", "king", "iii"], "word_count": {"ad": 1, "altern": 1, "avoid": 1, "background": 1, "base": 4, "bound": 1, "calculu": 1, "call": 1, "complet": 1, "comput": 1, "data": 3, "delet": 1, "english": 1, "express": 1, "facil": 1, "hoc": 1, "includ": 1, "insert": 1, "intend": 1, "interact": 1, "key": 1, "languag": 1, "limit": 1, "made": 1, "mathemat": 1, "model": 1, "non": 1, "paper": 1, "present": 1, "problem": 1, "quantifi": 1, "queri": 1, "relat": 3, "requir": 1, "shown": 1, "solv": 1, "specialist": 1, "squar": 2, "sublanguag": 1, "suggest": 1, "syntax": 3, "tabular": 1, "updat": 1, "user": 1, "variabl": 1, "word": 1, "boyc": 1, "chamberlin": 1, "king": 1, "iii": 1}}, "2711": {"id": "2711", "title": "A Vector Space Model for Automatic Indexing", "abstract": "In a document retrieval, or other pattern matching environment where stored entities (documents)  are compared with each other or with incoming patterns (search requests), it appears that the best indexing  (property) space is one where each entity lies as far away from the others as possible; in these circumstances  the value of an indexing system may be expressible as a function of the density of the object space;  in particular, retrieval performance may correlate inversely with space density.  An approach based on  space density computations is used to choose an optimum indexing vocabulary for a collection of documents.   Typical evaluation results are shown, demonstrating the usefulness of the model.", "authors": "Salton, G. Wong, A. Yang, C. S.", "words_pool": ["appear", "approach", "automat", "base", "choos", "circumst", "collect", "compar", "comput", "correl", "demonstr", "densiti", "document", "document", "entiti", "entiti", "environ", "evalu", "express", "function", "incom", "index", "invers", "lie", "match", "model", "object", "optimum", "pattern", "pattern", "perform", "properti", "request", "result", "retriev", "search", "shown", "space", "store", "system", "typic", "use", "vector", "vocabulari", "salton", "wong", "yang"], "word_count": {"appear": 1, "approach": 1, "automat": 1, "base": 1, "choos": 1, "circumst": 1, "collect": 1, "compar": 1, "comput": 1, "correl": 1, "demonstr": 1, "densiti": 3, "document": 3, "entiti": 2, "environ": 1, "evalu": 1, "express": 1, "function": 1, "incom": 1, "index": 3, "invers": 1, "lie": 1, "match": 1, "model": 1, "object": 1, "optimum": 1, "pattern": 2, "perform": 1, "properti": 1, "request": 1, "result": 1, "retriev": 2, "search": 1, "shown": 1, "space": 4, "store": 1, "system": 1, "typic": 1, "use": 1, "vector": 1, "vocabulari": 1, "salton": 1, "wong": 1, "yang": 1}}, "2712": {"id": "2712", "title": "Horner's Rule for the Evaluation of General Closed Queueing Networks", "abstract": "The solution of separable closed queueing networks requires the evaluation of homogeneous multinomial  expressions.  The number of terms in those expressions grows combinatorially with the size of\u0019 the network  such that a direct summation may become impractical.  An algorithm is given which does not show a combinatorial  operation count.  The algorithm is based on a generalization of Horner's rule for polynomials.  It is  also shown how mean queue size and throughput an be obtained at negligible extra cost once the normalization  constant is evaluated.", "authors": "Reiser, M. Kobayashi, H.", "words_pool": ["algorithm", "base", "close", "combinatori", "combinatori", "constant", "cost", "count", "direct", "evalu", "evalu", "express", "extra", "gener", "gener", "grow", "homogen", "horner", "impract", "mean", "multinomi", "neglig", "network", "network", "normal", "number", "obtain", "oper", "polynomi", "queue", "queue", "requir", "rule", "separ", "show", "shown", "size", "solut", "summat", "term", "throughput", "reiser", "kobayashi"], "word_count": {"algorithm": 2, "base": 1, "close": 1, "combinatori": 2, "constant": 1, "cost": 1, "count": 1, "direct": 1, "evalu": 2, "express": 2, "extra": 1, "gener": 1, "grow": 1, "homogen": 1, "horner": 1, "impract": 1, "mean": 1, "multinomi": 1, "neglig": 1, "network": 2, "normal": 1, "number": 1, "obtain": 1, "oper": 1, "polynomi": 1, "queue": 2, "requir": 1, "rule": 1, "separ": 1, "show": 1, "shown": 1, "size": 2, "solut": 1, "summat": 1, "term": 1, "throughput": 1, "reiser": 1, "kobayashi": 1}}, "2713": {"id": "2713", "title": "Remark on Stably Updating Mean and Standard Deviation of Data (Corrigendum)", "authors": "Cotton, I.", "words_pool": ["corrigendum", "data", "deviat", "mean", "remark", "stabli", "standard", "updat", "cotton"], "word_count": {"corrigendum": 1, "data": 1, "deviat": 1, "mean": 1, "remark": 1, "stabli": 1, "standard": 1, "updat": 1, "cotton": 1}}, "2714": {"id": "2714", "title": "Merging with Parallel Processors", "abstract": "Consider two linearly ordered sets A, B, |A|=m, |B|=n, m<=n, and p, p<=m, parallel processors  working synchronously.  The paper presents an algorithm for merging A and B with the p parallel processors,  which requires at most 2[log2 (2m+1)]+[3m/p] + [m/p][log2 (n/m)] steps.  If n = (2^B)m (B an integer),  the algorithm requires at most 2[log2 (m+1)] + [m/p](2+B) steps.  In the case where m and n are of the  same order of magnitude, i.e. n=km with k being a constant, the algorithm requires 2[log2 (m+1)] + [m/p](3+k)  steps.  These performances compare very favorably with the previous best parallel merging algorithm,  Batcher's algorithm, which requires n/p + ((m+n)/2p)log2 m steps in the general case and km/p + ((k+1)/2)(m/p)log2  m in the special case where n=km.", "authors": "Gavril, F.", "words_pool": ["2m", "2p", "3m", "algorithm", "batcher", "case", "compar", "consid", "constant", "favor", "gener", "integ", "km", "linearli", "log2", "magnitud", "merg", "order", "order", "paper", "parallel", "perform", "present", "previou", "processor", "requir", "set", "special", "step", "synchron", "work", "gavril"], "word_count": {"2m": 1, "2p": 1, "3m": 1, "algorithm": 5, "batcher": 1, "case": 3, "compar": 1, "consid": 1, "constant": 1, "favor": 1, "gener": 1, "integ": 1, "km": 3, "linearli": 1, "log2": 6, "magnitud": 1, "merg": 2, "order": 2, "paper": 1, "parallel": 3, "perform": 1, "present": 1, "previou": 1, "processor": 2, "requir": 4, "set": 1, "special": 1, "step": 4, "synchron": 1, "work": 1, "gavril": 1}}, "2715": {"id": "2715", "title": "Implementation of a Structured English Query Language", "abstract": "The relational model of data, the XRM Relational Memory System, and the SEQUEL language have  been covered in previous papers and are reviewed.  SEQUEL is a relational data sublanguages intended  for the ad hoc interactive problem solving by non-computer specialists.  A version of SEQUEL that has  been implemented in a prototype interpreter is described.  The interpreter is designed to minimize the  data accessing operations required to respond to an arbitrary query.  The optimization algorithms designed  for this purpose are described.", "authors": "Astrahan, M. M. Chamberlin,D. D.", "words_pool": ["access", "ad", "algorithm", "arbitrari", "comput", "cover", "data", "design", "english", "hoc", "implement", "implement", "intend", "interact", "interpret", "languag", "memori", "minim", "model", "non", "oper", "optim", "paper", "previou", "problem", "prototyp", "purpos", "queri", "relat", "requir", "respond", "review", "sequel", "solv", "specialist", "structur", "sublanguag", "system", "version", "xrm", "astrahan", "chamberlin"], "word_count": {"access": 1, "ad": 1, "algorithm": 1, "arbitrari": 1, "comput": 1, "cover": 1, "data": 3, "design": 2, "english": 1, "hoc": 1, "implement": 1, "intend": 1, "interact": 1, "interpret": 2, "languag": 1, "memori": 1, "minim": 1, "model": 1, "non": 1, "oper": 1, "optim": 1, "paper": 1, "previou": 1, "problem": 1, "prototyp": 1, "purpos": 1, "queri": 1, "relat": 3, "requir": 1, "respond": 1, "review": 1, "sequel": 3, "solv": 1, "specialist": 1, "structur": 1, "sublanguag": 1, "system": 1, "version": 1, "xrm": 1, "astrahan": 1, "chamberlin": 1}}, "2716": {"id": "2716", "title": "Optimizing the Performance of a Relational Algebra Database Interface", "abstract": "An approach for implementing a \"smart\" interface to support a relational view of data is proposed.   The basic idea is to employ automatic programming techniques so that the interface analyzes and efficiently  refines the high level query specification supplied by the user.  A relational algebra interface, called  SQUIRAL, which was designed using this approach, is described in detail. SQUIRAL seeks to minimize query  response time and space utilization by: (1) performing global query optimization, (2) exploiting disjoint  and pipelined concurrency, (3) coordinating sort orders in temporary relations, (4) employing directory  analysis, and (5) maintaining locality in page references.  Algorithms for implementing the operators  of E. F. Codd's relational algebra are presented, and a methodology for composing them to optimize the  performance of a particular user query is described.", "authors": "Smith, J. M. Yen-Tang Chang, P.", "words_pool": ["algebra", "algorithm", "analysi", "analyz", "approach", "automat", "basic", "call", "codd", "compos", "concurr", "coordin", "data", "databas", "design", "detail", "directori", "disjoint", "effici", "employ", "employ", "exploit", "global", "high", "idea", "implement", "interfac", "level", "local", "maintain", "methodolog", "minim", "oper", "optim", "optim", "optim", "order", "page", "perform", "perform", "pipelin", "present", "program", "propos", "queri", "refer", "refin", "relat", "relat", "respons", "seek", "smart", "sort", "space", "specif", "squiral", "suppli", "support", "techniqu", "temporari", "time", "user", "util", "view", "smith", "yen", "tang", "chang"], "word_count": {"algebra": 2, "algorithm": 1, "analysi": 1, "analyz": 1, "approach": 2, "automat": 1, "basic": 1, "call": 1, "codd": 1, "compos": 1, "concurr": 1, "coordin": 1, "data": 1, "databas": 1, "design": 1, "detail": 1, "directori": 1, "disjoint": 1, "effici": 1, "employ": 2, "exploit": 1, "global": 1, "high": 1, "idea": 1, "implement": 2, "interfac": 3, "level": 1, "local": 1, "maintain": 1, "methodolog": 1, "minim": 1, "oper": 1, "optim": 2, "order": 1, "page": 1, "perform": 2, "pipelin": 1, "present": 1, "program": 1, "propos": 1, "queri": 4, "refer": 1, "refin": 1, "relat": 4, "respons": 1, "seek": 1, "smart": 1, "sort": 1, "space": 1, "specif": 1, "squiral": 2, "suppli": 1, "support": 1, "techniqu": 1, "temporari": 1, "time": 1, "user": 2, "util": 1, "view": 1, "smith": 1, "yen": 1, "tang": 1, "chang": 1}}, "2717": {"id": "2717", "title": "CONVERT: A High Level Translation Definition Language for Data Conversion", "abstract": "This paper describes a high level and nonprocedural translation definition language, CONVERT,  which provides very powerful and highly flexible data restructuring capabilities. Its design is based  on the simple underlying concept of a form which enables the users to visualize the translation processes,  and thus makes data translation a much simpler task.  \"CONVERT\" has been chosen for conveying the purpose  of the language and should not be confused with any other language or program bearing the same name.", "authors": "Shu, N. C. Housel, B. C. Lum, V. Y.", "words_pool": ["base", "bear", "capabl", "chosen", "concept", "confus", "convers", "convert", "convey", "data", "definit", "describ", "design", "enabl", "flexibl", "form", "high", "highli", "languag", "level", "make", "nonprocedur", "paper", "power", "process", "program", "purpos", "restructur", "simpl", "simpler", "task", "translat", "underli", "user", "visual", "shu", "housel", "lum"], "word_count": {"base": 1, "bear": 1, "capabl": 1, "chosen": 1, "concept": 1, "confus": 1, "convers": 1, "convert": 2, "convey": 1, "data": 2, "definit": 1, "describ": 1, "design": 1, "enabl": 1, "flexibl": 1, "form": 1, "high": 1, "highli": 1, "languag": 3, "level": 1, "make": 1, "nonprocedur": 1, "paper": 1, "power": 1, "process": 1, "program": 1, "purpos": 1, "restructur": 1, "simpl": 1, "simpler": 1, "task": 1, "translat": 3, "underli": 1, "user": 1, "visual": 1, "shu": 1, "housel": 1, "lum": 1}}, "2718": {"id": "2718", "title": "A Preliminary System for the Design of DBTG Data Structures", "abstract": "The functional approach to database design is introduced.  In this approach the goal of design  is to derive a data structure which is capable of supporting a set of anticipated queries rather than  a structure which \"models the business\" in some other way. An operational computer program is described  which utilizers the functional approach to design data structures conforming to the Data Base Task Group  specifications.  The automatic programming technology utilized by this program, although typically used  to generate procedure, is here used to generate declaratives.", "authors": "Gerritsen, R.", "words_pool": ["anticip", "approach", "automat", "base", "busi", "capabl", "comput", "conform", "data", "databas", "dbtg", "declar", "deriv", "design", "function", "gener", "goal", "group", "introduc", "model", "oper", "preliminari", "procedur", "program", "program", "queri", "set", "specif", "structur", "structur", "support", "system", "task", "technolog", "typic", "util", "util", "gerritsen"], "word_count": {"anticip": 1, "approach": 3, "automat": 1, "base": 1, "busi": 1, "capabl": 1, "comput": 1, "conform": 1, "data": 3, "databas": 1, "dbtg": 1, "declar": 1, "deriv": 1, "design": 3, "function": 2, "gener": 2, "goal": 1, "group": 1, "introduc": 1, "model": 1, "oper": 1, "preliminari": 1, "procedur": 1, "program": 3, "queri": 1, "set": 1, "specif": 1, "structur": 3, "support": 1, "system": 1, "task": 1, "technolog": 1, "typic": 1, "util": 2, "gerritsen": 1}}, "2719": {"id": "2719", "title": "Mechanical Program Analysis", "abstract": "One means of analyzing program performance is by deriving closed-form expressions for their  execution behavior.  This paper discusses the mechanization of such analysis, and describes a system,  Metric, which is able to analyze simple Lisp programs and produce, for example, closed-form expressions for their running time expressed in terms of size of input.  This paper presents the reasons for mechanizing  program analysis, describes the operation of Metric, explains its implementation, and discusses its limitations.", "authors": "Wegbreit, B.", "words_pool": ["abl", "analysi", "analyz", "analyz", "behavior", "close", "deriv", "describ", "discuss", "execut", "explain", "express", "express", "form", "implement", "input", "limit", "lisp", "mean", "mechan", "mechan", "mechan", "metric", "oper", "paper", "perform", "present", "produc", "program", "program", "reason", "run", "simpl", "size", "system", "term", "time", "wegbreit"], "word_count": {"abl": 1, "analysi": 2, "analyz": 2, "behavior": 1, "close": 2, "deriv": 1, "describ": 2, "discuss": 2, "execut": 1, "explain": 1, "express": 3, "form": 2, "implement": 1, "input": 1, "limit": 1, "lisp": 1, "mean": 1, "mechan": 2, "metric": 2, "oper": 1, "paper": 2, "perform": 1, "present": 1, "produc": 1, "program": 3, "reason": 1, "run": 1, "simpl": 1, "size": 1, "system": 1, "term": 1, "time": 1, "wegbreit": 1}}, "2720": {"id": "2720", "title": "Optimal Balancing of I/O Requests to Disks", "abstract": "Determining a policy for efficient allocation and utilization of a set of disk drives with  differing operational characteristics is examined using analytical techniques.  Using standard queueing  theory, each disk drive is characterized by a queueing model with service time of a disk drive represented  by the probability density function of the sum of two uniform distributions. Total response time of the  set of disk models is then minimized under varying load conditions. The results indicate that faster  devices should have higher utilization factors and that the number of different device types utilized  tends to decrease with decreasing load.  Specific examples using 2314 and 3330 combinations are examined.", "authors": "Piepmeier, W. F.", "words_pool": ["alloc", "analyt", "balanc", "characterist", "character", "combin", "condit", "decreas", "decreas", "densiti", "determin", "devic", "devic", "differ", "disk", "disk", "distribut", "drive", "drive", "effici", "examin", "exampl", "factor", "faster", "function", "higher", "load", "minim", "model", "model", "number", "oper", "optim", "polici", "probabl", "queue", "repres", "request", "respons", "result", "servic", "set", "specif", "standard", "sum", "techniqu", "tend", "theori", "time", "total", "type", "uniform", "util", "util", "vari", "piepmeier"], "word_count": {"alloc": 1, "analyt": 1, "balanc": 1, "characterist": 1, "character": 1, "combin": 1, "condit": 1, "decreas": 2, "densiti": 1, "determin": 1, "devic": 2, "differ": 1, "disk": 4, "distribut": 1, "drive": 3, "effici": 1, "examin": 2, "exampl": 1, "factor": 1, "faster": 1, "function": 1, "higher": 1, "load": 2, "minim": 1, "model": 2, "number": 1, "oper": 1, "optim": 1, "polici": 1, "probabl": 1, "queue": 2, "repres": 1, "request": 1, "respons": 1, "result": 1, "servic": 1, "set": 2, "specif": 1, "standard": 1, "sum": 1, "techniqu": 1, "tend": 1, "theori": 1, "time": 2, "total": 1, "type": 1, "uniform": 1, "util": 3, "vari": 1, "piepmeier": 1}}, "2721": {"id": "2721", "title": "The Digital Simulation of River Plankton Population Dynamics", "abstract": "This paper deals with the development of a mathematical model for and the digital simulation  in Fortran IV of phytoplankton and zooplankton population densities in a river using previously developed  rate expressions.  In order to study the relationships between the ecological mechanisms involved, the  simulation parameters were varied illustrating the response of the ecosystem to different conditions,  including those corresponding to certain types of chemical and thermal pollution.  As an investigation  of the accuracy of the simulation methods, a simulation of the actual population dynamics of Asterionella  in the Columbia River was made based on approximations of conditions in that river. Although not totally  accurate, the simulation was found to predict the general annual pattern of plankton growth fairly well  and, specifically, revealed the importance of the annual velocity cycle in determining such patterns.   In addition, the study demonstrates the usefulness of digital simulations in the examinations of certain  aquatic ecosystems, as well as in environmental planning involving such examinations.", "authors": "Claudson, R. M.", "words_pool": ["accuraci", "accur", "actual", "addit", "annual", "approxim", "aquat", "asterionella", "base", "chemic", "columbia", "condit", "cycl", "deal", "demonstr", "densiti", "determin", "develop", "develop", "digit", "dynam", "ecolog", "ecosystem", "ecosystem", "environment", "examin", "express", "fairli", "fortran", "found", "gener", "growth", "illustr", "import", "includ", "investig", "involv", "involv", "iv", "made", "mathemat", "mechan", "method", "model", "order", "paper", "paramet", "pattern", "pattern", "phytoplankton", "plankton", "plan", "pollut", "popul", "predict", "previous", "rate", "relationship", "respons", "reveal", "river", "simul", "simul", "specif", "studi", "thermal", "total", "type", "use", "vari", "veloc", "zooplankton", "claudson"], "word_count": {"accuraci": 1, "accur": 1, "actual": 1, "addit": 1, "annual": 2, "approxim": 1, "aquat": 1, "asterionella": 1, "base": 1, "chemic": 1, "columbia": 1, "condit": 2, "cycl": 1, "deal": 1, "demonstr": 1, "densiti": 1, "determin": 1, "develop": 2, "digit": 2, "dynam": 1, "ecolog": 1, "ecosystem": 2, "environment": 1, "examin": 2, "express": 1, "fairli": 1, "fortran": 1, "found": 1, "gener": 1, "growth": 1, "illustr": 1, "import": 1, "includ": 1, "investig": 1, "involv": 2, "iv": 1, "made": 1, "mathemat": 1, "mechan": 1, "method": 1, "model": 1, "order": 1, "paper": 1, "paramet": 1, "pattern": 2, "phytoplankton": 1, "plankton": 1, "plan": 1, "pollut": 1, "popul": 2, "predict": 1, "previous": 1, "rate": 1, "relationship": 1, "respons": 1, "reveal": 1, "river": 3, "simul": 6, "specif": 1, "studi": 2, "thermal": 1, "total": 1, "type": 1, "use": 1, "vari": 1, "veloc": 1, "zooplankton": 1, "claudson": 1}}, "2722": {"id": "2722", "title": "Multidimensional Binary Search Trees Used for Associative Searching", "abstract": "This paper develops the multidimensional binary search tree (or k-d tree, where k is the dimensionality  of the search space) as a data structure for storage of information to be retrieved by associative searches.  The k-d tree is defined and examples are given. It is shown to be quite in its storage requirements.   A significant advantage of this structure is that a single data structure can handle many types of queries  very efficiently.  Various utility algorithms are developed; their proven average running times in an  n record file are: insertion, O (log n); deletion of the root, O (n^(k-1)/k); deletion of a random node,  O (log n); and optimization (guarantees logarithmic performance of searches), O (n log n).  Search algorithms  are given for partial match queries with t keys specified [proven maximum running time of O (n^(k-t)/k)]  and for nearest neighbor queries [empirically observed average running time of O (log n).]  These performances  far surpass the best currently known algorithms for these tasks.  An algorithm is presented to handle  any general intersection query. The main focus of this paper theoretical.  It is felt, however, that  k-d trees could be quite useful in many applications, and examples of potential uses are given.", "authors": "Bently, J. L.", "words_pool": ["advantag", "algorithm", "algorithm", "applic", "associ", "averag", "binari", "data", "defin", "delet", "develop", "develop", "dimension", "effici", "empir", "exampl", "felt", "focu", "gener", "guarante", "handl", "inform", "insert", "intersect", "key", "known", "log", "logarithm", "main", "match", "maximum", "multidimension", "nearest", "neighbor", "node", "observ", "optim", "paper", "partial", "perform", "perform", "potenti", "present", "proven", "queri", "queri", "random", "record", "requir", "retriev", "root", "run", "search", "search", "search", "shown", "signific", "singl", "space", "storag", "structur", "surpass", "task", "theoret", "time", "time", "tree", "tree", "type", "util", "bentli"], "word_count": {"advantag": 1, "algorithm": 4, "applic": 1, "associ": 1, "averag": 2, "binari": 1, "data": 2, "defin": 1, "delet": 2, "develop": 2, "dimension": 1, "effici": 1, "empir": 1, "exampl": 2, "felt": 1, "focu": 1, "gener": 1, "guarante": 1, "handl": 2, "inform": 1, "insert": 1, "intersect": 1, "key": 1, "known": 1, "log": 4, "logarithm": 1, "main": 1, "match": 1, "maximum": 1, "multidimension": 1, "nearest": 1, "neighbor": 1, "node": 1, "observ": 1, "optim": 1, "paper": 2, "partial": 1, "perform": 2, "potenti": 1, "present": 1, "proven": 2, "queri": 4, "random": 1, "record": 1, "requir": 1, "retriev": 1, "root": 1, "run": 3, "search": 5, "shown": 1, "signific": 1, "singl": 1, "space": 1, "storag": 2, "structur": 3, "surpass": 1, "task": 1, "theoret": 1, "time": 3, "tree": 4, "type": 1, "util": 1, "bentli": 1}}, "2723": {"id": "2723", "title": "Multiprocessing Compactifying Garbage Collection", "abstract": "Algorithms for a multiprocessing compactifying garbage collector are presented and discussed.   The simple case of two processors, one performing LISP-like list operations and the other performing  garbage collection continuously, is thoroughly examined. The necessary capabilities of each processor  are defined, as well as interprocessor communication and interlocks. Complete procedures for garbage  collection and for standard list processing primitives are presented and thoroughly explained.  Particular  attention is given to the problems of marking and relocating list cells while another processor may be  operating on them.  The primary aim throughout is to allow the list processor to run unimpeded while  the other processor reclaims list storage.  The more complex cases involving several list processors  and one or more garbage collection processors are also briefly discussed.", "authors": "Steele, G. L. Jr.", "words_pool": ["aim", "algorithm", "allow", "attent", "briefli", "capabl", "case", "case", "cell", "collect", "collector", "commun", "compactifi", "complet", "complex", "continu", "defin", "discuss", "examin", "explain", "garbag", "interlock", "interprocessor", "involv", "lisp", "list", "mark", "multiprocess", "oper", "oper", "perform", "present", "primari", "primit", "problem", "procedur", "process", "processor", "processor", "reclaim", "reloc", "run", "simpl", "standard", "storag", "unimped", "steel", "jr"], "word_count": {"aim": 1, "algorithm": 1, "allow": 1, "attent": 1, "briefli": 1, "capabl": 1, "case": 2, "cell": 1, "collect": 3, "collector": 1, "commun": 1, "compactifi": 1, "complet": 1, "complex": 1, "continu": 1, "defin": 1, "discuss": 2, "examin": 1, "explain": 1, "garbag": 4, "interlock": 1, "interprocessor": 1, "involv": 1, "lisp": 1, "list": 6, "mark": 1, "multiprocess": 1, "oper": 2, "perform": 2, "present": 2, "primari": 1, "primit": 1, "problem": 1, "procedur": 1, "process": 1, "processor": 7, "reclaim": 1, "reloc": 1, "run": 1, "simpl": 1, "standard": 1, "storag": 1, "unimped": 1, "steel": 1, "jr": 1}}, "2724": {"id": "2724", "title": "The Lemniscate Constants (Corrigendum)", "authors": "Todd, J.", "words_pool": ["constant", "corrigendum", "lemnisc", "todd"], "word_count": {"constant": 1, "corrigendum": 1, "lemnisc": 1, "todd": 1}}, "2725": {"id": "2725", "title": "A Comparison of Simulation Event List Algorithms (Corrigendum)", "authors": "Vaucher, J. C. Duval, P.", "words_pool": ["algorithm", "comparison", "corrigendum", "event", "list", "simul", "vaucher", "duval"], "word_count": {"algorithm": 1, "comparison": 1, "corrigendum": 1, "event": 1, "list": 1, "simul": 1, "vaucher": 1, "duval": 1}}, "2726": {"id": "2726", "title": "Combining Decision Rules in a Decision Table", "abstract": "The techniques for minimizing logic circuits are applied to the simplification of decision  tables by the combining of decision rules. This method is logically equivalent to the Quien-McCluskey  method for finding prime implicants.  If some of the decision rules implied in the ELSE Rule occur with  low frequency, then the ELSE Rule can be used to further simplify the decision table.  Several objectives  merit consideration in optimizing a decision table:(1) reducing machine execution time; (2) reducing  preprocessing time; (3) reducing required machine memory; (4) reducing the number of decision rules.   (This often improves the clarity of the decision table to a human reader.)  It will be shown that objectives  (3) and (4) can be furthered with the above methods.  Objective (1) is also attained if overspecified  decision rules are not combined.  Objective (2) must be compared against the potential benefits of objectives  (1), (3), and (4) in deciding whether to use the above methods.", "authors": "Shwayder, K.", "words_pool": ["appli", "attain", "benefit", "circuit", "clariti", "combin", "combin", "compar", "consider", "decid", "decis", "equival", "execut", "find", "frequenc", "further", "human", "implic", "impli", "improv", "logic", "logic", "low", "machin", "mccluskey", "memori", "merit", "method", "method", "minim", "number", "object", "object", "occur", "optim", "overspecifi", "potenti", "preprocess", "prime", "quien", "reader", "reduc", "requir", "rule", "rule", "shown", "simplif", "simplifi", "tabl", "tabl", "techniqu", "time", "shwayder"], "word_count": {"appli": 1, "attain": 1, "benefit": 1, "circuit": 1, "clariti": 1, "combin": 2, "compar": 1, "consider": 1, "decid": 1, "decis": 8, "equival": 1, "execut": 1, "find": 1, "frequenc": 1, "further": 1, "human": 1, "implic": 1, "impli": 1, "improv": 1, "logic": 2, "low": 1, "machin": 2, "mccluskey": 1, "memori": 1, "merit": 1, "method": 4, "minim": 1, "number": 1, "object": 5, "occur": 1, "optim": 1, "overspecifi": 1, "potenti": 1, "preprocess": 1, "prime": 1, "quien": 1, "reader": 1, "reduc": 4, "requir": 1, "rule": 6, "shown": 1, "simplif": 1, "simplifi": 1, "tabl": 4, "techniqu": 1, "time": 2, "shwayder": 1}}, "2727": {"id": "2727", "title": "Multiple Byte Processing with Full-Word Instructions", "abstract": "A method is described which allows parallel processing of packed data items using only ordinary  full-word computer instructions, even though the processing requires operations whose execution is contingent  upon the value of a datum.  It provides a useful technique for processing small data items such as alphanumeric  characters.", "authors": "Lamport, L.", "words_pool": ["alphanumer", "byte", "charact", "comput", "conting", "data", "datum", "execut", "full", "instruct", "item", "method", "multipl", "oper", "ordinari", "pack", "parallel", "process", "requir", "small", "techniqu", "word", "lamport"], "word_count": {"alphanumer": 1, "byte": 1, "charact": 1, "comput": 1, "conting": 1, "data": 2, "datum": 1, "execut": 1, "full": 1, "instruct": 1, "item": 2, "method": 1, "multipl": 1, "oper": 1, "ordinari": 1, "pack": 1, "parallel": 1, "process": 3, "requir": 1, "small": 1, "techniqu": 1, "word": 1, "lamport": 1}}, "2728": {"id": "2728", "title": "Consecutive Storage of Relevant Records with Redundancy", "abstract": "This paper studies the properties of a new class of file organizations (CRWR) where records  relevant to every query are stored in consecutive storage locations but the organizations contain redundancy.  Some theorems which provide tools for reducing redundancy in CRWR organizations have been also developed.  Redundancies obtained by the application of these theorems are compared with that of query-inverted file  organizations.  Some CRWR organization with minimum redundancy have also been developed for queries which  specify sets of keys.", "authors": "Ghosh, S. P.", "words_pool": ["applic", "class", "compar", "consecut", "crwr", "develop", "invert", "key", "locat", "minimum", "obtain", "organ", "organ", "paper", "properti", "provid", "queri", "queri", "record", "reduc", "redund", "redund", "relev", "set", "storag", "store", "studi", "theorem", "tool", "ghosh"], "word_count": {"applic": 1, "class": 1, "compar": 1, "consecut": 1, "crwr": 3, "develop": 2, "invert": 1, "key": 1, "locat": 1, "minimum": 1, "obtain": 1, "organ": 5, "paper": 1, "properti": 1, "provid": 1, "queri": 3, "record": 1, "reduc": 1, "redund": 4, "relev": 1, "set": 1, "storag": 1, "store": 1, "studi": 1, "theorem": 2, "tool": 1, "ghosh": 1}}, "2729": {"id": "2729", "title": "Comments on a Paper by T. C. Chen and I. T. Ho", "authors": "Smith, A. J.", "words_pool": ["chen", "comment", "ho", "paper", "smith"], "word_count": {"chen": 1, "comment": 1, "ho": 1, "paper": 1, "smith": 1}}, "2730": {"id": "2730", "title": "Interactive Consulting via Natural Language", "abstract": "Interactive programming systems often contain help commands to give the programmer on-line  instruction regarding the use of the various systems commands.  It is argued that it would be relatively  easy to make these help commands significantly more helpful by having them accept requests in natural  language.  As a demonstration, Weizenbaum's ELIZA program has been provided with a script that turns  it into a natural language system consultant.", "authors": "Sharo, S. C. Kwasny, S. C.", "words_pool": ["accept", "argu", "command", "consult", "consult", "demonstr", "easi", "eliza", "give", "help", "help", "instruct", "interact", "languag", "line", "make", "natur", "program", "programm", "program", "provid", "regard", "request", "script", "significantli", "system", "system", "turn", "weizenbaum", "sharo", "kwasni"], "word_count": {"accept": 1, "argu": 1, "command": 3, "consult": 1, "demonstr": 1, "easi": 1, "eliza": 1, "give": 1, "help": 3, "instruct": 1, "interact": 1, "languag": 2, "line": 1, "make": 1, "natur": 2, "program": 2, "programm": 1, "provid": 1, "regard": 1, "request": 1, "script": 1, "significantli": 1, "system": 3, "turn": 1, "weizenbaum": 1, "sharo": 1, "kwasni": 1}}, "2731": {"id": "2731", "title": "Remark on Stably Updating Mean and Standard Deviation of Data", "authors": "Cotton, I. W.", "words_pool": ["data", "deviat", "mean", "remark", "stabli", "standard", "updat", "cotton"], "word_count": {"data": 1, "deviat": 1, "mean": 1, "remark": 1, "stabli": 1, "standard": 1, "updat": 1, "cotton": 1}}, "2732": {"id": "2732", "title": "Guarded Commands, Nondeterminacy and Formal Derivation of Programs", "abstract": "So-called \"guarded commands\" are introduced as a building block for alternative and repetitive  constructs that allow nondeterministic program components for which at least the activity evoked, but  possible even the final state, is not necessarily uniquely determined by the initial state.  For the  formal derivation of programs expressed in terms of these constructs, a calculus will be shown.", "authors": "Dijkstra, E. W.", "words_pool": ["activ", "allow", "altern", "block", "build", "calculu", "call", "command", "compon", "construct", "deriv", "determin", "evok", "express", "final", "formal", "guard", "initi", "introduc", "necessarili", "nondeterminaci", "nondeterminist", "program", "program", "repetit", "shown", "state", "term", "uniqu", "dijkstra"], "word_count": {"activ": 1, "allow": 1, "altern": 1, "block": 1, "build": 1, "calculu": 1, "call": 1, "command": 1, "compon": 1, "construct": 2, "deriv": 1, "determin": 1, "evok": 1, "express": 1, "final": 1, "formal": 1, "guard": 1, "initi": 1, "introduc": 1, "necessarili": 1, "nondeterminaci": 1, "nondeterminist": 1, "program": 2, "repetit": 1, "shown": 1, "state": 2, "term": 1, "uniqu": 1, "dijkstra": 1}}, "2733": {"id": "2733", "title": "Deterministic Parsing of Ambiguous Grammars", "abstract": "Methods of describing the syntax of programming languages in ways that are more flexible and  natural than conventional BNF descriptions are considered.  These methods involve the use of ambiguous  context-free grammars together with rules to resolve syntactic ambiguities.  It is shown how efficient  LR and LL parsers can be constructed directly from certain classes of these specifications.", "authors": "Aho, A. V. Johnson, S. C. Ullman, J. D.", "words_pool": ["ambigu", "ambigu", "bnf", "class", "consid", "construct", "context", "convent", "describ", "descript", "determinist", "directli", "effici", "flexibl", "free", "grammar", "involv", "languag", "ll", "lr", "method", "natur", "parser", "pars", "program", "resolv", "rule", "shown", "specif", "syntact", "syntax", "way", "aho", "johnson", "ullman"], "word_count": {"ambigu": 2, "bnf": 1, "class": 1, "consid": 1, "construct": 1, "context": 1, "convent": 1, "describ": 1, "descript": 1, "determinist": 1, "directli": 1, "effici": 1, "flexibl": 1, "free": 1, "grammar": 1, "involv": 1, "languag": 1, "ll": 1, "lr": 1, "method": 2, "natur": 1, "parser": 1, "pars": 1, "program": 1, "resolv": 1, "rule": 1, "shown": 1, "specif": 1, "syntact": 1, "syntax": 1, "way": 1, "aho": 1, "johnson": 1, "ullman": 1}}, "2734": {"id": "2734", "title": "On the External Storage Fragmentation Produced by First-Fit and Best-Fit Allocation Strategies", "abstract": "Published comparisons of the external fragmentation produced by first-fit and best-fit memory  allocation have not been consistent.  Through simulation, a series of experiments were performed in order  to obtain better data on the relative performance of first-fit and best-fit and a better understanding  of the reasons underlying observed differences. The time-memory-product efficiencies of first-fit and  best-fit were generally within 1 to 3 percent of each other.  Except for small populations, the size  of the request population had little effect on allocation efficiency.  For exponential and hyperexponential  distributions of requests, first-fit outperformed best-fit; but for normal and uniform distributions,  and for exponential distributions distorted in various ways, best-fit outperformed first-fit.  It is  hypothesized that when first-fit outperforms best-fit, it does so because first-fit, by preferentially  allocating toward one end of memory, encourages large blocks to grow at the other end.  Sufficient contiguous  space is thereby more likely to be available for relatively large requests.  Results of simulation experiments  supported this hypothesis and showed that the relative performance of first-fit and best-fit depends  on the frequency of request.  When the coefficient of variation of the request distribution is greater  than or approximately equal to unity, first-fit outperformed best-fit.", "authors": "Shore, J. E.", "words_pool": ["alloc", "alloc", "approxim", "block", "coeffici", "comparison", "consist", "contigu", "data", "depend", "differ", "distort", "distribut", "distribut", "effect", "effici", "effici", "encourag", "end", "equal", "experi", "exponenti", "extern", "fit", "fragment", "frequenc", "gener", "greater", "grow", "hyperexponenti", "hypothesi", "hypothes", "larg", "like", "memori", "normal", "observ", "obtain", "order", "outperform", "outperform", "percent", "perform", "perform", "popul", "popul", "preferenti", "produc", "product", "publish", "reason", "rel", "request", "request", "result", "seri", "show", "simul", "size", "small", "space", "storag", "strategi", "suffici", "support", "time", "underli", "understand", "uniform", "uniti", "variat", "way", "shore"], "word_count": {"alloc": 3, "approxim": 1, "block": 1, "coeffici": 1, "comparison": 1, "consist": 1, "contigu": 1, "data": 1, "depend": 1, "differ": 1, "distort": 1, "distribut": 4, "effect": 1, "effici": 2, "encourag": 1, "end": 2, "equal": 1, "experi": 2, "exponenti": 2, "extern": 1, "fit": 17, "fragment": 1, "frequenc": 1, "gener": 1, "greater": 1, "grow": 1, "hyperexponenti": 1, "hypothesi": 1, "hypothes": 1, "larg": 2, "like": 1, "memori": 3, "normal": 1, "observ": 1, "obtain": 1, "order": 1, "outperform": 4, "percent": 1, "perform": 3, "popul": 2, "preferenti": 1, "produc": 1, "product": 1, "publish": 1, "reason": 1, "rel": 2, "request": 5, "result": 1, "seri": 1, "show": 1, "simul": 2, "size": 1, "small": 1, "space": 1, "storag": 1, "strategi": 1, "suffici": 1, "support": 1, "time": 1, "underli": 1, "understand": 1, "uniform": 1, "uniti": 1, "variat": 1, "way": 1, "shore": 1}}, "2735": {"id": "2735", "title": "Discrimination in the Employment of Women in the Computer Industry", "authors": "Weber, R. E. Gilchrist, B.", "words_pool": ["comput", "discrimin", "employ", "industri", "women", "weber", "gilchrist"], "word_count": {"comput": 1, "discrimin": 1, "employ": 1, "industri": 1, "women": 1, "weber": 1, "gilchrist": 1}}, "2736": {"id": "2736", "title": "A Note on Hash Linking", "authors": "Bobrow, D. G.", "words_pool": ["hash", "link", "note", "bobrow"], "word_count": {"hash": 1, "link": 1, "note": 1, "bobrow": 1}}, "2737": {"id": "2737", "title": "Determining the Minimum-Area Encasing Rectangle for an Arbitrary Closed Curve", "abstract": "This paper describes a method for finding the rectangle of minimum area in which a given arbitrary  plane curve can be contained.  The method is of interest in certain packing and optimum layout problems.   It consists of first determining the minimal-perimeter convex polygon that encloses the given curve  and then selecting the rectangle of minimum area capable of containing this polygon.  Three theorems  are introduced to show that one side of the minimum-area rectangle must be colinear with an edge of the  enclosed polygon and that the minimum-area encasing rectangle for the convex polygon is also the minimum-area  rectangle for the curve.", "authors": "Freeman, H. Shapira, R.", "words_pool": ["arbitrari", "area", "capabl", "close", "colinear", "consist", "contain", "convex", "curv", "describ", "determin", "edg", "encas", "enclos", "enclos", "find", "interest", "introduc", "layout", "method", "minim", "minimum", "optimum", "pack", "paper", "perimet", "plane", "polygon", "problem", "rectangl", "select", "show", "side", "theorem", "freeman", "shapira"], "word_count": {"arbitrari": 1, "area": 5, "capabl": 1, "close": 1, "colinear": 1, "consist": 1, "contain": 1, "convex": 2, "curv": 3, "describ": 1, "determin": 1, "edg": 1, "encas": 1, "enclos": 2, "find": 1, "interest": 1, "introduc": 1, "layout": 1, "method": 2, "minim": 1, "minimum": 5, "optimum": 1, "pack": 1, "paper": 1, "perimet": 1, "plane": 1, "polygon": 4, "problem": 1, "rectangl": 5, "select": 1, "show": 1, "side": 1, "theorem": 1, "freeman": 1, "shapira": 1}}, "2738": {"id": "2738", "title": "Use of the Concept of Transparency in the Design of Hierarchically Structured Systems", "abstract": "This paper deals with the design of hierarchically structured programming systems.  It develops  a method for evaluating the cost of requiring programmers to work with an abstraction of a real machine.   A number of examples from hardware and software are given as illustrations of the method.", "authors": "Parnas, D. L. Siewiorek, D. P.", "words_pool": ["abstract", "concept", "cost", "deal", "design", "develop", "evalu", "exampl", "hardwar", "hierarch", "illustr", "machin", "method", "number", "paper", "programm", "program", "real", "requir", "softwar", "structur", "system", "transpar", "work", "parna", "siewiorek"], "word_count": {"abstract": 1, "concept": 1, "cost": 1, "deal": 1, "design": 1, "develop": 1, "evalu": 1, "exampl": 1, "hardwar": 1, "hierarch": 1, "illustr": 1, "machin": 1, "method": 2, "number": 1, "paper": 1, "programm": 1, "program": 1, "real": 1, "requir": 1, "softwar": 1, "structur": 1, "system": 1, "transpar": 1, "work": 1, "parna": 1, "siewiorek": 1}}, "2739": {"id": "2739", "title": "The Restriction Language for Computer Grammars of Natural Language", "abstract": "Over the past few years, a number of systems for the computer analysis of natural language  sentences have been based on augmented context-free grammars: a context-free grammar which defines a  set of parse trees for a sentence, plus a group of restrictions to which a tree must conform in order  to be a valid sentence analysis.  As the coverage of the grammar is increased, an efficient representation  becomes essential for further development.  This paper presents a programming language designed specifically  for the compact and perspicuous statement of restrictions of a natural language grammar.  It is based  on ten years' experience parsing text sentences with the comprehensive English grammar of the N.Y.U.  Linguistic String Project, and embodies in its syntax and routines the relations which were found to  be useful and adequate for computerized natural language analysis.  The language is used in the current  implementation of the Linguistic String Parser.", "authors": "Sager, N. Grishman, R.", "words_pool": ["adequ", "analysi", "augment", "base", "compact", "comprehens", "comput", "computer", "conform", "context", "coverag", "defin", "design", "develop", "effici", "embodi", "english", "essenti", "experi", "found", "free", "grammar", "grammar", "group", "implement", "increas", "languag", "linguist", "natur", "number", "order", "paper", "pars", "parser", "pars", "past", "perspicu", "present", "program", "project", "relat", "represent", "restrict", "restrict", "routin", "sentenc", "sentenc", "set", "specif", "statement", "string", "syntax", "system", "ten", "text", "tree", "tree", "valid", "year", "sager", "grishman"], "word_count": {"adequ": 1, "analysi": 3, "augment": 1, "base": 2, "compact": 1, "comprehens": 1, "comput": 1, "computer": 1, "conform": 1, "context": 2, "coverag": 1, "defin": 1, "design": 1, "develop": 1, "effici": 1, "embodi": 1, "english": 1, "essenti": 1, "experi": 1, "found": 1, "free": 2, "grammar": 5, "group": 1, "implement": 1, "increas": 1, "languag": 5, "linguist": 2, "natur": 3, "number": 1, "order": 1, "paper": 1, "pars": 2, "parser": 1, "past": 1, "perspicu": 1, "present": 1, "program": 1, "project": 1, "relat": 1, "represent": 1, "restrict": 2, "routin": 1, "sentenc": 4, "set": 1, "specif": 1, "statement": 1, "string": 2, "syntax": 1, "system": 1, "ten": 1, "text": 1, "tree": 2, "valid": 1, "year": 2, "sager": 1, "grishman": 1}}, "2740": {"id": "2740", "title": "A Large Semaphore Based Operating System", "abstract": "The paper describes the internal structure of a large operating system as a set of cooperating  sequential processes.  The processes synchronize by means of semaphores and extended semaphores (queue  semaphores).  The number of parallel processes is carefully justified, and the various semaphore constructions  are explained.  The system is proved to be free of \"deadly embrace\" (deadlock).  The design principle  is an alternative to Dijkstra's hierarchical structuring of operating systems.  The project management  and the performance are discussed, too.  The operating system is the first large one using the RC 4000  multiprogramming system.", "authors": "Lauesen, S.", "words_pool": ["altern", "base", "care", "construct", "cooper", "deadlock", "deadli", "describ", "design", "dijkstra", "discuss", "embrac", "explain", "extend", "free", "hierarch", "intern", "justifi", "larg", "manag", "mean", "multiprogram", "number", "oper", "paper", "parallel", "perform", "principl", "process", "project", "prove", "queue", "rc", "semaphor", "semaphor", "sequenti", "set", "structur", "structur", "synchron", "system", "system", "lauesen"], "word_count": {"altern": 1, "base": 1, "care": 1, "construct": 1, "cooper": 1, "deadlock": 1, "deadli": 1, "describ": 1, "design": 1, "dijkstra": 1, "discuss": 1, "embrac": 1, "explain": 1, "extend": 1, "free": 1, "hierarch": 1, "intern": 1, "justifi": 1, "larg": 2, "manag": 1, "mean": 1, "multiprogram": 1, "number": 1, "oper": 3, "paper": 1, "parallel": 1, "perform": 1, "principl": 1, "process": 3, "project": 1, "prove": 1, "queue": 1, "rc": 1, "semaphor": 4, "sequenti": 1, "set": 1, "structur": 2, "synchron": 1, "system": 5, "lauesen": 1}}, "2741": {"id": "2741", "title": "Decomposability, Instabilities, and Saturation in Multiprogramming Systems", "abstract": "A step-by-step approach to model the dynamic behavior and evaluate the performance of computing  systems is proposed.  It is based on a technique of variable aggregation and the concept of nearly decomposable  system, both borrowed from Econometrics.  This approach is taken in order to identify in multiprogramming  paging systems (i) unstable regimes of operations and (ii) critical computing loads which bring the system  into states of saturation.  This analysis leads to a more complete definition of the circumstances in  which \"thrashing\" can set in.", "authors": "Courtois, P. J.", "words_pool": ["aggreg", "analysi", "approach", "base", "behavior", "borrow", "bring", "circumst", "complet", "comput", "concept", "critic", "decompos", "decompos", "definit", "dynam", "econometr", "evalu", "identifi", "ii", "instabl", "lead", "load", "model", "multiprogram", "nearli", "oper", "order", "page", "perform", "propos", "regim", "satur", "set", "state", "step", "system", "system", "techniqu", "thrash", "unstabl", "variabl", "courtoi"], "word_count": {"aggreg": 1, "analysi": 1, "approach": 2, "base": 1, "behavior": 1, "borrow": 1, "bring": 1, "circumst": 1, "complet": 1, "comput": 2, "concept": 1, "critic": 1, "decompos": 1, "definit": 1, "dynam": 1, "econometr": 1, "evalu": 1, "identifi": 1, "ii": 1, "instabl": 1, "lead": 1, "load": 1, "model": 1, "multiprogram": 1, "nearli": 1, "oper": 1, "order": 1, "page": 1, "perform": 1, "propos": 1, "regim": 1, "satur": 1, "set": 1, "state": 1, "step": 2, "system": 4, "techniqu": 1, "thrash": 1, "unstabl": 1, "variabl": 1, "courtoi": 1}}, "2742": {"id": "2742", "title": "Improved Event-Scanning Mechanisms for Discrete Event Simulation", "abstract": "Simulation models of large, complex \"real-world\" applications have occasionally earned the  reputation of eating up hours of computer time.  This problem may be attributed in part to difficulties  such as slow stochastic convergence.  However, an additional problem lies in the fact that a significant  amount of bookkeeping time is required to keep future events in their proper sequence.  This paper presents  a method for significantly reducing the time spent scanning future event lists in discrete event simulations.   There models are presented, all of which improve in effectiveness as the events-list scan problem becomes  more burdensome.", "authors": "Wyman, F. P.", "words_pool": ["addit", "amount", "applic", "attribut", "bookkeep", "burdensom", "complex", "comput", "converg", "difficulti", "discret", "earn", "eat", "effect", "event", "event", "fact", "futur", "hour", "improv", "improv", "larg", "lie", "list", "list", "mechan", "method", "model", "occasion", "paper", "part", "present", "present", "problem", "proper", "real", "reduc", "reput", "requir", "scan", "scan", "sequenc", "signific", "significantli", "simul", "simul", "slow", "spent", "stochast", "time", "world", "wyman"], "word_count": {"addit": 1, "amount": 1, "applic": 1, "attribut": 1, "bookkeep": 1, "burdensom": 1, "complex": 1, "comput": 1, "converg": 1, "difficulti": 1, "discret": 1, "earn": 1, "eat": 1, "effect": 1, "event": 4, "fact": 1, "futur": 2, "hour": 1, "improv": 1, "larg": 1, "lie": 1, "list": 2, "mechan": 1, "method": 1, "model": 2, "occasion": 1, "paper": 1, "part": 1, "present": 2, "problem": 3, "proper": 1, "real": 1, "reduc": 1, "reput": 1, "requir": 1, "scan": 2, "sequenc": 1, "signific": 1, "significantli": 1, "simul": 2, "slow": 1, "spent": 1, "stochast": 1, "time": 3, "world": 1, "wyman": 1}}, "2743": {"id": "2743", "title": "Sorting X + Y", "authors": "Harper, L. H. Payne, T. H. Savage, J. E. Straus, E.", "words_pool": ["sort", "harper", "payn", "savag", "strau"], "word_count": {"sort": 1, "harper": 1, "payn": 1, "savag": 1, "strau": 1}}, "2744": {"id": "2744", "title": "Addition in an Arbitrary Base Without Radix Conversion", "abstract": "This paper presents a generalization of an old programming technique; using it,one may add  and subtract numbers represented in any radix, including a mixed radix, and stored one digit per byte  in bytes of sufficient size.  Radix conversion is unnecessary, no looping is required, and numbers may  even be stored in a display (I/O) format.  Applications to Cobol, MIX, and hexadecimal sums are discussed.", "authors": "Soule, S.", "words_pool": ["add", "addit", "applic", "arbitrari", "base", "byte", "byte", "cobol", "convers", "digit", "discuss", "display", "format", "gener", "hexadecim", "includ", "loop", "mix", "mix", "number", "paper", "present", "program", "radix", "repres", "requir", "size", "store", "subtract", "suffici", "sum", "techniqu", "unnecessari", "soul"], "word_count": {"add": 1, "addit": 1, "applic": 1, "arbitrari": 1, "base": 1, "byte": 2, "cobol": 1, "convers": 1, "digit": 1, "discuss": 1, "display": 1, "format": 1, "gener": 1, "hexadecim": 1, "includ": 1, "loop": 1, "mix": 2, "number": 2, "paper": 1, "present": 1, "program": 1, "radix": 3, "repres": 1, "requir": 1, "size": 1, "store": 2, "subtract": 1, "suffici": 1, "sum": 1, "techniqu": 1, "unnecessari": 1, "soul": 1}}, "2745": {"id": "2745", "title": "A Linear Space Algorithm for Computing Maximal Common Subsequences", "abstract": "The problem of finding a longest common subsequence of two strings has been solved in quadratic  time and space.  An algorithm is presented which will solve this problem in quadratic time and in linear  space.", "authors": "Hirschberg, D. S.", "words_pool": ["algorithm", "common", "comput", "find", "linear", "longest", "maxim", "present", "problem", "quadrat", "solv", "solv", "space", "string", "subsequ", "subsequ", "time", "hirschberg"], "word_count": {"algorithm": 1, "common": 1, "comput": 1, "find": 1, "linear": 1, "longest": 1, "maxim": 1, "present": 1, "problem": 2, "quadrat": 2, "solv": 2, "space": 2, "string": 1, "subsequ": 1, "time": 2, "hirschberg": 1}}, "2746": {"id": "2746", "title": "Efficient String Matching: An Aid to Bibliographic Search", "abstract": "This paper describes a simple, efficient algorithm to locate all occurrences of any of a finite  number of keywords in a string of text.  The algorithm consists of constructing a finite state pattern  matching machine from the keywords and then using the pattern matching machine to process the text string  in a single pass.  Construction of the pattern matching machine takes time proportional to the sum of  the lengths of the keywords.  The number of state transitions made by the pattern matching machine in  processing the text string is independent of the number of keywords.  The algorithm has been used to  improve the speed of a library bibliographic search program by a factor of 5 to 10.", "authors": "Aho, A. V. Corasick, M. J.", "words_pool": ["aid", "algorithm", "bibliograph", "consist", "construct", "construct", "describ", "effici", "factor", "finit", "improv", "independ", "keyword", "length", "librari", "locat", "machin", "made", "match", "number", "occurr", "paper", "pass", "pattern", "process", "process", "program", "proport", "search", "simpl", "singl", "speed", "state", "string", "sum", "take", "text", "time", "transit", "aho", "corasick"], "word_count": {"aid": 1, "algorithm": 3, "bibliograph": 1, "consist": 1, "construct": 2, "describ": 1, "effici": 1, "factor": 1, "finit": 2, "improv": 1, "independ": 1, "keyword": 4, "length": 1, "librari": 1, "locat": 1, "machin": 4, "made": 1, "match": 4, "number": 3, "occurr": 1, "paper": 1, "pass": 1, "pattern": 4, "process": 2, "program": 1, "proport": 1, "search": 1, "simpl": 1, "singl": 1, "speed": 1, "state": 2, "string": 3, "sum": 1, "take": 1, "text": 3, "time": 1, "transit": 1, "aho": 1, "corasick": 1}}, "2747": {"id": "2747", "title": "A Simplified Recombination Scheme for the Fibonacci Buddy System", "abstract": "A simplified recombination scheme for the Fibonacci buddy system which requires neither tables  nor repetitive calculations and uses only two additional bits per buffer is presented.", "authors": "Cranston, B. Thomas, R.", "words_pool": ["addit", "bit", "buddi", "buffer", "calcul", "fibonacci", "present", "recombin", "repetit", "requir", "scheme", "simplifi", "system", "tabl", "cranston", "thoma"], "word_count": {"addit": 1, "bit": 1, "buddi": 1, "buffer": 1, "calcul": 1, "fibonacci": 1, "present": 1, "recombin": 1, "repetit": 1, "requir": 1, "scheme": 1, "simplifi": 1, "system": 1, "tabl": 1, "cranston": 1, "thoma": 1}}, "2748": {"id": "2748", "title": "Indirect Threaded Code", "abstract": "An efficient arrangement for interpretive code is described.  It is related to Bell's notion  of threaded code but requires less space and is more amenable to machine independent implementations.", "authors": "Dewar, R. B. K.", "words_pool": ["amen", "arrang", "bell", "code", "effici", "implement", "independ", "indirect", "interpret", "machin", "notion", "relat", "requir", "space", "thread", "dewar"], "word_count": {"amen": 1, "arrang": 1, "bell": 1, "code": 2, "effici": 1, "implement": 1, "independ": 1, "indirect": 1, "interpret": 1, "machin": 1, "notion": 1, "relat": 1, "requir": 1, "space": 1, "thread": 1, "dewar": 1}}, "2749": {"id": "2749", "title": "Significant Event Simulation", "abstract": "This paper compares a new method of simulation organization, called the significant event method,  with an old one, called the clock pulse method, using as examples two automobile traffic models.  The  significant event method is found to be more efficient than the clock pulse method at low levels of system  interaction and less efficient at high levels.  A simple mathematical model for the trade-off in the  relative running time of the two methods is developed.  The model aids in choosing between the two simulation  methods for a particular experiment.  It is concluded that the significant event method can be of value  in the simulation of some systems when computational efficiency is of sufficient importance.", "authors": "Babich, A. F. Grason, J. Parnas, D. L.", "words_pool": ["aid", "automobil", "call", "choos", "clock", "compar", "comput", "conclud", "develop", "effici", "effici", "event", "exampl", "experi", "found", "high", "import", "interact", "level", "low", "mathemat", "method", "method", "model", "model", "organ", "paper", "puls", "rel", "run", "signific", "simpl", "simul", "suffici", "system", "system", "time", "trade", "traffic", "babich", "grason", "parna"], "word_count": {"aid": 1, "automobil": 1, "call": 2, "choos": 1, "clock": 2, "compar": 1, "comput": 1, "conclud": 1, "develop": 1, "effici": 3, "event": 3, "exampl": 1, "experi": 1, "found": 1, "high": 1, "import": 1, "interact": 1, "level": 2, "low": 1, "mathemat": 1, "method": 8, "model": 3, "organ": 1, "paper": 1, "puls": 2, "rel": 1, "run": 1, "signific": 3, "simpl": 1, "simul": 3, "suffici": 1, "system": 2, "time": 1, "trade": 1, "traffic": 1, "babich": 1, "grason": 1, "parna": 1}}, "2750": {"id": "2750", "title": "A Cost Oriented Algorithm for Data Set Allocation in Storage Hierarchies", "abstract": "Data set allocation in today's multilevel storage systems is usually based on qualitative,  ad hoc decisions.  While it would be desirable to obtain an optimal solution to this allocation problem,  it is clear that the number of parameters involved makes it intractable to straight-forward solution.   In such a situation, we must find a set of assumptions which simplify the problem greatly, but which  still provide a basis for considering all significant cost elements. This paper presents such a first,  quantitative allocation step.  It considers many of the significant detailed costs of system utilization,  data storage, data staging, and data migration.  Although many avenues of further improvement are available,  the present algorithm seems to be usefully accurate. As such, it can aid in quantifying the problems  of data set allocation, storage system configuration, and new device designs.", "authors": "Lum, V. Y. Senko, M. E Wang, C. P. Ling, H.", "words_pool": ["accur", "ad", "aid", "algorithm", "alloc", "assumpt", "avenu", "base", "basi", "clear", "configur", "consid", "consid", "cost", "cost", "data", "decis", "design", "desir", "detail", "devic", "element", "find", "forward", "greatli", "hierarchi", "hoc", "improv", "intract", "involv", "make", "migrat", "multilevel", "number", "obtain", "optim", "orient", "paper", "paramet", "present", "present", "problem", "problem", "provid", "qualit", "quantifi", "quantit", "set", "signific", "simplifi", "situat", "solut", "stage", "step", "storag", "straight", "system", "system", "today", "use", "util", "lum", "senko", "wang", "ling"], "word_count": {"accur": 1, "ad": 1, "aid": 1, "algorithm": 1, "alloc": 4, "assumpt": 1, "avenu": 1, "base": 1, "basi": 1, "clear": 1, "configur": 1, "consid": 2, "cost": 2, "data": 5, "decis": 1, "design": 1, "desir": 1, "detail": 1, "devic": 1, "element": 1, "find": 1, "forward": 1, "greatli": 1, "hierarchi": 1, "hoc": 1, "improv": 1, "intract": 1, "involv": 1, "make": 1, "migrat": 1, "multilevel": 1, "number": 1, "obtain": 1, "optim": 1, "orient": 1, "paper": 1, "paramet": 1, "present": 2, "problem": 3, "provid": 1, "qualit": 1, "quantifi": 1, "quantit": 1, "set": 3, "signific": 2, "simplifi": 1, "situat": 1, "solut": 2, "stage": 1, "step": 1, "storag": 3, "straight": 1, "system": 3, "today": 1, "use": 1, "util": 1, "lum": 1, "senko": 1, "wang": 1, "ling": 1}}, "2751": {"id": "2751", "title": "Illumination for Computer Generated Pictures", "abstract": "The quality of computer generated images of three-dimensional scenes depends on the shading  technique used to paint the objects on the cathode-ray tube screen.  The shading algorithm itself depends  in part on the method for modeling the object, which also determines the hidden surface algorithm.  The  various methods of object modeling, shading, and hidden surface removal are thus strongly interconnected.   Several shading techniques corresponding to different methods of object modeling and the related hidden  surface algorithms are presented here.  Human visual perception and the fundamental laws of optics are  considered in the development of a shading rule that provides better quality and increased realism in  generated images.", "authors": "Phong, B. T.", "words_pool": ["algorithm", "algorithm", "cathod", "comput", "consid", "depend", "determin", "develop", "dimension", "fundament", "gener", "hidden", "human", "illumin", "imag", "increas", "interconnect", "law", "method", "method", "model", "object", "object", "optic", "paint", "part", "percept", "pictur", "present", "qualiti", "ray", "realism", "relat", "remov", "rule", "scene", "screen", "shade", "strongli", "surfac", "techniqu", "techniqu", "tube", "visual", "phong"], "word_count": {"algorithm": 3, "cathod": 1, "comput": 1, "consid": 1, "depend": 2, "determin": 1, "develop": 1, "dimension": 1, "fundament": 1, "gener": 2, "hidden": 3, "human": 1, "illumin": 1, "imag": 2, "increas": 1, "interconnect": 1, "law": 1, "method": 3, "model": 3, "object": 4, "optic": 1, "paint": 1, "part": 1, "percept": 1, "pictur": 1, "present": 1, "qualiti": 2, "ray": 1, "realism": 1, "relat": 1, "remov": 1, "rule": 1, "scene": 1, "screen": 1, "shade": 5, "strongli": 1, "surfac": 3, "techniqu": 2, "tube": 1, "visual": 1, "phong": 1}}, "2752": {"id": "2752", "title": "Generation of All the Cycles of a Graph from a Set of Basic Cycles [H] (Algorithm 492)", "authors": "Gibbs, N. E.", "words_pool": ["algorithm", "basic", "cycl", "gener", "graph", "set", "gibb"], "word_count": {"algorithm": 1, "basic": 1, "cycl": 2, "gener": 1, "graph": 1, "set": 1, "gibb": 1}}, "2753": {"id": "2753", "title": "A Heuristic Problem Solving Design System for Equipment or Furniture Layouts", "abstract": "The Designer Problem Solver (DPS) demonstrates that the computer can perform simple design  tasks.  In particular, it designs furniture and equipment layouts.  This task was chosen because it is  simple, well defined, and characteristic of many design tasks in architecture, engineering, urban planning,  and natural resource management.  These space planning tasks usually involve manipulating two-dimensional  representations of objects to create feasible or optimal solutions for problems involving topological  and metric spatial constraints.  The paper describes extensive tests performed on the program.  DPS is  a heuristic problem solver with a planning phase prefixed to it.  It uses the planning process to give  it a sense of direction, diagnostic procedures to locate difficulties, and remedial actions to recover  from difficulties.  It uses a convex polygon representation to accurately describe the objects and the  layout.  This representation allows topological and metric constraints to be tested and the design to  be easily updated.  DPS has been applied to 50 problems.  While it is slow and limited in scope, the  ideas behind it are general.  It demonstrates the need for selectivity in controlling search and the  methods used to achieve it: task-specific information, planning, diagnostic procedures, remedial actions,  and selective alternative generators.", "authors": "Pfefferkorn, C. E.", "words_pool": ["accur", "achiev", "action", "altern", "appli", "architectur", "characterist", "chosen", "comput", "constraint", "control", "convex", "creat", "defin", "demonstr", "describ", "describ", "design", "design", "design", "diagnost", "difficulti", "dimension", "direct", "dp", "easili", "engin", "equip", "extens", "feasibl", "furnitur", "gener", "gener", "give", "heurist", "idea", "inform", "involv", "involv", "layout", "layout", "limit", "locat", "manag", "manipul", "method", "metric", "natur", "need", "object", "optim", "paper", "perform", "perform", "phase", "plan", "polygon", "prefix", "problem", "problem", "procedur", "process", "program", "recov", "remedi", "represent", "represent", "resourc", "scope", "search", "select", "select", "sens", "simpl", "slow", "solut", "solver", "solv", "space", "spatial", "specif", "system", "task", "task", "test", "test", "topolog", "updat", "urban", "pfefferkorn"], "word_count": {"accur": 1, "achiev": 1, "action": 2, "altern": 1, "appli": 1, "architectur": 1, "characterist": 1, "chosen": 1, "comput": 1, "constraint": 2, "control": 1, "convex": 1, "creat": 1, "defin": 1, "demonstr": 2, "describ": 2, "design": 5, "diagnost": 2, "difficulti": 2, "dimension": 1, "direct": 1, "dp": 3, "easili": 1, "engin": 1, "equip": 1, "extens": 1, "feasibl": 1, "furnitur": 1, "gener": 2, "give": 1, "heurist": 1, "idea": 1, "inform": 1, "involv": 2, "layout": 2, "limit": 1, "locat": 1, "manag": 1, "manipul": 1, "method": 1, "metric": 2, "natur": 1, "need": 1, "object": 2, "optim": 1, "paper": 1, "perform": 2, "phase": 1, "plan": 5, "polygon": 1, "prefix": 1, "problem": 4, "procedur": 2, "process": 1, "program": 1, "recov": 1, "remedi": 2, "represent": 3, "resourc": 1, "scope": 1, "search": 1, "select": 2, "sens": 1, "simpl": 2, "slow": 1, "solut": 1, "solver": 2, "solv": 1, "space": 1, "spatial": 1, "specif": 1, "system": 1, "task": 5, "test": 2, "topolog": 2, "updat": 1, "urban": 1, "pfefferkorn": 1}}, "2754": {"id": "2754", "title": "A Syntactic Algorithm for Peak Detection in Waveforms with Applications to Cardiography", "abstract": "Peaks in a digitized waveform are detected by an algorithm incorporating piecewise linear approximation  and tabular parsing techniques.  Several parameters serve to identify the waveform context enabling accurate  measurement of peak amplitude, duration, and shape.  The algorithm is of sufficient speed to allow on-line  real-time processing.  An example of its application is demonstrated on an electrocardiogram.", "authors": "Horowitz, S. L.", "words_pool": ["accur", "algorithm", "allow", "amplitud", "applic", "applic", "approxim", "cardiographi", "context", "demonstr", "detect", "detect", "digit", "durat", "electrocardiogram", "enabl", "identifi", "incorpor", "line", "linear", "measur", "paramet", "pars", "peak", "peak", "piecewis", "process", "real", "serv", "shape", "speed", "suffici", "syntact", "tabular", "techniqu", "time", "waveform", "waveform", "horowitz"], "word_count": {"accur": 1, "algorithm": 2, "allow": 1, "amplitud": 1, "applic": 1, "approxim": 1, "cardiographi": 1, "context": 1, "demonstr": 1, "detect": 1, "digit": 1, "durat": 1, "electrocardiogram": 1, "enabl": 1, "identifi": 1, "incorpor": 1, "line": 1, "linear": 1, "measur": 1, "paramet": 1, "pars": 1, "peak": 2, "piecewis": 1, "process": 1, "real": 1, "serv": 1, "shape": 1, "speed": 1, "suffici": 1, "syntact": 1, "tabular": 1, "techniqu": 1, "time": 1, "waveform": 2, "horowitz": 1}}, "2755": {"id": "2755", "title": "The New Math of Computer Programming (Corrigendum)", "authors": "Mills, H. D.", "words_pool": ["comput", "corrigendum", "math", "program", "mill"], "word_count": {"comput": 1, "corrigendum": 1, "math": 1, "program": 1, "mill": 1}}, "2756": {"id": "2756", "title": "A Problem-List of Public Policy Issues Concerning Computers and Health Care", "authors": "Wasserman, A. I.", "words_pool": ["care", "comput", "concern", "health", "issu", "list", "polici", "problem", "public", "wasserman"], "word_count": {"care": 1, "comput": 1, "concern": 1, "health": 1, "issu": 1, "list": 1, "polici": 1, "problem": 1, "public": 1, "wasserman": 1}}, "2757": {"id": "2757", "title": "More on kth Shortest Paths", "authors": "Fox, B.L.", "words_pool": ["kth", "path", "shortest", "fox"], "word_count": {"kth": 1, "path": 1, "shortest": 1, "fox": 1}}, "2758": {"id": "2758", "title": "A Note on the LU Factorization of a Symmetric Matrix", "authors": "Evans, D. J. Hatzopoulos, M.", "words_pool": ["factor", "lu", "matrix", "note", "symmetr", "evan", "hatzopoulo"], "word_count": {"factor": 1, "lu": 1, "matrix": 1, "note": 1, "symmetr": 1, "evan": 1, "hatzopoulo": 1}}, "2759": {"id": "2759", "title": "Solution of an Overdetermined System of Equations in the L1 Norm (Algorithm R478)", "authors": "Fritsch, F. N. Hindmarsh, A. C.", "words_pool": ["algorithm", "equat", "l1", "norm", "overdetermin", "r478", "solut", "system", "fritsch", "hindmarsh"], "word_count": {"algorithm": 1, "equat": 1, "l1": 1, "norm": 1, "overdetermin": 1, "r478": 1, "solut": 1, "system": 1, "fritsch": 1, "hindmarsh": 1}}, "2760": {"id": "2760", "title": "Visible Surface Plotting Program (Algorithm R475)", "authors": "Doran, C. J.", "words_pool": ["algorithm", "plot", "program", "r475", "surfac", "visibl", "doran"], "word_count": {"algorithm": 1, "plot": 1, "program": 1, "r475": 1, "surfac": 1, "visibl": 1, "doran": 1}}, "2761": {"id": "2761", "title": "Visible Surface Plotting Program (Algorithm R475)", "authors": "Mashburn, R. G.", "words_pool": ["algorithm", "plot", "program", "r475", "surfac", "visibl", "mashburn"], "word_count": {"algorithm": 1, "plot": 1, "program": 1, "r475": 1, "surfac": 1, "visibl": 1, "mashburn": 1}}, "2762": {"id": "2762", "title": "Ten Subroutines for the Manipulation of Chebyshev Series (Algorithm R446, C446)", "authors": "Piessens, R. Mertens, I.", "words_pool": ["algorithm", "c446", "chebyshev", "manipul", "r446", "seri", "subroutin", "ten", "piessen", "merten"], "word_count": {"algorithm": 1, "c446": 1, "chebyshev": 1, "manipul": 1, "r446": 1, "seri": 1, "subroutin": 1, "ten": 1, "piessen": 1, "merten": 1}}, "2763": {"id": "2763", "title": "Basic Cycle Generation [H] (Algorithm 491)", "authors": "Gibbs, N. E.", "words_pool": ["algorithm", "basic", "cycl", "gener", "gibb"], "word_count": {"algorithm": 1, "basic": 1, "cycl": 1, "gener": 1, "gibb": 1}}, "2764": {"id": "2764", "title": "An Intelligent Analyzer and Understander of English", "abstract": "The paper describes a working analysis and generation program for natural language, which handles  paragraph length input.  Its core is a system of preferential choice between deep semantic patterns,  based on what we call \"semantic density.\"  The system is contrasted: (1) with syntax oriented linguistic  approaches, and (2) with theorem proving approaches to the understanding problem.", "authors": "Wilks, Y.", "words_pool": ["analysi", "analyz", "approach", "base", "call", "choic", "contrast", "core", "deep", "densiti", "describ", "english", "gener", "handl", "input", "intellig", "languag", "length", "linguist", "natur", "orient", "paper", "paragraph", "pattern", "preferenti", "problem", "program", "prove", "semant", "syntax", "system", "theorem", "understand", "understand", "work", "wilk"], "word_count": {"analysi": 1, "analyz": 1, "approach": 2, "base": 1, "call": 1, "choic": 1, "contrast": 1, "core": 1, "deep": 1, "densiti": 1, "describ": 1, "english": 1, "gener": 1, "handl": 1, "input": 1, "intellig": 1, "languag": 1, "length": 1, "linguist": 1, "natur": 1, "orient": 1, "paper": 1, "paragraph": 1, "pattern": 1, "preferenti": 1, "problem": 1, "program": 1, "prove": 1, "semant": 2, "syntax": 1, "system": 2, "theorem": 1, "understand": 1, "work": 1, "wilk": 1}}, "2765": {"id": "2765", "title": "Analysis and performance of Inverted Data Base Structures", "abstract": "The need to envision and architecture data base systems in a hierarchical level by level framework  is stressed. The inverted data base (file) organization is then analyzed, considering implementation  oriented aspects.  The inverted directory is viewed realistically as another large data base which itself  is subjected to inversion.  Formulations are derived to estimate average access time (read only) and  storage requirements, formalizing the interaction of data base content characteristics, logical complexity  of queries, and machine timing and blocking specifications identified as having a first-order effect  on performance.  The formulations presented are necessary to be used in conjunction with any index selection  criteria to determine the optimum set of index keys.", "authors": "Cardenas, A. F.", "words_pool": ["access", "analysi", "analyz", "architectur", "aspect", "averag", "base", "block", "characterist", "complex", "conjunct", "consid", "content", "criteria", "data", "deriv", "determin", "directori", "effect", "envis", "estim", "formal", "formul", "framework", "hierarch", "identifi", "implement", "index", "interact", "invers", "invert", "key", "larg", "level", "logic", "machin", "need", "optimum", "order", "organ", "orient", "perform", "present", "queri", "read", "realist", "requir", "select", "set", "specif", "storag", "stress", "structur", "subject", "system", "time", "time", "view", "cardena"], "word_count": {"access": 1, "analysi": 1, "analyz": 1, "architectur": 1, "aspect": 1, "averag": 1, "base": 4, "block": 1, "characterist": 1, "complex": 1, "conjunct": 1, "consid": 1, "content": 1, "criteria": 1, "data": 4, "deriv": 1, "determin": 1, "directori": 1, "effect": 1, "envis": 1, "estim": 1, "formal": 1, "formul": 2, "framework": 1, "hierarch": 1, "identifi": 1, "implement": 1, "index": 2, "interact": 1, "invers": 1, "invert": 2, "key": 1, "larg": 1, "level": 2, "logic": 1, "machin": 1, "need": 1, "optimum": 1, "order": 1, "organ": 1, "orient": 1, "perform": 1, "present": 1, "queri": 1, "read": 1, "realist": 1, "requir": 1, "select": 1, "set": 1, "specif": 1, "storag": 1, "stress": 1, "structur": 1, "subject": 1, "system": 1, "time": 2, "view": 1, "cardena": 1}}, "2766": {"id": "2766", "title": "Copying Cyclic List Structures in Linear Time Using Bounded Workspace", "abstract": "A bounded workspace copying algorithm for arbitrary list structures is given.  This algorithm  operates in linear time and does not require tag bits.  The best previous bounded workspace copying algorithms  achieved n^2 time without tag bits and n log n time with one tag.  The only restriction on the algorithm  given here is that the copy must be placed into a contiguous section of memory.  The method is applicable  to fixed or variable size nodes.", "authors": "Fisher, D. A.", "words_pool": ["achiev", "algorithm", "algorithm", "applic", "arbitrari", "bit", "bound", "contigu", "copi", "copi", "cyclic", "fix", "linear", "list", "log", "memori", "method", "node", "oper", "previou", "requir", "restrict", "section", "size", "structur", "tag", "time", "variabl", "workspac", "fisher"], "word_count": {"achiev": 1, "algorithm": 4, "applic": 1, "arbitrari": 1, "bit": 2, "bound": 2, "contigu": 1, "copi": 3, "cyclic": 1, "fix": 1, "linear": 1, "list": 1, "log": 1, "memori": 1, "method": 1, "node": 1, "oper": 1, "previou": 1, "requir": 1, "restrict": 1, "section": 1, "size": 1, "structur": 1, "tag": 3, "time": 3, "variabl": 1, "workspac": 2, "fisher": 1}}, "2767": {"id": "2767", "title": "A Comparison of Simulation Event List Algorithms", "abstract": "Four algorithms are considered which can be used to schedule events in a general purpose discrete  simulation system.  Two of the algorithms are new, one is based on an end-order tree structure for event  notices, and another uses an indexed linear list. The algorithms are tested with a set of typical stochastic  scheduling distributions especially chosen to show the advantages and limitations of the algorithms.   The end-order tree algorithm is shown to be an advantageous, immediate replacement for the algorithm  in use with current simulation languages.  The most promising algorithm uses the indexed list concept.   It will require an adaptive routine before it can be employed in general purpose simulators,but its  performance is such that further study would be fruitful.", "authors": "Vaucher, J. G. Duval, P.", "words_pool": ["adapt", "advantag", "advantag", "algorithm", "algorithm", "base", "chosen", "comparison", "concept", "consid", "discret", "distribut", "employ", "end", "especi", "event", "event", "fruit", "gener", "index", "languag", "limit", "linear", "list", "notic", "order", "perform", "promis", "purpos", "replac", "requir", "routin", "schedul", "schedul", "set", "show", "shown", "simul", "simul", "stochast", "structur", "studi", "system", "test", "tree", "typic", "vaucher", "duval"], "word_count": {"adapt": 1, "advantag": 2, "algorithm": 7, "base": 1, "chosen": 1, "comparison": 1, "concept": 1, "consid": 1, "discret": 1, "distribut": 1, "employ": 1, "end": 2, "especi": 1, "event": 2, "fruit": 1, "gener": 2, "index": 2, "languag": 1, "limit": 1, "linear": 1, "list": 2, "notic": 1, "order": 2, "perform": 1, "promis": 1, "purpos": 2, "replac": 1, "requir": 1, "routin": 1, "schedul": 2, "set": 1, "show": 1, "shown": 1, "simul": 3, "stochast": 1, "structur": 1, "studi": 1, "system": 1, "test": 1, "tree": 2, "typic": 1, "vaucher": 1, "duval": 1}}, "2768": {"id": "2768", "title": "An Algorithm for Locating Adjacent Storage Blocks in the Buddy System", "abstract": "A simple scheme for the determination of the location of a block of storage relative to other  blocks is described.  This scheme is applicable to the buddy type storage allocation systems.", "authors": "Hinds, J. A.", "words_pool": ["adjac", "algorithm", "alloc", "applic", "block", "block", "buddi", "determin", "locat", "locat", "rel", "scheme", "simpl", "storag", "system", "system", "type", "hind"], "word_count": {"adjac": 1, "algorithm": 1, "alloc": 1, "applic": 1, "block": 2, "buddi": 1, "determin": 1, "locat": 1, "rel": 1, "scheme": 2, "simpl": 1, "storag": 2, "system": 1, "type": 1, "hind": 1}}, "2769": {"id": "2769", "title": "A Modification of Warshall's Algorithm for the Transitive Closure of Binary Relations", "abstract": "An algorithm is given for computing the transitive closure of a binary relation that is represented  by a Boolean matrix. The algorithm is similar to Warshall's although it executes faster for sparse matrices on most computers, particularly in a paging environment.", "authors": "Warren, H. S. Jr.", "words_pool": ["algorithm", "binari", "boolean", "closur", "comput", "comput", "environ", "execut", "faster", "matric", "matrix", "modif", "page", "relat", "relat", "repres", "similar", "spars", "transit", "warshal", "warren", "jr"], "word_count": {"algorithm": 2, "binari": 1, "boolean": 1, "closur": 1, "comput": 2, "environ": 1, "execut": 1, "faster": 1, "matric": 1, "matrix": 1, "modif": 1, "page": 1, "relat": 1, "repres": 1, "similar": 1, "spars": 1, "transit": 1, "warshal": 1, "warren": 1, "jr": 1}}, "2770": {"id": "2770", "title": "The Quadratic Hash Method When the Table Size Is Not a Prime Number", "abstract": "Previous work on quadratic hash methods is limited mainly to the case where the table size  is a prime number.  Here, certain results are derived for composite numbers.  It is shown that all composite  numbers containing at least the square of one of the component primes have full-period integer-coefficient  quadratic hash functions.", "authors": "Batagelj, V.", "words_pool": ["case", "coeffici", "compon", "composit", "deriv", "full", "function", "hash", "integ", "limit", "mainli", "method", "method", "number", "number", "period", "previou", "prime", "prime", "quadrat", "result", "shown", "size", "squar", "tabl", "work", "batagelj"], "word_count": {"case": 1, "coeffici": 1, "compon": 1, "composit": 2, "deriv": 1, "full": 1, "function": 1, "hash": 2, "integ": 1, "limit": 1, "mainli": 1, "method": 1, "number": 3, "period": 1, "previou": 1, "prime": 2, "quadrat": 2, "result": 1, "shown": 1, "size": 1, "squar": 1, "tabl": 1, "work": 1, "batagelj": 1}}, "2771": {"id": "2771", "title": "The Synthesis of Solids Bounded by Many Faces", "abstract": "A technique is presented which allows a class of solid objects to be synthesized and stored  using a computer.  Synthesis begins with primitive solids like a cube, wedge, or cylinder.  Any solid  can be moved, scaled, or rotated.  Solids may also be added together or subtracted.  Two algorithms to  perform addition are described.  For practical designers, the technique has the advantage that operations  are concise, readily composed, and are given in terms of easily imagined solids.Quite short sequences  of operations suffice to build up complex solids bounded by many faces.", "authors": "Braid, I. C.", "words_pool": ["ad", "addit", "advantag", "algorithm", "begin", "bound", "build", "class", "complex", "compos", "comput", "concis", "cube", "cylind", "design", "easili", "face", "imagin", "move", "object", "oper", "perform", "practic", "present", "primit", "readili", "rotat", "scale", "sequenc", "short", "solid", "solid", "store", "subtract", "suffic", "synthesi", "synthes", "techniqu", "term", "wedg", "braid"], "word_count": {"ad": 1, "addit": 1, "advantag": 1, "algorithm": 1, "begin": 1, "bound": 1, "build": 1, "class": 1, "complex": 1, "compos": 1, "comput": 1, "concis": 1, "cube": 1, "cylind": 1, "design": 1, "easili": 1, "face": 1, "imagin": 1, "move": 1, "object": 1, "oper": 2, "perform": 1, "practic": 1, "present": 1, "primit": 1, "readili": 1, "rotat": 1, "scale": 1, "sequenc": 1, "short": 1, "solid": 6, "store": 1, "subtract": 1, "suffic": 1, "synthesi": 1, "synthes": 1, "techniqu": 2, "term": 1, "wedg": 1, "braid": 1}}, "2772": {"id": "2772", "title": "On Maintenance of the Opportunity List for Class-Teacher Timetable Problems", "abstract": "One of the principal components of procedures for the solution of class-teacher timetable problems  is that for maintenance of the opportunity list.  Opportunity list maintenance methods are based on necessary  conditions for the existence of a solution. A general framework for necessary conditions, together with  four specific sets of necessary conditions, is given.", "authors": "Smith, G.", "words_pool": ["base", "class", "compon", "condit", "exist", "framework", "gener", "list", "mainten", "method", "opportun", "princip", "problem", "procedur", "set", "solut", "specif", "teacher", "timet", "smith"], "word_count": {"base": 1, "class": 1, "compon": 1, "condit": 3, "exist": 1, "framework": 1, "gener": 1, "list": 2, "mainten": 2, "method": 1, "opportun": 2, "princip": 1, "problem": 1, "procedur": 1, "set": 1, "solut": 2, "specif": 1, "teacher": 1, "timet": 1, "smith": 1}}, "2773": {"id": "2773", "title": "A Weighted Buddy Method for Dynamic Storage Allocation (Corrigendum)", "authors": "Shen, K. K. Peterson, J. L.", "words_pool": ["alloc", "buddi", "corrigendum", "dynam", "method", "storag", "weight", "shen", "peterson"], "word_count": {"alloc": 1, "buddi": 1, "corrigendum": 1, "dynam": 1, "method": 1, "storag": 1, "weight": 1, "shen": 1, "peterson": 1}}, "2774": {"id": "2774", "title": "Remark on Algorithm 475", "authors": "Frederick, L. W.", "words_pool": ["algorithm", "remark", "frederick"], "word_count": {"algorithm": 1, "remark": 1, "frederick": 1}}, "2775": {"id": "2775", "title": "The Dilogarithm Function of a Real Argument [S22] (Algorithm 490)", "authors": "Ginsberg, E. S. Zaborowski, D.", "words_pool": ["algorithm", "argument", "dilogarithm", "function", "real", "s22", "ginsberg", "zaborowski"], "word_count": {"algorithm": 1, "argument": 1, "dilogarithm": 1, "function": 1, "real": 1, "s22": 1, "ginsberg": 1, "zaborowski": 1}}, "2776": {"id": "2776", "title": "Computer Networks in Higher Education: Socio-Economic-Political Factors", "abstract": "This study presents the results of a nationwide survey of computer networks in higher education  conducted during 1971-73.  Five major and 18 minor networks were identified.  The five major networks  included: the ARPA Net, the California State College network, the University of Iowa/Iowa State University  network, the Michigan Educational Research Information Triad, Inc., and the Triangle Universities Computation  Center network in North Carolina. In-depth studies were conducted of the latter two nets.  Based on the  experiences of these operating networks, a number of factors are identified for consideration in developing  networks.  Finally, recommendations are advanced regarding the development of networks in higher education  in the future.", "authors": "Chambers, J. A. Poore, R. V.", "words_pool": ["advanc", "arpa", "base", "california", "carolina", "center", "colleg", "comput", "comput", "conduct", "consider", "depth", "develop", "develop", "econom", "educ", "educ", "experi", "factor", "final", "futur", "higher", "identifi", "includ", "inform", "iowa", "major", "michigan", "minor", "nationwid", "net", "net", "network", "network", "north", "number", "oper", "polit", "present", "recommend", "regard", "research", "result", "socio", "state", "studi", "studi", "survey", "triad", "triangl", "univers", "univers", "chamber", "poor"], "word_count": {"advanc": 1, "arpa": 1, "base": 1, "california": 1, "carolina": 1, "center": 1, "colleg": 1, "comput": 2, "conduct": 2, "consider": 1, "depth": 1, "develop": 2, "econom": 1, "educ": 3, "experi": 1, "factor": 1, "final": 1, "futur": 1, "higher": 2, "identifi": 2, "includ": 1, "inform": 1, "iowa": 2, "major": 2, "michigan": 1, "minor": 1, "nationwid": 1, "net": 2, "network": 9, "north": 1, "number": 1, "oper": 1, "polit": 1, "present": 1, "recommend": 1, "regard": 1, "research": 1, "result": 1, "socio": 1, "state": 2, "studi": 2, "survey": 1, "triad": 1, "triangl": 1, "univers": 3, "chamber": 1, "poor": 1}}, "2777": {"id": "2777", "title": "On a Solution to the Cigarette Smoker's Problem (Without Conditional Statements)", "abstract": "This report discusses a problem first introduced by Patil, who has claimed that the cigarette  smoker's problem cannot be solved using the P and V operations introduced by Dijkstra unless conditional  statements are used.  An examination of Patil's proof shows that he has established this claim only under  strong restrictions on the use of P and V.  These restrictions eliminate programming techniques used  by Dijkstra and others since the first introduction of the semaphore concept.  This paper contains a  solution to the problem.  It also discusses the need for the generalized operators suggested by Patil.", "authors": "Parnas, D. L.", "words_pool": ["cigarett", "claim", "claim", "concept", "condit", "dijkstra", "discuss", "elimin", "establish", "examin", "gener", "introduc", "introduct", "need", "oper", "oper", "paper", "patil", "problem", "program", "proof", "report", "restrict", "semaphor", "show", "smoker", "solut", "solv", "statement", "strong", "suggest", "techniqu", "parna"], "word_count": {"cigarett": 1, "claim": 2, "concept": 1, "condit": 1, "dijkstra": 2, "discuss": 2, "elimin": 1, "establish": 1, "examin": 1, "gener": 1, "introduc": 2, "introduct": 1, "need": 1, "oper": 2, "paper": 1, "patil": 3, "problem": 3, "program": 1, "proof": 1, "report": 1, "restrict": 2, "semaphor": 1, "show": 1, "smoker": 1, "solut": 1, "solv": 1, "statement": 1, "strong": 1, "suggest": 1, "techniqu": 1, "parna": 1}}, "2778": {"id": "2778", "title": "Perturbations of Eigenvalues of Non-normal Matrices (Corrigendum)", "authors": "Sluis, A.", "words_pool": ["corrigendum", "eigenvalu", "matric", "non", "normal", "perturb", "slui"], "word_count": {"corrigendum": 1, "eigenvalu": 1, "matric": 1, "non": 1, "normal": 1, "perturb": 1, "slui": 1}}, "2779": {"id": "2779", "title": "Discrete Least Squares Polynomial Fits", "abstract": "The recurrence relation between orthogonal polynomials is widely used for discrete least squares  data fitting.  A variant of the classical algorithm which has better numerical properties is presented  and the reason for its improved performance is explained.", "authors": "Shampine, L. F.", "words_pool": ["algorithm", "classic", "data", "discret", "explain", "fit", "fit", "improv", "numer", "orthogon", "perform", "polynomi", "polynomi", "present", "properti", "reason", "recurr", "relat", "squar", "variant", "wide", "shampin"], "word_count": {"algorithm": 1, "classic": 1, "data": 1, "discret": 1, "explain": 1, "fit": 1, "improv": 1, "numer": 1, "orthogon": 1, "perform": 1, "polynomi": 1, "present": 1, "properti": 1, "reason": 1, "recurr": 1, "relat": 1, "squar": 1, "variant": 1, "wide": 1, "shampin": 1}}, "2780": {"id": "2780", "title": "On Computing Certain Elements of the Inverse of a Sparse Matrix", "abstract": "A recursive algorithm for computing the inverse of a matrix from the LU factors based on relationships  in Takahashi, et al., is examined.  The formulas for the algorithm are given; the dependency relationships  are derived; the computational costs are developed; and some general comments on application and stability  are made.", "authors": "Erisman, E. M. Tinney, W. F.", "words_pool": ["al", "algorithm", "applic", "base", "comment", "comput", "comput", "cost", "depend", "deriv", "develop", "element", "examin", "factor", "formula", "gener", "invers", "lu", "made", "matrix", "recurs", "relationship", "spars", "stabil", "takahashi", "erisman", "tinney"], "word_count": {"al": 1, "algorithm": 2, "applic": 1, "base": 1, "comment": 1, "comput": 2, "cost": 1, "depend": 1, "deriv": 1, "develop": 1, "element": 1, "examin": 1, "factor": 1, "formula": 1, "gener": 1, "invers": 1, "lu": 1, "made": 1, "matrix": 1, "recurs": 1, "relationship": 2, "spars": 1, "stabil": 1, "takahashi": 1, "erisman": 1, "tinney": 1}}, "2781": {"id": "2781", "title": "The Algorithm Sequential Access Method: An Alternative to Index Sequential", "authors": "Whitt, J. D. Sullenberger, A. G.", "words_pool": ["access", "algorithm", "altern", "index", "method", "sequenti", "whitt", "sullenberg"], "word_count": {"access": 1, "algorithm": 1, "altern": 1, "index": 1, "method": 1, "sequenti": 2, "whitt": 1, "sullenberg": 1}}, "2782": {"id": "2782", "title": "A Reply to Gentleman and Marovich", "authors": "Karp, R. A.", "words_pool": ["gentleman", "marovich", "repli", "karp"], "word_count": {"gentleman": 1, "marovich": 1, "repli": 1, "karp": 1}}, "2783": {"id": "2783", "title": "The Algorithm SELECT-for Finding the ith Smallest of n Elements [M1] (Algorithm 489)", "authors": "Floyd, R. W. Rivest, R. L.", "words_pool": ["algorithm", "element", "find", "ith", "m1", "select", "smallest", "floyd", "rivest"], "word_count": {"algorithm": 2, "element": 1, "find": 1, "ith": 1, "m1": 1, "select": 1, "smallest": 1, "floyd": 1, "rivest": 1}}, "2784": {"id": "2784", "title": "Expected Time Bounds for Selection", "abstract": "A new selection algorithm is presented which is shown to be very efficient on the average,  both theoretically and practically.  The number of comparisons used to select the ith smallest of n numbers  is n+min(i,n-i)+o(n).  A lower bound within 9 percent of the above formula is also derived.", "authors": "Floyd, R. W. Rivest, R. L.", "words_pool": ["algorithm", "averag", "bound", "bound", "comparison", "deriv", "effici", "expect", "formula", "ith", "lower", "min", "number", "number", "percent", "practic", "present", "select", "select", "shown", "smallest", "theoret", "time", "floyd", "rivest"], "word_count": {"algorithm": 1, "averag": 1, "bound": 1, "comparison": 1, "deriv": 1, "effici": 1, "expect": 1, "formula": 1, "ith": 1, "lower": 1, "min": 1, "number": 2, "percent": 1, "practic": 1, "present": 1, "select": 2, "shown": 1, "smallest": 1, "theoret": 1, "time": 1, "floyd": 1, "rivest": 1}}, "2785": {"id": "2785", "title": "Glypnir-A Programming Language for Illiac IV", "abstract": "GLYPNIR is one of the earliest existing languages designed for programming the Illiac IV computer.  The syntax of the language is based on ALGOL 60, but has been extended to allow the programmer explicitly  to specify the parallelism of his algorithm in terms of 64-word vectors.  This paper describes the characteristics,  goals and philosophy of the language, and discusses some of the problems associated with parallel computer  architectures.", "authors": "Lawrie, D. H. Layman, T. Baer, D. Randal, J. M.", "words_pool": ["algol", "algorithm", "allow", "architectur", "base", "characterist", "comput", "describ", "design", "discuss", "earliest", "exist", "explicitli", "extend", "glypnir", "goal", "illiac", "iv", "languag", "languag", "paper", "parallel", "parallel", "philosophi", "problem", "programm", "program", "syntax", "term", "vector", "word", "lawri", "layman", "baer", "randal"], "word_count": {"algol": 1, "algorithm": 1, "allow": 1, "architectur": 1, "base": 1, "characterist": 1, "comput": 2, "describ": 1, "design": 1, "discuss": 1, "earliest": 1, "exist": 1, "explicitli": 1, "extend": 1, "glypnir": 1, "goal": 1, "illiac": 1, "iv": 1, "languag": 3, "paper": 1, "parallel": 2, "philosophi": 1, "problem": 1, "programm": 1, "program": 1, "syntax": 1, "term": 1, "vector": 1, "word": 1, "lawri": 1, "layman": 1, "baer": 1, "randal": 1}}, "2786": {"id": "2786", "title": "A System for Typesetting Mathematics", "abstract": "This paper describes the design and implementation of a system for typesetting mathematics.   The language has been designed to be easy to learn and to use by people (for example, secretaries and  mathematical typists) who know neither mathematics nor typesetting.  Experience indicates that the language  can be learned in an hour or so, for it has few rules and fewer exceptions.  For typical expressions,  the size and font changes, positioning, line drawing, and the like necessary to print according to mathematical  conventions are all done automatically.  For example, the input sum from i=o to infinity x sub i=pi over  2 produces (formula).  The syntax of the language is specified by a small context-free grammar; a compiler-compiler  is used to make a compiler that translates this language into typesetting commands.  Output maybe produced  on either a phototypesetter or on a terminal with forward and reverse half-line motions.  The system  interfaces directly with text formatting programs, so mixtures of text and mathematics may be handled  simply.  This paper was typeset by the authors using the system described", "authors": "Kernighan, B. W. Cherry, L. L.", "words_pool": ["accord", "author", "command", "compil", "context", "convent", "describ", "design", "design", "directli", "draw", "easi", "except", "experi", "express", "fewer", "font", "format", "formula", "forward", "free", "grammar", "half", "handl", "hour", "implement", "infin", "input", "interfac", "know", "languag", "learn", "learn", "line", "make", "mathemat", "mathemat", "mayb", "mixtur", "motion", "output", "paper", "peopl", "phototypesett", "pi", "posit", "print", "produc", "produc", "program", "revers", "rule", "secretari", "simpli", "size", "small", "sum", "syntax", "system", "termin", "text", "translat", "typeset", "typeset", "typic", "typist", "kernighan", "cherri"], "word_count": {"accord": 1, "author": 1, "command": 1, "compil": 3, "context": 1, "convent": 1, "describ": 1, "design": 2, "directli": 1, "draw": 1, "easi": 1, "except": 1, "experi": 1, "express": 1, "fewer": 1, "font": 1, "format": 1, "formula": 1, "forward": 1, "free": 1, "grammar": 1, "half": 1, "handl": 1, "hour": 1, "implement": 1, "infin": 1, "input": 1, "interfac": 1, "know": 1, "languag": 4, "learn": 2, "line": 2, "make": 1, "mathemat": 5, "mayb": 1, "mixtur": 1, "motion": 1, "output": 1, "paper": 2, "peopl": 1, "phototypesett": 1, "pi": 1, "posit": 1, "print": 1, "produc": 2, "program": 1, "revers": 1, "rule": 1, "secretari": 1, "simpli": 1, "size": 1, "small": 1, "sum": 1, "syntax": 1, "system": 3, "termin": 1, "text": 2, "translat": 1, "typeset": 4, "typic": 1, "typist": 1, "kernighan": 1, "cherri": 1}}, "2787": {"id": "2787", "title": "Matrix Reduction-An Efficient Method", "abstract": "The paper describes an efficient method for reduction of the binary matrices which arise in  some school time-tabling problems.  It is a development of that described by John Lions.  It has been  generalized and adapted to fit into the complete timetabling process; to use a more compact data representation  and more efficient processing techniques; to take fuller advantage of possible available previous knowledge  about the matrix.  And it is designed as a structured program, which can readily be coded by the reader  in the high level or low level programming language of his choice.  Practical tests of the method have  shown it to be a good basis for a realistic timetabling algorithm.", "authors": "Johnston, H. C. Hoare, C. A. R.", "words_pool": ["adapt", "advantag", "algorithm", "aris", "basi", "binari", "choic", "code", "compact", "complet", "data", "describ", "design", "develop", "effici", "fit", "fuller", "gener", "good", "high", "john", "knowledg", "languag", "level", "lion", "low", "matric", "matrix", "method", "paper", "practic", "previou", "problem", "process", "process", "program", "program", "reader", "readili", "realist", "reduct", "represent", "school", "shown", "structur", "tabl", "take", "techniqu", "test", "time", "timet", "johnston", "hoar"], "word_count": {"adapt": 1, "advantag": 1, "algorithm": 1, "aris": 1, "basi": 1, "binari": 1, "choic": 1, "code": 1, "compact": 1, "complet": 1, "data": 1, "describ": 1, "design": 1, "develop": 1, "effici": 2, "fit": 1, "fuller": 1, "gener": 1, "good": 1, "high": 1, "john": 1, "knowledg": 1, "languag": 1, "level": 2, "lion": 1, "low": 1, "matric": 1, "matrix": 1, "method": 2, "paper": 1, "practic": 1, "previou": 1, "problem": 1, "process": 2, "program": 2, "reader": 1, "readili": 1, "realist": 1, "reduct": 1, "represent": 1, "school": 1, "shown": 1, "structur": 1, "tabl": 1, "take": 1, "techniqu": 1, "test": 1, "time": 1, "timet": 2, "johnston": 1, "hoar": 1}}, "2788": {"id": "2788", "title": "Finding Circles by an Array of Accumulators", "authors": "Kimme, C. Balard, D. Sklansky, J.", "words_pool": ["accumul", "array", "circl", "find", "kimm", "balard", "sklanski"], "word_count": {"accumul": 1, "array": 1, "circl": 1, "find": 1, "kimm": 1, "balard": 1, "sklanski": 1}}, "2789": {"id": "2789", "title": "A Minimal Spanning Tree Clustering Method (Algorithm R479)", "authors": "Magnuski, H. S.", "words_pool": ["algorithm", "cluster", "method", "minim", "r479", "span", "tree", "magnuski"], "word_count": {"algorithm": 1, "cluster": 1, "method": 1, "minim": 1, "r479": 1, "span": 1, "tree": 1, "magnuski": 1}}, "2790": {"id": "2790", "title": "The Elementary Circuits of a Graph (Algorithm R459)", "authors": "Syslo, M. M.", "words_pool": ["algorithm", "circuit", "elementari", "graph", "r459", "syslo"], "word_count": {"algorithm": 1, "circuit": 1, "elementari": 1, "graph": 1, "r459": 1, "syslo": 1}}, "2791": {"id": "2791", "title": "Exact Probabilities for R x C Contingency Tables (Algorithm R434)", "authors": "Hancock, T. W.", "words_pool": ["algorithm", "conting", "exact", "probabl", "r434", "tabl", "hancock"], "word_count": {"algorithm": 1, "conting": 1, "exact": 1, "probabl": 1, "r434": 1, "tabl": 1, "hancock": 1}}, "2792": {"id": "2792", "title": "Jacobi Polynomials (Algorithm R332)", "authors": "Skovgaard, O.", "words_pool": ["algorithm", "jacobi", "polynomi", "r332", "skovgaard"], "word_count": {"algorithm": 1, "jacobi": 1, "polynomi": 1, "r332": 1, "skovgaard": 1}}, "2793": {"id": "2793", "title": "Chi-Square Quantiles (Algorithm C451)", "authors": "Knight,W.", "words_pool": ["algorithm", "c451", "chi", "quantil", "squar", "knight"], "word_count": {"algorithm": 1, "c451": 1, "chi": 1, "quantil": 1, "squar": 1, "knight": 1}}, "2794": {"id": "2794", "title": "State-Space, Problem-Reduction, and Theorem Proving-Some Relationships", "abstract": "This paper suggests a bidirectional relationship between state-space and problem-reduction  representations. It presents a formalism based on multiple-input and multiple-output operators which  provides a basis for viewing the two types of representations in this manner.  A representation of the  language recognition problem which is based on the Cocke parsing algorithm is used as an illustration.   A method for representing problems in first-order logic in such a way that the inference system employed  by a resolution-based theorem prover determines whether the set of clauses is interpreted in the state-spacer  mode or in the problem-reduction mode is presented.  The analogous concepts in problem-reduction and  theorem proving, and the terminology used to refer to them, are noted.  The relationship between problem-reduction,  input resolution, and linear resolution is discussed.", "authors": "VanderBrug, G. J. Minker, J.", "words_pool": ["algorithm", "analog", "base", "basi", "bidirect", "claus", "cock", "concept", "determin", "discuss", "employ", "formal", "illustr", "infer", "input", "interpret", "languag", "linear", "logic", "manner", "method", "mode", "multipl", "note", "oper", "order", "output", "paper", "pars", "present", "present", "problem", "problem", "prover", "prove", "recognit", "reduct", "refer", "relationship", "relationship", "represent", "represent", "repres", "resolut", "set", "space", "spacer", "state", "suggest", "system", "terminolog", "theorem", "type", "view", "vanderbrug", "minker"], "word_count": {"algorithm": 1, "analog": 1, "base": 3, "basi": 1, "bidirect": 1, "claus": 1, "cock": 1, "concept": 1, "determin": 1, "discuss": 1, "employ": 1, "formal": 1, "illustr": 1, "infer": 1, "input": 2, "interpret": 1, "languag": 1, "linear": 1, "logic": 1, "manner": 1, "method": 1, "mode": 2, "multipl": 2, "note": 1, "oper": 1, "order": 1, "output": 1, "paper": 1, "pars": 1, "present": 2, "problem": 6, "prover": 1, "prove": 1, "recognit": 1, "reduct": 4, "refer": 1, "relationship": 2, "represent": 3, "repres": 1, "resolut": 3, "set": 1, "space": 1, "spacer": 1, "state": 2, "suggest": 1, "system": 1, "terminolog": 1, "theorem": 2, "type": 1, "view": 1, "vanderbrug": 1, "minker": 1}}, "2795": {"id": "2795", "title": "Sentence Paraphrasing from a Conceptual Base", "abstract": "A model of natural language based on an underlying language-free representation of meaning  is described.  A program based on this model is able to produce sentence paraphrases which demonstrate  understanding with respect to a given context.  This generator operates in conjunction with a natural  language analyzer and a combined memory and inference model.  In generating sentences from meaning structures,  the program employs both the information retrieval and deduction capabilities of the memory model.  The  model encompasses several diverse classes of linguistic knowledge, which include: (1) executable tests  of conceptual properties stored in discrimination nets; (2) information relating conceptual to syntactic  roles, stored in a word-sense dictionary, and (3) surface grammatical knowledge, stored in a formal grammar.", "authors": "Goldman, N. M.", "words_pool": ["abl", "analyz", "base", "base", "capabl", "class", "combin", "conceptu", "conjunct", "context", "deduct", "demonstr", "dictionari", "discrimin", "divers", "employ", "encompass", "execut", "formal", "free", "gener", "gener", "grammar", "grammat", "includ", "infer", "inform", "knowledg", "languag", "linguist", "mean", "memori", "model", "natur", "net", "oper", "paraphras", "paraphras", "produc", "program", "properti", "relat", "represent", "respect", "retriev", "role", "sens", "sentenc", "sentenc", "store", "structur", "surfac", "syntact", "test", "underli", "understand", "word", "goldman"], "word_count": {"abl": 1, "analyz": 1, "base": 2, "capabl": 1, "class": 1, "combin": 1, "conceptu": 2, "conjunct": 1, "context": 1, "deduct": 1, "demonstr": 1, "dictionari": 1, "discrimin": 1, "divers": 1, "employ": 1, "encompass": 1, "execut": 1, "formal": 1, "free": 1, "gener": 2, "grammar": 1, "grammat": 1, "includ": 1, "infer": 1, "inform": 2, "knowledg": 2, "languag": 3, "linguist": 1, "mean": 2, "memori": 2, "model": 5, "natur": 2, "net": 1, "oper": 1, "paraphras": 1, "produc": 1, "program": 2, "properti": 1, "relat": 1, "represent": 1, "respect": 1, "retriev": 1, "role": 1, "sens": 1, "sentenc": 2, "store": 3, "structur": 1, "surfac": 1, "syntact": 1, "test": 1, "underli": 1, "understand": 1, "word": 1, "goldman": 1}}, "2796": {"id": "2796", "title": "Monitors: An Operating System Structuring Concept (Corrigendum)", "authors": "Hoare, C. A. R.", "words_pool": ["concept", "corrigendum", "monitor", "oper", "structur", "system", "hoar"], "word_count": {"concept": 1, "corrigendum": 1, "monitor": 1, "oper": 1, "structur": 1, "system": 1, "hoar": 1}}, "2797": {"id": "2797", "title": "A First Order Approximation to the Optimal Checkpoint Interval (Corrigendum)", "authors": "Young, J. W.", "words_pool": ["approxim", "checkpoint", "corrigendum", "interv", "optim", "order", "young"], "word_count": {"approxim": 1, "checkpoint": 1, "corrigendum": 1, "interv": 1, "optim": 1, "order": 1, "young": 1}}, "2798": {"id": "2798", "title": "Analysis of Interleaved Memory Systems Using Blockage Buffers", "abstract": "A model of interleaved memory systems is presented, and the analysis of the model by Monte  Carlo simulation is discussed.  The simulations investigate the performance of various system structures,  i.e. schemes for sending instruction and data requests to the memory system.  Performance is measured  by determining the distribution of the number of memory modules in operation during a memory cycle.   An important observation from these investigations is that separately grouping instruction and data requests  for memory can substantially increase the average number of memory modules in operation during a memory  cycle.  Results of the simulations and an analytical study are displayed for various system structures.", "authors": "Burnett, G. J. Coffman, E. G. Jr.", "words_pool": ["analysi", "analyt", "averag", "blockag", "buffer", "carlo", "cycl", "data", "determin", "discuss", "display", "distribut", "group", "import", "increas", "instruct", "interleav", "investig", "investig", "measur", "memori", "model", "modul", "mont", "number", "observ", "oper", "perform", "present", "request", "result", "scheme", "send", "separ", "simul", "simul", "structur", "studi", "substanti", "system", "system", "burnett", "coffman", "jr"], "word_count": {"analysi": 1, "analyt": 1, "averag": 1, "blockag": 1, "buffer": 1, "carlo": 1, "cycl": 2, "data": 2, "determin": 1, "discuss": 1, "display": 1, "distribut": 1, "group": 1, "import": 1, "increas": 1, "instruct": 2, "interleav": 1, "investig": 2, "measur": 1, "memori": 7, "model": 2, "modul": 2, "mont": 1, "number": 2, "observ": 1, "oper": 2, "perform": 2, "present": 1, "request": 2, "result": 1, "scheme": 1, "send": 1, "separ": 1, "simul": 3, "structur": 2, "studi": 1, "substanti": 1, "system": 4, "burnett": 1, "coffman": 1, "jr": 1}}, "2799": {"id": "2799", "title": "Stably Updating Mean and Standard Deviation of Data", "abstract": "By considering the (sample) mean of a set of data as a fit to this data by a constant function,  a computational method is given based on a matrix formulation and Givens transformations. The (sample)  mean and standard deviation can be updated as data accumulates.  The procedure is numerically stable  and does not require storage of the data.  Methods for dealing with weighted data and data removal are  presented.  When updating the mean and square of the standard deviation, the process requires no square  roots.", "authors": "Hanson, R. J.", "words_pool": ["accumul", "base", "comput", "consid", "constant", "data", "deal", "deviat", "fit", "formul", "function", "given", "matrix", "mean", "method", "method", "numer", "present", "procedur", "process", "remov", "requir", "requir", "root", "sampl", "set", "squar", "stabl", "stabli", "standard", "storag", "transform", "updat", "updat", "weight", "hanson"], "word_count": {"accumul": 1, "base": 1, "comput": 1, "consid": 1, "constant": 1, "data": 6, "deal": 1, "deviat": 2, "fit": 1, "formul": 1, "function": 1, "given": 1, "matrix": 1, "mean": 3, "method": 2, "numer": 1, "present": 1, "procedur": 1, "process": 1, "remov": 1, "requir": 2, "root": 1, "sampl": 2, "set": 1, "squar": 2, "stabl": 1, "stabli": 1, "standard": 2, "storag": 1, "transform": 1, "updat": 2, "weight": 1, "hanson": 1}}, "2800": {"id": "2800", "title": "Connections Between Accuracy and Stability Properties of Linear Multistep Formulas", "abstract": "This paper is concerned with stability and accuracy of families of linear k-step formulas depending  on parameters, with particular emphasis on the numerical solution of stiff ordinary differential equations.   An upper bound, p=k, is derived for the order of accuracy of A(inf)-stable formulas.  Three criteria  are given for A(0)-stability.  It is shown that (1) for p=k, k arbitrary, A(inf)-stability implies certain  necessary conditions for A(0)-stability and for strict stability (meaning that the extraneous roots of  p(psi) satisfy |psi|<1); (2) for p=k=2,3,4,and 5, A(inf)-stability (for k=5 together with another constraint)  implies strict stability; and (3) for certain one-parameter classes of formulas with p=k=3,4,and/or 5,  A(inf)-stability implies A(0)-stability.", "authors": "Liniger, W.", "words_pool": ["accuraci", "arbitrari", "bound", "class", "concern", "condit", "connect", "constraint", "criteria", "depend", "deriv", "differenti", "emphasi", "equat", "extran", "famili", "formula", "impli", "inf", "linear", "mean", "multistep", "numer", "order", "ordinari", "paper", "paramet", "paramet", "properti", "psi", "root", "satisfi", "shown", "solut", "stabil", "stabl", "step", "stiff", "strict", "upper", "linig"], "word_count": {"accuraci": 2, "arbitrari": 1, "bound": 1, "class": 1, "concern": 1, "condit": 1, "connect": 1, "constraint": 1, "criteria": 1, "depend": 1, "deriv": 1, "differenti": 1, "emphasi": 1, "equat": 1, "extran": 1, "famili": 1, "formula": 3, "impli": 3, "inf": 4, "linear": 1, "mean": 1, "multistep": 1, "numer": 1, "order": 1, "ordinari": 1, "paper": 1, "paramet": 2, "properti": 1, "psi": 2, "root": 1, "satisfi": 1, "shown": 1, "solut": 1, "stabil": 9, "stabl": 1, "step": 1, "stiff": 1, "strict": 2, "upper": 1, "linig": 1}}, "2801": {"id": "2801", "title": "Storage-Efficient Representation of Decimal Data", "abstract": "Usually n decimal digits are represented by 4n bits in computers.  Actually, two BCD digits  can be compressed optimally and reversibly into 7 bits, and three digits into 10 bits, by a very simple  algorithm based on the fixed-length combination of two variable field-length encodings.  In over half  of the cases the compressed code results from the conventional BCD code by simple removal of redundant  0 bits.  A long decimal message can be subdivided into three-digit blocks, and separately compressed;  the result differs from the asymptotic minimum length by only 0.34 percent.  The hardware requirement  is small, and the mappings can be done manually.", "authors": "Chi Chen, T. Ho, I. T.", "words_pool": ["4n", "actual", "algorithm", "asymptot", "base", "bcd", "bit", "block", "case", "code", "combin", "compress", "comput", "convent", "data", "decim", "differ", "digit", "digit", "effici", "encod", "field", "fix", "half", "hardwar", "length", "long", "manual", "map", "messag", "minimum", "optim", "percent", "redund", "remov", "represent", "repres", "requir", "result", "result", "revers", "separ", "simpl", "small", "storag", "subdivid", "variabl", "chi", "chen", "ho"], "word_count": {"4n": 1, "actual": 1, "algorithm": 1, "asymptot": 1, "base": 1, "bcd": 2, "bit": 4, "block": 1, "case": 1, "code": 2, "combin": 1, "compress": 3, "comput": 1, "convent": 1, "data": 1, "decim": 2, "differ": 1, "digit": 4, "effici": 1, "encod": 1, "field": 1, "fix": 1, "half": 1, "hardwar": 1, "length": 3, "long": 1, "manual": 1, "map": 1, "messag": 1, "minimum": 1, "optim": 1, "percent": 1, "redund": 1, "remov": 1, "represent": 1, "repres": 1, "requir": 1, "result": 2, "revers": 1, "separ": 1, "simpl": 2, "small": 1, "storag": 1, "subdivid": 1, "variabl": 1, "chi": 1, "chen": 1, "ho": 1}}, "2802": {"id": "2802", "title": "The New Math of Computer Programming", "abstract": "Structured programming has proved to be an important methodology for systematic program design  and development.  Structured programs are identified as compound function expressions in the algebra  of functions. The algebraic properties of these function expressions permit the reformulation (expansion  as well as reduction) of a nested subexpression independently of its environment, thus modeling what  is known as stepwise program refinement as well as program execution.  Finally, structured programming  is characterized in terms of the selection and solution of certain elementary equations defined in the  algebra of functions.  These solutions can be given in general formulas, each involving a single parameter,  which display the entire freedom available in creating correct structured programs.", "authors": "Mills, H. D.", "words_pool": ["algebra", "algebra", "character", "compound", "comput", "correct", "creat", "defin", "design", "develop", "display", "elementari", "entir", "environ", "equat", "execut", "expans", "express", "final", "formula", "freedom", "function", "function", "gener", "identifi", "import", "independ", "involv", "known", "math", "methodolog", "model", "nest", "paramet", "permit", "program", "program", "program", "properti", "prove", "reduct", "refin", "reformul", "select", "singl", "solut", "solut", "stepwis", "structur", "subexpress", "systemat", "term", "mill"], "word_count": {"algebra": 3, "character": 1, "compound": 1, "comput": 1, "correct": 1, "creat": 1, "defin": 1, "design": 1, "develop": 1, "display": 1, "elementari": 1, "entir": 1, "environ": 1, "equat": 1, "execut": 1, "expans": 1, "express": 2, "final": 1, "formula": 1, "freedom": 1, "function": 4, "gener": 1, "identifi": 1, "import": 1, "independ": 1, "involv": 1, "known": 1, "math": 1, "methodolog": 1, "model": 1, "nest": 1, "paramet": 1, "permit": 1, "program": 7, "properti": 1, "prove": 1, "reduct": 1, "refin": 1, "reformul": 1, "select": 1, "singl": 1, "solut": 2, "stepwis": 1, "structur": 4, "subexpress": 1, "systemat": 1, "term": 1, "mill": 1}}, "2803": {"id": "2803", "title": "Pseudoinverses and Conjugate Gradients", "abstract": "This paper is devoted to the study of connections between pseudoinverses of matrices and conjugate  gradients and conjugate direction routines.", "authors": "Hestenes, M. R.", "words_pool": ["conjug", "connect", "devot", "direct", "gradient", "matric", "paper", "pseudoinvers", "routin", "studi", "hesten"], "word_count": {"conjug": 2, "connect": 1, "devot": 1, "direct": 1, "gradient": 1, "matric": 1, "paper": 1, "pseudoinvers": 1, "routin": 1, "studi": 1, "hesten": 1}}, "2804": {"id": "2804", "title": "Elementary Divisors of Tensor Products", "abstract": "The elementary divisors of a tensor product of linear transformations have been known for 40  years.  This paper provides a short, easily accessible proof of these results, and points out an interesting  combinatorial consequence of the proof.", "authors": "Marcus, M. Robinson, H.", "words_pool": ["access", "combinatori", "consequ", "divisor", "easili", "elementari", "interest", "known", "linear", "paper", "point", "product", "product", "proof", "result", "short", "tensor", "transform", "year", "marcu", "robinson"], "word_count": {"access": 1, "combinatori": 1, "consequ": 1, "divisor": 1, "easili": 1, "elementari": 1, "interest": 1, "known": 1, "linear": 1, "paper": 1, "point": 1, "product": 1, "proof": 2, "result": 1, "short": 1, "tensor": 1, "transform": 1, "year": 1, "marcu": 1, "robinson": 1}}, "2805": {"id": "2805", "title": "Perturbations of Eigenvalues of Non-normal Matrices", "abstract": "The problem considered is to give bounds for finite perturbations of simple and multiple eigenvalues  of nonnormal matrices, where these bounds are in terms of the eigenvalues, the departure from normality,  and the Frobenius norm of the perturbation matrix, but not in terms of the eigen system.  The bounds which  are derived are shown to be almost attainable for any set of matrices.", "authors": "van der Sluis, A.", "words_pool": ["attain", "bound", "consid", "departur", "deriv", "eigen", "eigenvalu", "finit", "frobeniu", "give", "matric", "matrix", "multipl", "non", "nonnorm", "norm", "normal", "normal", "perturb", "perturb", "problem", "set", "shown", "simpl", "system", "term", "van", "der", "slui"], "word_count": {"attain": 1, "bound": 3, "consid": 1, "departur": 1, "deriv": 1, "eigen": 1, "eigenvalu": 2, "finit": 1, "frobeniu": 1, "give": 1, "matric": 2, "matrix": 1, "multipl": 1, "non": 1, "nonnorm": 1, "norm": 1, "normal": 1, "perturb": 2, "problem": 1, "set": 1, "shown": 1, "simpl": 1, "system": 1, "term": 2, "van": 1, "der": 1, "slui": 1}}, "2806": {"id": "2806", "title": "Two Hadamard Numbers for Matrices", "abstract": "A discussion is given of two functions of the entries of a square matrix, both related to Hadamard's  determinant theorem, which have some merits as alternatives to norm-bound \"condition numbers.\"  One (for  linear systems) is known; the other (for eigen systems) seems to be new.", "authors": "Birkhoff, G.", "words_pool": ["altern", "bound", "condit", "determin", "discuss", "eigen", "entri", "function", "hadamard", "known", "linear", "matric", "matrix", "merit", "norm", "number", "relat", "squar", "system", "theorem", "birkhoff"], "word_count": {"altern": 1, "bound": 1, "condit": 1, "determin": 1, "discuss": 1, "eigen": 1, "entri": 1, "function": 1, "hadamard": 1, "known": 1, "linear": 1, "matric": 1, "matrix": 1, "merit": 1, "norm": 1, "number": 1, "relat": 1, "squar": 1, "system": 2, "theorem": 1, "birkhoff": 1}}, "2807": {"id": "2807", "title": "On the Stability of Gauss-Jordan Elimination with Pivoting", "abstract": "The stability of the Gauss-Jordan algorithm with partial pivoting for the solution of general  systems of linear equations is commonly regarded as suspect.  It is shown that in many respects suspicions  are unfounded, and in general the absolute error in the solution is strictly comparable with that corresponding  to Gaussian elimination with partial pivoting plus back substitution.  However, when A is ill conditioned,  the residual corresponding to the Gauss-Jordan solution will often be much greater than that corresponding  to the Gaussian elimination solution.", "authors": "Peters, G. Wilkinson, J. H.", "words_pool": ["absolut", "algorithm", "back", "commonli", "compar", "condit", "elimin", "equat", "error", "gauss", "gaussian", "gener", "greater", "ill", "jordan", "linear", "partial", "pivot", "regard", "residu", "respect", "shown", "solut", "stabil", "strictli", "substitut", "suspect", "suspicion", "system", "unfound", "peter", "wilkinson"], "word_count": {"absolut": 1, "algorithm": 1, "back": 1, "commonli": 1, "compar": 1, "condit": 1, "elimin": 2, "equat": 1, "error": 1, "gauss": 2, "gaussian": 2, "gener": 2, "greater": 1, "ill": 1, "jordan": 2, "linear": 1, "partial": 2, "pivot": 2, "regard": 1, "residu": 1, "respect": 1, "shown": 1, "solut": 4, "stabil": 1, "strictli": 1, "substitut": 1, "suspect": 1, "suspicion": 1, "system": 1, "unfound": 1, "peter": 1, "wilkinson": 1}}, "2808": {"id": "2808", "title": "The Lemniscate Constants", "abstract": "The lemniscate constants, and indeed some of the methods used for actually computing them,  have played an enormous part in the development of mathematics.  An account is given here of some of  the methods used-most of the derivations can be made by elementary methods.  This material can be used  for teaching purposes, and there is much relevant and interesting historical material.  The acceleration  methods developed for the purpose of evaluating these constants are useful in other problems.", "authors": "Todd, J.", "words_pool": ["acceler", "account", "actual", "comput", "constant", "deriv", "develop", "develop", "elementari", "enorm", "evalu", "histor", "interest", "lemnisc", "made", "materi", "mathemat", "method", "part", "play", "problem", "purpos", "purpos", "relev", "teach", "todd"], "word_count": {"acceler": 1, "account": 1, "actual": 1, "comput": 1, "constant": 2, "deriv": 1, "develop": 2, "elementari": 1, "enorm": 1, "evalu": 1, "histor": 1, "interest": 1, "lemnisc": 1, "made": 1, "materi": 2, "mathemat": 1, "method": 4, "part": 1, "play": 1, "problem": 1, "purpos": 2, "relev": 1, "teach": 1, "todd": 1}}, "2809": {"id": "2809", "title": "Positivity and Norms", "abstract": "Following some lines of joint work with A. S. Householder, the character and use of algebraic  methods in the theory of norms is demonstrated.  New results concerning norms with values in an Archimedian  vector lattice (not necessarily being totally ordered) are given, in particular for the generalization  of order unit norms, L-norms and M-norms.  An example of application to operator norms is given concerning  contraction properties of positive operators.", "authors": "Bauer, F. L.", "words_pool": ["algebra", "applic", "archimedian", "charact", "concern", "contract", "demonstr", "gener", "household", "joint", "lattic", "line", "method", "necessarili", "norm", "oper", "oper", "order", "order", "posit", "posit", "properti", "result", "theori", "total", "unit", "valu", "vector", "work", "bauer"], "word_count": {"algebra": 1, "applic": 1, "archimedian": 1, "charact": 1, "concern": 2, "contract": 1, "demonstr": 1, "gener": 1, "household": 1, "joint": 1, "lattic": 1, "line": 1, "method": 1, "necessarili": 1, "norm": 6, "oper": 2, "order": 2, "posit": 1, "properti": 1, "result": 1, "theori": 1, "total": 1, "unit": 1, "valu": 1, "vector": 1, "work": 1, "bauer": 1}}, "2810": {"id": "2810", "title": "Professionalism in the Computing Field", "abstract": "The term professional means different things to different people; nevertheless, there are certain  general technical and social standards normally associated with a professional.  Further, the term is  more generally applied to the practitioner rather than to the researcher.  But within the rather broad  definition specified, the computing practitioner is, as yet, not regarded as a professional.  Each of  the four types of institutions-academic, industry, government, and the professional society- that educate, employ, regulate, and mold the practitioner contributes to the \"nonprofessional\" status of the computing  practitioner.  The roles of these institutions are examined, various shortcomings are noted, and recommended  changes are suggested.  In the last analysis, professional status is not bestowed; it is earned.  However,  universities and industry, specifically, can make certain  improvements to help the computing practitioner  achieve professional status.", "authors": "Finerman, A.", "words_pool": ["academ", "achiev", "analysi", "appli", "bestow", "broad", "comput", "contribut", "definit", "earn", "educ", "employ", "examin", "field", "gener", "gener", "govern", "help", "improv", "industri", "institut", "make", "mean", "mold", "nonprofession", "note", "peopl", "practition", "profession", "profession", "recommend", "regard", "regul", "research", "role", "shortcom", "social", "societi", "specif", "standard", "statu", "suggest", "technic", "term", "thing", "type", "univers", "finerman"], "word_count": {"academ": 1, "achiev": 1, "analysi": 1, "appli": 1, "bestow": 1, "broad": 1, "comput": 3, "contribut": 1, "definit": 1, "earn": 1, "educ": 1, "employ": 1, "examin": 1, "field": 1, "gener": 2, "govern": 1, "help": 1, "improv": 1, "industri": 2, "institut": 2, "make": 1, "mean": 1, "mold": 1, "nonprofession": 1, "note": 1, "peopl": 1, "practition": 5, "profession": 6, "recommend": 1, "regard": 1, "regul": 1, "research": 1, "role": 1, "shortcom": 1, "social": 1, "societi": 1, "specif": 1, "standard": 1, "statu": 3, "suggest": 1, "technic": 1, "term": 2, "thing": 1, "type": 1, "univers": 1, "finerman": 1}}, "2811": {"id": "2811", "title": "Structural Pattern Recognition Of Carotid Pulse Waves Using A General Waveform Parsing System", "abstract": "A general waveform parsing system with application to structural pattern recognition of carotid  pulse waves is described.  The carotid arterial pulse wave is of medical importance because of variation  in its structure induced by arterial aging and cardiovascular disease.  The syntax-driven waveform analysis  system has been applied with good results to these pulse waves to detect and measure structural variations.   The waveform parsing system is modeled on a compiler-compiler system and allows the user to enter application  specific information as data.  It is thus general enough to be applicable to other waveforms.", "authors": "Stockman, G. Kanal, L. Kyle, M. C.", "words_pool": ["age", "analysi", "applic", "applic", "appli", "arteri", "cardiovascular", "carotid", "compil", "data", "detect", "diseas", "driven", "enter", "gener", "good", "import", "induc", "inform", "measur", "medic", "model", "pars", "pattern", "puls", "recognit", "result", "specif", "structur", "structur", "syntax", "system", "user", "variat", "variat", "wave", "waveform", "waveform", "wave", "stockman", "kanal", "kyle"], "word_count": {"age": 1, "analysi": 1, "applic": 3, "appli": 1, "arteri": 2, "cardiovascular": 1, "carotid": 2, "compil": 2, "data": 1, "detect": 1, "diseas": 1, "driven": 1, "enter": 1, "gener": 2, "good": 1, "import": 1, "induc": 1, "inform": 1, "measur": 1, "medic": 1, "model": 1, "pars": 2, "pattern": 1, "puls": 3, "recognit": 1, "result": 1, "specif": 1, "structur": 3, "syntax": 1, "system": 4, "user": 1, "variat": 2, "wave": 3, "waveform": 4, "stockman": 1, "kanal": 1, "kyle": 1}}, "2812": {"id": "2812", "title": "Computer-Aided Analysis and Design of Information Systems", "abstract": "This paper describes the use of computer-aided analysis for the design and development of an  integrated financial management system by the Navy Material Command Support Activity (NMCSA).  Computer-aided  analysis consists of a set of procedures and computer programs specifically designed to aid in the process  of applications software design, computer selection and performance evaluation.  There are four major  components: Problem Statement Language, Problem Statement Analyzer, Generator of Alternative Designs,  and Performance Evaluator. The statement of requirements was written in ADS (Accurately Defined Systems)  and analyzed by a Problem Statement Analyzer for ADS.  The ADS problem definition was supplemented with  additional information in order to create a complete problem definition.  The analyzed problem statement  was translated to the form necessary for use by the SODA (Systems Optimization and Design Algorithm) program for the generation of alternative specifications of program modules and logical database structures.", "authors": "Nunamaker, J. F. Jr. Konsynski, B. R. Jr. Ho, T. Singer, C.", "words_pool": ["accur", "activ", "addit", "ad", "aid", "aid", "algorithm", "altern", "analysi", "analyz", "analyz", "applic", "command", "complet", "compon", "comput", "consist", "creat", "databas", "defin", "definit", "describ", "design", "design", "design", "develop", "evalu", "evalu", "financi", "form", "gener", "gener", "inform", "integr", "languag", "logic", "major", "manag", "materi", "modul", "navi", "nmcsa", "optim", "order", "paper", "perform", "problem", "procedur", "process", "program", "program", "requir", "select", "set", "soda", "softwar", "specif", "specif", "statement", "structur", "supplement", "support", "system", "system", "translat", "written", "nunamak", "jr", "konsynski", "jr", "ho", "singer"], "word_count": {"accur": 1, "activ": 1, "addit": 1, "ad": 3, "aid": 3, "algorithm": 1, "altern": 2, "analysi": 2, "analyz": 4, "applic": 1, "command": 1, "complet": 1, "compon": 1, "comput": 4, "consist": 1, "creat": 1, "databas": 1, "defin": 1, "definit": 2, "describ": 1, "design": 5, "develop": 1, "evalu": 2, "financi": 1, "form": 1, "gener": 2, "inform": 1, "integr": 1, "languag": 1, "logic": 1, "major": 1, "manag": 1, "materi": 1, "modul": 1, "navi": 1, "nmcsa": 1, "optim": 1, "order": 1, "paper": 1, "perform": 2, "problem": 6, "procedur": 1, "process": 1, "program": 3, "requir": 1, "select": 1, "set": 1, "soda": 1, "softwar": 1, "specif": 2, "statement": 5, "structur": 1, "supplement": 1, "support": 1, "system": 3, "translat": 1, "written": 1, "nunamak": 1, "jr": 1, "konsynski": 1, "ho": 1, "singer": 1}}, "2813": {"id": "2813", "title": "The Computer Science and Engineering Research Study (COSERS)", "abstract": "The Computer Science and Engineering Research Study (COSERS) is briefly described.  The motivation,  organization, and schedule for this NSF supported study are given.  For possible further reference, the  subject area panel chairmen and the members of the Steering Committee are identified.", "authors": "Arden, B.", "words_pool": ["area", "briefli", "chairmen", "committe", "comput", "coser", "engin", "identifi", "member", "motiv", "nsf", "organ", "panel", "refer", "research", "schedul", "scienc", "steer", "studi", "subject", "support", "arden"], "word_count": {"area": 1, "briefli": 1, "chairmen": 1, "committe": 1, "comput": 1, "coser": 1, "engin": 1, "identifi": 1, "member": 1, "motiv": 1, "nsf": 1, "organ": 1, "panel": 1, "refer": 1, "research": 1, "schedul": 1, "scienc": 1, "steer": 1, "studi": 2, "subject": 1, "support": 1, "arden": 1}}, "2814": {"id": "2814", "title": "Roster of Programming Languages for 1974-75", "authors": "Sammet, J. E.", "words_pool": ["languag", "program", "roster", "sammet"], "word_count": {"languag": 1, "program": 1, "roster": 1, "sammet": 1}}, "2815": {"id": "2815", "title": "High-Level Binding with Low-Level Linkers", "abstract": "An easy to implement scheme is described by which a compiler can enforce agreement between  complex data types in separately compiled modules.  The scheme is designed to work with any existing  link editor or linking loader, no matter how deficient.  Obscure run-time errors caused by inconsistent  usages are forestalled by static errors detected at linking time.", "authors": "Hamlet, R. G.", "words_pool": ["agreement", "bind", "caus", "compil", "compil", "complex", "data", "defici", "design", "detect", "easi", "editor", "enforc", "error", "exist", "forestal", "high", "implement", "inconsist", "level", "link", "linker", "link", "loader", "low", "matter", "modul", "obscur", "run", "scheme", "separ", "static", "time", "type", "usag", "work", "hamlet"], "word_count": {"agreement": 1, "bind": 1, "caus": 1, "compil": 2, "complex": 1, "data": 1, "defici": 1, "design": 1, "detect": 1, "easi": 1, "editor": 1, "enforc": 1, "error": 2, "exist": 1, "forestal": 1, "high": 1, "implement": 1, "inconsist": 1, "level": 2, "link": 3, "linker": 1, "loader": 1, "low": 1, "matter": 1, "modul": 1, "obscur": 1, "run": 1, "scheme": 2, "separ": 1, "static": 1, "time": 2, "type": 1, "usag": 1, "work": 1, "hamlet": 1}}, "2816": {"id": "2816", "title": "Optimal Reorganization of Distributed Space Disk Files", "abstract": "In most database organizations, the cost of accessing the database will increase due to structural  changes caused by updates and insertions.  By reorganizing the database,the access costs can be reduced.   A basic problem is to establish the proper tradeoff between performance, storage costs, and reorganization  costs.  This paper considers the optimum points at which to reorganize a database.  A disk file organization  which allows for distributed free space is described.  A cost function describing the excess costs due  to physical disorganization is defined, and this function is minimized to obtain the optimum reorganization  points.  Numerical examples based on the characteristics of existing disk storage devices are given.", "authors": "Maruyama, K. Smith, S. E.", "words_pool": ["access", "access", "base", "basic", "caus", "characterist", "consid", "cost", "cost", "databas", "defin", "describ", "devic", "disk", "disorgan", "distribut", "due", "establish", "exampl", "excess", "exist", "free", "function", "increas", "insert", "minim", "numer", "obtain", "optim", "optimum", "organ", "organ", "paper", "perform", "physic", "point", "problem", "proper", "reduc", "reorgan", "reorgan", "reorgan", "space", "storag", "structur", "tradeoff", "updat", "maruyama", "smith"], "word_count": {"access": 2, "base": 1, "basic": 1, "caus": 1, "characterist": 1, "consid": 1, "cost": 6, "databas": 4, "defin": 1, "describ": 1, "devic": 1, "disk": 2, "disorgan": 1, "distribut": 1, "due": 2, "establish": 1, "exampl": 1, "excess": 1, "exist": 1, "free": 1, "function": 2, "increas": 1, "insert": 1, "minim": 1, "numer": 1, "obtain": 1, "optim": 1, "optimum": 2, "organ": 2, "paper": 1, "perform": 1, "physic": 1, "point": 2, "problem": 1, "proper": 1, "reduc": 1, "reorgan": 4, "space": 1, "storag": 2, "structur": 1, "tradeoff": 1, "updat": 1, "maruyama": 1, "smith": 1}}, "2817": {"id": "2817", "title": "The Notions of Consistency and Predicate Locks in a Database System", "abstract": "In database systems, users access shared data under the assumption that the data satisfies  certain consistency constraints.  This paper defines the concepts of transaction, consistency and schedule  and shows that consistency requires that a transaction cannot request new locks after releasing a lock.   Then it is argued that a transaction needs to lock a logical rather than a physical subset of the database.   These subsets may be specified by predicates.  An implementation of predicate locks which satisfies  the consistency condition is suggested.", "authors": "Eswarran, K.. Gray, J.. Lorie, R.. Traiger, I. L.", "words_pool": ["access", "argu", "assumpt", "concept", "condit", "consist", "constraint", "data", "databas", "defin", "implement", "lock", "lock", "logic", "need", "notion", "paper", "physic", "predic", "predic", "releas", "request", "requir", "satisfi", "schedul", "share", "show", "subset", "subset", "suggest", "system", "system", "transact", "user", "eswarran", "gray", "lori", "traiger"], "word_count": {"access": 1, "argu": 1, "assumpt": 1, "concept": 1, "condit": 1, "consist": 4, "constraint": 1, "data": 2, "databas": 2, "defin": 1, "implement": 1, "lock": 4, "logic": 1, "need": 1, "notion": 1, "paper": 1, "physic": 1, "predic": 2, "releas": 1, "request": 1, "requir": 1, "satisfi": 2, "schedul": 1, "share": 1, "show": 1, "subset": 2, "suggest": 1, "system": 1, "transact": 3, "user": 1, "eswarran": 1, "gray": 1, "lori": 1, "traiger": 1}}, "2818": {"id": "2818", "title": "Interference in Multiprocessor Computer Systems with Interleaved Memory (Corrigendum)", "authors": "Baskett, F. Smith, A. J.", "words_pool": ["comput", "corrigendum", "interfer", "interleav", "memori", "multiprocessor", "system", "baskett", "smith"], "word_count": {"comput": 1, "corrigendum": 1, "interfer": 1, "interleav": 1, "memori": 1, "multiprocessor": 1, "system": 1, "baskett": 1, "smith": 1}}, "2819": {"id": "2819", "title": "Experiments in Text File Compression", "abstract": "A system for the compression of data files, viewed as strings of characters, is presented.   The method is general, and applies equally well to English, to PL/I, or to digital data.  The system  consists of an encoder, an analysis program, and a decoder.   Two algorithms for encoding a string differ  slightly from earlier proposals.  The analysis program attempts to find an optimal set of codes for representing  substrings of the file.  Four new algorithms for this operation are described and compared.  Various  parameters in the algorithms are optimized to obtain a high degree of compression for sample texts.", "authors": "Rubin, F.", "words_pool": ["algorithm", "analysi", "appli", "attempt", "charact", "code", "compar", "compress", "consist", "data", "decod", "degre", "differ", "digit", "earlier", "encod", "encod", "english", "equal", "experi", "find", "gener", "high", "method", "obtain", "oper", "optim", "optim", "paramet", "pl", "present", "program", "propos", "repres", "sampl", "set", "slightli", "string", "string", "substr", "system", "text", "text", "view", "rubin"], "word_count": {"algorithm": 3, "analysi": 2, "appli": 1, "attempt": 1, "charact": 1, "code": 1, "compar": 1, "compress": 2, "consist": 1, "data": 2, "decod": 1, "degre": 1, "differ": 1, "digit": 1, "earlier": 1, "encod": 2, "english": 1, "equal": 1, "experi": 1, "find": 1, "gener": 1, "high": 1, "method": 1, "obtain": 1, "oper": 1, "optim": 2, "paramet": 1, "pl": 1, "present": 1, "program": 2, "propos": 1, "repres": 1, "sampl": 1, "set": 1, "slightli": 1, "string": 2, "substr": 1, "system": 2, "text": 1, "view": 1, "rubin": 1}}, "2820": {"id": "2820", "title": "The Design and Implementation of a Table Driven, Interactive Diagnostic Programming System", "abstract": "CAPS is a highly interactive diagnostic compiler/interpreter that allows beginning programmers  to prepare, debug, and execute fairly simple programs at a graphics display terminal.  Complete syntax  checking and most semantic analysis is performed as the program is entered and as it is subsequently edited.  Analysis is performed character by character.  The most remarkable feature of CAPS is its ability  to automatically diagnose errors both at compile time and at run time.  Errors are not automatically  corrected.  Instead, CAPS interacts with the student to help him find the cause of his error.  Most components  of CAPS are table driven, both to reduce the space needed for implementation and to increase the flexibility  of the multilingual system.  Over 500 students have used CAPS to learn Fortran, PL/I, or Cobolin conjunction  with a computer assisted course on introductory computer science.", "authors": "Wilcox, T. R. Davis, A. M. Tindall, M. H.", "words_pool": ["abil", "analysi", "assist", "begin", "cap", "charact", "check", "cobolin", "compil", "compil", "complet", "compon", "comput", "conjunct", "correct", "cours", "debug", "design", "diagnos", "diagnost", "display", "driven", "edit", "enter", "error", "error", "execut", "fairli", "featur", "find", "flexibl", "fortran", "graphic", "help", "highli", "implement", "increas", "interact", "interact", "interpret", "introductori", "learn", "multilingu", "need", "perform", "pl", "prepar", "program", "programm", "program", "program", "reduc", "remark", "run", "scienc", "semant", "simpl", "space", "student", "student", "subsequ", "syntax", "system", "tabl", "termin", "time", "wilcox", "davi", "tindal"], "word_count": {"abil": 1, "analysi": 2, "assist": 1, "begin": 1, "cap": 5, "charact": 2, "check": 1, "cobolin": 1, "compil": 2, "complet": 1, "compon": 1, "comput": 2, "conjunct": 1, "correct": 1, "cours": 1, "debug": 1, "design": 1, "diagnos": 1, "diagnost": 1, "display": 1, "driven": 1, "edit": 1, "enter": 1, "error": 3, "execut": 1, "fairli": 1, "featur": 1, "find": 1, "flexibl": 1, "fortran": 1, "graphic": 1, "help": 1, "highli": 1, "implement": 1, "increas": 1, "interact": 2, "interpret": 1, "introductori": 1, "learn": 1, "multilingu": 1, "need": 1, "perform": 2, "pl": 1, "prepar": 1, "program": 2, "programm": 1, "reduc": 1, "remark": 1, "run": 1, "scienc": 1, "semant": 1, "simpl": 1, "space": 1, "student": 2, "subsequ": 1, "syntax": 1, "system": 1, "tabl": 1, "termin": 1, "time": 2, "wilcox": 1, "davi": 1, "tindal": 1}}, "2821": {"id": "2821", "title": "Cobol Under Control", "abstract": "A sample set of Cobol programming standards is offered.  These standards constrain code to  be developed in a \"structured\" form for both data and control structures.  They do not require syntax  beyond the existing Cobol language and in fact utilize a typical limited subset of the 1974 ANS Cobol  standard.  These standards have proved extremely valuable in practice and have reduced the cost and time  to produce and maintain large software systems that have been deployed in live multiple customer environments.", "authors": "Ledgard, H. F. Cave, W. C.", "words_pool": ["an", "cobol", "code", "constrain", "control", "cost", "custom", "data", "deploy", "develop", "environ", "exist", "extrem", "fact", "form", "languag", "larg", "limit", "live", "maintain", "multipl", "offer", "practic", "produc", "program", "prove", "reduc", "requir", "sampl", "set", "softwar", "standard", "standard", "structur", "structur", "subset", "syntax", "system", "time", "typic", "util", "valuabl", "ledgard", "cave"], "word_count": {"an": 1, "cobol": 3, "code": 1, "constrain": 1, "control": 1, "cost": 1, "custom": 1, "data": 1, "deploy": 1, "develop": 1, "environ": 1, "exist": 1, "extrem": 1, "fact": 1, "form": 1, "languag": 1, "larg": 1, "limit": 1, "live": 1, "maintain": 1, "multipl": 1, "offer": 1, "practic": 1, "produc": 1, "program": 1, "prove": 1, "reduc": 1, "requir": 1, "sampl": 1, "set": 1, "softwar": 1, "standard": 4, "structur": 2, "subset": 1, "syntax": 1, "system": 1, "time": 1, "typic": 1, "util": 1, "valuabl": 1, "ledgard": 1, "cave": 1}}, "2822": {"id": "2822", "title": "Homilies for Humble Standards", "abstract": "Copyright 1976, Association for Computing Machinery, Inc. General permission to republish,  but not for profit, all or part of this material is granted provided that ACM's copyright notice is given  and that reference is made to the publication, to its data of issue, and to the fact that reprinting  privileges were granted by permission of the Association for Computing Machinery.", "authors": "Ross, D. T.", "words_pool": ["acm", "associ", "comput", "copyright", "data", "fact", "gener", "grant", "homili", "humbl", "issu", "machineri", "made", "materi", "notic", "part", "permiss", "privileg", "profit", "provid", "public", "refer", "reprint", "republish", "standard", "ross"], "word_count": {"acm": 1, "associ": 2, "comput": 2, "copyright": 2, "data": 1, "fact": 1, "gener": 1, "grant": 2, "homili": 1, "humbl": 1, "issu": 1, "machineri": 2, "made": 1, "materi": 1, "notic": 1, "part": 1, "permiss": 2, "privileg": 1, "profit": 1, "provid": 1, "public": 1, "refer": 1, "reprint": 1, "republish": 1, "standard": 1, "ross": 1}}, "2823": {"id": "2823", "title": "The Status of Women and Minorities in Academic Computer Science", "abstract": "The results of a survey concerning women and minority students and faculty in computer science  during the years 1971 to 1975 are presented.  Analysis of the data indicated that effective affirmative  action programs for recruitment into graduate degree programs are needed to enlarge the number of women  and minorities qualified for later employment in computer science.  Also, possible discrimination in  employment of women and minority graduate students was revealed.", "authors": "Montanelli, R. G. Jr. Mamrak, S. A.", "words_pool": ["academ", "action", "affirm", "analysi", "comput", "concern", "data", "degre", "discrimin", "effect", "employ", "enlarg", "faculti", "graduat", "later", "minor", "minor", "need", "number", "present", "program", "qualifi", "recruit", "result", "reveal", "scienc", "statu", "student", "survey", "women", "year", "montanelli", "jr", "mamrak"], "word_count": {"academ": 1, "action": 1, "affirm": 1, "analysi": 1, "comput": 2, "concern": 1, "data": 1, "degre": 1, "discrimin": 1, "effect": 1, "employ": 2, "enlarg": 1, "faculti": 1, "graduat": 2, "later": 1, "minor": 3, "need": 1, "number": 1, "present": 1, "program": 2, "qualifi": 1, "recruit": 1, "result": 1, "reveal": 1, "scienc": 2, "statu": 1, "student": 2, "survey": 1, "women": 3, "year": 1, "montanelli": 1, "jr": 1, "mamrak": 1}}, "2824": {"id": "2824", "title": "An Improvement to Martin's Algorithm for Computation of Linear Precedence Functions", "authors": "Duong-Kien, C. Hoffmann, H. J. Muth, D.", "words_pool": ["algorithm", "comput", "function", "improv", "linear", "martin", "preced", "duong", "kien", "hoffmann", "muth"], "word_count": {"algorithm": 1, "comput": 1, "function": 1, "improv": 1, "linear": 1, "martin": 1, "preced": 1, "duong": 1, "kien": 1, "hoffmann": 1, "muth": 1}}, "2825": {"id": "2825", "title": "The BMD and BMDP Series of Statistical Computer Programs", "authors": "Frane, J. W.", "words_pool": ["bmd", "bmdp", "comput", "program", "seri", "statist", "frane"], "word_count": {"bmd": 1, "bmdp": 1, "comput": 1, "program": 1, "seri": 1, "statist": 1, "frane": 1}}, "2826": {"id": "2826", "title": "Interactive Skeleton Techniques for Enhancing Motion Dynamics in Key Frame Animation", "abstract": "A significant increase in the capability for controlling motion dynamics in key frame animation  is achieved through skeleton control.  This technique allows an animator to develop a complex motion  sequence by animating a stick figure representation of an image.  This control sequence is then used  to drive an image sequence through the same movement.  The simplicity of the stick figure image encourages  a high level of interaction during the design stage.  Its compatibility with the basic key frame animation  technique permits skeleton control to be applied selectively to only those components of a composite  image sequence that require enhancement.", "authors": "Burtnyk, N. Wein, M.", "words_pool": ["achiev", "anim", "anim", "anim", "appli", "basic", "capabl", "compat", "complex", "compon", "composit", "control", "control", "design", "develop", "drive", "dynam", "encourag", "enhanc", "enhanc", "figur", "frame", "high", "imag", "increas", "interact", "interact", "key", "level", "motion", "movement", "permit", "represent", "requir", "select", "sequenc", "signific", "simplic", "skeleton", "stage", "stick", "techniqu", "techniqu", "burtnyk", "wein"], "word_count": {"achiev": 1, "anim": 4, "appli": 1, "basic": 1, "capabl": 1, "compat": 1, "complex": 1, "compon": 1, "composit": 1, "control": 4, "design": 1, "develop": 1, "drive": 1, "dynam": 1, "encourag": 1, "enhanc": 1, "figur": 2, "frame": 2, "high": 1, "imag": 4, "increas": 1, "interact": 1, "key": 2, "level": 1, "motion": 2, "movement": 1, "permit": 1, "represent": 1, "requir": 1, "select": 1, "sequenc": 4, "signific": 1, "simplic": 1, "skeleton": 2, "stage": 1, "stick": 2, "techniqu": 2, "burtnyk": 1, "wein": 1}}, "2827": {"id": "2827", "title": "A Parametric Algorithm for Drawing Pictures of Solid Objects Composed of Quadric Surfaces", "abstract": "An algorithm for drawing pictures of three-dimensional objects, with surfaces made up of patches  of quadric surfaces, is described.  The emphasis of this algorithm is on calculating the intersections  of quadric surfaces. A parameterization scheme is used.  Each quadric surface intersection curve (QSIC)  is represented as a set of coefficients and parameter limits.  Each value of the parameter represents  at most two points, and these may easily be distinguished.  This scheme can find the coordinates of points  of even quartic (fourth-order) intersection curves, using equations of no more than second order.  Methods  of parameterization for each type of OSIC are discussed, as well as surface bounding and hidden surface  removal.", "authors": "Levin, J.", "words_pool": ["algorithm", "bound", "calcul", "coeffici", "compos", "coordin", "curv", "curv", "dimension", "discuss", "distinguish", "draw", "easili", "emphasi", "equat", "find", "fourth", "hidden", "intersect", "intersect", "limit", "made", "method", "object", "order", "osic", "paramet", "parameter", "parametr", "patch", "pictur", "point", "qsic", "quadric", "quartic", "remov", "repres", "repres", "scheme", "set", "solid", "surfac", "surfac", "type", "levin"], "word_count": {"algorithm": 2, "bound": 1, "calcul": 1, "coeffici": 1, "compos": 1, "coordin": 1, "curv": 2, "dimension": 1, "discuss": 1, "distinguish": 1, "draw": 1, "easili": 1, "emphasi": 1, "equat": 1, "find": 1, "fourth": 1, "hidden": 1, "intersect": 3, "limit": 1, "made": 1, "method": 1, "object": 1, "order": 2, "osic": 1, "paramet": 2, "parameter": 2, "parametr": 1, "patch": 1, "pictur": 1, "point": 2, "qsic": 1, "quadric": 3, "quartic": 1, "remov": 1, "repres": 2, "scheme": 2, "set": 1, "solid": 1, "surfac": 6, "type": 1, "levin": 1}}, "2828": {"id": "2828", "title": "Hierarchical Geometric Models for Visible Surface Algorithms", "abstract": "The geometric structure inherent in the definition of the shapes of three-dimensional objects  and environments is used not just to define their relative motion and placement, but also to assist in  solving many other problems of systems for producing pictures by computer.  By using an extension of  traditional structure information, or a geometric hierarchy, five significant improvements to current  techniques are possible.  First, the range of complexity of an environment is greatly increased while  the visible complexity of any given scene is kept within a fixed upper limit.  Second, a meaningful way  is provided to vary the amount of detail presented in a scene.  Third, \"clipping\" becomes a very fast  logarithmic search for the resolvable parts of the environment within the field of view.  Fourth, frame  to frame coherence and clipping define a graphical \"working set,\" or fraction of the total structure  that should be present in primary store for immediate access by the visible surface algorithm.  Finally,  the geometric structure suggests a recursive descent, visible surface algorithm in which the computation  time potentially grows linearly with the visible complexity of the scene.", "authors": "Clark, J. H.", "words_pool": ["access", "algorithm", "algorithm", "amount", "assist", "clip", "coher", "complex", "comput", "comput", "defin", "definit", "descent", "detail", "dimension", "environ", "environ", "extens", "fast", "field", "final", "fix", "fourth", "fraction", "frame", "geometr", "graphic", "greatli", "grow", "hierarch", "hierarchi", "improv", "increas", "inform", "inher", "limit", "linearli", "logarithm", "meaning", "model", "motion", "object", "part", "pictur", "placement", "potenti", "present", "present", "primari", "problem", "produc", "provid", "rang", "recurs", "rel", "resolv", "scene", "search", "set", "shape", "signific", "solv", "store", "structur", "suggest", "surfac", "system", "techniqu", "time", "total", "tradit", "upper", "vari", "view", "visibl", "work", "clark"], "word_count": {"access": 1, "algorithm": 2, "amount": 1, "assist": 1, "clip": 2, "coher": 1, "complex": 3, "comput": 2, "defin": 2, "definit": 1, "descent": 1, "detail": 1, "dimension": 1, "environ": 3, "extens": 1, "fast": 1, "field": 1, "final": 1, "fix": 1, "fourth": 1, "fraction": 1, "frame": 2, "geometr": 3, "graphic": 1, "greatli": 1, "grow": 1, "hierarch": 1, "hierarchi": 1, "improv": 1, "increas": 1, "inform": 1, "inher": 1, "limit": 1, "linearli": 1, "logarithm": 1, "meaning": 1, "model": 1, "motion": 1, "object": 1, "part": 1, "pictur": 1, "placement": 1, "potenti": 1, "present": 2, "primari": 1, "problem": 1, "produc": 1, "provid": 1, "rang": 1, "recurs": 1, "rel": 1, "resolv": 1, "scene": 3, "search": 1, "set": 1, "shape": 1, "signific": 1, "solv": 1, "store": 1, "structur": 4, "suggest": 1, "surfac": 2, "system": 1, "techniqu": 1, "time": 1, "total": 1, "tradit": 1, "upper": 1, "vari": 1, "view": 1, "visibl": 4, "work": 1, "clark": 1}}, "2829": {"id": "2829", "title": "Texture and Reflection in Computer Generated Images", "abstract": "In 1974 Catmull developed a new algorithm for rendering images of bivariate surface patches.   This paper describes extensions of this algorithm in the areas of texture simulation and lighting models.   The parameterization of a patch defines a coordinate system which is used as a key for mapping patterns  onto the surface.  The intensity of the pattern at each picture element is computed as a weighted average  of regions of the pattern definition function. The shape and size of this weighting function are chosen  using digital signal processing theory.  The patch rendering algorithm allows accurate computation of  the surface normal to the patch at each picture element, permitting the simulation of the mirror reflections.   The amount of light coming from a given direction is modeled in a similar manner to the texture mapping  and then added to the intensity obtained from the texture mapping.  Several examples of images synthesized  using these new techniques are included.", "authors": "Blinn, J. F. Newell, M. E.", "words_pool": ["accur", "ad", "algorithm", "amount", "area", "averag", "bivari", "catmul", "chosen", "come", "comput", "comput", "comput", "coordin", "defin", "definit", "describ", "develop", "digit", "direct", "element", "exampl", "extens", "function", "gener", "imag", "includ", "intens", "key", "light", "light", "manner", "map", "mirror", "model", "model", "normal", "obtain", "paper", "parameter", "patch", "patch", "pattern", "pattern", "permit", "pictur", "process", "reflect", "reflect", "region", "render", "shape", "signal", "similar", "simul", "size", "surfac", "synthes", "system", "techniqu", "textur", "theori", "weight", "weight", "blinn", "newel"], "word_count": {"accur": 1, "ad": 1, "algorithm": 3, "amount": 1, "area": 1, "averag": 1, "bivari": 1, "catmul": 1, "chosen": 1, "come": 1, "comput": 2, "coordin": 1, "defin": 1, "definit": 1, "describ": 1, "develop": 1, "digit": 1, "direct": 1, "element": 2, "exampl": 1, "extens": 1, "function": 2, "gener": 1, "imag": 2, "includ": 1, "intens": 2, "key": 1, "light": 2, "manner": 1, "map": 3, "mirror": 1, "model": 2, "normal": 1, "obtain": 1, "paper": 1, "parameter": 1, "patch": 4, "pattern": 3, "permit": 1, "pictur": 2, "process": 1, "reflect": 1, "region": 1, "render": 2, "shape": 1, "signal": 1, "similar": 1, "simul": 2, "size": 1, "surfac": 3, "synthes": 1, "system": 1, "techniqu": 1, "textur": 3, "theori": 1, "weight": 2, "blinn": 1, "newel": 1}}, "2830": {"id": "2830", "title": "A Practitioner's Guide to Addressing Algorithms (Corrigendum)", "authors": "Severance, D. G. Duhne, R. A.", "words_pool": ["address", "algorithm", "corrigendum", "guid", "practition", "sever", "duhn"], "word_count": {"address": 1, "algorithm": 1, "corrigendum": 1, "guid": 1, "practition": 1, "sever": 1, "duhn": 1}}, "2831": {"id": "2831", "title": "Analysis of the PFF Replacement Algorithm via a Semi-Markov Model (Corrigendum)", "authors": "Chu, W. W. Opderbeck, H.", "words_pool": ["algorithm", "analysi", "corrigendum", "markov", "model", "pff", "replac", "semi", "chu", "opderbeck"], "word_count": {"algorithm": 1, "analysi": 1, "corrigendum": 1, "markov": 1, "model": 1, "pff": 1, "replac": 1, "semi": 1, "chu": 1, "opderbeck": 1}}, "2832": {"id": "2832", "title": "Faster Retrieval from Context Trees (Corrigendum)", "abstract": "Context trees provide a convenient way of storing data which is to be viewed as a hierarchy  of contexts.  This note presents an algorithm which improves on previous context tree retrieval algorithms.  It is based on the observation that in typical uses context changes are infrequent relative to retrievals,  so that data can be cached to speed up retrieval.  A retrieval is started from the position of the previous  retrieval and auxiliary structures are built up to make the search rapid.  Algorithms for addition and  deletion of data and for garbage collection are outlined.", "authors": "Wegbreit, B.", "words_pool": ["addit", "algorithm", "algorithm", "auxiliari", "base", "built", "cach", "collect", "context", "context", "conveni", "corrigendum", "data", "delet", "faster", "garbag", "hierarchi", "improv", "infrequ", "make", "note", "observ", "outlin", "posit", "present", "previou", "provid", "rapid", "rel", "retriev", "retriev", "search", "speed", "start", "store", "structur", "tree", "tree", "typic", "view", "wegbreit"], "word_count": {"addit": 1, "algorithm": 3, "auxiliari": 1, "base": 1, "built": 1, "cach": 1, "collect": 1, "context": 4, "conveni": 1, "corrigendum": 1, "data": 3, "delet": 1, "faster": 1, "garbag": 1, "hierarchi": 1, "improv": 1, "infrequ": 1, "make": 1, "note": 1, "observ": 1, "outlin": 1, "posit": 1, "present": 1, "previou": 2, "provid": 1, "rapid": 1, "rel": 1, "retriev": 5, "search": 1, "speed": 1, "start": 1, "store": 1, "structur": 1, "tree": 2, "typic": 1, "view": 1, "wegbreit": 1}}, "2833": {"id": "2833", "title": "An Efficient, Incremental, Automatic Garbage Collector", "abstract": "This paper describes a new way of solving the storage reclamation problem for a system such  as Lisp that allocates storage automatically from a heap, and does not require the programmer to give  any indication that particular items are no longer useful or accessible.  A reference count scheme for  reclaiming non-self-referential structures, and a linearizing, compacting, copying scheme to reorganize  all storage at the users discretion are proposed.  The algorithms are designed to work well in systems  which use multiple levels of storage, and large virtual address space.  They depend on the fact that  most cells are referenced exactly once, and that reference counts need only be accurate when storage  is about to be reclaimed.  A transaction file stores changes to reference counts, and a multiple reference  table stores the count for items which are referenced more than once.", "authors": "Deutsch, L. P. Bobrow, D. G.", "words_pool": ["access", "accur", "address", "algorithm", "alloc", "automat", "cell", "collector", "compact", "copi", "count", "count", "depend", "describ", "design", "discret", "effici", "exactli", "fact", "garbag", "give", "heap", "increment", "indic", "item", "larg", "level", "linear", "lisp", "longer", "multipl", "need", "non", "paper", "problem", "programm", "propos", "reclaim", "reclaim", "reclam", "refer", "referenc", "referenti", "reorgan", "requir", "scheme", "solv", "space", "storag", "store", "structur", "system", "system", "tabl", "transact", "user", "virtual", "work", "deutsch", "bobrow"], "word_count": {"access": 1, "accur": 1, "address": 1, "algorithm": 1, "alloc": 1, "automat": 1, "cell": 1, "collector": 1, "compact": 1, "copi": 1, "count": 4, "depend": 1, "describ": 1, "design": 1, "discret": 1, "effici": 1, "exactli": 1, "fact": 1, "garbag": 1, "give": 1, "heap": 1, "increment": 1, "indic": 1, "item": 2, "larg": 1, "level": 1, "linear": 1, "lisp": 1, "longer": 1, "multipl": 2, "need": 1, "non": 1, "paper": 1, "problem": 1, "programm": 1, "propos": 1, "reclaim": 2, "reclam": 1, "refer": 4, "referenc": 2, "referenti": 1, "reorgan": 1, "requir": 1, "scheme": 2, "solv": 1, "space": 1, "storag": 5, "store": 2, "structur": 1, "system": 2, "tabl": 1, "transact": 1, "user": 1, "virtual": 1, "work": 1, "deutsch": 1, "bobrow": 1}}, "2834": {"id": "2834", "title": "Efficient Generation of the Binary Reflected Gray Code and Its Applications", "abstract": "Algorithms are presented to generate the n-bit binary reflected Gray code and codewords of  fixed weight in that code.  Both algorithms are efficient in that the time required to generate the next  element from the current one is constant.  Applications to the generation of the combinations of n things taken k at a time, the compositions of integers, and the permutations of a multiset are discussed.", "authors": "Bitner, J. R. Ehrlich, G. Reingold, E. M.", "words_pool": ["algorithm", "applic", "binari", "bit", "code", "codeword", "combin", "composit", "constant", "discuss", "effici", "element", "fix", "gener", "gener", "gray", "integ", "multiset", "permut", "present", "reflect", "requir", "thing", "time", "weight", "bitner", "ehrlich", "reingold"], "word_count": {"algorithm": 2, "applic": 1, "binari": 1, "bit": 1, "code": 2, "codeword": 1, "combin": 1, "composit": 1, "constant": 1, "discuss": 1, "effici": 1, "element": 1, "fix": 1, "gener": 3, "gray": 1, "integ": 1, "multiset": 1, "permut": 1, "present": 1, "reflect": 1, "requir": 1, "thing": 1, "time": 2, "weight": 1, "bitner": 1, "ehrlich": 1, "reingold": 1}}, "2835": {"id": "2835", "title": "Recursion Analysis for Compiler Optimization", "abstract": "A relatively simple method for the detection of recursive use of procedures is presented for  use in compiler optimization.  Implementation considerations are discussed, and a modification of the  algorithm is given to further improve optimization.  This analysis can also be used to determine what  possible subset of values could be assumed by variables which can only take on a relatively small discrete  set of values.  The most common are parameters of variables assuming values of label, procedure, or Pascal's  enumerated type.", "authors": "Walter, K. G.", "words_pool": ["algorithm", "analysi", "assum", "assum", "common", "compil", "consider", "detect", "determin", "discret", "discuss", "enumer", "implement", "improv", "label", "method", "modif", "optim", "paramet", "pascal", "present", "procedur", "procedur", "recurs", "recurs", "set", "simpl", "small", "subset", "take", "type", "valu", "variabl", "walter"], "word_count": {"algorithm": 1, "analysi": 1, "assum": 2, "common": 1, "compil": 1, "consider": 1, "detect": 1, "determin": 1, "discret": 1, "discuss": 1, "enumer": 1, "implement": 1, "improv": 1, "label": 1, "method": 1, "modif": 1, "optim": 2, "paramet": 1, "pascal": 1, "present": 1, "procedur": 2, "recurs": 1, "set": 1, "simpl": 1, "small": 1, "subset": 1, "take": 1, "type": 1, "valu": 3, "variabl": 2, "walter": 1}}, "2836": {"id": "2836", "title": "Weighted Derivation Trees", "abstract": "The nodes of a weighted derivation tree are associated with weighting functions over the vocabulary  of a context-free grammar.  An algorithm is presented for constructing the optimal derivation tree having  the same structure as a given weighted derivation tree.  In addition, the correctness of the algorithm  is established.  The method may be applied to problems involving probabilistic parsing or combinatorial  optimization.", "authors": "Loui, M. C.", "words_pool": ["addit", "algorithm", "appli", "combinatori", "construct", "context", "correct", "deriv", "establish", "free", "function", "grammar", "involv", "method", "node", "optim", "optim", "pars", "present", "probabilist", "problem", "structur", "tree", "tree", "vocabulari", "weight", "weight", "loui"], "word_count": {"addit": 1, "algorithm": 2, "appli": 1, "combinatori": 1, "construct": 1, "context": 1, "correct": 1, "deriv": 3, "establish": 1, "free": 1, "function": 1, "grammar": 1, "involv": 1, "method": 1, "node": 1, "optim": 2, "pars": 1, "present": 1, "probabilist": 1, "problem": 1, "structur": 1, "tree": 3, "vocabulari": 1, "weight": 3, "loui": 1}}, "2837": {"id": "2837", "title": "New Upper Bounds for Selection", "abstract": "The worst-case minimum number of comparisons complexity Vi(n) of the i-th selection problem  is considered.  A new upper bound for Vi(n) improves the bound given by the standard Hadian-Sobel algorithm  by a generalization of the Kirkpatrick-Hadian-Sobel algorithm, and extends Kirkpatrick's method to a  much wider range of application.  This generalization compares favorably with a recent algorithm by Hyafil.", "authors": "Yap, C. K.", "words_pool": ["algorithm", "applic", "bound", "bound", "case", "compar", "comparison", "complex", "consid", "extend", "favor", "gener", "hadian", "hyafil", "improv", "kirkpatrick", "method", "minimum", "number", "problem", "rang", "recent", "select", "sobel", "standard", "th", "upper", "vi", "wider", "worst", "yap"], "word_count": {"algorithm": 3, "applic": 1, "bound": 2, "case": 1, "compar": 1, "comparison": 1, "complex": 1, "consid": 1, "extend": 1, "favor": 1, "gener": 2, "hadian": 2, "hyafil": 1, "improv": 1, "kirkpatrick": 2, "method": 1, "minimum": 1, "number": 1, "problem": 1, "rang": 1, "recent": 1, "select": 1, "sobel": 2, "standard": 1, "th": 1, "upper": 1, "vi": 2, "wider": 1, "worst": 1, "yap": 1}}, "2838": {"id": "2838", "title": "Analysis of an Algorithm for Real Time Garbage Collection", "abstract": "A real time garbage collection system avoids suspending the operations of a list processor  for the long times that garbage collection normally requires by performing garbage collection on a second  processor in parallel with list processing operations, or on a single processor time-shared with them.   Algorithms for recovering discarded list structures in this manner are presented and analyzed to determine  sufficient conditions under which the list processor never needs to wait on the collector.  These techniques  are shown to require at most twice as much processing power as regular garbage collectors, if they are  used efficiently.  The average behavior of the program is shown to be very nearly equal to the worst-case  performance, so that the sufficient conditions are also suitable for measuring the typical behavior of  the algorithm.", "authors": "Wadler, P. L.", "words_pool": ["algorithm", "algorithm", "analysi", "analyz", "averag", "avoid", "behavior", "case", "collect", "collector", "collector", "condit", "determin", "discard", "effici", "equal", "garbag", "list", "long", "manner", "measur", "nearli", "need", "oper", "parallel", "perform", "perform", "power", "present", "process", "processor", "program", "real", "recov", "regular", "requir", "requir", "share", "shown", "singl", "structur", "suffici", "suitabl", "suspend", "system", "techniqu", "time", "time", "typic", "wait", "worst", "wadler"], "word_count": {"algorithm": 2, "analysi": 1, "analyz": 1, "averag": 1, "avoid": 1, "behavior": 2, "case": 1, "collect": 3, "collector": 2, "condit": 2, "determin": 1, "discard": 1, "effici": 1, "equal": 1, "garbag": 4, "list": 4, "long": 1, "manner": 1, "measur": 1, "nearli": 1, "need": 1, "oper": 2, "parallel": 1, "perform": 2, "power": 1, "present": 1, "process": 2, "processor": 4, "program": 1, "real": 1, "recov": 1, "regular": 1, "requir": 2, "share": 1, "shown": 2, "singl": 1, "structur": 1, "suffici": 2, "suitabl": 1, "suspend": 1, "system": 1, "techniqu": 1, "time": 3, "typic": 1, "wait": 1, "worst": 1, "wadler": 1}}, "2839": {"id": "2839", "title": "An Insertion Technique for One-Sided Height-Balanced Trees", "abstract": "A restriction on height-balanced binary trees is presented.  It is seen that this restriction  reduces the extra memory requirements by half (from two extra bits per node to one) and maintains fast  search capabilities at a cost of increased time requirements for inserting new nodes.", "authors": "Hirschberg, D. S.", "words_pool": ["balanc", "binari", "bit", "capabl", "cost", "extra", "fast", "half", "height", "increas", "insert", "insert", "maintain", "memori", "node", "node", "present", "reduc", "requir", "restrict", "search", "seen", "side", "techniqu", "time", "tree", "hirschberg"], "word_count": {"balanc": 1, "binari": 1, "bit": 1, "capabl": 1, "cost": 1, "extra": 2, "fast": 1, "half": 1, "height": 1, "increas": 1, "insert": 1, "maintain": 1, "memori": 1, "node": 2, "present": 1, "reduc": 1, "requir": 2, "restrict": 2, "search": 1, "seen": 1, "side": 1, "techniqu": 1, "time": 1, "tree": 1, "hirschberg": 1}}, "2840": {"id": "2840", "title": "Protection in Operating Systems", "abstract": "A model of protection mechanisms in computing systems is presented and its appropriateness  is argued.  The \"safety\" problem for protection systems under this model is to determine in a given situation  whether a subject can acquire a particular right to an object.   In restricted cases, it can be shown  that this problem is decidable, i.e. there is an algorithm to determine whether a system in a particular  configuration is safe.  In general, and under surprisingly weak assumptions, it cannot be decided if  a situation is safe. Various implications of this fact are discussed.", "authors": "Harrison, M. A. Ruzzo, W. L. Ullman, J. D.", "words_pool": ["acquir", "algorithm", "appropri", "argu", "assumpt", "case", "comput", "configur", "decid", "decid", "determin", "discuss", "fact", "gener", "implic", "mechan", "model", "object", "oper", "present", "problem", "protect", "restrict", "safe", "safeti", "shown", "situat", "subject", "surprisingli", "system", "system", "weak", "harrison", "ruzzo", "ullman"], "word_count": {"acquir": 1, "algorithm": 1, "appropri": 1, "argu": 1, "assumpt": 1, "case": 1, "comput": 1, "configur": 1, "decid": 2, "determin": 2, "discuss": 1, "fact": 1, "gener": 1, "implic": 1, "mechan": 1, "model": 2, "object": 1, "oper": 1, "present": 1, "problem": 2, "protect": 2, "restrict": 1, "safe": 2, "safeti": 1, "shown": 1, "situat": 2, "subject": 1, "surprisingli": 1, "system": 3, "weak": 1, "harrison": 1, "ruzzo": 1, "ullman": 1}}, "2841": {"id": "2841", "title": "Designing Surfaces in 3-D", "abstract": "An experimental system for computer-aided design of free-form surfaces in three dimensions  is described. The surfaces are represented in the system as parametric basis splines. The principal features  of the system are: (1) the surfaces are rendered as isoparametric line drawings on a head-mounted display,  and they are designed with the aid of a three-dimensional \"wand,\" which allows 3-D movements of the points  controlling the shapes of the surfaces, (2) all of the interactions with the surfaces are in real-time,  and (3) the mathematical formulations used assume no knowledge of them by the user of the system.  Also  examined are some of the features that should be part of a practical 3-D system for designing space-forms.", "authors": "Clark, J. H.", "words_pool": ["aid", "aid", "assum", "basi", "comput", "control", "design", "design", "design", "dimension", "dimens", "display", "draw", "examin", "experiment", "featur", "form", "form", "formul", "free", "head", "interact", "isoparametr", "knowledg", "line", "mathemat", "mount", "movement", "parametr", "part", "point", "practic", "princip", "real", "render", "repres", "shape", "space", "spline", "surfac", "system", "time", "user", "wand", "clark"], "word_count": {"aid": 2, "assum": 1, "basi": 1, "comput": 1, "control": 1, "design": 3, "dimension": 1, "dimens": 1, "display": 1, "draw": 1, "examin": 1, "experiment": 1, "featur": 2, "form": 2, "formul": 1, "free": 1, "head": 1, "interact": 1, "isoparametr": 1, "knowledg": 1, "line": 1, "mathemat": 1, "mount": 1, "movement": 1, "parametr": 1, "part": 1, "point": 1, "practic": 1, "princip": 1, "real": 1, "render": 1, "repres": 1, "shape": 1, "space": 1, "spline": 1, "surfac": 5, "system": 5, "time": 1, "user": 1, "wand": 1, "clark": 1}}, "2842": {"id": "2842", "title": "The Denotational Semantics of Programming Languages", "abstract": "This paper is a tutorial introduction to the theory of programming language semantics developed  by D. Scott and C. Strachey.  The application of the theory to formal language specification is demonstrated  and other applications are surveyed. The first language considered, LOOP, is very elementary and its  definition merely introduces the notation and methodology of the approach.  Then the semantic concepts of environments, stores, and continuations are introduced to model classes of programming language features  and the underlying mathematical theory of computation due to Scott is motivated and outlined.  Finally,  the paper presents a formal definition of the language GEDANKEN.", "authors": "Tennent, R. D.", "words_pool": ["applic", "applic", "approach", "class", "comput", "concept", "consid", "continu", "definit", "demonstr", "denot", "develop", "due", "elementari", "environ", "featur", "final", "formal", "gedanken", "introduc", "introduc", "introduct", "languag", "languag", "loop", "mathemat", "mere", "methodolog", "model", "motiv", "notat", "outlin", "paper", "present", "program", "scott", "semant", "semant", "specif", "store", "strachey", "survey", "theori", "tutori", "underli", "tennent"], "word_count": {"applic": 2, "approach": 1, "class": 1, "comput": 1, "concept": 1, "consid": 1, "continu": 1, "definit": 2, "demonstr": 1, "denot": 1, "develop": 1, "due": 1, "elementari": 1, "environ": 1, "featur": 1, "final": 1, "formal": 2, "gedanken": 1, "introduc": 2, "introduct": 1, "languag": 5, "loop": 1, "mathemat": 1, "mere": 1, "methodolog": 1, "model": 1, "motiv": 1, "notat": 1, "outlin": 1, "paper": 2, "present": 1, "program": 2, "scott": 2, "semant": 2, "specif": 1, "store": 1, "strachey": 1, "survey": 1, "theori": 3, "tutori": 1, "underli": 1, "tennent": 1}}, "2843": {"id": "2843", "title": "Tools and Philosophy for Software Education", "abstract": "This paper describes a set of tools and a philosophy for teaching software that have been found  very useful in course at MIT over the past seven years.  The tools include programs such as simulators,  graders, compilers, and monitor.  These allow the instructor to augment the basic concepts with relevant,  exciting, and economical student project activities.", "authors": "Donovan, J. J.", "words_pool": ["activ", "allow", "augment", "basic", "compil", "concept", "cours", "describ", "econom", "educ", "excit", "found", "grader", "includ", "instructor", "mit", "monitor", "paper", "past", "philosophi", "program", "project", "relev", "set", "simul", "softwar", "student", "teach", "tool", "year", "donovan"], "word_count": {"activ": 1, "allow": 1, "augment": 1, "basic": 1, "compil": 1, "concept": 1, "cours": 1, "describ": 1, "econom": 1, "educ": 1, "excit": 1, "found": 1, "grader": 1, "includ": 1, "instructor": 1, "mit": 1, "monitor": 1, "paper": 1, "past": 1, "philosophi": 1, "program": 1, "project": 1, "relev": 1, "set": 1, "simul": 1, "softwar": 1, "student": 1, "teach": 1, "tool": 2, "year": 1, "donovan": 1}}, "2844": {"id": "2844", "title": "Heaps Applied to Event Driven Mechanisms", "authors": "Gonnet, G. H.", "words_pool": ["appli", "driven", "event", "heap", "mechan", "gonnet"], "word_count": {"appli": 1, "driven": 1, "event": 1, "heap": 1, "mechan": 1, "gonnet": 1}}, "2845": {"id": "2845", "title": "A Buddy System Variation for Disk Storage Allocation", "abstract": "A generalization of the buddy system for storage allocation is described. The set of permitted  block sizes {SIZE(i)}, i=0,n, must satisfy the condition SIZE(i)=SIZE(i-1)+SIZE(i-k(i)) where k may be  any meaningful integral-valued function.  This makes it possible to force logical storage blocks to coincide  with physical storage blocks, such as tracks and cylinders.", "authors": "Burton, W.", "words_pool": ["alloc", "block", "block", "buddi", "coincid", "condit", "cylind", "disk", "forc", "function", "gener", "integr", "logic", "make", "meaning", "permit", "physic", "satisfi", "set", "size", "size", "storag", "system", "track", "valu", "variat", "burton"], "word_count": {"alloc": 1, "block": 3, "buddi": 1, "coincid": 1, "condit": 1, "cylind": 1, "disk": 1, "forc": 1, "function": 1, "gener": 1, "integr": 1, "logic": 1, "make": 1, "meaning": 1, "permit": 1, "physic": 1, "satisfi": 1, "set": 1, "size": 5, "storag": 3, "system": 1, "track": 1, "valu": 1, "variat": 1, "burton": 1}}, "2846": {"id": "2846", "title": "Compressed Tries", "abstract": "This paper presents a new data structure, called a compressed trie or C-trie, to be used in  information retrieval systems.  It has the same underlying m-ary tree structure as a trie, where m is  a parameter of the trie, but whereas the fields of the nodes in a trie have to be large enough to hold  a key or at least a pointer, the fields in a C-trie are only one bit long.  In the analysis part of the  paper it will be shown that for a collection of n keys the retrieval time, measured in terms of bit inspections  of one key, is of the order logm(n) and the storage requirement of the order n*(m+log2 n) bits.  This  improvement in storage requirements and retrieval time is achieved at the cost of decreasing the flexibility  of the structure, and therefore updating costs are increased.  First the C-trie is analyzed as a data  structure, and then several methods of its use for relatively static databases are discussed.", "authors": "Maly, K.", "words_pool": ["achiev", "analysi", "analyz", "ari", "bit", "bit", "call", "collect", "compress", "cost", "cost", "data", "databas", "decreas", "discuss", "field", "flexibl", "hold", "improv", "increas", "inform", "inspect", "key", "key", "larg", "log2", "logm", "long", "measur", "method", "node", "order", "paper", "paramet", "part", "pointer", "present", "requir", "requir", "retriev", "shown", "static", "storag", "structur", "system", "term", "time", "tree", "trie", "tri", "underli", "updat", "mali"], "word_count": {"achiev": 1, "analysi": 1, "analyz": 1, "ari": 1, "bit": 3, "call": 1, "collect": 1, "compress": 1, "cost": 2, "data": 2, "databas": 1, "decreas": 1, "discuss": 1, "field": 2, "flexibl": 1, "hold": 1, "improv": 1, "increas": 1, "inform": 1, "inspect": 1, "key": 3, "larg": 1, "log2": 1, "logm": 1, "long": 1, "measur": 1, "method": 1, "node": 1, "order": 2, "paper": 2, "paramet": 1, "part": 1, "pointer": 1, "present": 1, "requir": 2, "retriev": 3, "shown": 1, "static": 1, "storag": 2, "structur": 4, "system": 1, "term": 1, "time": 2, "tree": 1, "trie": 7, "tri": 1, "underli": 1, "updat": 1, "mali": 1}}, "2847": {"id": "2847", "title": "Sampling from the Gamma Distribution on a Computer", "abstract": "This paper describes a method of generating gamma variates that appears to be less costly than  Wallace's recently suggested method.  For large shape parameter (a); the cost of computation is proportional  to (a), whereas Wallace's method is proportional to (a).  Experimentation by Robinson and Lewis indicates  that for small (a) the method suggested here also dominates methods recently suggested by Dieter and  Ahrens, albeit those methods dominate for large (a).  The method suggested here uses the rejection technique.", "authors": "Fishman, G. S.", "words_pool": ["ahren", "albeit", "appear", "comput", "comput", "cost", "costli", "describ", "dieter", "distribut", "domin", "domin", "experiment", "gamma", "gener", "larg", "lewi", "method", "method", "paper", "paramet", "proport", "recent", "reject", "robinson", "sampl", "shape", "small", "suggest", "techniqu", "variat", "wallac", "fishman"], "word_count": {"ahren": 1, "albeit": 1, "appear": 1, "comput": 1, "cost": 1, "costli": 1, "describ": 1, "dieter": 1, "distribut": 1, "domin": 2, "experiment": 1, "gamma": 1, "gener": 1, "larg": 2, "lewi": 1, "method": 7, "paper": 1, "paramet": 1, "proport": 2, "recent": 2, "reject": 1, "robinson": 1, "sampl": 1, "shape": 1, "small": 1, "suggest": 4, "techniqu": 1, "variat": 1, "wallac": 2, "fishman": 1}}, "2848": {"id": "2848", "title": "Synthesis of Decision Rules", "abstract": "Decision tables can be used as an effective tool during an interview to record the logic of  processes to be automated.  The result of such an interview is not a structure of complete decision tables  but rather sets of decision rules.  The purpose of this paper is to provide a procedure for synthesizing  the decision rules and thus provide an aid in developing a structure of complete decision tables.", "authors": "Cheng, C. Rabin, J.", "words_pool": ["aid", "autom", "complet", "decis", "develop", "effect", "interview", "logic", "paper", "procedur", "process", "provid", "purpos", "record", "result", "rule", "set", "structur", "synthesi", "synthes", "tabl", "tool", "cheng", "rabin"], "word_count": {"aid": 1, "autom": 1, "complet": 2, "decis": 5, "develop": 1, "effect": 1, "interview": 2, "logic": 1, "paper": 1, "procedur": 1, "process": 1, "provid": 2, "purpos": 1, "record": 1, "result": 1, "rule": 2, "set": 1, "structur": 2, "synthesi": 1, "synthes": 1, "tabl": 3, "tool": 1, "cheng": 1, "rabin": 1}}, "2849": {"id": "2849", "title": "Ethernet: Distributed Packet Switching for Local Computer Networks", "abstract": "Ethernet is a branching broadcast communication system for carrying digital data packets among  locally distributed computing stations. The packet transport mechanism provided by Ethernet has been  used to build systems which can be viewed as either local computer networks or loosely coupled multiprocessors.   An Ethernet's shared communication facility, its Ether, is a passive broadcast medium with no central  control.  Coordination of access to the Ether for packet broadcasts is distributed among the contending  transmitting stations using controlled statistical arbitration.  Switching of packets to their destinations  on the Ether is distributed among the receiving stations using packet address recognition.  Design principles  and implementation are described, based on experience with an operating Ethernet of 100 nodes along a  kilometer of coaxial cable.  A model for estimating performance under heavy loads and a packet protocol  for error controlled communication are included for completeness.", "authors": "Metcalfe, R. M. Boggs, D. R.", "words_pool": ["access", "address", "arbitr", "base", "branch", "broadcast", "broadcast", "build", "cabl", "carri", "central", "coaxial", "commun", "complet", "comput", "comput", "contend", "control", "control", "coordin", "coupl", "data", "design", "destin", "digit", "distribut", "error", "estim", "ether", "ethernet", "experi", "facil", "heavi", "implement", "includ", "kilomet", "load", "local", "local", "loos", "mechan", "medium", "model", "multiprocessor", "network", "node", "oper", "packet", "packet", "passiv", "perform", "principl", "protocol", "provid", "receiv", "recognit", "share", "station", "statist", "switch", "system", "system", "transmit", "transport", "view", "metcalf", "bogg"], "word_count": {"access": 1, "address": 1, "arbitr": 1, "base": 1, "branch": 1, "broadcast": 3, "build": 1, "cabl": 1, "carri": 1, "central": 1, "coaxial": 1, "commun": 3, "complet": 1, "comput": 2, "contend": 1, "control": 3, "coordin": 1, "coupl": 1, "data": 1, "design": 1, "destin": 1, "digit": 1, "distribut": 3, "error": 1, "estim": 1, "ether": 3, "ethernet": 4, "experi": 1, "facil": 1, "heavi": 1, "implement": 1, "includ": 1, "kilomet": 1, "load": 1, "local": 2, "loos": 1, "mechan": 1, "medium": 1, "model": 1, "multiprocessor": 1, "network": 1, "node": 1, "oper": 1, "packet": 6, "passiv": 1, "perform": 1, "principl": 1, "protocol": 1, "provid": 1, "receiv": 1, "recognit": 1, "share": 1, "station": 3, "statist": 1, "switch": 1, "system": 2, "transmit": 1, "transport": 1, "view": 1, "metcalf": 1, "bogg": 1}}, "2850": {"id": "2850", "title": "Symbolic Execution and Program Testing", "abstract": "This paper describes the symbolic execution of programs.  Instead of supplying the normal inputs  to a program (e.g. numbers) one supplies symbols representing arbitrary values.  The execution proceeds  as in a normal execution except that values may be symbolic formulas over the input symbols.  The difficult,  yet interesting issues arise during the symbolic execution of conditional branch type statements.  A  particular system called EFFIGY which provides symbolic execution for program testing and debugging is  also described.  It interpretively executes programs written in a simple PL/I style programming language.   It includes many standard debugging features, the ability to manage and to prove things about symbolic  expressions, a simple program testing manager, and a program verifier.  A brief discussion of the relationship  between symbolic execution and program proving is also included.", "authors": "King, J. C.", "words_pool": ["abil", "arbitrari", "aris", "branch", "call", "condit", "debug", "describ", "difficult", "discuss", "effigi", "execut", "execut", "express", "featur", "formula", "includ", "includ", "input", "input", "interest", "interpret", "issu", "languag", "manag", "manag", "normal", "number", "paper", "pl", "proce", "program", "program", "program", "prove", "prove", "relationship", "repres", "simpl", "standard", "statement", "style", "suppli", "suppli", "symbol", "symbol", "system", "test", "thing", "type", "valu", "verifi", "written", "king"], "word_count": {"abil": 1, "arbitrari": 1, "aris": 1, "branch": 1, "call": 1, "condit": 1, "debug": 2, "describ": 1, "difficult": 1, "discuss": 1, "effigi": 1, "execut": 7, "express": 1, "featur": 1, "formula": 1, "includ": 2, "input": 2, "interest": 1, "interpret": 1, "issu": 1, "languag": 1, "manag": 2, "normal": 2, "number": 1, "paper": 1, "pl": 1, "proce": 1, "program": 8, "prove": 2, "relationship": 1, "repres": 1, "simpl": 2, "standard": 1, "statement": 1, "style": 1, "suppli": 2, "symbol": 8, "system": 1, "test": 2, "thing": 1, "type": 1, "valu": 2, "verifi": 1, "written": 1, "king": 1}}, "2851": {"id": "2851", "title": "Formal Verification of Parallel Programs", "abstract": "Two formal models for parallel computation are presented: an abstract conceptual model and  a parallel-program model.  The former model does not distinguish between control and data states.  The  latter model includes the capability for the representation of an infinite set of control states by allowing  there to be arbitrarily many instruction pointers (or processes) executing the program.  An induction  principle is presented which treats the control and data state sets on the same ground.  Through the  use of \"place variables,\" it is observed that certain correctness conditions can be expressed without  enumeration of the set of all possible control states.  Examples are presented in which the induction  principle is used to demonstrate proofs of mutual exclusion.  It is shown that assertions-oriented proof  methods are special cases of the induction principle. A special case of the assertions method, which  is called parallel place assertions, is shown to be incomplete.  A formalization of \"deadlock\" is then  presented. The concept of a \"norm\" is introduced, which yields an extension, to the deadlock problem,  of Floyd's technique for proving termination.  Also discussed is an extension of the program model which  allows each process to have its own local variables and permits shared global variables.  Correctness  of certain forms of implementation is also discussed.  An Appendix is included which relates this work  to previous work on the satisfiability of certain logical formulas.", "authors": "Keller, R. M.", "words_pool": ["abstract", "allow", "appendix", "arbitrarili", "assert", "call", "capabl", "case", "case", "comput", "concept", "conceptu", "condit", "control", "correct", "data", "deadlock", "demonstr", "discuss", "distinguish", "enumer", "exampl", "exclus", "execut", "express", "extens", "floyd", "formal", "formal", "form", "formula", "global", "ground", "implement", "includ", "includ", "incomplet", "induct", "infinit", "instruct", "introduc", "local", "logic", "method", "method", "model", "model", "mutual", "norm", "observ", "orient", "parallel", "permit", "place", "pointer", "present", "previou", "principl", "problem", "process", "process", "program", "program", "proof", "proof", "prove", "relat", "represent", "satisfi", "set", "set", "share", "shown", "special", "state", "state", "techniqu", "termin", "treat", "variabl", "verif", "work", "yield", "keller"], "word_count": {"abstract": 1, "allow": 1, "appendix": 1, "arbitrarili": 1, "assert": 3, "call": 1, "capabl": 1, "case": 2, "comput": 1, "concept": 1, "conceptu": 1, "condit": 1, "control": 4, "correct": 2, "data": 2, "deadlock": 2, "demonstr": 1, "discuss": 2, "distinguish": 1, "enumer": 1, "exampl": 1, "exclus": 1, "execut": 1, "express": 1, "extens": 2, "floyd": 1, "formal": 2, "form": 1, "formula": 1, "global": 1, "ground": 1, "implement": 1, "includ": 2, "incomplet": 1, "induct": 3, "infinit": 1, "instruct": 1, "introduc": 1, "local": 1, "logic": 1, "method": 2, "model": 6, "mutual": 1, "norm": 1, "observ": 1, "orient": 1, "parallel": 3, "permit": 1, "place": 2, "pointer": 1, "present": 4, "previou": 1, "principl": 3, "problem": 1, "process": 2, "program": 3, "proof": 2, "prove": 1, "relat": 1, "represent": 1, "satisfi": 1, "set": 3, "share": 1, "shown": 2, "special": 2, "state": 4, "techniqu": 1, "termin": 1, "treat": 1, "variabl": 3, "verif": 1, "work": 2, "yield": 1, "keller": 1}}, "2852": {"id": "2852", "title": "The Technology of Computer Center Management: A Proposed Course for Graduate Professional Programs  in Computer Science or in Information Systems", "abstract": "McFarlan and Nolan have made a strong case for adding a course on information systems administration  to the 13 courses proposed by the ACM Curriculum Committee on Computer Education for Management for Graduate  Professional Programs in Information Systems.  This paper is a report on a course entitled, \"The Technology  of Computer Center Management,\" which has been offered at Purdue for the past four years.  The course  is suitable either for graduate professional programs in information systems or for graduate professional  programs in computer science.", "authors": "Conte, S. D. Halstead, M. H.", "words_pool": ["acm", "ad", "administr", "case", "center", "committe", "comput", "cours", "cours", "curriculum", "educ", "entitl", "graduat", "inform", "made", "manag", "mcfarlan", "nolan", "offer", "paper", "past", "profession", "program", "propos", "purdu", "report", "scienc", "strong", "suitabl", "system", "technolog", "year", "cont", "halstead"], "word_count": {"acm": 1, "ad": 1, "administr": 1, "case": 1, "center": 1, "committe": 1, "comput": 3, "cours": 4, "curriculum": 1, "educ": 1, "entitl": 1, "graduat": 3, "inform": 3, "made": 1, "manag": 2, "mcfarlan": 1, "nolan": 1, "offer": 1, "paper": 1, "past": 1, "profession": 3, "program": 3, "propos": 1, "purdu": 1, "report": 1, "scienc": 1, "strong": 1, "suitabl": 1, "system": 3, "technolog": 1, "year": 1, "cont": 1, "halstead": 1}}, "2853": {"id": "2853", "title": "A Numbering System for Permutations of Combinations", "authors": "Knott, G. D.", "words_pool": ["combin", "number", "permut", "system", "knott"], "word_count": {"combin": 1, "number": 1, "permut": 1, "system": 1, "knott": 1}}, "2854": {"id": "2854", "title": "Multiprocessing Compactifying Garbage Collection (Corrigendum)", "authors": "Steele, G. L. Jr.", "words_pool": ["collect", "compactifi", "corrigendum", "garbag", "multiprocess", "steel", "jr"], "word_count": {"collect": 1, "compactifi": 1, "corrigendum": 1, "garbag": 1, "multiprocess": 1, "steel": 1, "jr": 1}}, "2855": {"id": "2855", "title": "An Efficient List-Moving Algorithm Using Constant Workspace", "abstract": "An efficient algorithm is presented for moving arbitrary list structures, using no storage  (apart from program variables) other than that required to hold the original list and the copy.  The  original list is destroyed as it is moved.  No mark bits are necessary, but pointers to the copy must  be distinguishable from pointers to the original.  The algorithm is superior in execution speed to previous  algorithms for the same problem.  Some variations and extensions of the algorithm are discussed.", "authors": "Clark, D. W.", "words_pool": ["algorithm", "algorithm", "arbitrari", "bit", "constant", "copi", "destroy", "discuss", "distinguish", "effici", "execut", "extens", "hold", "list", "mark", "move", "move", "origin", "pointer", "present", "previou", "problem", "program", "requir", "speed", "storag", "structur", "superior", "variabl", "variat", "workspac", "clark"], "word_count": {"algorithm": 4, "arbitrari": 1, "bit": 1, "constant": 1, "copi": 2, "destroy": 1, "discuss": 1, "distinguish": 1, "effici": 1, "execut": 1, "extens": 1, "hold": 1, "list": 3, "mark": 1, "move": 2, "origin": 3, "pointer": 2, "present": 1, "previou": 1, "problem": 1, "program": 1, "requir": 1, "speed": 1, "storag": 1, "structur": 1, "superior": 1, "variabl": 1, "variat": 1, "workspac": 1, "clark": 1}}, "2856": {"id": "2856", "title": "The Synthetic Approach to Decision Table Conversion", "abstract": "Previous approaches to the problem of automatically converting decision tables to computer  programs have been based on decomposition.  At any stage, one condition is selected for testing, and  two smaller problems (decision tables with one less condition) are created.  An optimal program (with  respect to average execution time or storage space, for example) is located only through implicit enumeration  of all possible decision trees using a technique such as branch-and-bound.  The new approach described  in this paper uses dynamic programming to synthesize an optimal decision tree from which a program can  be created.  Using this approach, the efficiency of creating an optimal program is increased substantially,  permitting generation of optimal programs for decision tables with as many as ten to twelve conditions.", "authors": "Schumacher, H. Sevcik, K. C.", "words_pool": ["approach", "approach", "averag", "base", "bound", "branch", "comput", "condit", "condit", "convers", "convert", "creat", "creat", "decis", "decomposit", "dynam", "effici", "enumer", "execut", "gener", "implicit", "increas", "locat", "optim", "paper", "permit", "previou", "problem", "problem", "program", "program", "program", "respect", "select", "smaller", "space", "stage", "storag", "substanti", "synthes", "synthet", "tabl", "tabl", "techniqu", "ten", "test", "time", "tree", "tree", "twelv", "schumach", "sevcik"], "word_count": {"approach": 3, "averag": 1, "base": 1, "bound": 1, "branch": 1, "comput": 1, "condit": 3, "convers": 1, "convert": 1, "creat": 3, "decis": 5, "decomposit": 1, "dynam": 1, "effici": 1, "enumer": 1, "execut": 1, "gener": 1, "implicit": 1, "increas": 1, "locat": 1, "optim": 4, "paper": 1, "permit": 1, "previou": 1, "problem": 2, "program": 6, "respect": 1, "select": 1, "smaller": 1, "space": 1, "stage": 1, "storag": 1, "substanti": 1, "synthes": 1, "synthet": 1, "tabl": 3, "techniqu": 1, "ten": 1, "test": 1, "time": 1, "tree": 2, "twelv": 1, "schumach": 1, "sevcik": 1}}, "2857": {"id": "2857", "title": "Referencing Lists by an Edge", "abstract": "An edge reference into a list structure is a pair of pointers to adjacent nodes.  Such a reference  often requires little additional space, but its use can yield efficient algorithms. For instance, a circular  link between the ends of a list is redundant\u0019 if the list is always referenced by that edge, and list traversal  is easier when that link is null.  Edge references also allow threading of nonrecursive lists, can replace  some header cells, and enhance the famous exclusive-or-trick to double-link lists", "authors": "Wise, D. S.", "words_pool": ["addit", "adjac", "algorithm", "allow", "cell", "circular", "doubl", "easier", "edg", "effici", "end", "enhanc", "exclus", "famou", "header", "instanc", "link", "list", "list", "node", "nonrecurs", "null", "pair", "pointer", "redund", "refer", "referenc", "refer", "referenc", "replac", "requir", "space", "structur", "thread", "travers", "trick", "yield", "wise"], "word_count": {"addit": 1, "adjac": 1, "algorithm": 1, "allow": 1, "cell": 1, "circular": 1, "doubl": 1, "easier": 1, "edg": 3, "effici": 1, "end": 1, "enhanc": 1, "exclus": 1, "famou": 1, "header": 1, "instanc": 1, "link": 3, "list": 6, "node": 1, "nonrecurs": 1, "null": 1, "pair": 1, "pointer": 1, "redund": 1, "refer": 3, "referenc": 1, "replac": 1, "requir": 1, "space": 1, "structur": 1, "thread": 1, "travers": 1, "trick": 1, "yield": 1, "wise": 1}}, "2858": {"id": "2858", "title": "A Process for the Determination of Addresses in Variable Length Addressing", "abstract": "An algorithm is presented for the assignment of instruction addresses and formats under the  following conditions: (1) the length of the instruction varies as a function of the distance of the instruction  from its target; (2) there exists an optimality criterion which implies some preferential choices subject  to the addressing constraints.  This may be, for example, achieving the smallest number of long instructions,  in which case the total code length is minimized, or minimizing the assigned address of a specified point  in the program.  The algorithm is suitable for arbitrary program structure and a choice of optimization  criteria.", "authors": "Frieder, G. Saal, H. J.", "words_pool": ["achiev", "address", "address", "address", "algorithm", "arbitrari", "assign", "assign", "case", "choic", "choic", "code", "condit", "constraint", "criteria", "criterion", "determin", "distanc", "exist", "format", "function", "impli", "instruct", "instruct", "length", "long", "minim", "minim", "number", "optim", "optim", "point", "preferenti", "present", "process", "program", "smallest", "structur", "subject", "suitabl", "target", "total", "variabl", "vari", "frieder", "saal"], "word_count": {"achiev": 1, "address": 3, "algorithm": 2, "arbitrari": 1, "assign": 2, "case": 1, "choic": 2, "code": 1, "condit": 1, "constraint": 1, "criteria": 1, "criterion": 1, "determin": 1, "distanc": 1, "exist": 1, "format": 1, "function": 1, "impli": 1, "instruct": 4, "length": 2, "long": 1, "minim": 2, "number": 1, "optim": 2, "point": 1, "preferenti": 1, "present": 1, "process": 1, "program": 2, "smallest": 1, "structur": 1, "subject": 1, "suitabl": 1, "target": 1, "total": 1, "variabl": 1, "vari": 1, "frieder": 1, "saal": 1}}, "2859": {"id": "2859", "title": "Interference in Multiprocessor Computer Systems with Interleaved Memory", "abstract": "This paper analyzes the memory interference caused by several processors simultaneously using  several memory modules.  Exect results are computed for a simple model of such a system.   The limiting  value is derived for the relative degree of memory interference as the system size increases.  The model  of the limiting behavior of the system yields approximate results for the simple model and also suggests  that the results are valid for a much larger class of models, including those more nearly like real systems  that the simple model are tested against some measurements of program behavior and simulations of systems  using memory references from real programs.  The model results provide a good indication of the performance  that should be expected from real system of this type.", "authors": "Baskett, F. Smith, A. J.", "words_pool": ["analyz", "approxim", "behavior", "caus", "class", "comput", "comput", "degre", "deriv", "exect", "expect", "good", "includ", "increas", "indic", "interfer", "interleav", "larger", "limit", "measur", "memori", "model", "model", "modul", "multiprocessor", "nearli", "paper", "perform", "processor", "program", "program", "provid", "real", "refer", "rel", "result", "simpl", "simul", "simultan", "size", "suggest", "system", "system", "test", "type", "valid", "yield", "baskett", "smith"], "word_count": {"analyz": 1, "approxim": 1, "behavior": 2, "caus": 1, "class": 1, "comput": 1, "degre": 1, "deriv": 1, "exect": 1, "expect": 1, "good": 1, "includ": 1, "increas": 1, "indic": 1, "interfer": 2, "interleav": 1, "larger": 1, "limit": 2, "measur": 1, "memori": 4, "model": 6, "modul": 1, "multiprocessor": 1, "nearli": 1, "paper": 1, "perform": 1, "processor": 1, "program": 2, "provid": 1, "real": 3, "refer": 1, "rel": 1, "result": 4, "simpl": 3, "simul": 1, "simultan": 1, "size": 1, "suggest": 1, "system": 6, "test": 1, "type": 1, "valid": 1, "yield": 1, "baskett": 1, "smith": 1}}, "2860": {"id": "2860", "title": "A Practitioner's Guide To Addressing Algorithms", "abstract": "This paper consolidates a number of popular rules of thumb which have been suggested for the design of record addressing algorithms, and discusses the applicability of these rules to large commercial  databases.  Guidelines for selecting identifier transformations, overflow techniques, loading factors,  bucket sizes, and loading order and considered.  Particular attention is focused on the reasonableness  of common heuristics for determining primary or secondary bucket sizes. A mathematical model which explicitly  considers storage device characteristics and time/space cost tradeoffs is used to analyze the effect  of design parameters on overall system costs.  A specific design example is presented and solved.", "authors": "Severance, D. Duhne, R.", "words_pool": ["address", "algorithm", "analyz", "applic", "attent", "bucket", "characterist", "commerci", "common", "consid", "consid", "consolid", "cost", "cost", "databas", "design", "determin", "devic", "discuss", "effect", "explicitli", "factor", "focus", "guid", "guidelin", "heurist", "identifi", "larg", "load", "mathemat", "model", "number", "order", "overflow", "paper", "paramet", "popular", "practition", "present", "primari", "reason", "record", "rule", "secondari", "select", "size", "solv", "space", "specif", "storag", "suggest", "system", "techniqu", "thumb", "time", "tradeoff", "transform", "sever", "duhn"], "word_count": {"address": 1, "algorithm": 1, "analyz": 1, "applic": 1, "attent": 1, "bucket": 2, "characterist": 1, "commerci": 1, "common": 1, "consid": 2, "consolid": 1, "cost": 2, "databas": 1, "design": 3, "determin": 1, "devic": 1, "discuss": 1, "effect": 1, "explicitli": 1, "factor": 1, "focus": 1, "guid": 1, "guidelin": 1, "heurist": 1, "identifi": 1, "larg": 1, "load": 2, "mathemat": 1, "model": 1, "number": 1, "order": 1, "overflow": 1, "paper": 1, "paramet": 1, "popular": 1, "practition": 1, "present": 1, "primari": 1, "reason": 1, "record": 1, "rule": 2, "secondari": 1, "select": 1, "size": 2, "solv": 1, "space": 1, "specif": 1, "storag": 1, "suggest": 1, "system": 1, "techniqu": 1, "thumb": 1, "time": 1, "tradeoff": 1, "transform": 1, "sever": 1, "duhn": 1}}, "2861": {"id": "2861", "title": "Production and Employment of Ph.D.'s in Computer Science", "authors": "Taulbee, O. E. Conte, S. D.", "words_pool": ["comput", "employ", "ph", "product", "scienc", "taulbe", "cont"], "word_count": {"comput": 1, "employ": 1, "ph": 1, "product": 1, "scienc": 1, "taulbe": 1, "cont": 1}}, "2862": {"id": "2862", "title": "Analysis of the PFF Replacement Algorithm via a Semi-Markov Model", "abstract": "An analytical model is presented to estimate the performance of the Page Fault Frequency (PFF)  replacement algorithm.  In this model, program behavior is represented by the LRU stack distance model  and the PFF replacement algorithm is represented by a semi-Markov model.  Using these models, such parameters  as the inter-page-fault interval distribution, the probability of the number of distinct pages being  referenced during an inter-page-fault interval, etc. are able to be analytically determined.  Using these  models to evaluate these parameter values permits study of the performance of the replacement algorithm  by simulating the page fault events rather than every page reference event.  This significantly reduces  the required computation time in estimating the performance of the PFF algorithm.", "authors": "Chu, W. W. Opderbeck, H.", "words_pool": ["abl", "algorithm", "analysi", "analyt", "analyt", "behavior", "comput", "determin", "distanc", "distinct", "distribut", "estim", "estim", "evalu", "event", "event", "fault", "frequenc", "inter", "interv", "lru", "markov", "model", "model", "number", "page", "page", "paramet", "paramet", "perform", "permit", "pff", "present", "probabl", "program", "reduc", "refer", "referenc", "replac", "repres", "requir", "semi", "significantli", "simul", "stack", "studi", "time", "valu", "chu", "opderbeck"], "word_count": {"abl": 1, "algorithm": 4, "analysi": 1, "analyt": 2, "behavior": 1, "comput": 1, "determin": 1, "distanc": 1, "distinct": 1, "distribut": 1, "estim": 2, "evalu": 1, "event": 2, "fault": 4, "frequenc": 1, "inter": 2, "interv": 2, "lru": 1, "markov": 1, "model": 6, "number": 1, "page": 6, "paramet": 2, "perform": 3, "permit": 1, "pff": 3, "present": 1, "probabl": 1, "program": 1, "reduc": 1, "refer": 1, "referenc": 1, "replac": 3, "repres": 2, "requir": 1, "semi": 1, "significantli": 1, "simul": 1, "stack": 1, "studi": 1, "time": 1, "valu": 1, "chu": 1, "opderbeck": 1}}, "2863": {"id": "2863", "title": "VMIN-An Optimal Variable-Space Page Replacement Algorithm", "abstract": "A criterion for comparing variable space page replacement algorithms is presented.  An optimum  page replacement algorithm, called VMIN, is described and shown to be optimum with respect to this criterion.  The results of simulating VMIN, Denning's working set, and the page partitioning replacement algorithms  on five virtual memory programs are presented to demonstrate the improvement possible over the known  realizable variable space algorithms.", "authors": "Prieve, B. G. Fabry, R. S.", "words_pool": ["algorithm", "algorithm", "call", "compar", "criterion", "demonstr", "den", "improv", "known", "memori", "optim", "optimum", "page", "partit", "present", "program", "realiz", "replac", "respect", "result", "set", "shown", "simul", "space", "variabl", "virtual", "vmin", "work", "priev", "fabri"], "word_count": {"algorithm": 4, "call": 1, "compar": 1, "criterion": 2, "demonstr": 1, "den": 1, "improv": 1, "known": 1, "memori": 1, "optim": 1, "optimum": 2, "page": 3, "partit": 1, "present": 2, "program": 1, "realiz": 1, "replac": 3, "respect": 1, "result": 1, "set": 1, "shown": 1, "simul": 1, "space": 2, "variabl": 2, "virtual": 1, "vmin": 2, "work": 1, "priev": 1, "fabri": 1}}, "2864": {"id": "2864", "title": "Characteristics of Program Localities", "abstract": "The term \"locality\" has been used to denote that subset of a program's segments which are referenced  during a particular phase of its execution.  A program's behavior can be characterized in terms of its  residence in localities of various sizes and lifetimes, and the transitions between these localities.   In this paper the concept of a locality is made more explicit through a formal definition of what constitutes  a phase of localized reference behavior, and by a corresponding mechanism for the detection of localities  in actual reference strings.  This definition provides for the existence of a hierarchy of localities  at any given time, and the reasonableness of the definition is supported by examples taken from actual  programs.  Empirical data from a sample of production Algol 60 programs is used to display distributions  of locality sizes and lifetimes, and these results are discussed in terms of their implications for the  modeling of program behavior and memory management in virtual memory systems.", "authors": "Madison, A. W. Batson, A. P.", "words_pool": ["actual", "algol", "behavior", "characterist", "character", "concept", "constitut", "data", "definit", "denot", "detect", "discuss", "display", "distribut", "empir", "exampl", "execut", "exist", "explicit", "formal", "hierarchi", "implic", "lifetim", "local", "local", "local", "made", "manag", "mechan", "memori", "model", "paper", "phase", "product", "program", "program", "reason", "refer", "referenc", "resid", "result", "sampl", "segment", "size", "string", "subset", "support", "system", "term", "term", "time", "transit", "virtual", "madison", "batson"], "word_count": {"actual": 2, "algol": 1, "behavior": 3, "characterist": 1, "character": 1, "concept": 1, "constitut": 1, "data": 1, "definit": 3, "denot": 1, "detect": 1, "discuss": 1, "display": 1, "distribut": 1, "empir": 1, "exampl": 1, "execut": 1, "exist": 1, "explicit": 1, "formal": 1, "hierarchi": 1, "implic": 1, "lifetim": 2, "local": 8, "made": 1, "manag": 1, "mechan": 1, "memori": 2, "model": 1, "paper": 1, "phase": 2, "product": 1, "program": 5, "reason": 1, "refer": 2, "referenc": 1, "resid": 1, "result": 1, "sampl": 1, "segment": 1, "size": 2, "string": 1, "subset": 1, "support": 1, "system": 1, "term": 3, "time": 1, "transit": 1, "virtual": 1, "madison": 1, "batson": 1}}, "2865": {"id": "2865", "title": "Verifying Properties of Parallel Programs: An Axiomatic Approach", "abstract": "An axiomatic method for proving a number of properties of parallel programs is presented.   Hoare has given a set of axioms for partial correctness, but they are not strong enough in most cases.   This paper defines a more powerful deductive system which is in some sense complete for partial correctness.   A crucial axiom provides for the use of auxiliary variables, which are added to a parallel program as  an aid to proving it correct.  The information in a partial correctness proof can be used to prove such  properties as mutual exclusion, freedom from deadlock, and program termination.  Techniques for verifying  these properties are presented and illustrated by application to the dining philosophers problem.", "authors": "Owicki, S. Gries, D.", "words_pool": ["ad", "aid", "applic", "approach", "auxiliari", "axiom", "axiomat", "axiom", "case", "complet", "correct", "correct", "crucial", "deadlock", "deduct", "defin", "dine", "exclus", "freedom", "hoar", "illustr", "inform", "method", "mutual", "number", "paper", "parallel", "partial", "philosoph", "power", "present", "problem", "program", "program", "proof", "properti", "prove", "prove", "sens", "set", "strong", "system", "techniqu", "termin", "variabl", "verifi", "owicki", "gri"], "word_count": {"ad": 1, "aid": 1, "applic": 1, "approach": 1, "auxiliari": 1, "axiom": 2, "axiomat": 1, "case": 1, "complet": 1, "correct": 4, "crucial": 1, "deadlock": 1, "deduct": 1, "defin": 1, "dine": 1, "exclus": 1, "freedom": 1, "hoar": 1, "illustr": 1, "inform": 1, "method": 1, "mutual": 1, "number": 1, "paper": 1, "parallel": 2, "partial": 3, "philosoph": 1, "power": 1, "present": 2, "problem": 1, "program": 3, "proof": 1, "properti": 3, "prove": 3, "sens": 1, "set": 1, "strong": 1, "system": 1, "techniqu": 1, "termin": 1, "variabl": 1, "verifi": 1, "owicki": 1, "gri": 1}}, "2866": {"id": "2866", "title": "Proving Monitors", "abstract": "Interesting scheduling and sequential properties of monitors can be proved by using state variables  which record the monitor's history and by defining extended proof rules for their wait and signal operations.   These two techniques are defined, discussed, and applied to examples to prove properties such as freedom  from indefinitely repeated overtaking or unnecessary waiting upper bounds on queue lengths, and historical  behavior.", "authors": "Howard, J.H.", "words_pool": ["appli", "behavior", "bound", "defin", "defin", "discuss", "exampl", "extend", "freedom", "histor", "histori", "indefinit", "interest", "length", "monitor", "monitor", "oper", "overtak", "proof", "properti", "prove", "prove", "prove", "queue", "record", "repeat", "rule", "schedul", "sequenti", "signal", "state", "techniqu", "unnecessari", "upper", "variabl", "wait", "wait", "howard"], "word_count": {"appli": 1, "behavior": 1, "bound": 1, "defin": 2, "discuss": 1, "exampl": 1, "extend": 1, "freedom": 1, "histor": 1, "histori": 1, "indefinit": 1, "interest": 1, "length": 1, "monitor": 2, "oper": 1, "overtak": 1, "proof": 1, "properti": 2, "prove": 2, "queue": 1, "record": 1, "repeat": 1, "rule": 1, "schedul": 1, "sequenti": 1, "signal": 1, "state": 1, "techniqu": 1, "unnecessari": 1, "upper": 1, "variabl": 1, "wait": 2, "howard": 1}}, "2867": {"id": "2867", "title": "Modularization and Hierarchy in a Family of Operating Systems", "abstract": "This paper describes the design philosophy used in the construction of a family of operating  systems. It is shown that the concepts of module and level do not coincide in a hierarchy of functions.   Family members can share much software as a result of the implementation of run-time modules at the  lowest system level.", "authors": "Habermann,A. N. Flon, L. Cooprider, L.", "words_pool": ["coincid", "concept", "construct", "describ", "design", "famili", "function", "hierarchi", "implement", "level", "lowest", "member", "modular", "modul", "modul", "oper", "paper", "philosophi", "result", "run", "share", "shown", "softwar", "system", "system", "time", "habermann", "flon", "cooprid"], "word_count": {"coincid": 1, "concept": 1, "construct": 1, "describ": 1, "design": 1, "famili": 2, "function": 1, "hierarchi": 1, "implement": 1, "level": 2, "lowest": 1, "member": 1, "modular": 1, "modul": 2, "oper": 1, "paper": 1, "philosophi": 1, "result": 1, "run": 1, "share": 1, "shown": 1, "softwar": 1, "system": 2, "time": 1, "habermann": 1, "flon": 1, "cooprid": 1}}, "2868": {"id": "2868", "title": "Reflections on an Operating System Design", "abstract": "The main features of a general purpose multiaccess operating system developed for the CDC 6400  at Berkeley are presented, and its good and bad points are discussed as they appear in retrospect.  Distinctive  features of the design were the use of capabilities for protection, and the organization of the system  into a sequence of layers, each building on the facilities provided by earlier ones and protecting itself  from the malfunctions of later ones. There were serious problems in maintaining the protection between  layers when levels were added to the memory hierarchy; these problems are discussed and a new solution  is described.", "authors": "Lampson, B. W. Sturgis, H. E.", "words_pool": ["ad", "bad", "berkeley", "build", "capabl", "cdc", "design", "develop", "discuss", "distinct", "earlier", "facil", "featur", "gener", "good", "hierarchi", "later", "layer", "level", "main", "maintain", "malfunct", "memori", "multiaccess", "oper", "organ", "point", "present", "problem", "protect", "protect", "provid", "purpos", "reflect", "retrospect", "sequenc", "solut", "system", "lampson", "sturgi"], "word_count": {"ad": 1, "bad": 1, "berkeley": 1, "build": 1, "capabl": 1, "cdc": 1, "design": 1, "develop": 1, "discuss": 2, "distinct": 1, "earlier": 1, "facil": 1, "featur": 2, "gener": 1, "good": 1, "hierarchi": 1, "later": 1, "layer": 2, "level": 1, "main": 1, "maintain": 1, "malfunct": 1, "memori": 1, "multiaccess": 1, "oper": 1, "organ": 1, "point": 1, "present": 1, "problem": 2, "protect": 3, "provid": 1, "purpos": 1, "reflect": 1, "retrospect": 1, "sequenc": 1, "solut": 1, "system": 2, "lampson": 1, "sturgi": 1}}, "2869": {"id": "2869", "title": "Security Kernel Validation in Practice", "abstract": "A security kernel is a software and hardware mechanism that enforces access controls within  a computer system. The correctness of a security kernel on a PDP-11/45 is being proved.  This paper describes  the technique used to carry out the first step of the proof: validating a formal specification of the  program with respect to a axioms for a secure system.", "authors": "Millen, J. K.", "words_pool": ["access", "axiom", "carri", "comput", "control", "correct", "describ", "enforc", "formal", "hardwar", "kernel", "mechan", "paper", "pdp", "practic", "program", "proof", "prove", "respect", "secur", "secur", "softwar", "specif", "step", "system", "techniqu", "valid", "valid", "millen"], "word_count": {"access": 1, "axiom": 1, "carri": 1, "comput": 1, "control": 1, "correct": 1, "describ": 1, "enforc": 1, "formal": 1, "hardwar": 1, "kernel": 2, "mechan": 1, "paper": 1, "pdp": 1, "practic": 1, "program": 1, "proof": 1, "prove": 1, "respect": 1, "secur": 3, "softwar": 1, "specif": 1, "step": 1, "system": 2, "techniqu": 1, "valid": 1, "millen": 1}}, "2870": {"id": "2870", "title": "A Lattice Model of Secure Information Flow", "abstract": "This paper investigates mechanisms that guarantee secure information flow in a computer system.  These mechanisms are examined within a mathematical framework suitable for formulating the requirements  of secure information flow among security classes. The central component of the model is a lattice structure  derived from the security classes and justified by the semantics of information flow.  The lattice properties  permit concise formulations of the security requirements of different existing systems and facilitate  the construction of mechanisms that enforce security.  The model provides a unifying view of all systems  that restrict information flow, enables a classification of them according to security objectives, and  suggests some new approaches.  It also leads to the construction of automatic program certification mechanisms  for verifying the secure flow of information through a program.", "authors": "Denning, D. E.", "words_pool": ["accord", "approach", "automat", "central", "certif", "class", "classif", "compon", "comput", "concis", "construct", "deriv", "enabl", "enforc", "examin", "exist", "facilit", "flow", "formul", "formul", "framework", "guarante", "inform", "investig", "justifi", "lattic", "lead", "mathemat", "mechan", "model", "object", "paper", "permit", "program", "properti", "requir", "restrict", "secur", "secur", "semant", "structur", "suggest", "suitabl", "system", "system", "unifi", "verifi", "view", "den"], "word_count": {"accord": 1, "approach": 1, "automat": 1, "central": 1, "certif": 1, "class": 2, "classif": 1, "compon": 1, "comput": 1, "concis": 1, "construct": 2, "deriv": 1, "enabl": 1, "enforc": 1, "examin": 1, "exist": 1, "facilit": 1, "flow": 5, "formul": 2, "framework": 1, "guarante": 1, "inform": 5, "investig": 1, "justifi": 1, "lattic": 2, "lead": 1, "mathemat": 1, "mechan": 4, "model": 2, "object": 1, "paper": 1, "permit": 1, "program": 2, "properti": 1, "requir": 2, "restrict": 1, "secur": 8, "semant": 1, "structur": 1, "suggest": 1, "suitabl": 1, "system": 3, "unifi": 1, "verifi": 1, "view": 1, "den": 1}}, "2871": {"id": "2871", "title": "Logical Analysis of Programs", "abstract": "Most present systems for verification of computer programs are incomplete in that intermediate  inductive assertions must be provided manually by the user, termination is not proven, and incorrect  programs are not treated.  As a unified solution to these problems, this paper suggests conducting a  logical analysis of programs by using invariants which express what is actually occurring in the program.   The first part of the paper is devoted to techniques for the automatic generation of invariants.  The  second part provides criteria for using the invariants to check simultaneously for correctness (including  termination) or incorrectness.  A third part examines the implications of the approach for the automatic  diagnosis and correction of logical errors.", "authors": "Katz, S. Manna, Z.", "words_pool": ["actual", "analysi", "approach", "assert", "automat", "check", "comput", "conduct", "correct", "correct", "criteria", "devot", "diagnosi", "error", "examin", "express", "gener", "implic", "includ", "incomplet", "incorrect", "incorrect", "induct", "intermedi", "invari", "logic", "manual", "occur", "paper", "part", "present", "problem", "program", "program", "proven", "provid", "simultan", "solut", "suggest", "system", "techniqu", "termin", "treat", "unifi", "user", "verif", "katz", "manna"], "word_count": {"actual": 1, "analysi": 1, "approach": 1, "assert": 1, "automat": 2, "check": 1, "comput": 1, "conduct": 1, "correct": 2, "criteria": 1, "devot": 1, "diagnosi": 1, "error": 1, "examin": 1, "express": 1, "gener": 1, "implic": 1, "includ": 1, "incomplet": 1, "incorrect": 2, "induct": 1, "intermedi": 1, "invari": 3, "logic": 2, "manual": 1, "occur": 1, "paper": 2, "part": 3, "present": 1, "problem": 1, "program": 4, "proven": 1, "provid": 1, "simultan": 1, "solut": 1, "suggest": 1, "system": 1, "techniqu": 1, "termin": 2, "treat": 1, "unifi": 1, "user": 1, "verif": 1, "katz": 1, "manna": 1}}, "2872": {"id": "2872", "title": "A Counterintuitive Example of Computer Paging (Corrigendum)", "authors": "Fagin, R.", "words_pool": ["comput", "corrigendum", "counterintuit", "page", "fagin"], "word_count": {"comput": 1, "corrigendum": 1, "counterintuit": 1, "page": 1, "fagin": 1}}, "2873": {"id": "2873", "title": "LG: A Language for Analytic Geometry", "abstract": "A conversational programming language for analytic geometry is described, together with some  aspects of its implementation.  The language allows the flexible definition of geometric objects and  elements, computes their parameters, and displays the results. It also provides the capability of specifying  a geometric figure via a collection of parameters and displaying various loci corresponding to these  parameters. A third characteristic consists of the possibility of using this language to design other  user oriented languages.  LG has been specifically designed for use by nonprogrammers; it is easy to  learn and very close to the natural language used in geometry.", "authors": "Raymond, J.", "words_pool": ["analyt", "aspect", "capabl", "characterist", "close", "collect", "comput", "consist", "convers", "definit", "design", "design", "display", "display", "easi", "element", "figur", "flexibl", "geometr", "geometri", "implement", "languag", "languag", "learn", "lg", "loci", "natur", "nonprogramm", "object", "orient", "paramet", "possibl", "program", "result", "specif", "user", "raymond"], "word_count": {"analyt": 1, "aspect": 1, "capabl": 1, "characterist": 1, "close": 1, "collect": 1, "comput": 1, "consist": 1, "convers": 1, "definit": 1, "design": 2, "display": 2, "easi": 1, "element": 1, "figur": 1, "flexibl": 1, "geometr": 2, "geometri": 2, "implement": 1, "languag": 5, "learn": 1, "lg": 1, "loci": 1, "natur": 1, "nonprogramm": 1, "object": 1, "orient": 1, "paramet": 3, "possibl": 1, "program": 1, "result": 1, "specif": 1, "user": 1, "raymond": 1}}, "2874": {"id": "2874", "title": "A Comparative Evaluation of Versions of BASIC", "abstract": "From its inception, The BASIC language has grown in terms of its usage, scope of usage, and  its features.  This article compares ten of the current versions of BASIC with each other, with two earlier  versions, and with the proposed standard for minimal BASIC. The comparison is arranged by the features  of the versions and by computational comparison of computation and times and processing costs.", "authors": "Lientz, B. P.", "words_pool": ["arrang", "articl", "basic", "compar", "compar", "comparison", "comput", "comput", "cost", "earlier", "evalu", "featur", "grown", "incept", "languag", "minim", "process", "propos", "scope", "standard", "ten", "term", "time", "usag", "version", "lientz"], "word_count": {"arrang": 1, "articl": 1, "basic": 3, "compar": 1, "comparison": 2, "comput": 2, "cost": 1, "earlier": 1, "evalu": 1, "featur": 2, "grown": 1, "incept": 1, "languag": 1, "minim": 1, "process": 1, "propos": 1, "scope": 1, "standard": 1, "ten": 1, "term": 1, "time": 1, "usag": 2, "version": 3, "lientz": 1}}, "2875": {"id": "2875", "title": "Development of an International System for Legal Protection of Computer Programs", "authors": "Smoot, O. R.", "words_pool": ["comput", "develop", "intern", "legal", "program", "protect", "system", "smoot"], "word_count": {"comput": 1, "develop": 1, "intern": 1, "legal": 1, "program": 1, "protect": 1, "system": 1, "smoot": 1}}, "2876": {"id": "2876", "title": "Intentional Resolution of Privacy Protection in Database Systems", "abstract": "Traditionally, privacy protection in database systems is understood to be the control over  what information a given user can get from a database.  This paper is concerned with another, independent,  dimension of privacy protection, the control over what a user is allowed to do with a piece of information  supplied to him by the database.  The ability to condition the supply of information on its intended  use is called here \"intentional resolution\" of privacy protection.  The practical importance of intentional  resolution is demonstrated by several examples, and its realization is discussed.  It is shown that intentional  resolution can be achieved, but that it involves a radical change from the traditional approach to the  process of user-database interaction.  In particular, it appears to be necessary for the database to  impose a certain amount of control over the internal behavior of users' programs which interact with  it.  A model for user-database interaction which admits such a control is developed.", "authors": "Minsky, N.", "words_pool": ["abil", "achiev", "admit", "allow", "amount", "appear", "approach", "behavior", "call", "chang", "concern", "condit", "control", "databas", "demonstr", "develop", "dimens", "discuss", "exampl", "import", "impos", "independ", "inform", "intend", "intent", "interact", "interact", "intern", "involv", "model", "paper", "piec", "practic", "privaci", "process", "program", "protect", "radic", "realiz", "resolut", "shown", "suppli", "suppli", "system", "tradit", "tradit", "understood", "user", "user", "minski"], "word_count": {"abil": 1, "achiev": 1, "admit": 1, "allow": 1, "amount": 1, "appear": 1, "approach": 1, "behavior": 1, "call": 1, "chang": 1, "concern": 1, "condit": 1, "control": 4, "databas": 6, "demonstr": 1, "develop": 1, "dimens": 1, "discuss": 1, "exampl": 1, "import": 1, "impos": 1, "independ": 1, "inform": 3, "intend": 1, "intent": 3, "interact": 3, "intern": 1, "involv": 1, "model": 1, "paper": 1, "piec": 1, "practic": 1, "privaci": 3, "process": 1, "program": 1, "protect": 3, "radic": 1, "realiz": 1, "resolut": 3, "shown": 1, "suppli": 2, "system": 1, "tradit": 2, "understood": 1, "user": 5, "minski": 1}}, "2877": {"id": "2877", "title": "A Program Data Flow Analysis Procedure", "abstract": "The global data relationships in a program can be exposed and codified by the static analysis  methods described in this paper.  A procedure is given which determines all the definitions which can possibly \"reach\" each node of the control flow graph of the program and all the definitions that are  \"live\" on each edge of the graph.  The procedure uses an \"interval\" ordered edge listing data structure  and handles reducible and irreducible graphs indistinguishably.", "authors": "Allen, J. E. Cocke, J.", "words_pool": ["analysi", "codifi", "control", "data", "definit", "determin", "edg", "expos", "flow", "global", "graph", "graph", "handl", "indistinguish", "interv", "irreduc", "list", "live", "method", "node", "order", "paper", "possibl", "procedur", "program", "reach", "reduc", "relationship", "static", "structur", "allen", "cock"], "word_count": {"analysi": 1, "codifi": 1, "control": 1, "data": 2, "definit": 2, "determin": 1, "edg": 2, "expos": 1, "flow": 1, "global": 1, "graph": 3, "handl": 1, "indistinguish": 1, "interv": 1, "irreduc": 1, "list": 1, "live": 1, "method": 1, "node": 1, "order": 1, "paper": 1, "possibl": 1, "procedur": 2, "program": 2, "reach": 1, "reduc": 1, "relationship": 1, "static": 1, "structur": 1, "allen": 1, "cock": 1}}, "2878": {"id": "2878", "title": "Joining Policies in a Multipriority Multiclass Batch Computer System", "abstract": "Consider a multipriority batch computer system which users from several different classes may  join, its toll, service, and waiting charges.  Such a system is formulated here as a semi-Markov decision  process, in which the aim of arriving users is to minimize their expected loss.  The optimal joining  policy is one of arriving users who may join the system at some of its queues is a control limit policy,  with a single control number for any possible queue and the user's class; a newly arriving user will  join a queue that is not filled up to the control number corresponding to this queue and the user's class.   In this paper control numbers, as well as lower and upper bounds for the control numbers and the capacities  of the system's queues, are derived.", "authors": "Babad, J. M. Modiano, M. M.", "words_pool": ["aim", "arriv", "batch", "bound", "capac", "charg", "class", "class", "comput", "consid", "control", "decis", "deriv", "expect", "fill", "formul", "join", "join", "limit", "loss", "lower", "markov", "minim", "multiclass", "multiprior", "newli", "number", "number", "optim", "paper", "polici", "polici", "process", "queue", "queue", "semi", "servic", "singl", "system", "toll", "upper", "user", "user", "wait", "babad", "modiano"], "word_count": {"aim": 1, "arriv": 3, "batch": 1, "bound": 1, "capac": 1, "charg": 1, "class": 3, "comput": 1, "consid": 1, "control": 5, "decis": 1, "deriv": 1, "expect": 1, "fill": 1, "formul": 1, "join": 4, "limit": 1, "loss": 1, "lower": 1, "markov": 1, "minim": 1, "multiclass": 1, "multiprior": 1, "newli": 1, "number": 4, "optim": 1, "paper": 1, "polici": 2, "process": 1, "queue": 5, "semi": 1, "servic": 1, "singl": 1, "system": 4, "toll": 1, "upper": 1, "user": 6, "wait": 1, "babad": 1, "modiano": 1}}, "2879": {"id": "2879", "title": "Computer Science as Empirical Inquiry: Symbols and Search", "authors": "Newell, A. Simon, H. A.", "words_pool": ["comput", "empir", "inquiri", "scienc", "search", "symbol", "newel", "simon"], "word_count": {"comput": 1, "empir": 1, "inquiri": 1, "scienc": 1, "search": 1, "symbol": 1, "newel": 1, "simon": 1}}, "2880": {"id": "2880", "title": "A Fast Division Technique for Constant Divisors", "abstract": "A fast algorithm for division by constant divisors is presented.  The method has proved very  useful implemented as microcode ona binary machine, and can be adapted directly into hardware.  The  mathematical foundations of the algorithm are presented as well as some performance measures.", "authors": "Artzy, E. Hinds, J. A. Saal, H. J.", "words_pool": ["adapt", "algorithm", "binari", "constant", "directli", "divis", "divisor", "fast", "foundat", "hardwar", "implement", "machin", "mathemat", "measur", "method", "microcod", "ona", "perform", "present", "prove", "techniqu", "artzi", "hind", "saal"], "word_count": {"adapt": 1, "algorithm": 2, "binari": 1, "constant": 1, "directli": 1, "divis": 1, "divisor": 1, "fast": 1, "foundat": 1, "hardwar": 1, "implement": 1, "machin": 1, "mathemat": 1, "measur": 1, "method": 1, "microcod": 1, "ona": 1, "perform": 1, "present": 2, "prove": 1, "techniqu": 1, "artzi": 1, "hind": 1, "saal": 1}}, "2881": {"id": "2881", "title": "A Counterintuitive Example of Computer Paging", "abstract": "A counterexample is exhibited to a natural conjecture concerning the optimal way to group records  into pages in the independent reference model of computer paging (an organization is said to be optimal  if the \"least recently used\" miss ratio is minimized).", "authors": "Fagin, R.", "words_pool": ["comput", "concern", "conjectur", "counterexampl", "counterintuit", "exhibit", "group", "independ", "minim", "miss", "model", "natur", "optim", "organ", "page", "page", "ratio", "recent", "record", "refer", "fagin"], "word_count": {"comput": 1, "concern": 1, "conjectur": 1, "counterexampl": 1, "counterintuit": 1, "exhibit": 1, "group": 1, "independ": 1, "minim": 1, "miss": 1, "model": 1, "natur": 1, "optim": 2, "organ": 1, "page": 2, "ratio": 1, "recent": 1, "record": 1, "refer": 1, "fagin": 1}}, "2882": {"id": "2882", "title": "A Stochastic Evaluation Model for Database Organization in Data Retrieval Systems", "abstract": "Experimental work in the valuation of large scale data retrieval systems has been scarce due  to its difficulty and prohibitive cost. This paper discusses a simulation model of a data retrieval  system which has the effect of significantly reducing the cost of experimentation and enabling research  never attempted before.  The model is designed to estimate the retrieval workload of alternative data  retrieval systems.  These data retrieval systems can be organized under several database organizations,  including inverted list, threaded list, and cellular list organizations and hybrid combinations of these  systems.  Effectiveness of the methodology is demonstrated by using the model to study the effect of  database organizations in data retrieval systems.  In particular, the impact of query complexity is analyzed.", "authors": "Siler, K. F.", "words_pool": ["altern", "analyz", "attempt", "cellular", "combin", "complex", "cost", "data", "databas", "demonstr", "design", "difficulti", "discuss", "due", "effect", "effect", "enabl", "estim", "evalu", "experiment", "experiment", "hybrid", "impact", "includ", "invert", "larg", "list", "methodolog", "model", "organ", "organ", "organ", "paper", "prohibit", "queri", "reduc", "research", "retriev", "scale", "scarc", "significantli", "simul", "stochast", "studi", "system", "system", "thread", "valuat", "work", "workload", "siler"], "word_count": {"altern": 1, "analyz": 1, "attempt": 1, "cellular": 1, "combin": 1, "complex": 1, "cost": 2, "data": 5, "databas": 2, "demonstr": 1, "design": 1, "difficulti": 1, "discuss": 1, "due": 1, "effect": 3, "enabl": 1, "estim": 1, "evalu": 1, "experiment": 2, "hybrid": 1, "impact": 1, "includ": 1, "invert": 1, "larg": 1, "list": 3, "methodolog": 1, "model": 3, "organ": 4, "paper": 1, "prohibit": 1, "queri": 1, "reduc": 1, "research": 1, "retriev": 6, "scale": 1, "scarc": 1, "significantli": 1, "simul": 1, "stochast": 1, "studi": 1, "system": 6, "thread": 1, "valuat": 1, "work": 1, "workload": 1, "siler": 1}}, "2883": {"id": "2883", "title": "An Application of Heuristic Search Methods to Edge and Contour Detection", "abstract": "This paper presents a method for detecting edges and contours in noisy pictures.  The properties  of an edge are embedded in a figure of merit and the edge detection problem becomes the problem of minimizing  the given figure of merit.  This problem can be represented as a shortest path problem on a graph and  can be solved using well-known graph search algorithms.  The relations between this representation of  the minimization problem and a dynamic programming approach are discussed, showing that the graph search  method can lead to substantial improvements in computing time.  Moreover, if heuristic search methods  are used, the computing time will depend on the amount of noise in the picture.  Some experimental results  are given; these show how various information about the shape of the contour of an object can be embedded in the figure of merit, thus allowing the extraction of contours from noisy picture and the separation  of touching objects.", "authors": "Martelli, A.", "words_pool": ["algorithm", "allow", "amount", "applic", "approach", "comput", "contour", "contour", "depend", "detect", "detect", "discuss", "dynam", "edg", "edg", "embed", "experiment", "extract", "figur", "graph", "heurist", "improv", "inform", "known", "lead", "merit", "method", "method", "minim", "minim", "nois", "noisi", "object", "object", "paper", "path", "pictur", "pictur", "present", "problem", "program", "properti", "relat", "represent", "repres", "result", "search", "separ", "shape", "shortest", "show", "show", "solv", "substanti", "time", "touch", "martelli"], "word_count": {"algorithm": 1, "allow": 1, "amount": 1, "applic": 1, "approach": 1, "comput": 2, "contour": 3, "depend": 1, "detect": 2, "discuss": 1, "dynam": 1, "edg": 3, "embed": 2, "experiment": 1, "extract": 1, "figur": 3, "graph": 3, "heurist": 1, "improv": 1, "inform": 1, "known": 1, "lead": 1, "merit": 3, "method": 3, "minim": 2, "nois": 1, "noisi": 2, "object": 2, "paper": 1, "path": 1, "pictur": 3, "present": 1, "problem": 5, "program": 1, "properti": 1, "relat": 1, "represent": 1, "repres": 1, "result": 1, "search": 3, "separ": 1, "shape": 1, "shortest": 1, "show": 2, "solv": 1, "substanti": 1, "time": 2, "touch": 1, "martelli": 1}}, "2884": {"id": "2884", "title": "Permutation Enumeration: Four New Permutation Algorithms", "abstract": "Classical permutation enumeration algorithms encounter special cases requiring additional computation  every nth permutation when generating the n! permutations on n marks.  Four new algorithms have the attribute  that special cases occur every n(n-1)permutations.  Two of the algorithms produce the next permutation  with a single exchange of two marks.  The other two algorithms infrequently exchange more than two marks,  but the rules for generating the next permutation are very simple.  Performance tests which have counted  execution of assignment statements, comparisons, arithmetic operations, and subscripted array references  have shown superiority of the new algorithms compared to Boothroyd's implementation of M. B. Well's algorithm  and Ehrlich's implementation of the Johnson-Trotter algorithm.", "authors": "Ives, F. M.", "words_pool": ["addit", "algorithm", "algorithm", "arithmet", "array", "assign", "attribut", "boothroyd", "case", "classic", "compar", "comparison", "comput", "count", "ehrlich", "encount", "enumer", "exchang", "execut", "gener", "implement", "infrequ", "johnson", "mark", "nth", "occur", "oper", "perform", "permut", "permut", "produc", "refer", "requir", "rule", "shown", "simpl", "singl", "special", "statement", "subscript", "superior", "test", "trotter", "ive"], "word_count": {"addit": 1, "algorithm": 7, "arithmet": 1, "array": 1, "assign": 1, "attribut": 1, "boothroyd": 1, "case": 2, "classic": 1, "compar": 1, "comparison": 1, "comput": 1, "count": 1, "ehrlich": 1, "encount": 1, "enumer": 1, "exchang": 2, "execut": 1, "gener": 2, "implement": 2, "infrequ": 1, "johnson": 1, "mark": 3, "nth": 1, "occur": 1, "oper": 1, "perform": 1, "permut": 6, "produc": 1, "refer": 1, "requir": 1, "rule": 1, "shown": 1, "simpl": 1, "singl": 1, "special": 2, "statement": 1, "subscript": 1, "superior": 1, "test": 1, "trotter": 1, "ive": 1}}, "2885": {"id": "2885", "title": "On Self-Organizing Sequential Search Heuristics", "abstract": "This paper examines a class of heuristics for maintaining a sequential list in approximately  optimal order with respect to the average time required to search for a specified element, assuming that  each element is searched for with a fixed probability independent of previous searches performed.  The  \"move to front\" and \"transposition\" heuristics are shown to be optimal to within a constant factor, and  the transposition rule is shown to be the more efficient of the two. Empirical evidence suggests that  transposition is in fact optimal for any distribution of search probabilities.", "authors": "Rivest, R.", "words_pool": ["approxim", "assum", "averag", "class", "constant", "distribut", "effici", "element", "empir", "evid", "examin", "fact", "factor", "fix", "front", "heurist", "independ", "list", "maintain", "move", "optim", "order", "organ", "paper", "perform", "previou", "probabl", "probabl", "requir", "respect", "rule", "search", "search", "search", "sequenti", "shown", "suggest", "time", "transposit", "rivest"], "word_count": {"approxim": 1, "assum": 1, "averag": 1, "class": 1, "constant": 1, "distribut": 1, "effici": 1, "element": 2, "empir": 1, "evid": 1, "examin": 1, "fact": 1, "factor": 1, "fix": 1, "front": 1, "heurist": 2, "independ": 1, "list": 1, "maintain": 1, "move": 1, "optim": 3, "order": 1, "organ": 1, "paper": 1, "perform": 1, "previou": 1, "probabl": 2, "requir": 1, "respect": 1, "rule": 1, "search": 4, "sequenti": 1, "shown": 2, "suggest": 1, "time": 1, "transposit": 3, "rivest": 1}}, "2886": {"id": "2886", "title": "Semantic Evaluation from Left to Right", "abstract": "This paper describes attribute grammars and their use for the definition of programming languages  and compilers; a formal definition of attribute grammars and a discussion of some of its important aspects  are included. The paper concentrates on the evaluation of semantic attributes in a few passes from left  to right over the derivation tree of a program.  A condition for an attribute grammar is given which  assures that the semantics of any program can be evaluated in a single pass over the derivation tree,  and an algorithm is discussed which decides how many passes from left to right are in general necessary,  given the attribute grammar. These notions are explained in terms of an example grammar which describes  the scope rules of Algol 60.  Practical questions, such as the relative efficiency of different evaluation  schemes, and the ease of adapting the attribute grammar of a given programming language to the left-to-right  evaluation scheme are discussed.", "authors": "Bochmann, G. V.", "words_pool": ["adapt", "algol", "algorithm", "aspect", "assur", "attribut", "attribut", "compil", "concentr", "condit", "decid", "definit", "deriv", "describ", "discuss", "discuss", "eas", "effici", "evalu", "evalu", "explain", "formal", "gener", "grammar", "grammar", "import", "includ", "languag", "languag", "left", "notion", "paper", "pass", "pass", "practic", "program", "program", "question", "rel", "rule", "scheme", "scheme", "scope", "semant", "semant", "singl", "term", "tree", "bochmann"], "word_count": {"adapt": 1, "algol": 1, "algorithm": 1, "aspect": 1, "assur": 1, "attribut": 6, "compil": 1, "concentr": 1, "condit": 1, "decid": 1, "definit": 2, "deriv": 2, "describ": 2, "discuss": 3, "eas": 1, "effici": 1, "evalu": 4, "explain": 1, "formal": 1, "gener": 1, "grammar": 6, "import": 1, "includ": 1, "languag": 2, "left": 3, "notion": 1, "paper": 2, "pass": 3, "practic": 1, "program": 4, "question": 1, "rel": 1, "rule": 1, "scheme": 2, "scope": 1, "semant": 2, "singl": 1, "term": 1, "tree": 2, "bochmann": 1}}, "2887": {"id": "2887", "title": "A Study of Errors, Error-Proneness, and Error Diagnosis in Cobol", "abstract": "This paper provides data on Cobol error frequency for correction of errors in student-oriented  compilers, improvement of teaching, and changes in programming language.  Cobol was studied because of  economic importance, widespread usage, possible error-including design, and lack of research.  The types  of errors were identified in a pilot study; then, using the 132 error types found, 1,777 errors were  classified in 1,4000 runs of 73 Cobol students.  Error density was high: 20 percent of the types contained  80 percent of the total frequency, which implies high potential effectiveness for software based correction  of Cobol.  Surprisingly, only four high-frequency errors were error-prone, which implies minimal error  inducing design. 80 percent of Cobol misspellings were classifiable in the four error categories of previous  researchers, which implies that Cobol misspellings are correctable by existent algorithms.  Reserved  word usage was not error-prone, which implies minimal interference with usage of reserved words.  Over  80 percent of error diagnosis was found to be inaccurate.  Such feedback is not optimal for users, particularly  for the learning user of Cobol.", "authors": "Litecky, C. R. Davis, G. B.", "words_pool": ["algorithm", "base", "categori", "classifi", "classifi", "cobol", "compil", "contain", "correct", "correct", "data", "densiti", "design", "diagnosi", "econom", "effect", "error", "error", "exist", "feedback", "found", "frequenc", "high", "identifi", "impli", "import", "improv", "inaccur", "includ", "induc", "interfer", "lack", "languag", "learn", "minim", "misspel", "optim", "orient", "paper", "percent", "pilot", "potenti", "previou", "program", "prone", "prone", "research", "research", "reserv", "run", "softwar", "student", "student", "studi", "studi", "surprisingli", "teach", "total", "type", "usag", "user", "user", "widespread", "word", "word", "litecki", "davi"], "word_count": {"algorithm": 1, "base": 1, "categori": 1, "classifi": 2, "cobol": 7, "compil": 1, "contain": 1, "correct": 3, "data": 1, "densiti": 1, "design": 2, "diagnosi": 1, "econom": 1, "effect": 1, "error": 13, "exist": 1, "feedback": 1, "found": 2, "frequenc": 3, "high": 3, "identifi": 1, "impli": 4, "import": 1, "improv": 1, "inaccur": 1, "includ": 1, "induc": 1, "interfer": 1, "lack": 1, "languag": 1, "learn": 1, "minim": 2, "misspel": 2, "optim": 1, "orient": 1, "paper": 1, "percent": 4, "pilot": 1, "potenti": 1, "previou": 1, "program": 1, "prone": 2, "research": 2, "reserv": 2, "run": 1, "softwar": 1, "student": 2, "studi": 2, "surprisingli": 1, "teach": 1, "total": 1, "type": 3, "usag": 3, "user": 2, "widespread": 1, "word": 2, "litecki": 1, "davi": 1}}, "2888": {"id": "2888", "title": "Information Reference Coding", "abstract": "Items in business systems have to be identified by reference codes, which can later be used  as data codes and file keys in an associated data processing system.  In business systems associated  with large collections of integrated files (database) it is vital to assign codes in a methodical way  so as to control future extension and changes while maintaining correct program action. The principles  of methodical coding are discussed, and the way in which logical connections between data items must  be reflected in the reference code framework is shown through a set-theoretic information model.", "authors": "Florentin, J. J.", "words_pool": ["action", "assign", "busi", "code", "code", "code", "collect", "connect", "control", "correct", "data", "databas", "discuss", "extens", "framework", "futur", "identifi", "inform", "integr", "item", "key", "larg", "later", "logic", "maintain", "method", "model", "principl", "process", "program", "refer", "reflect", "set", "shown", "system", "system", "theoret", "vital", "florentin"], "word_count": {"action": 1, "assign": 1, "busi": 2, "code": 5, "collect": 1, "connect": 1, "control": 1, "correct": 1, "data": 3, "databas": 1, "discuss": 1, "extens": 1, "framework": 1, "futur": 1, "identifi": 1, "inform": 1, "integr": 1, "item": 2, "key": 1, "larg": 1, "later": 1, "logic": 1, "maintain": 1, "method": 2, "model": 1, "principl": 1, "process": 1, "program": 1, "refer": 2, "reflect": 1, "set": 1, "shown": 1, "system": 3, "theoret": 1, "vital": 1, "florentin": 1}}, "2889": {"id": "2889", "title": "Performance of Height-Balanced Trees", "abstract": "This paper presents the results of simulations that investigate the performance of height-balanced  (HB[k]) trees.  It is shown that the only statistic of HB[1] trees (AVL trees) that is a function of  the size of the tree is the time to search for an item in the tree.  For sufficiently large trees, the  execution times of all procedures for maintaining HB[1] trees are independent of the size of the tree.   In particular, an average of .465 restructures are required per insertion, with an average of 2.78 nodes  revisited to restore the HB[1] property; an average of  .214 restructures are required per deletion, with  an average of 1.91 nodes revisited to restore the HB[1] property.  Moreover,the execution times of procedures  for maintaining HB[k] trees, for k>1, are also independent of the size of the tree except for the average  number of nodes revisited on a delete operation in order to restore the HB[k] property on trace back.   The cost of maintaining HB[k] trees drops sharply as the allowable imbalance (k) increases.  Both analytical  and experimental results that show the cost of maintaining HB[k] trees as a function of k are discussed.", "authors": "Karlton, P. L. Fuller, S. H. Scroggs, R. E. Kaehler, E. B.", "words_pool": ["allow", "analyt", "averag", "avl", "back", "balanc", "cost", "delet", "delet", "discuss", "drop", "execut", "experiment", "function", "hb", "height", "imbal", "increas", "independ", "insert", "investig", "item", "larg", "maintain", "node", "number", "oper", "order", "paper", "perform", "present", "procedur", "properti", "requir", "restor", "restructur", "result", "revisit", "search", "sharpli", "show", "shown", "simul", "size", "statist", "suffici", "time", "time", "trace", "tree", "tree", "karlton", "fuller", "scrogg", "kaehler"], "word_count": {"allow": 1, "analyt": 1, "averag": 5, "avl": 1, "back": 1, "balanc": 1, "cost": 2, "delet": 2, "discuss": 1, "drop": 1, "execut": 2, "experiment": 1, "function": 2, "hb": 9, "height": 1, "imbal": 1, "increas": 1, "independ": 2, "insert": 1, "investig": 1, "item": 1, "larg": 1, "maintain": 4, "node": 3, "number": 1, "oper": 1, "order": 1, "paper": 1, "perform": 1, "present": 1, "procedur": 2, "properti": 3, "requir": 2, "restor": 3, "restructur": 2, "result": 2, "revisit": 3, "search": 1, "sharpli": 1, "show": 1, "shown": 1, "simul": 1, "size": 3, "statist": 1, "suffici": 1, "time": 3, "trace": 1, "tree": 12, "karlton": 1, "fuller": 1, "scrogg": 1, "kaehler": 1}}, "2890": {"id": "2890", "title": "On Quadratic Adaptive Routing Algorithms", "abstract": "Two analytic models of a store-and-forward communications network are constructed, one to find  the optimal message routing and the other to illustrate the equilibrium (stationary state) maintained  by an adaptive routing algorithm.  These models show that adaptive routing does not satisfy the necessary  conditions for an optimal routing,  Adaptive routing tends to overuse the direct path and underuse alternate  routes because it does not consider the impact of its current routing decision on the future state of  the network.  The form of the optimality conditions suggests that a modification of the adaptive algorithm  will result in optimality.  The modification requires the substitution of a quadratic bias term instead  of a linear one in the routing table maintained at each network node.  Simulation results are presented  which confirm the theoretical analysis for a simple network.", "authors": "Agnew, C. E.", "words_pool": ["adapt", "algorithm", "algorithm", "altern", "analysi", "analyt", "bia", "commun", "condit", "confirm", "consid", "construct", "decis", "direct", "equilibrium", "find", "form", "forward", "futur", "illustr", "impact", "linear", "maintain", "messag", "model", "modif", "network", "node", "optim", "optim", "overus", "path", "present", "quadrat", "requir", "result", "result", "rout", "rout", "satisfi", "show", "simpl", "simul", "state", "stationari", "store", "substitut", "suggest", "tabl", "tend", "term", "theoret", "underus", "agnew"], "word_count": {"adapt": 4, "algorithm": 2, "altern": 1, "analysi": 1, "analyt": 1, "bia": 1, "commun": 1, "condit": 2, "confirm": 1, "consid": 1, "construct": 1, "decis": 1, "direct": 1, "equilibrium": 1, "find": 1, "form": 1, "forward": 1, "futur": 1, "illustr": 1, "impact": 1, "linear": 1, "maintain": 2, "messag": 1, "model": 2, "modif": 2, "network": 4, "node": 1, "optim": 4, "overus": 1, "path": 1, "present": 1, "quadrat": 1, "requir": 1, "result": 2, "rout": 8, "satisfi": 1, "show": 1, "simpl": 1, "simul": 1, "state": 2, "stationari": 1, "store": 1, "substitut": 1, "suggest": 1, "tabl": 1, "tend": 1, "term": 1, "theoret": 1, "underus": 1, "agnew": 1}}, "2891": {"id": "2891", "title": "An Anomaly in Disk Scheduling: A Comparison of FCFS and SSTF Seek Scheduling Using an Empirical  Model for Disk Accesses", "abstract": "A model for disk accesses based on published measurements is developed.  The model is used  to show that under highly probable conditions, FCFS seek scheduling is superior to SSTF scheduling in  the sense of having a lower mean queue length.  A simple example of an arrival sequence illustration  this anomaly is presented.", "authors": "Wilhelm, N. C.", "words_pool": ["access", "anomali", "arriv", "base", "comparison", "condit", "develop", "disk", "empir", "fcf", "highli", "illustr", "length", "lower", "mean", "measur", "model", "present", "probabl", "publish", "queue", "schedul", "seek", "sens", "sequenc", "show", "simpl", "sstf", "superior", "wilhelm"], "word_count": {"access": 1, "anomali": 1, "arriv": 1, "base": 1, "comparison": 1, "condit": 1, "develop": 1, "disk": 1, "empir": 1, "fcf": 1, "highli": 1, "illustr": 1, "length": 1, "lower": 1, "mean": 1, "measur": 1, "model": 2, "present": 1, "probabl": 1, "publish": 1, "queue": 1, "schedul": 2, "seek": 1, "sens": 1, "sequenc": 1, "show": 1, "simpl": 1, "sstf": 1, "superior": 1, "wilhelm": 1}}, "2892": {"id": "2892", "title": "A Study of Line Overhead in the Arpanet", "abstract": "The form, extent, and effect of the communication line overhead in the ARPANET are considered.   The source of this over head is separated into various levels of protocol hierarchy and the characteristics  of each level are summarized.  Then the line efficiency for various models of system use is studied.   Some measurements of line efficiency for the ARPANET are presented and by extrapolation these measurements  are used to anticipate overhead in a heavily loaded network. Similar results are derived for a recently  proposed network protocol and compared with those for the current system.", "authors": "Kleinrock, L. Naylor, W. E. Opderbeck, H.", "words_pool": ["anticip", "arpanet", "characterist", "commun", "compar", "consid", "deriv", "effect", "effici", "extent", "extrapol", "form", "head", "heavili", "hierarchi", "level", "level", "line", "load", "measur", "model", "network", "overhead", "present", "propos", "protocol", "recent", "result", "separ", "similar", "sourc", "studi", "studi", "summar", "system", "kleinrock", "naylor", "opderbeck"], "word_count": {"anticip": 1, "arpanet": 2, "characterist": 1, "commun": 1, "compar": 1, "consid": 1, "deriv": 1, "effect": 1, "effici": 2, "extent": 1, "extrapol": 1, "form": 1, "head": 1, "heavili": 1, "hierarchi": 1, "level": 2, "line": 3, "load": 1, "measur": 2, "model": 1, "network": 2, "overhead": 2, "present": 1, "propos": 1, "protocol": 2, "recent": 1, "result": 1, "separ": 1, "similar": 1, "sourc": 1, "studi": 1, "summar": 1, "system": 2, "kleinrock": 1, "naylor": 1, "opderbeck": 1}}, "2893": {"id": "2893", "title": "Computers as an Innovation in American Local Governments", "abstract": "Computers and electronic data processing are a major technological innovation in the operations  of American local government. This paper establishes that there is substantial variation among the larger  local governments in the rate at which they adopt computer technology, in the level of financial support  they provide for EDP, and in the extensiveness and sophistication of their automated applications.  The  central question addressed is: What might explain the differences between governments in the extent to  which they adopt and use computers?  Hypotheses are tested for several streams of explanatory factors,  using data from more than 500 city and county governments.  The findings identify certain local government  milieus which are particularly conducive to higher levels of computer innovation.  Somewhat unexpected  findings reveal the significant impact of the distribution of control over EDP decisions and the dominant  political values within the government. Other important factors include the measured need for computer  applications and the presence of external funding support for computing.  Finally, the paper suggests  a framework for identifying the key determinants of other technological innovations.", "authors": "Danziger, J. N. Dutton, W. H.", "words_pool": ["address", "adopt", "american", "applic", "autom", "central", "citi", "comput", "comput", "comput", "conduc", "control", "counti", "data", "decis", "determin", "differ", "distribut", "domin", "edp", "electron", "establish", "explain", "explanatori", "extens", "extent", "extern", "factor", "final", "financi", "find", "framework", "fund", "govern", "govern", "higher", "hypothes", "identifi", "identifi", "impact", "import", "includ", "innov", "innov", "key", "larger", "level", "level", "local", "major", "measur", "milieu", "need", "oper", "paper", "polit", "presenc", "process", "provid", "question", "rate", "reveal", "signific", "sophist", "stream", "substanti", "suggest", "support", "technolog", "technolog", "test", "unexpect", "valu", "variat", "danzig", "dutton"], "word_count": {"address": 1, "adopt": 2, "american": 1, "applic": 2, "autom": 1, "central": 1, "citi": 1, "comput": 6, "conduc": 1, "control": 1, "counti": 1, "data": 2, "decis": 1, "determin": 1, "differ": 1, "distribut": 1, "domin": 1, "edp": 2, "electron": 1, "establish": 1, "explain": 1, "explanatori": 1, "extens": 1, "extent": 1, "extern": 1, "factor": 2, "final": 1, "financi": 1, "find": 2, "framework": 1, "fund": 1, "govern": 6, "higher": 1, "hypothes": 1, "identifi": 2, "impact": 1, "import": 1, "includ": 1, "innov": 3, "key": 1, "larger": 1, "level": 2, "local": 3, "major": 1, "measur": 1, "milieu": 1, "need": 1, "oper": 1, "paper": 2, "polit": 1, "presenc": 1, "process": 1, "provid": 1, "question": 1, "rate": 1, "reveal": 1, "signific": 1, "sophist": 1, "stream": 1, "substanti": 1, "suggest": 1, "support": 2, "technolog": 3, "test": 1, "unexpect": 1, "valu": 1, "variat": 1, "danzig": 1, "dutton": 1}}, "2894": {"id": "2894", "title": "A Methodology for Interactive Computer Service Measurement", "abstract": "A measurement methodology applicable to in teractive computer service is described.  Its primary  purpose is to enable external, user-oriented assessment of computer performance, instead of the more  frequently used in ternal system measurement techniques.  The NBS Network Measurement System is employed  as the external measurement tool.  Example data have been collected and analyzed.  A demonstration of  the methodology, leading to a pragmatic figure-of-merit evaluation of results, is included.", "authors": "Adrams, M. D.", "words_pool": ["analyz", "applic", "assess", "collect", "comput", "data", "demonstr", "employ", "enabl", "evalu", "extern", "figur", "frequent", "includ", "interact", "lead", "measur", "merit", "methodolog", "nb", "network", "orient", "perform", "pragmat", "primari", "purpos", "result", "servic", "system", "techniqu", "teract", "ternal", "tool", "user", "adram"], "word_count": {"analyz": 1, "applic": 1, "assess": 1, "collect": 1, "comput": 2, "data": 1, "demonstr": 1, "employ": 1, "enabl": 1, "evalu": 1, "extern": 2, "figur": 1, "frequent": 1, "includ": 1, "interact": 1, "lead": 1, "measur": 4, "merit": 1, "methodolog": 2, "nb": 1, "network": 1, "orient": 1, "perform": 1, "pragmat": 1, "primari": 1, "purpos": 1, "result": 1, "servic": 1, "system": 2, "techniqu": 1, "teract": 1, "ternal": 1, "tool": 1, "user": 1, "adram": 1}}, "2895": {"id": "2895", "title": "A Language for Formal Problem Specification", "abstract": "A language for specifying the in tended behavior of communicating parallel processes is described.   The specifications are constrain ts on the order in which events of a computation can occur.  The language  is used to write specifications of the readers/writers problem and the writer priority of the second  readers/writers problem.", "authors": "Greif, I.", "words_pool": ["behavior", "commun", "comput", "constrain", "event", "formal", "languag", "occur", "order", "parallel", "prioriti", "problem", "process", "reader", "specif", "specif", "tend", "ts", "write", "writer", "writer", "greif"], "word_count": {"behavior": 1, "commun": 1, "comput": 1, "constrain": 1, "event": 1, "formal": 1, "languag": 2, "occur": 1, "order": 1, "parallel": 1, "prioriti": 1, "problem": 2, "process": 1, "reader": 2, "specif": 2, "tend": 1, "ts": 1, "write": 1, "writer": 3, "greif": 1}}, "2896": {"id": "2896", "title": "An Exercise in Proving Parallel Programs Correct", "abstract": "A parallel program, Dijkstra's on-the-fly garbage collector, is proved correct using a proof  method developed by Owicki.  The fine degree of in terleaving in this program makes it especially difficult  to understand, and complicates the proof greatly.  Difficulties with proving such parallel programs correct  are discussed.", "authors": "Gries, D.", "words_pool": ["collector", "complic", "correct", "degre", "develop", "difficult", "difficulti", "dijkstra", "discuss", "especi", "exercis", "fine", "fli", "garbag", "greatli", "make", "method", "owicki", "parallel", "program", "program", "proof", "prove", "prove", "terleav", "understand", "gri"], "word_count": {"collector": 1, "complic": 1, "correct": 2, "degre": 1, "develop": 1, "difficult": 1, "difficulti": 1, "dijkstra": 1, "discuss": 1, "especi": 1, "exercis": 1, "fine": 1, "fli": 1, "garbag": 1, "greatli": 1, "make": 1, "method": 1, "owicki": 1, "parallel": 2, "program": 3, "proof": 2, "prove": 2, "terleav": 1, "understand": 1, "gri": 1}}, "2897": {"id": "2897", "title": "A Case Study of a New Code Generation Technique for Compilers", "abstract": "Recent developments in optimizing techniques have allowed a new design for compilers to emerge.   Such a compiler translates the parsed source code into lower level code by a sequence of steps.  Each  step expands higher level statements into blocks of lower level code and then performs optimizations  on the result.  Each statement has only one possible expansion-the task of tailoring this code to take  advantage of any special cases is done by the optimizations.  This paper provides evidence that this  strategy can indeed result in good object code.  The traditionally difficult PL/I concatenate statement  was investigated as a detailed example.  A set of fairly simple optimizations was identified which allow  the compiler to produce good code. More elaborate optimizations can further improve the object code.   For most contexts of the concatenate statement, the code produced by a compiler using the expansion-optimization  strategy described above compares favorably with the code produced by a conventional PL/I optimizing  compiler.", "authors": "Carter, J. L.", "words_pool": ["advantag", "allow", "allow", "block", "case", "case", "code", "compar", "compil", "compil", "concaten", "context", "convent", "design", "detail", "develop", "difficult", "elabor", "emerg", "evid", "expand", "expans", "fairli", "favor", "gener", "good", "higher", "identifi", "improv", "investig", "level", "lower", "object", "optim", "optim", "optim", "paper", "pars", "perform", "pl", "produc", "produc", "recent", "result", "sequenc", "set", "simpl", "sourc", "special", "statement", "statement", "step", "step", "strategi", "studi", "tailor", "take", "task", "techniqu", "techniqu", "tradit", "translat", "carter"], "word_count": {"advantag": 1, "allow": 2, "block": 1, "case": 1, "code": 9, "compar": 1, "compil": 5, "concaten": 2, "context": 1, "convent": 1, "design": 1, "detail": 1, "develop": 1, "difficult": 1, "elabor": 1, "emerg": 1, "evid": 1, "expand": 1, "expans": 2, "fairli": 1, "favor": 1, "gener": 1, "good": 2, "higher": 1, "identifi": 1, "improv": 1, "investig": 1, "level": 3, "lower": 2, "object": 2, "optim": 7, "paper": 1, "pars": 1, "perform": 1, "pl": 2, "produc": 3, "recent": 1, "result": 2, "sequenc": 1, "set": 1, "simpl": 1, "sourc": 1, "special": 1, "statement": 4, "step": 2, "strategi": 2, "studi": 1, "tailor": 1, "take": 1, "task": 1, "techniqu": 1, "tradit": 1, "translat": 1, "carter": 1}}, "2898": {"id": "2898", "title": "A Conceptual Framework for a Nonprocedural Programming Language", "abstract": "A sequential programming language forces the programmer to prescribe explicitly the order in  which the operations in his program have to be executed, even if the order is not relevant to the solution  of his problem.  The requirement to indicate irrelevant sequencing can be removed if the language provides  facilities for specifying a task in a nonprocedural manner.  In general, a program specified in this  way will allow concurrent evaluation.  This paper describes a conceptual framework for a high level programming  language providing both nonprocedural and sequential facilities.  Within a program, nonprocedural and  sequential program modules may be nested freely.", "authors": "Kessels, J. L. W.", "words_pool": ["allow", "conceptu", "concurr", "describ", "evalu", "execut", "explicitli", "facil", "forc", "framework", "freeli", "gener", "high", "irrelev", "languag", "level", "manner", "modul", "nest", "nonprocedur", "oper", "order", "paper", "prescrib", "problem", "program", "programm", "program", "provid", "relev", "remov", "requir", "sequenc", "sequenti", "solut", "task", "kessel"], "word_count": {"allow": 1, "conceptu": 1, "concurr": 1, "describ": 1, "evalu": 1, "execut": 1, "explicitli": 1, "facil": 2, "forc": 1, "framework": 1, "freeli": 1, "gener": 1, "high": 1, "irrelev": 1, "languag": 3, "level": 1, "manner": 1, "modul": 1, "nest": 1, "nonprocedur": 3, "oper": 1, "order": 2, "paper": 1, "prescrib": 1, "problem": 1, "program": 6, "programm": 1, "provid": 1, "relev": 1, "remov": 1, "requir": 1, "sequenc": 1, "sequenti": 3, "solut": 1, "task": 1, "kessel": 1}}, "2899": {"id": "2899", "title": "A Survey of Computer Science Offerings In Small Liberal Arts Colleges.", "abstract": "Recent curricular development in computer science together with student in terest in pursuing  topics in computer science beyond the usual programming courses have encouraged small liberal arts colleges  to expand their offerings.  This paper summarizes the results of a survey taken to determine the type  of computer science programs being offered in these colleges.  The results indicate that over half of  these colleges either have no computer science program or offer only programming courses.", "authors": "Lopez, A. A. Raymond, R. Tardiff, R.", "words_pool": ["art", "colleg", "comput", "cours", "curricular", "determin", "develop", "encourag", "expand", "half", "liber", "offer", "offer", "offer", "paper", "program", "program", "program", "pursu", "recent", "result", "scienc", "small", "student", "summar", "survey", "terest", "topic", "type", "usual", "lopez", "raymond", "tardiff"], "word_count": {"art": 1, "colleg": 3, "comput": 4, "cours": 2, "curricular": 1, "determin": 1, "develop": 1, "encourag": 1, "expand": 1, "half": 1, "liber": 1, "offer": 3, "paper": 1, "program": 4, "pursu": 1, "recent": 1, "result": 2, "scienc": 4, "small": 1, "student": 1, "summar": 1, "survey": 1, "terest": 1, "topic": 1, "type": 1, "usual": 1, "lopez": 1, "raymond": 1, "tardiff": 1}}, "2900": {"id": "2900", "title": "Some Theorems to Aid in Solving the File Allocation Problem", "abstract": "The file allocation problem-i.e. the problem of finding the optimal set of network sites at  which to locate copies of a file-is known to be, in general, polynomial complete.  Heuristics and other  aids to finding optimal, or near-optimal, solutions are therefore much needed.  In this paper we present  three theorems which can be applied a priori to indicate that certain sites should (or should not) be  included in an optimal allocation.", "authors": "Grapa, E. Belford, G. G.", "words_pool": ["aid", "aid", "alloc", "appli", "complet", "copi", "find", "gener", "heurist", "includ", "known", "locat", "need", "network", "optim", "paper", "polynomi", "present", "priori", "problem", "set", "site", "solut", "solv", "theorem", "grapa", "belford"], "word_count": {"aid": 1, "alloc": 2, "appli": 1, "complet": 1, "copi": 1, "find": 2, "gener": 1, "heurist": 1, "includ": 1, "known": 1, "locat": 1, "need": 1, "network": 1, "optim": 4, "paper": 1, "polynomi": 1, "present": 1, "priori": 1, "problem": 2, "set": 1, "site": 2, "solut": 1, "solv": 1, "theorem": 1, "grapa": 1, "belford": 1}}, "2901": {"id": "2901", "title": "An Encoding Method for Multifield Sorting and Indexing", "abstract": "Sequences of character strings with an order relation imposed between sequences are considered.   An encoding scheme is described which produces a single, order-preserving string from a sequence of  strings.  The original sequence can be recovered from the encoded string, and one sequence of strings  precedes another if and only if the encoding of the first precedes the encoding of the second.  The strings  may be variable length, without a maximum length restriction, and no symbols need be reserved for control  purposes.  Hence any symbol may occur in any string.  The scheme is useful for multifield sorting, multifield  indexing, and other applications where ordering on more than one field is important.", "authors": "Blasgen, M. W. Casey, R. G. Eswaran, K. P.", "words_pool": ["applic", "charact", "consid", "control", "encod", "encod", "field", "import", "impos", "index", "length", "maximum", "method", "multifield", "need", "occur", "order", "order", "origin", "preced", "preserv", "produc", "purpos", "recov", "relat", "reserv", "restrict", "scheme", "sequenc", "sequenc", "singl", "sort", "string", "string", "symbol", "symbol", "variabl", "blasgen", "casey", "eswaran"], "word_count": {"applic": 1, "charact": 1, "consid": 1, "control": 1, "encod": 4, "field": 1, "import": 1, "impos": 1, "index": 1, "length": 2, "maximum": 1, "method": 1, "multifield": 2, "need": 1, "occur": 1, "order": 3, "origin": 1, "preced": 2, "preserv": 1, "produc": 1, "purpos": 1, "recov": 1, "relat": 1, "reserv": 1, "restrict": 1, "scheme": 2, "sequenc": 5, "singl": 1, "sort": 1, "string": 7, "symbol": 2, "variabl": 1, "blasgen": 1, "casey": 1, "eswaran": 1}}, "2902": {"id": "2902", "title": "Dynamic Memory Allocation in Computer Simulation", "abstract": "This paper investigates the performance of 35 dynamic memory allocation algorithms when used  to service simulation programs as represented by 18 test cases.  Algorithm performance was measured in terms of processing time, memory usage, and external memory fragmentation.  Algorithms main taining separate  free space lists for each size of memory block used tended to perform quite well compared with other  algorithms.  Simple algorithms operating on memory ordered lists (without any free list) performed surprisingly  well.  Algorithms employing power-of-two block sizes had favorable processing requirements but generally  unfavorable memory usage.  Algorithms employing LIFO, FIFO, or memory ordered free lists generally performed  poorly compared with others.", "authors": "Nielsen, N. R.", "words_pool": ["algorithm", "algorithm", "alloc", "block", "case", "compar", "comput", "dynam", "employ", "extern", "favor", "fifo", "fragment", "free", "gener", "investig", "lifo", "list", "list", "main", "measur", "memori", "oper", "order", "paper", "perform", "perform", "perform", "poorli", "power", "process", "program", "repres", "requir", "separ", "servic", "simpl", "simul", "size", "size", "space", "surprisingli", "tain", "tend", "term", "test", "time", "unfavor", "usag", "nielsen"], "word_count": {"algorithm": 7, "alloc": 1, "block": 2, "case": 1, "compar": 2, "comput": 1, "dynam": 1, "employ": 2, "extern": 1, "favor": 1, "fifo": 1, "fragment": 1, "free": 3, "gener": 2, "investig": 1, "lifo": 1, "list": 4, "main": 1, "measur": 1, "memori": 7, "oper": 1, "order": 2, "paper": 1, "perform": 5, "poorli": 1, "power": 1, "process": 2, "program": 1, "repres": 1, "requir": 1, "separ": 1, "servic": 1, "simpl": 1, "simul": 1, "size": 2, "space": 1, "surprisingli": 1, "tain": 1, "tend": 1, "term": 1, "test": 1, "time": 1, "unfavor": 1, "usag": 2, "nielsen": 1}}, "2903": {"id": "2903", "title": "Improving Programs by the Introduction of Recursion", "abstract": "A new technique of program transformation, called \"recursion in troduction,\" is described and  applied to two algorithms which solve pattern matching problems.  By using recursion in troduction, algorithms  which manipulate a stack are first translated into recursive algorithms in which no stack operations  occur.  These algorithms are then subjected to a second transformation, a method of recursion elimination  called \"tabulation,\" to produce programs with a very efficient running time.  In particular, it is shown  how the fast linear pattern matching algorithm of Knuth, Morris, and Pratt can be derived in a few steps  from a simple nonlinear stack algorithm.", "authors": "Bird, R. S.", "words_pool": ["algorithm", "algorithm", "appli", "call", "deriv", "effici", "elimin", "fast", "improv", "introduct", "knuth", "linear", "manipul", "match", "method", "morri", "nonlinear", "occur", "oper", "pattern", "pratt", "problem", "produc", "program", "program", "recurs", "recurs", "run", "shown", "simpl", "solv", "stack", "step", "subject", "tabul", "techniqu", "time", "transform", "translat", "troduct", "bird"], "word_count": {"algorithm": 6, "appli": 1, "call": 2, "deriv": 1, "effici": 1, "elimin": 1, "fast": 1, "improv": 1, "introduct": 1, "knuth": 1, "linear": 1, "manipul": 1, "match": 2, "method": 1, "morri": 1, "nonlinear": 1, "occur": 1, "oper": 1, "pattern": 2, "pratt": 1, "problem": 1, "produc": 1, "program": 2, "recurs": 4, "run": 1, "shown": 1, "simpl": 1, "solv": 1, "stack": 3, "step": 1, "subject": 1, "tabul": 1, "techniqu": 1, "time": 1, "transform": 2, "translat": 1, "troduct": 2, "bird": 1}}, "2904": {"id": "2904", "title": "An Algorithm for Reduction of Operator Strength", "abstract": "A simple algorithm which uses an indexed temporary table to perform reduction of operator strength  in strongly connected regions is presented.  Several extensions, including linear function test replacement,  are discussed.  These algorithms should fit well into an integrated package of local optimization algorithms.", "authors": "Cocke, J.", "words_pool": ["algorithm", "algorithm", "connect", "discuss", "extens", "fit", "function", "includ", "index", "integr", "linear", "local", "oper", "optim", "packag", "perform", "present", "reduct", "region", "replac", "simpl", "strength", "strongli", "tabl", "temporari", "test", "cock"], "word_count": {"algorithm": 3, "connect": 1, "discuss": 1, "extens": 1, "fit": 1, "function": 1, "includ": 1, "index": 1, "integr": 1, "linear": 1, "local": 1, "oper": 1, "optim": 1, "packag": 1, "perform": 1, "present": 1, "reduct": 1, "region": 1, "replac": 1, "simpl": 1, "strength": 1, "strongli": 1, "tabl": 1, "temporari": 1, "test": 1, "cock": 1}}, "2905": {"id": "2905", "title": "Perfect Hashing Functions: A Single Probe Retrieving Method for Static Sets", "abstract": "A refinement of hashing which allows retrieval of an item in a static table with a single probe  is considered.  Given a set I of identifiers, two methods are presented for building, in a mechanical  way, perfect hashing functions, i.e. functions transforming the elements of I into unique addresses.   The first method, the \"quotient reduction\" method, is shown to be complete in the sense that for every  set I the smallest table in which the elements of I can be stored and from which they can be retrieved  by using a perfect hashing function constructed by this method can be found.  However, for nonuniformly  distributed sets, this method can give rather sparse tables.  The second method, the \"remainder reduction\"  method, is not complete in the above sense, but it seems to give minimal (or almost minimal) tables for  every kind of set.  The two techniques are applicable directly to small sets.  Some methods to extend  these results to larger sets are also presented.  A rough comparison with ordinary hashing is given which  shows that this method can be used conveniently in several practical applications.", "authors": "Sprugnoli, R.", "words_pool": ["address", "applic", "applic", "build", "comparison", "complet", "consid", "construct", "conveni", "directli", "distribut", "element", "extend", "found", "function", "function", "give", "hash", "identifi", "item", "kind", "larger", "mechan", "method", "method", "minim", "nonuniformli", "ordinari", "perfect", "practic", "present", "probe", "quotient", "reduct", "refin", "remaind", "result", "retriev", "retriev", "retriev", "rough", "sens", "set", "set", "shown", "show", "singl", "small", "smallest", "spars", "static", "store", "tabl", "tabl", "techniqu", "transform", "uniqu", "sprugnoli"], "word_count": {"address": 1, "applic": 2, "build": 1, "comparison": 1, "complet": 2, "consid": 1, "construct": 1, "conveni": 1, "directli": 1, "distribut": 1, "element": 2, "extend": 1, "found": 1, "function": 3, "give": 2, "hash": 4, "identifi": 1, "item": 1, "kind": 1, "larger": 1, "mechan": 1, "method": 9, "minim": 2, "nonuniformli": 1, "ordinari": 1, "perfect": 2, "practic": 1, "present": 2, "probe": 1, "quotient": 1, "reduct": 2, "refin": 1, "remaind": 1, "result": 1, "retriev": 2, "rough": 1, "sens": 2, "set": 6, "shown": 1, "show": 1, "singl": 1, "small": 1, "smallest": 1, "spars": 1, "static": 1, "store": 1, "tabl": 4, "techniqu": 1, "transform": 1, "uniqu": 1, "sprugnoli": 1}}, "2906": {"id": "2906", "title": "A Very High Level Programming Language for Data Processing Applications", "abstract": "Application development today is too labor-in tensive.  In recent years, very high-level languages  have been increasingly explored as a solution to this problem.  The Business Definition Language (BDL)  is such a language, one aimed at business data processing problems.  The concepts in BDL mimic those  which have evolved through the years in businesses using manual methods.  This results in three different  sublanguages or components: one for defining the business forms, one for describing the business organization,  and one for writing calculations.", "authors": "Hammer, M. owe, W. G. Kruskal, V. J. Wladawsky, I.", "words_pool": ["aim", "applic", "applic", "bdl", "busi", "busi", "calcul", "compon", "concept", "data", "defin", "definit", "describ", "develop", "evolv", "explor", "form", "high", "increasingli", "labor", "languag", "languag", "level", "method", "mimic", "organ", "problem", "problem", "process", "program", "recent", "result", "solut", "sublanguag", "tensiv", "today", "write", "year", "hammer", "owe", "kruskal", "wladawski"], "word_count": {"aim": 1, "applic": 1, "bdl": 2, "busi": 5, "calcul": 1, "compon": 1, "concept": 1, "data": 1, "defin": 1, "definit": 1, "describ": 1, "develop": 1, "evolv": 1, "explor": 1, "form": 1, "high": 1, "increasingli": 1, "labor": 1, "languag": 3, "level": 1, "method": 1, "mimic": 1, "organ": 1, "problem": 2, "process": 1, "program": 1, "recent": 1, "result": 1, "solut": 1, "sublanguag": 1, "tensiv": 1, "today": 1, "write": 1, "year": 2, "hammer": 1, "owe": 1, "kruskal": 1, "wladawski": 1}}, "2907": {"id": "2907", "title": "The Optimal Approach to Recursive Programs", "abstract": "The classical fixed poin t approach toward recursive programs suggests choosing the \"least defined  fixed poin t\" as the most appropriate solution to a recursive program.  A new approach is described which  in troduction an \" optimal fixed point,\" which, in contrast to the least defined fixed poin t, embodies the  maximal amount of valuable information embedded in the program.  The practical implications of this approach  are discussed and techniques for proving properties of optimal fixed poin t are given.  The presentation  is informal, with emphasis on examples.", "authors": "Manna, Z. Shamir, A.", "words_pool": ["amount", "approach", "choos", "classic", "contrast", "defin", "discuss", "embed", "embodi", "emphasi", "exampl", "fix", "implic", "inform", "inform", "maxim", "optim", "poin", "point", "practic", "present", "program", "program", "properti", "prove", "recurs", "solut", "suggest", "techniqu", "troduct", "valuabl", "manna", "shamir"], "word_count": {"amount": 1, "approach": 3, "choos": 1, "classic": 1, "contrast": 1, "defin": 2, "discuss": 1, "embed": 1, "embodi": 1, "emphasi": 1, "exampl": 1, "fix": 5, "implic": 1, "inform": 2, "maxim": 1, "optim": 2, "poin": 4, "point": 1, "practic": 1, "present": 1, "program": 3, "properti": 1, "prove": 1, "recurs": 2, "solut": 1, "suggest": 1, "techniqu": 1, "troduct": 1, "valuabl": 1, "manna": 1, "shamir": 1}}, "2908": {"id": "2908", "title": "A Note On Reflection-Free Permutation Enumeration", "authors": "Roy, M. K.", "words_pool": ["enumer", "free", "note", "permut", "reflect", "roy"], "word_count": {"enumer": 1, "free": 1, "note": 1, "permut": 1, "reflect": 1, "roy": 1}}, "2909": {"id": "2909", "title": "What Can We Do about the Unnecessary Diversity of Notation for Syntactic Definitions?", "authors": "Wirth, N.", "words_pool": ["definit", "divers", "notat", "syntact", "unnecessari", "wirth"], "word_count": {"definit": 1, "divers": 1, "notat": 1, "syntact": 1, "unnecessari": 1, "wirth": 1}}, "2910": {"id": "2910", "title": "Equivalence of Hough Curve Detection to Template Matching", "authors": "Stockman, G. C.", "words_pool": ["curv", "detect", "equival", "hough", "match", "templat", "stockman"], "word_count": {"curv": 1, "detect": 1, "equival": 1, "hough": 1, "match": 1, "templat": 1, "stockman": 1}}, "2911": {"id": "2911", "title": "Anomalous Behavior of the Fifty-Percent Rule in Dynamic Memory Allocation", "abstract": "This paper reports simulation data showing that, in dynamic memory allocation, the average  free-to-allocated-block ratio can differ considerably and in both directions from the predictions of  the 50 percent rule.  A new derivation is given, and it is shown that previous derivations make an assumption  that may be violated frequently.  On the basis of the simulation data and the derivation, it is hypothesized  that the anomalous behavior results from the combined effects of systematic placement and the statistics  of the release process.  Additional simulations support this hypothesis.  Systematic placement, which  refers to the natural convention of always allocating storage requests against the same end of the free  block selected by the allocation strategy, tends to order blocks within contiguous groups according to  their allocation time.  The degree of anomalous behavior depends on the extent to which allocated blocks  are released in the order of their allocation.  For non-Markovian release processes, the extent of the  correlation between allocation order and release order varies approximately inversely with the coefficient  of variation of the memory residence time distribution.  The simulations show that allocation efficiency  depends strongly on the residence time distribution; efficiency decreases as the distribution's coefficient  of variation increases.  Some practical implications are briefly discussed.", "authors": "Shore, J. E.", "words_pool": ["accord", "addit", "alloc", "alloc", "alloc", "anomal", "approxim", "assumpt", "averag", "basi", "behavior", "block", "block", "briefli", "coeffici", "combin", "consider", "contigu", "convent", "correl", "data", "decreas", "degre", "depend", "deriv", "deriv", "differ", "direct", "discuss", "distribut", "dynam", "effect", "effici", "end", "extent", "fifti", "free", "frequent", "group", "hypothesi", "hypothes", "implic", "increas", "invers", "make", "markovian", "memori", "natur", "non", "order", "paper", "percent", "placement", "practic", "predict", "previou", "process", "process", "ratio", "refer", "releas", "releas", "report", "request", "resid", "result", "rule", "select", "show", "show", "shown", "simul", "simul", "statist", "storag", "strategi", "strongli", "support", "systemat", "tend", "time", "variat", "vari", "violat", "shore"], "word_count": {"accord": 1, "addit": 1, "alloc": 9, "anomal": 2, "approxim": 1, "assumpt": 1, "averag": 1, "basi": 1, "behavior": 2, "block": 4, "briefli": 1, "coeffici": 2, "combin": 1, "consider": 1, "contigu": 1, "convent": 1, "correl": 1, "data": 2, "decreas": 1, "degre": 1, "depend": 2, "deriv": 3, "differ": 1, "direct": 1, "discuss": 1, "distribut": 3, "dynam": 1, "effect": 1, "effici": 2, "end": 1, "extent": 2, "fifti": 1, "free": 2, "frequent": 1, "group": 1, "hypothesi": 1, "hypothes": 1, "implic": 1, "increas": 1, "invers": 1, "make": 1, "markovian": 1, "memori": 2, "natur": 1, "non": 1, "order": 4, "paper": 1, "percent": 1, "placement": 2, "practic": 1, "predict": 1, "previou": 1, "process": 2, "ratio": 1, "refer": 1, "releas": 4, "report": 1, "request": 1, "resid": 2, "result": 1, "rule": 1, "select": 1, "show": 2, "shown": 1, "simul": 4, "statist": 1, "storag": 1, "strategi": 1, "strongli": 1, "support": 1, "systemat": 2, "tend": 1, "time": 3, "variat": 2, "vari": 1, "violat": 1, "shore": 1}}, "2912": {"id": "2912", "title": "Concurrent Reading and Writing", "abstract": "The problem of sharing data among asynchronous process is considered.  It is assumed that only  one process at a time can modify the data, but concurrent reading and writing is permitted.  Two general  theorems are proved, and some algorithms are presented to illustrate their use.  These include a solution  to the general problem in which a read is repeated if it might have obtained an incorrect result, and  two techniques for transmitting messages between processes.  These solutions do not assume any synchronizing  mechanism other than data which can be written by one process and read by other processes.", "authors": "Lamport, L.", "words_pool": ["algorithm", "assum", "assum", "asynchron", "concurr", "consid", "data", "gener", "illustr", "includ", "incorrect", "mechan", "messag", "modifi", "obtain", "permit", "present", "problem", "process", "process", "prove", "read", "read", "repeat", "result", "share", "solut", "solut", "synchron", "techniqu", "theorem", "time", "transmit", "write", "written", "lamport"], "word_count": {"algorithm": 1, "assum": 2, "asynchron": 1, "concurr": 1, "consid": 1, "data": 3, "gener": 2, "illustr": 1, "includ": 1, "incorrect": 1, "mechan": 1, "messag": 1, "modifi": 1, "obtain": 1, "permit": 1, "present": 1, "problem": 2, "process": 5, "prove": 1, "read": 3, "repeat": 1, "result": 1, "share": 1, "solut": 2, "synchron": 1, "techniqu": 1, "theorem": 1, "time": 1, "transmit": 1, "write": 1, "written": 1, "lamport": 1}}, "2913": {"id": "2913", "title": "The Aliasing Problem in Computer-Generated Shaded Images", "abstract": "Certain defects, such as jagged edges and disappearing detail, have long been an annoyance  in digitally generated shaded images.  Although increasing the resolution or defocusing the display can  attenuate them, an understanding of these defects leads to more effective methods.  This paper explains  the observed defects in terms of the aliasing phenomenon inherent in sampled signals and discusses prefiltering  as a recognized cure.  A method for evaluating filters is presented, the application of prefiltering  to hidden-surface algorithms is discussed, and an implementation of a filtering tiler is shown accompanied  by examples of its effectiveness.", "authors": "Crow, F. C.", "words_pool": ["accompani", "algorithm", "alias", "annoy", "applic", "attenu", "comput", "cure", "defect", "defocus", "detail", "digit", "disappear", "discuss", "discuss", "display", "edg", "effect", "effect", "evalu", "exampl", "explain", "filter", "filter", "gener", "hidden", "imag", "implement", "increas", "inher", "jag", "lead", "long", "method", "method", "observ", "paper", "phenomenon", "prefilt", "present", "problem", "recogn", "resolut", "sampl", "shade", "shown", "signal", "surfac", "term", "tiler", "understand", "crow"], "word_count": {"accompani": 1, "algorithm": 1, "alias": 1, "annoy": 1, "applic": 1, "attenu": 1, "comput": 1, "cure": 1, "defect": 3, "defocus": 1, "detail": 1, "digit": 1, "disappear": 1, "discuss": 2, "display": 1, "edg": 1, "effect": 2, "evalu": 1, "exampl": 1, "explain": 1, "filter": 2, "gener": 1, "hidden": 1, "imag": 1, "implement": 1, "increas": 1, "inher": 1, "jag": 1, "lead": 1, "long": 1, "method": 2, "observ": 1, "paper": 1, "phenomenon": 1, "prefilt": 2, "present": 1, "problem": 1, "recogn": 1, "resolut": 1, "sampl": 1, "shade": 1, "shown": 1, "signal": 1, "surfac": 1, "term": 1, "tiler": 1, "understand": 1, "crow": 1}}, "2914": {"id": "2914", "title": "Use of the LRU Stack Depth Distribution for Simulation of Paging Behavior", "abstract": "Two families of probability distributions were needed for use by a virtual memory simulation  model: headway between page fault distributions, and working set size distributions.  All members of  both families can be derived from the LRU stack depth distribution.  Simple expressions for the computation  of both kinds of distributions are given.  Finally, examples are given of both families of distributions  as computed from a published stack depth distribution.", "authors": "Turner, R. Strecker, B.", "words_pool": ["behavior", "comput", "comput", "depth", "deriv", "distribut", "distribut", "exampl", "express", "famili", "fault", "final", "headway", "kind", "lru", "member", "memori", "model", "need", "page", "page", "probabl", "publish", "set", "simpl", "simul", "size", "stack", "virtual", "work", "turner", "strecker"], "word_count": {"behavior": 1, "comput": 2, "depth": 2, "deriv": 1, "distribut": 7, "exampl": 1, "express": 1, "famili": 3, "fault": 1, "final": 1, "headway": 1, "kind": 1, "lru": 1, "member": 1, "memori": 1, "model": 1, "need": 1, "page": 1, "probabl": 1, "publish": 1, "set": 1, "simpl": 1, "simul": 1, "size": 1, "stack": 2, "virtual": 1, "work": 1, "turner": 1, "strecker": 1}}, "2915": {"id": "2915", "title": "Considerations for Future Programming Language Standards Activities", "abstract": "This paper reviews the current state of programming language standards activities with respect  to the anomalies which exist between the various published and proposed standards for Fortran, Cobol,  PL/I, and Basic.  Proposals are made for the inclusion of formalisms within future standards and the  extension of the standards to include additional items such as error conditions and documentation.", "authors": "Lee, J. A. N.", "words_pool": ["activ", "addit", "anomali", "basic", "cobol", "condit", "consider", "document", "error", "exist", "extens", "formal", "fortran", "futur", "includ", "inclus", "item", "languag", "made", "paper", "pl", "program", "propos", "propos", "publish", "respect", "review", "standard", "state", "lee"], "word_count": {"activ": 1, "addit": 1, "anomali": 1, "basic": 1, "cobol": 1, "condit": 1, "consider": 1, "document": 1, "error": 1, "exist": 1, "extens": 1, "formal": 1, "fortran": 1, "futur": 1, "includ": 1, "inclus": 1, "item": 1, "languag": 1, "made": 1, "paper": 1, "pl": 1, "program": 1, "propos": 2, "publish": 1, "respect": 1, "review": 1, "standard": 4, "state": 1, "lee": 1}}, "2916": {"id": "2916", "title": "A Fast String Searching Algorithm", "abstract": "An algorithm is presented that searches for the location, \"i,\" of the first occurrence of a  character string, \"pat,\" in another string, \"string.\"  During the search operation, the characters of  pat are matched starting with the last character of pat.  The information gained by starting the match  at the end of the pattern often allows the algorithm to proceed in large jumps through the text being  searched.  Thus the algorithm has the unusual property that, in most cases, not all of the first i characters  of string are inspected.  The number of characters actually inspected (on the average) decreases as a  function of the length of pat.  For a random English pattern of length 5, the algorithm will typically  inspect i/4 characters of string before finding a match at i.  Furthermore, the algorithm has been implemented  so that (on the average) fewer than i+patlen machine instructions are executed.  These conclusions are  supported with empirical evidence and a theoretical analysis of the average behavior of the algorithm.   The worst case behavior of the algorithm is linear in i+patlen, assuming the availability of array space  for tables linear in patlen plus the size of the alphabet.", "authors": "Boyer, R. S.", "words_pool": ["actual", "algorithm", "alphabet", "analysi", "array", "assum", "avail", "averag", "behavior", "case", "case", "charact", "charact", "conclus", "decreas", "empir", "end", "english", "evid", "execut", "fast", "fewer", "find", "function", "gain", "implement", "inform", "inspect", "inspect", "instruct", "jump", "larg", "length", "linear", "locat", "machin", "match", "match", "number", "occurr", "oper", "pat", "patlen", "pattern", "present", "proceed", "properti", "random", "search", "search", "search", "search", "size", "space", "start", "string", "support", "tabl", "text", "theoret", "typic", "unusu", "worst", "boyer"], "word_count": {"actual": 1, "algorithm": 7, "alphabet": 1, "analysi": 1, "array": 1, "assum": 1, "avail": 1, "averag": 3, "behavior": 2, "case": 2, "charact": 6, "conclus": 1, "decreas": 1, "empir": 1, "end": 1, "english": 1, "evid": 1, "execut": 1, "fast": 1, "fewer": 1, "find": 1, "function": 1, "gain": 1, "implement": 1, "inform": 1, "inspect": 3, "instruct": 1, "jump": 1, "larg": 1, "length": 2, "linear": 2, "locat": 1, "machin": 1, "match": 3, "number": 1, "occurr": 1, "oper": 1, "pat": 4, "patlen": 3, "pattern": 2, "present": 1, "proceed": 1, "properti": 1, "random": 1, "search": 3, "size": 1, "space": 1, "start": 2, "string": 5, "support": 1, "tabl": 1, "text": 1, "theoret": 1, "typic": 1, "unusu": 1, "worst": 1, "boyer": 1}}, "2917": {"id": "2917", "title": "SITAR: An Interactive Text Processing System for Small Computers (Corrigendum)", "authors": "Schneider, B. R. Jr. Watts, R. M.", "words_pool": ["comput", "corrigendum", "interact", "process", "sitar", "small", "system", "text", "schneider", "jr", "watt"], "word_count": {"comput": 1, "corrigendum": 1, "interact": 1, "process": 1, "sitar": 1, "small": 1, "system": 1, "text": 1, "schneider": 1, "jr": 1, "watt": 1}}, "2918": {"id": "2918", "title": "Multiprocessor Memory Organization and Memory Interference", "abstract": "The structure of shared memory in a multiprocessor computer system is examined with particular  attention to nonin terleaved memory.  Alternative memory organizations are compared and it is shown that  a home memory organization, in which each processor is associated with one or more memories in which  its address space is concentrated, is quite effective in reducing memory in terference.  Home memory organization  is shown to be particularly suited to certain specialized computation problems as well as to possess  advantages in terms of in terference and reliability for general purpose computation.  Results for in terleaved  memory are drawn from previous work and are used for comparison.  Trace-driven simulations are used to  verify the conclusions of the analysis.", "authors": "Smith, A. J.", "words_pool": ["address", "advantag", "altern", "analysi", "attent", "compar", "comparison", "comput", "comput", "concentr", "conclus", "drawn", "driven", "effect", "examin", "gener", "home", "interfer", "memori", "memori", "multiprocessor", "nonin", "organ", "organ", "possess", "previou", "problem", "processor", "purpos", "reduc", "reliabl", "result", "share", "shown", "simul", "space", "special", "structur", "suit", "system", "terfer", "terleav", "term", "trace", "verifi", "work", "smith"], "word_count": {"address": 1, "advantag": 1, "altern": 1, "analysi": 1, "attent": 1, "compar": 1, "comparison": 1, "comput": 3, "concentr": 1, "conclus": 1, "drawn": 1, "driven": 1, "effect": 1, "examin": 1, "gener": 1, "home": 2, "interfer": 1, "memori": 8, "multiprocessor": 1, "nonin": 1, "organ": 3, "possess": 1, "previou": 1, "problem": 1, "processor": 1, "purpos": 1, "reduc": 1, "reliabl": 1, "result": 1, "share": 1, "shown": 2, "simul": 1, "space": 1, "special": 1, "structur": 1, "suit": 1, "system": 1, "terfer": 2, "terleav": 2, "term": 1, "trace": 1, "verifi": 1, "work": 1, "smith": 1}}, "2919": {"id": "2919", "title": "The Programmer's Workbench-A Machine for Software Development", "abstract": "On almost all software development projects the assumption is made that the program development  function will be done on the same machine on which the eventual system will run.  It is only when this  production machine is unavailable or when its programming environment is totally inadequate that alternatives  are considered.  In this paper it is suggested that there are many other situations where it would be  advantageous to separate the program development and main tenance function onto a specialized computer  which is dedicated to that purpose.  Such a computer is here called a Programmer's Workbench.  The four  basic sections of the paper in troduce the subject,outline the general concept, discuss areas where such  an approach may prove beneficial, and describe an operational system utilizing this concept.", "authors": "Ivie, E. L.", "words_pool": ["advantag", "altern", "approach", "area", "assumpt", "basic", "benefici", "call", "comput", "concept", "consid", "dedic", "describ", "develop", "discuss", "environ", "eventu", "function", "gener", "inadequ", "machin", "made", "main", "oper", "outlin", "paper", "product", "program", "programm", "program", "project", "prove", "purpos", "run", "section", "separ", "situat", "softwar", "special", "subject", "suggest", "system", "tenanc", "total", "troduc", "unavail", "util", "workbench", "ivi"], "word_count": {"advantag": 1, "altern": 1, "approach": 1, "area": 1, "assumpt": 1, "basic": 1, "benefici": 1, "call": 1, "comput": 2, "concept": 2, "consid": 1, "dedic": 1, "describ": 1, "develop": 3, "discuss": 1, "environ": 1, "eventu": 1, "function": 2, "gener": 1, "inadequ": 1, "machin": 2, "made": 1, "main": 1, "oper": 1, "outlin": 1, "paper": 2, "product": 1, "program": 3, "programm": 1, "project": 1, "prove": 1, "purpos": 1, "run": 1, "section": 1, "separ": 1, "situat": 1, "softwar": 1, "special": 1, "subject": 1, "suggest": 1, "system": 2, "tenanc": 1, "total": 1, "troduc": 1, "unavail": 1, "util": 1, "workbench": 1, "ivi": 1}}, "2920": {"id": "2920", "title": "Game Interpretation of the Deadlock Avoidance Problem", "abstract": "The deadlock avoidance problem may be defined informally as the determination, from some a  priori information about the processes, resources, operating system, etc., of the \"safe situations\" which  may be realized without endangering the smooth running of the system.  When each process specifies its  future needs by a flowchart of need-defined steps, a global approach to the phenomenon and its in terpretation  as a game between the operating system and the processes allows formalization of risk and safety concepts.   The bipartite graph representation of this game may then be used to construct explicitly the set of safe  states and to study their properties.", "authors": "Devillers, R.", "words_pool": ["approach", "avoid", "bipartit", "concept", "construct", "deadlock", "defin", "determin", "endang", "explicitli", "flowchart", "formal", "futur", "game", "global", "graph", "inform", "inform", "interpret", "need", "need", "oper", "phenomenon", "priori", "problem", "process", "process", "properti", "realiz", "represent", "resourc", "risk", "run", "safe", "safeti", "set", "situat", "smooth", "specifi", "state", "step", "studi", "system", "terpret", "devil"], "word_count": {"approach": 1, "avoid": 1, "bipartit": 1, "concept": 1, "construct": 1, "deadlock": 1, "defin": 2, "determin": 1, "endang": 1, "explicitli": 1, "flowchart": 1, "formal": 1, "futur": 1, "game": 2, "global": 1, "graph": 1, "inform": 2, "interpret": 1, "need": 2, "oper": 2, "phenomenon": 1, "priori": 1, "problem": 1, "process": 3, "properti": 1, "realiz": 1, "represent": 1, "resourc": 1, "risk": 1, "run": 1, "safe": 2, "safeti": 1, "set": 1, "situat": 1, "smooth": 1, "specifi": 1, "state": 1, "step": 1, "studi": 1, "system": 3, "terpret": 1, "devil": 1}}, "2921": {"id": "2921", "title": "Regular Right Part Grammars and Their Parsers", "abstract": "This paper in troduces an alternative to context-free grammars called regular right part (RRP)  grammars, which resemble PASCAL syntax diagrams.  Formally, RRP grammars have production right parts,  which are nondeterministic finite state machines (FSMs), and, as a special case, regular expressions,  since these can be converted to FSMs.  RRP grammars describe the syntax of programming languages more  concisely and more understandably than is possible with CF grammars.  Also in troduced is a class of parsers,  RRP LR(m, k) parsers, which includes the CF LR(k) parsers and provides the same advantages.  Informally,  an RRP LR(m, k) parser can determine the right end of each handle by considering at most k symbols to  the right of the handle and the left end, after the right end has been found, by considering at most  m symbols to the left of the handle.  A mechanism for determining the left end is required because there  is no bound on the length of the handle.", "authors": "LaLonde, W. R.", "words_pool": ["advantag", "altern", "bound", "call", "case", "cf", "class", "concis", "consid", "context", "convert", "describ", "determin", "determin", "diagram", "end", "express", "finit", "formal", "found", "free", "fsm", "grammar", "handl", "includ", "inform", "languag", "left", "length", "lr", "machin", "mechan", "nondeterminist", "paper", "parser", "parser", "part", "part", "pascal", "product", "program", "regular", "requir", "resembl", "rrp", "special", "state", "symbol", "syntax", "troduc", "troduc", "understand", "lalond"], "word_count": {"advantag": 1, "altern": 1, "bound": 1, "call": 1, "case": 1, "cf": 2, "class": 1, "concis": 1, "consid": 2, "context": 1, "convert": 1, "describ": 1, "determin": 2, "diagram": 1, "end": 4, "express": 1, "finit": 1, "formal": 1, "found": 1, "free": 1, "fsm": 2, "grammar": 5, "handl": 4, "includ": 1, "inform": 1, "languag": 1, "left": 3, "length": 1, "lr": 3, "machin": 1, "mechan": 1, "nondeterminist": 1, "paper": 1, "parser": 4, "part": 2, "pascal": 1, "product": 1, "program": 1, "regular": 2, "requir": 1, "resembl": 1, "rrp": 5, "special": 1, "state": 1, "symbol": 2, "syntax": 2, "troduc": 2, "understand": 1, "lalond": 1}}, "2922": {"id": "2922", "title": "Two-Level Control Structure for Nondeterministic Programming", "abstract": "The basic ideas of nondeterministic programming are critically reconsidered to single out a  proper attitude and programming style for language allowing direct control of nondeterministic features.   The proposed attitude aims at retaining the purity of the nondeterministic formulation of search processes  on one level (the attempt level), deferring the coordination of problem solving efforts to another (the  choice level).  The feasibility of recognizing these two levels is discussed, stressing that the structure  to be managed at the choice level is a free of contexts.  The leaves are computational environments,  each holding an alternative under inspection, while the other nodes are associated with choice poin ts.   According to the proposed programming style, a generative function is associated with each choice poin t,  which expresses the desired choice strategy. The main advantage on this approach is the localization  of the search strategies: Each nonterminal node of the tree keeps track of the state of the computation  as it was when the choice poin t was last interrogated, holding at the same time the strategy to coordinate  the available alternatives.  Examples are given in term of ND-Lisp, an extension of Lisp designed and  implemented according to these guidelines.", "authors": "Montangero, C. Pacini, G. Turini, F.", "words_pool": ["accord", "advantag", "aim", "allow", "altern", "altern", "approach", "attempt", "attitud", "basic", "choic", "comput", "comput", "context", "control", "coordin", "coordin", "critic", "defer", "design", "desir", "direct", "discuss", "effort", "environ", "exampl", "express", "extens", "feasibl", "featur", "formul", "free", "function", "gener", "guidelin", "hold", "idea", "implement", "inspect", "interrog", "keep", "languag", "leav", "level", "level", "lisp", "local", "main", "manag", "nd", "node", "node", "nondeterminist", "nontermin", "poin", "problem", "process", "program", "proper", "propos", "puriti", "recogn", "reconsid", "retain", "search", "singl", "solv", "state", "strategi", "strategi", "stress", "structur", "style", "term", "time", "track", "tree", "ts", "montangero", "pacini", "turini"], "word_count": {"accord": 2, "advantag": 1, "aim": 1, "allow": 1, "altern": 2, "approach": 1, "attempt": 1, "attitud": 2, "basic": 1, "choic": 6, "comput": 2, "context": 1, "control": 1, "coordin": 2, "critic": 1, "defer": 1, "design": 1, "desir": 1, "direct": 1, "discuss": 1, "effort": 1, "environ": 1, "exampl": 1, "express": 1, "extens": 1, "feasibl": 1, "featur": 1, "formul": 1, "free": 1, "function": 1, "gener": 1, "guidelin": 1, "hold": 2, "idea": 1, "implement": 1, "inspect": 1, "interrog": 1, "keep": 1, "languag": 1, "leav": 1, "level": 5, "lisp": 2, "local": 1, "main": 1, "manag": 1, "nd": 1, "node": 2, "nondeterminist": 3, "nontermin": 1, "poin": 3, "problem": 1, "process": 1, "program": 3, "proper": 1, "propos": 2, "puriti": 1, "recogn": 1, "reconsid": 1, "retain": 1, "search": 2, "singl": 1, "solv": 1, "state": 1, "strategi": 3, "stress": 1, "structur": 1, "style": 2, "term": 1, "time": 1, "track": 1, "tree": 1, "ts": 1, "montangero": 1, "pacini": 1, "turini": 1}}, "2923": {"id": "2923", "title": "High-Level Data Flow Analysis", "abstract": "In contrast to the predominant use of low-level in termediate text, high-level data flow analysis  deals with programs essentially at source level and exploits the control flow information implicit in  the parse tree.  The need for high-level flow analysis arises from several aspects of recent work on  advanced methods of program certification and optimization.  This paper proposes a simple general method  of high-level data flow analysis that allows free use of escape and jump statements, avoids large graphs  when compiling large programs, facilitates updating of data flow information to reflect program changes,  and derives new global information helpful in solving many familiar global flow analysis problems.  An  illustrative application to live variable analysis is presented.  Many of the graphs involved are constructed  and analyzed before any programs are compiled, thus avoiding certain costs that low-level methods incur  repeatedly at compile time.", "authors": "Rosen, B. K.", "words_pool": ["advanc", "analysi", "analyz", "applic", "aris", "aspect", "avoid", "avoid", "certif", "compil", "compil", "compil", "construct", "contrast", "control", "cost", "data", "deal", "deriv", "escap", "essenti", "exploit", "facilit", "familiar", "flow", "free", "gener", "global", "graph", "help", "high", "illustr", "implicit", "incur", "inform", "involv", "jump", "larg", "level", "live", "low", "method", "method", "need", "optim", "paper", "pars", "predomin", "present", "problem", "program", "program", "propos", "recent", "reflect", "repeatedli", "simpl", "solv", "sourc", "statement", "termedi", "text", "time", "tree", "updat", "variabl", "work", "rosen"], "word_count": {"advanc": 1, "analysi": 5, "analyz": 1, "applic": 1, "aris": 1, "aspect": 1, "avoid": 2, "certif": 1, "compil": 3, "construct": 1, "contrast": 1, "control": 1, "cost": 1, "data": 3, "deal": 1, "deriv": 1, "escap": 1, "essenti": 1, "exploit": 1, "facilit": 1, "familiar": 1, "flow": 6, "free": 1, "gener": 1, "global": 2, "graph": 2, "help": 1, "high": 3, "illustr": 1, "implicit": 1, "incur": 1, "inform": 3, "involv": 1, "jump": 1, "larg": 2, "level": 6, "live": 1, "low": 2, "method": 3, "need": 1, "optim": 1, "paper": 1, "pars": 1, "predomin": 1, "present": 1, "problem": 1, "program": 5, "propos": 1, "recent": 1, "reflect": 1, "repeatedli": 1, "simpl": 1, "solv": 1, "sourc": 1, "statement": 1, "termedi": 1, "text": 1, "time": 1, "tree": 1, "updat": 1, "variabl": 1, "work": 1, "rosen": 1}}, "2924": {"id": "2924", "title": "An Interactive Computer Graphics Approach to Surface Representation", "abstract": "An in teractive computer graphics method has been developed for the rapid generation of arbitrary  shaped three-dimensional surfaces.  The method is a synthesis of spline theory and algorithms, an in teractive  means for man-machine communication, and software for static or dynamic graphics display.  The basic  technique employed is a modified lofting method on which sectional curves are represented by uniform  B-splines and the surface is in terpolated between sections by Cardinal splines.  Among the features of  this method are algorithms which enable in teractive modification of the B-spline representation of the  sectional curves.  At all stages of the process, the spatial information is graphically displayed to  the user.  Complex surfaces can be created by the combination of a number of shapes that have been separately  generated and automatically joined.  The system has been successfully in terfaced to a variety of analytical  routines for structural, medical and graphical applications.", "authors": "Wu, Sheng-Chuan Abel, J. F. Greenberg, D. P.", "words_pool": ["algorithm", "analyt", "applic", "approach", "arbitrari", "basic", "cardin", "combin", "commun", "complex", "comput", "creat", "curv", "develop", "dimension", "display", "display", "dynam", "employ", "enabl", "featur", "gener", "gener", "graphic", "graphic", "graphic", "inform", "interact", "join", "loft", "machin", "man", "mean", "medic", "method", "modif", "modifi", "number", "process", "rapid", "represent", "repres", "routin", "section", "section", "separ", "shape", "shape", "softwar", "spatial", "spline", "spline", "stage", "static", "structur", "success", "surfac", "surfac", "synthesi", "system", "techniqu", "teract", "terfac", "terpol", "theori", "uniform", "user", "varieti", "wu", "sheng", "chuan", "abel", "greenberg"], "word_count": {"algorithm": 2, "analyt": 1, "applic": 1, "approach": 1, "arbitrari": 1, "basic": 1, "cardin": 1, "combin": 1, "commun": 1, "complex": 1, "comput": 1, "creat": 1, "curv": 2, "develop": 1, "dimension": 1, "display": 2, "dynam": 1, "employ": 1, "enabl": 1, "featur": 1, "gener": 2, "graphic": 4, "inform": 1, "interact": 1, "join": 1, "loft": 1, "machin": 1, "man": 1, "mean": 1, "medic": 1, "method": 4, "modif": 1, "modifi": 1, "number": 1, "process": 1, "rapid": 1, "represent": 1, "repres": 1, "routin": 1, "section": 3, "separ": 1, "shape": 2, "softwar": 1, "spatial": 1, "spline": 4, "stage": 1, "static": 1, "structur": 1, "success": 1, "surfac": 3, "synthesi": 1, "system": 1, "techniqu": 1, "teract": 3, "terfac": 1, "terpol": 1, "theori": 1, "uniform": 1, "user": 1, "varieti": 1, "wu": 1, "sheng": 1, "chuan": 1, "abel": 1, "greenberg": 1}}, "2925": {"id": "2925", "title": "Optimal Surface Reconstruction from Planar Contours", "abstract": "In many scientific and technical endeavors, a three-dimensional solid must be reconstructed  from serial sections, either to aid in the comprehension of the object's structure or to facilitate its  automatic manipulation and analysis.  This paper presents a general solution to the problem of constructing  a surface over a set of cross-sectional contours.  This surface, to be composed of triangular tiles,  is constructed by separately determining an optimal surface between each pair of consecutive contours.  Determining such a surface is reduced to the problem of finding certain minimum cost cycles in a directed  toroidal graph.  A new fast algorithm for finding such cycles is utilized.  Also developed is a closed-form  expression, in term of the number of contour poin ts, for an upper bound on the number of operations required  to execute the algorithm.  An illustrated example which involves the construction of a minimum area surface  describing a human head is included.", "authors": "Fuchs, H. Kedem,Z. M. Uselton, S. P.", "words_pool": ["aid", "algorithm", "analysi", "area", "automat", "bound", "close", "compos", "comprehens", "consecut", "construct", "construct", "construct", "contour", "contour", "cost", "cross", "cycl", "describ", "determin", "develop", "dimension", "direct", "endeavor", "execut", "express", "facilit", "fast", "find", "form", "gener", "graph", "head", "human", "illustr", "includ", "involv", "manipul", "minimum", "number", "object", "oper", "optim", "pair", "paper", "planar", "poin", "present", "problem", "reconstruct", "reconstruct", "reduc", "requir", "scientif", "section", "section", "separ", "serial", "set", "solid", "solut", "structur", "surfac", "technic", "term", "tile", "toroid", "triangular", "ts", "upper", "util", "fuch", "kedem", "uselton"], "word_count": {"aid": 1, "algorithm": 2, "analysi": 1, "area": 1, "automat": 1, "bound": 1, "close": 1, "compos": 1, "comprehens": 1, "consecut": 1, "construct": 3, "contour": 3, "cost": 1, "cross": 1, "cycl": 2, "describ": 1, "determin": 2, "develop": 1, "dimension": 1, "direct": 1, "endeavor": 1, "execut": 1, "express": 1, "facilit": 1, "fast": 1, "find": 2, "form": 1, "gener": 1, "graph": 1, "head": 1, "human": 1, "illustr": 1, "includ": 1, "involv": 1, "manipul": 1, "minimum": 2, "number": 2, "object": 1, "oper": 1, "optim": 1, "pair": 1, "paper": 1, "planar": 1, "poin": 1, "present": 1, "problem": 2, "reconstruct": 1, "reduc": 1, "requir": 1, "scientif": 1, "section": 2, "separ": 1, "serial": 1, "set": 1, "solid": 1, "solut": 1, "structur": 1, "surfac": 5, "technic": 1, "term": 1, "tile": 1, "toroid": 1, "triangular": 1, "ts": 1, "upper": 1, "util": 1, "fuch": 1, "kedem": 1, "uselton": 1}}, "2926": {"id": "2926", "title": "Pagination of B*-Trees with Variable-Length Records", "abstract": "A strategy is presented for pagination of B*-trees with variable-length records.  If records  of each length are uniformly distributed within the file, and if a wide distribution of record lengths  exists within the file, then this strategy results in shallow trees with fast access times.  The performance  of this strategy in an application is presented, compared with that of another strategy, and analyzed.", "authors": "McCreight, E. M.", "words_pool": ["access", "analyz", "applic", "compar", "distribut", "distribut", "exist", "fast", "length", "length", "pagin", "perform", "present", "record", "record", "result", "shallow", "strategi", "time", "tree", "uniformli", "variabl", "wide", "mccreight"], "word_count": {"access": 1, "analyz": 1, "applic": 1, "compar": 1, "distribut": 2, "exist": 1, "fast": 1, "length": 3, "pagin": 1, "perform": 1, "present": 2, "record": 3, "result": 1, "shallow": 1, "strategi": 4, "time": 1, "tree": 2, "uniformli": 1, "variabl": 1, "wide": 1, "mccreight": 1}}, "2927": {"id": "2927", "title": "Some New Upper Bounds on the Generation of Prime Numbers", "abstract": "Given an integer N, what is the computational complexity of finding all the primes less than  N?  A modified sieve of Eratosthenes using doubly linked lists yields an algorithm of O(N) arithmetic  complexity.  This upper bound is shown to be equivalent to the theoretical lower bound for sieve methods  without preprocessing.  Use of preprocessing techniques involving space-time and additive-multiplicative  tradeoffs reduces this upper bound to O(N/log logN) and the bit complexity to O(N logN log log logN).   A storage requirement is described using O(N logN/log logN) bits as well.", "authors": "Mairson, H. G.", "words_pool": ["addit", "algorithm", "arithmet", "bit", "bit", "bound", "bound", "complex", "comput", "doubli", "equival", "eratosthen", "find", "gener", "integ", "involv", "link", "list", "log", "logn", "lower", "method", "modifi", "multipl", "number", "preprocess", "prime", "prime", "reduc", "requir", "shown", "siev", "space", "storag", "techniqu", "theoret", "time", "tradeoff", "upper", "yield", "mairson"], "word_count": {"addit": 1, "algorithm": 1, "arithmet": 1, "bit": 2, "bound": 3, "complex": 3, "comput": 1, "doubli": 1, "equival": 1, "eratosthen": 1, "find": 1, "gener": 1, "integ": 1, "involv": 1, "link": 1, "list": 1, "log": 4, "logn": 5, "lower": 1, "method": 1, "modifi": 1, "multipl": 1, "number": 1, "preprocess": 2, "prime": 1, "reduc": 1, "requir": 1, "shown": 1, "siev": 2, "space": 1, "storag": 1, "techniqu": 1, "theoret": 1, "time": 1, "tradeoff": 1, "upper": 2, "yield": 1, "mairson": 1}}, "2928": {"id": "2928", "title": "Hardware Estimation of a Process' Primary Memory Requirements", "abstract": "A minor hardware extension to the Honeywell 6180 processor is demonstrated to allow the primary  memory requirements of a process in Multics to be approximated.  The additional hardware required for  this estimate to be computed consists of a program accessible register containing the miss rate of the  associative memory used for page table words.  This primary memory requirement estimate was employed  in an experimental version of Multics to control the level of multiprogramming in the system and to bill  for memory usage.  The resulting system's tuning parameters display configuration insensitivity, and it is conjectured that the system would also track shifts in the referencing characteristics of its workload  and keep the system in tune.", "authors": "Giffor, D. K.", "words_pool": ["access", "addit", "allow", "approxim", "associ", "bill", "characterist", "comput", "configur", "conjectur", "consist", "control", "demonstr", "display", "employ", "estim", "estim", "experiment", "extens", "hardwar", "honeywel", "insensit", "level", "memori", "minor", "miss", "multic", "multiprogram", "page", "paramet", "primari", "process", "processor", "program", "rate", "referenc", "regist", "requir", "requir", "requir", "result", "shift", "system", "tabl", "track", "tune", "tune", "usag", "version", "word", "workload", "giffor"], "word_count": {"access": 1, "addit": 1, "allow": 1, "approxim": 1, "associ": 1, "bill": 1, "characterist": 1, "comput": 1, "configur": 1, "conjectur": 1, "consist": 1, "control": 1, "demonstr": 1, "display": 1, "employ": 1, "estim": 2, "experiment": 1, "extens": 1, "hardwar": 2, "honeywel": 1, "insensit": 1, "level": 1, "memori": 4, "minor": 1, "miss": 1, "multic": 2, "multiprogram": 1, "page": 1, "paramet": 1, "primari": 2, "process": 1, "processor": 1, "program": 1, "rate": 1, "referenc": 1, "regist": 1, "requir": 3, "result": 1, "shift": 1, "system": 4, "tabl": 1, "track": 1, "tune": 2, "usag": 1, "version": 1, "word": 1, "workload": 1, "giffor": 1}}, "2929": {"id": "2929", "title": "An Analysis of Inline Substitution for a Structured Programming Language", "abstract": "An optimization technique known as inline substitution is analyzed.  The optimization consists  of replacing a procedure invocation by a modified copy of the procedure body.  The general problem of  using inline substitution to minimize execution time subject to size constrain ts is formulated, and an  approximate algorithmic solution is proposed.  The algorithm depends on run-time statistics about the  program to be optimized.  Preliminary results for the CLU structured programming language indicate that,  in programs with a low degree of recursion, over 90 percent of all procedure calls can be eliminated,  with little increase in the size of compiled code and a small savings in execution time.  Other conclusions  based on these results are also presented.", "authors": "Scheifler, R. W.", "words_pool": ["algorithm", "algorithm", "analysi", "analyz", "approxim", "base", "bodi", "call", "clu", "code", "compil", "conclus", "consist", "constrain", "copi", "degre", "depend", "elimin", "execut", "formul", "gener", "increas", "inlin", "invoc", "known", "languag", "low", "minim", "modifi", "optim", "optim", "percent", "preliminari", "present", "problem", "procedur", "program", "program", "program", "propos", "recurs", "replac", "result", "run", "save", "size", "small", "solut", "statist", "structur", "subject", "substitut", "techniqu", "time", "ts", "scheifler"], "word_count": {"algorithm": 2, "analysi": 1, "analyz": 1, "approxim": 1, "base": 1, "bodi": 1, "call": 1, "clu": 1, "code": 1, "compil": 1, "conclus": 1, "consist": 1, "constrain": 1, "copi": 1, "degre": 1, "depend": 1, "elimin": 1, "execut": 2, "formul": 1, "gener": 1, "increas": 1, "inlin": 2, "invoc": 1, "known": 1, "languag": 1, "low": 1, "minim": 1, "modifi": 1, "optim": 3, "percent": 1, "preliminari": 1, "present": 1, "problem": 1, "procedur": 3, "program": 3, "propos": 1, "recurs": 1, "replac": 1, "result": 2, "run": 1, "save": 1, "size": 2, "small": 1, "solut": 1, "statist": 1, "structur": 1, "subject": 1, "substitut": 2, "techniqu": 1, "time": 3, "ts": 1, "scheifler": 1}}, "2930": {"id": "2930", "title": "The GRE Advanced Test in Computer Science", "abstract": "This report describes the Advanced Test in Computer Science which was recently in troduced in  the Graduate Record Examination Program.  The GRE program is described in general, and, the events leading  to the establishment of the Advanced Computer Science Test are discussed.  Content specifications and  their rationale are given.  A set of sample questions is included.", "authors": "Austing, R. H.", "words_pool": ["advanc", "comput", "content", "describ", "discuss", "establish", "event", "examin", "gener", "graduat", "gre", "includ", "lead", "program", "question", "rational", "recent", "record", "report", "sampl", "scienc", "set", "specif", "test", "troduc", "aust"], "word_count": {"advanc": 2, "comput": 2, "content": 1, "describ": 1, "discuss": 1, "establish": 1, "event": 1, "examin": 1, "gener": 1, "graduat": 1, "gre": 1, "includ": 1, "lead": 1, "program": 2, "question": 1, "rational": 1, "recent": 1, "record": 1, "report": 1, "sampl": 1, "scienc": 2, "set": 1, "specif": 1, "test": 2, "troduc": 1, "aust": 1}}, "2931": {"id": "2931", "title": "Logic and Programming Languages", "abstract": "Logic has been long in terested in whether answers to certain questions are computable in principle,  since the outcome puts bounds on the possibilities of formalization.  More recently, precise comparisons  in the efficiency of decision methods have become available through the developments in complexity theory.   These, however, are applications to logic, and a big question is whether methods of logic have significance  in the other direction for the more applied parts of computability theory.  Programming languages offer  an obvious opportunity as their syntactic formalization is well advanced; however, the semantical theory  can hardly be said to be complete.  Though we have many examples, we have still to give wide-ranging  mathematical answers to these queries:  What is a machine?  What is a computable process?  How (or how  well) does a machine simulate a process?  Programs naturally enter in giving descriptions of processes.   The definition of the precise meaning of a program then requires us to explain what are the objects  of computation (in a way, the statics of the problem) and how they are to be transformed (the dynamics).   So far the theories of automata and of nets, though most in teresting for dynamics, have formalized only  a portion of the field, and there has been perhaps too much concentration on the finite-state and algebraic  aspects.  It would seem that the understanding of higher-level program features involves us with infinite  objects and forces us to pass through several levels of explanation to go from the conceptual ideas to  the final simulation on a real machine.  These levels can be made mathematically exact if we can find  the right abstractions to represent the necessary structures.  The experience of many independent workers  with the method of data types as lattices (or partial orderings) under an information content ordering,  and with their continuous mappings, has demonstrated the flexibility of this approach in providing definitions  and proofs, which are clean and without undue dependence on implementations.  Nevertheless much remains  to be done in showing how abstract conceptualizations can (or cannot) be actualized before we can say  we have a unified theory.", "authors": "Scott, D. S.", "words_pool": ["abstract", "abstract", "actual", "advanc", "algebra", "answer", "applic", "appli", "approach", "aspect", "automata", "big", "bound", "clean", "comparison", "complet", "complex", "comput", "comput", "comput", "concentr", "conceptu", "conceptu", "content", "continu", "data", "decis", "definit", "definit", "demonstr", "depend", "descript", "develop", "direct", "dynam", "effici", "enter", "exact", "exampl", "experi", "explain", "explan", "featur", "field", "final", "find", "finit", "flexibl", "forc", "formal", "formal", "give", "give", "higher", "idea", "implement", "independ", "infinit", "inform", "involv", "languag", "lattic", "level", "level", "logic", "long", "machin", "made", "map", "mathemat", "mathemat", "mean", "method", "method", "natur", "net", "object", "obviou", "offer", "opportun", "order", "order", "outcom", "partial", "part", "pass", "portion", "possibl", "precis", "principl", "problem", "process", "process", "program", "program", "program", "proof", "provid", "put", "queri", "question", "question", "rang", "real", "recent", "remain", "repres", "requir", "say", "semant", "show", "signific", "simul", "simul", "state", "static", "structur", "syntact", "terest", "terest", "theori", "theori", "transform", "type", "understand", "undu", "unifi", "wide", "worker", "scott"], "word_count": {"abstract": 2, "actual": 1, "advanc": 1, "algebra": 1, "answer": 2, "applic": 1, "appli": 1, "approach": 1, "aspect": 1, "automata": 1, "big": 1, "bound": 1, "clean": 1, "comparison": 1, "complet": 1, "complex": 1, "comput": 4, "concentr": 1, "conceptu": 2, "content": 1, "continu": 1, "data": 1, "decis": 1, "definit": 2, "demonstr": 1, "depend": 1, "descript": 1, "develop": 1, "direct": 1, "dynam": 2, "effici": 1, "enter": 1, "exact": 1, "exampl": 1, "experi": 1, "explain": 1, "explan": 1, "featur": 1, "field": 1, "final": 1, "find": 1, "finit": 1, "flexibl": 1, "forc": 1, "formal": 3, "give": 2, "higher": 1, "idea": 1, "implement": 1, "independ": 1, "infinit": 1, "inform": 1, "involv": 1, "languag": 1, "lattic": 1, "level": 3, "logic": 3, "long": 1, "machin": 3, "made": 1, "map": 1, "mathemat": 2, "mean": 1, "method": 3, "natur": 1, "net": 1, "object": 2, "obviou": 1, "offer": 1, "opportun": 1, "order": 2, "outcom": 1, "partial": 1, "part": 1, "pass": 1, "portion": 1, "possibl": 1, "precis": 2, "principl": 1, "problem": 1, "process": 3, "program": 4, "proof": 1, "provid": 1, "put": 1, "queri": 1, "question": 2, "rang": 1, "real": 1, "recent": 1, "remain": 1, "repres": 1, "requir": 1, "say": 1, "semant": 1, "show": 1, "signific": 1, "simul": 2, "state": 1, "static": 1, "structur": 1, "syntact": 1, "terest": 2, "theori": 5, "transform": 1, "type": 1, "understand": 1, "undu": 1, "unifi": 1, "wide": 1, "worker": 1, "scott": 1}}, "2932": {"id": "2932", "title": "Complexity of Computations", "abstract": "The framework for research in the theory of complexity of computations is described, emphasizing  the in terrelation between seemingly diverse problems and methods.  Illustrative examples of practical  and theoretical significance are given.  Directions for new research are discussed.", "authors": "Rabin, M. O.", "words_pool": ["complex", "comput", "direct", "discuss", "divers", "emphas", "exampl", "framework", "illustr", "method", "practic", "problem", "research", "seemingli", "signific", "terrel", "theoret", "theori", "rabin"], "word_count": {"complex": 1, "comput": 1, "direct": 1, "discuss": 1, "divers": 1, "emphas": 1, "exampl": 1, "framework": 1, "illustr": 1, "method": 1, "practic": 1, "problem": 1, "research": 2, "seemingli": 1, "signific": 1, "terrel": 1, "theoret": 1, "theori": 1, "rabin": 1}}, "2933": {"id": "2933", "title": "Another Advantage of Keyword Notation for Parameter Communication with Subprograms", "authors": "Francez, N.", "words_pool": ["advantag", "commun", "keyword", "notat", "paramet", "subprogram", "francez"], "word_count": {"advantag": 1, "commun": 1, "keyword": 1, "notat": 1, "paramet": 1, "subprogram": 1, "francez": 1}}, "2934": {"id": "2934", "title": "Comment on Computing the k Shortest Paths in a Graph", "authors": "Lawler, E. L.", "words_pool": ["comment", "comput", "graph", "path", "shortest", "lawler"], "word_count": {"comment": 1, "comput": 1, "graph": 1, "path": 1, "shortest": 1, "lawler": 1}}, "2935": {"id": "2935", "title": "Production and Employment of Ph.D.'s in Computer Science-1976 (Corrigendum)", "authors": "Taulbee, O. E. Conte, S. D.", "words_pool": ["comput", "corrigendum", "employ", "ph", "product", "scienc", "taulbe", "cont"], "word_count": {"comput": 1, "corrigendum": 1, "employ": 1, "ph": 1, "product": 1, "scienc": 1, "taulbe": 1, "cont": 1}}, "2936": {"id": "2936", "title": "An Efficient Data Structure for the Simulation Event Set", "abstract": "Recently algorithms have been presented for the realization of event scheduling routines suitable  for general purpose discrete event simulation systems.  Several exhibited a performance superior to that  of commonly used simple linked list algorithms.  In this paper a new event scheduling algorithm is presented  which improves on two aspects of the best of the previously published algorithms.  First, the new algorithm's  performance is quite insensitive to skewed distributions, and second, its worst-case complexity is O(  n), where n is the number of events in the set.  Furthermore, tests conducted to estimate the average  complexity showed it to be nearly independent of n.", "authors": "Franta, W. R. Maly, K.", "words_pool": ["algorithm", "algorithm", "aspect", "averag", "case", "commonli", "complex", "conduct", "data", "discret", "distribut", "effici", "estim", "event", "event", "exhibit", "gener", "improv", "independ", "insensit", "link", "list", "nearli", "number", "paper", "perform", "present", "previous", "publish", "purpos", "realiz", "recent", "routin", "schedul", "set", "show", "simpl", "simul", "skew", "structur", "suitabl", "superior", "system", "test", "worst", "franta", "mali"], "word_count": {"algorithm": 5, "aspect": 1, "averag": 1, "case": 1, "commonli": 1, "complex": 2, "conduct": 1, "data": 1, "discret": 1, "distribut": 1, "effici": 1, "estim": 1, "event": 4, "exhibit": 1, "gener": 1, "improv": 1, "independ": 1, "insensit": 1, "link": 1, "list": 1, "nearli": 1, "number": 1, "paper": 1, "perform": 2, "present": 2, "previous": 1, "publish": 1, "purpos": 1, "realiz": 1, "recent": 1, "routin": 1, "schedul": 2, "set": 1, "show": 1, "simpl": 1, "simul": 1, "skew": 1, "structur": 1, "suitabl": 1, "superior": 1, "system": 1, "test": 1, "worst": 1, "franta": 1, "mali": 1}}, "2937": {"id": "2937", "title": "An Experimental Evaluation of Data Type Conventions", "abstract": "The language in which programs are written can have a substantial effect on the reliability  of the resulting programs.  This paper discusses an experiment that compares the programming reliability  of subjects using a statically typed language and a \"typeless\" language.  Analysis of the number of errors  and the number of runs containing errors shows that, at least in one environment, the use of a statically  typed language can increase programming reliability.  Detailed analysis of the errors made by the subjects  in programming solutions to reasonably small problems shows that the subjects had difficulty manipulating  the representation of data.", "authors": "Gannon, J. D.", "words_pool": ["analysi", "compar", "convent", "data", "detail", "difficulti", "discuss", "effect", "environ", "error", "evalu", "experi", "experiment", "increas", "languag", "made", "manipul", "number", "paper", "problem", "program", "program", "reason", "reliabl", "represent", "result", "run", "show", "small", "solut", "static", "subject", "substanti", "type", "type", "typeless", "written", "gannon"], "word_count": {"analysi": 2, "compar": 1, "convent": 1, "data": 1, "detail": 1, "difficulti": 1, "discuss": 1, "effect": 1, "environ": 1, "error": 3, "evalu": 1, "experi": 1, "experiment": 1, "increas": 1, "languag": 4, "made": 1, "manipul": 1, "number": 2, "paper": 1, "problem": 1, "program": 5, "reason": 1, "reliabl": 3, "represent": 1, "result": 1, "run": 1, "show": 2, "small": 1, "solut": 1, "static": 2, "subject": 3, "substanti": 1, "type": 2, "typeless": 1, "written": 1, "gannon": 1}}, "2938": {"id": "2938", "title": "Toward a Discipline of Real-Time Programming", "abstract": "Programming is divided into three major categories with increasing complexity of reasoning  in program validation: sequential programming, multiprogramming, and real-time programming.  By adhering  to a strict programming discipline and by using a suitable high-level language molded after this discipline,  the complexity of reasoning about concurrency and execution time constrain ts may be drastically reduced.   This may be the only practical way to make real-time systems analytically verifiable and ultimately  reliable.  A possible discipline is outlined and expressed in terms of the language Modula.", "authors": "Wirth, N.", "words_pool": ["adher", "analyt", "categori", "complex", "concurr", "constrain", "disciplin", "divid", "drastic", "execut", "express", "high", "increas", "languag", "level", "major", "make", "modula", "mold", "multiprogram", "outlin", "practic", "program", "program", "real", "reason", "reduc", "reliabl", "sequenti", "strict", "suitabl", "system", "term", "time", "ts", "ultim", "valid", "verifi", "wirth"], "word_count": {"adher": 1, "analyt": 1, "categori": 1, "complex": 2, "concurr": 1, "constrain": 1, "disciplin": 3, "divid": 1, "drastic": 1, "execut": 1, "express": 1, "high": 1, "increas": 1, "languag": 2, "level": 1, "major": 1, "make": 1, "modula": 1, "mold": 1, "multiprogram": 1, "outlin": 1, "practic": 1, "program": 5, "real": 2, "reason": 2, "reduc": 1, "reliabl": 1, "sequenti": 1, "strict": 1, "suitabl": 1, "system": 1, "term": 1, "time": 3, "ts": 1, "ultim": 1, "valid": 1, "verifi": 1, "wirth": 1}}, "2939": {"id": "2939", "title": "Abstraction Mechanisms in CLU", "abstract": "CLU is a new programming language designed to support the use of abstractions in program construction.   Work in programming methodology has led to the realization that three kinds of abstractions-procedural,  control, and especially data abstractions-are useful in the programming process.  Of these, only the  procedural abstraction is supported well by conventional languages, through the procedure or subroutine.   CLU provides, in addition to procedures, novel linguistic mechanisms that support the use of data and  control abstractions.  This paper provides an in troduction to the abstraction mechanisms in CLU.  By  means of programming examples, the utility of the three kinds of abstractions in program construction  is illustrated, and it is shown how CLU programs may be written to use and implement abstractions.  The  CLU library, which permits incremental program development with complete type checking performed at compile  time, is also discussed.", "authors": "Liskov, B. Snyder, A. Atkinson, R. Schaffert, C.", "words_pool": ["abstract", "abstract", "addit", "check", "clu", "compil", "complet", "construct", "control", "convent", "data", "design", "develop", "discuss", "especi", "exampl", "illustr", "implement", "increment", "kind", "languag", "languag", "led", "librari", "linguist", "mean", "mechan", "methodolog", "paper", "perform", "permit", "procedur", "procedur", "procedur", "process", "program", "program", "program", "realiz", "shown", "subroutin", "support", "support", "time", "troduct", "type", "util", "work", "written", "liskov", "snyder", "atkinson", "schaffert"], "word_count": {"abstract": 8, "addit": 1, "check": 1, "clu": 5, "compil": 1, "complet": 1, "construct": 2, "control": 2, "convent": 1, "data": 2, "design": 1, "develop": 1, "discuss": 1, "especi": 1, "exampl": 1, "illustr": 1, "implement": 1, "increment": 1, "kind": 2, "languag": 2, "led": 1, "librari": 1, "linguist": 1, "mean": 1, "mechan": 2, "methodolog": 1, "paper": 1, "perform": 1, "permit": 1, "procedur": 4, "process": 1, "program": 8, "realiz": 1, "shown": 1, "subroutin": 1, "support": 3, "time": 1, "troduct": 1, "type": 1, "util": 1, "work": 1, "written": 1, "liskov": 1, "snyder": 1, "atkinson": 1, "schaffert": 1}}, "2940": {"id": "2940", "title": "Abstraction and Verification in Alphard: Defining and Specifying Iteration and Generators", "abstract": "The Alphard \"form\" provides the programmer with a great deal of control over the implementation  of abstract data types.  In this paper the abstraction techniques are extended from simple data representation  and function definition to the iteration statement, the most important poin t of interaction between data  and the control structure of the language itself.  A means of specializing Alphard's loops to operate  on abstract entities without explicit dependence on the representation of those entities is in troduced.   Specification and verification techniques that allow the properties of the generators for such iterations  to be expressed in the form of proof rules are developed.  Results are obtained that for common special  cases of these loops are essentially identical to the corresponding constructs in other languages.  A  means of showing that a generator will terminate is also provided.", "authors": "Shaw, M. Wulf, W. A.", "words_pool": ["abstract", "abstract", "allow", "alphard", "case", "common", "construct", "control", "data", "deal", "defin", "definit", "depend", "develop", "entiti", "essenti", "explicit", "express", "extend", "form", "function", "gener", "gener", "great", "ident", "implement", "import", "interact", "iter", "iter", "languag", "languag", "loop", "mean", "obtain", "oper", "paper", "poin", "programm", "proof", "properti", "provid", "represent", "result", "rule", "show", "simpl", "special", "special", "specif", "statement", "structur", "techniqu", "termin", "troduc", "type", "verif", "shaw", "wulf"], "word_count": {"abstract": 3, "allow": 1, "alphard": 2, "case": 1, "common": 1, "construct": 1, "control": 2, "data": 3, "deal": 1, "defin": 1, "definit": 1, "depend": 1, "develop": 1, "entiti": 2, "essenti": 1, "explicit": 1, "express": 1, "extend": 1, "form": 2, "function": 1, "gener": 2, "great": 1, "ident": 1, "implement": 1, "import": 1, "interact": 1, "iter": 2, "languag": 2, "loop": 2, "mean": 2, "obtain": 1, "oper": 1, "paper": 1, "poin": 1, "programm": 1, "proof": 1, "properti": 1, "provid": 1, "represent": 2, "result": 1, "rule": 1, "show": 1, "simpl": 1, "special": 2, "specif": 1, "statement": 1, "structur": 1, "techniqu": 2, "termin": 1, "troduc": 1, "type": 1, "verif": 1, "shaw": 1, "wulf": 1}}, "2941": {"id": "2941", "title": "Early Experience with Mesa", "abstract": "The experiences of Mesa's first users-primarily its implementers-are discussed, and some implications  for Mesa and similar programming languages are suggested. The specific topics addressed are: module structure  and its use in defining abstractions, data-structuring facilities in Mesa, an equivalence algorithm for  types and type coercions, the benefits of the type system and why it is breached occasionally, and the  difficulty of making the treatment of variant records safe.", "authors": "Geschke, C. M. Morris, J. H. Jr. Satterthwaite, E. H.", "words_pool": ["abstract", "address", "algorithm", "benefit", "breach", "coercion", "data", "defin", "difficulti", "discuss", "earli", "equival", "experi", "experi", "facil", "implement", "implic", "languag", "make", "mesa", "modul", "occasion", "primarili", "program", "record", "safe", "similar", "specif", "structur", "structur", "suggest", "system", "topic", "treatment", "type", "type", "user", "variant", "geschk", "morri", "jr", "satterthwait"], "word_count": {"abstract": 1, "address": 1, "algorithm": 1, "benefit": 1, "breach": 1, "coercion": 1, "data": 1, "defin": 1, "difficulti": 1, "discuss": 1, "earli": 1, "equival": 1, "experi": 1, "facil": 1, "implement": 1, "implic": 1, "languag": 1, "make": 1, "mesa": 3, "modul": 1, "occasion": 1, "primarili": 1, "program": 1, "record": 1, "safe": 1, "similar": 1, "specif": 1, "structur": 2, "suggest": 1, "system": 1, "topic": 1, "treatment": 1, "type": 3, "user": 1, "variant": 1, "geschk": 1, "morri": 1, "jr": 1, "satterthwait": 1}}, "2942": {"id": "2942", "title": "An Algol-Based Implementation of SNOBOL 4 Patterns", "authors": "Brownlee, J. N.", "words_pool": ["algol", "base", "implement", "pattern", "snobol", "brownle"], "word_count": {"algol": 1, "base": 1, "implement": 1, "pattern": 1, "snobol": 1, "brownle": 1}}, "2943": {"id": "2943", "title": "Lucid, a Nonprocedural Language with Iteration", "abstract": "Lucid is a formal system in which programs can be written and proofs of programs carried out.   The proofs are particularly easy to follow and straightforward to produce because the statements in  a Lucid program are simply axioms from which the proof proceeds by (almost) conventional logical reasoning,  with the help of a few axioms and rules of inference for the special Lucid functions.  As a programming  language, Lucid is unconventional because, among other things, the order of statements is irrelevant  and assignment statements are equations.  Nevertheless, Lucid programs need not look much different than  iterative programs in a conventional structured programming language using assignment and conditional  statements and loops.", "authors": "Ashcrof, E. A. Wadge, W. W.", "words_pool": ["assign", "axiom", "carri", "condit", "convent", "easi", "equat", "follow", "formal", "function", "help", "infer", "irrelev", "iter", "iter", "languag", "logic", "look", "loop", "lucid", "need", "nonprocedur", "order", "proce", "produc", "program", "program", "program", "proof", "proof", "reason", "rule", "simpli", "special", "statement", "straightforward", "structur", "system", "thing", "unconvent", "written", "ashcrof", "wadg"], "word_count": {"assign": 2, "axiom": 2, "carri": 1, "condit": 1, "convent": 2, "easi": 1, "equat": 1, "follow": 1, "formal": 1, "function": 1, "help": 1, "infer": 1, "irrelev": 1, "iter": 1, "languag": 2, "logic": 1, "look": 1, "loop": 1, "lucid": 5, "need": 1, "nonprocedur": 1, "order": 1, "proce": 1, "produc": 1, "program": 7, "proof": 3, "reason": 1, "rule": 1, "simpli": 1, "special": 1, "statement": 4, "straightforward": 1, "structur": 1, "system": 1, "thing": 1, "unconvent": 1, "written": 1, "ashcrof": 1, "wadg": 1}}, "2944": {"id": "2944", "title": "Shifting Garbage Collection Overhead to Compile Time", "abstract": "This paper discusses techniques which enable automatic storage reclamation overhead to be partially  shifted to compile time.  The paper assumes a transaction oriented collection scheme, as proposed by  Deutsch and Bobrow, the necessary features of which are summarized.  Implementing the described optimizations  requires global flow analysis to be performed on the source program.  It is shown that at compile time  certain program actions that affect the reference counts of cells can be deduced.  This information is  used to find actions that cancel when the code is executed and those that can be grouped to achieve improved  efficiency.", "authors": "Barth, J. M.", "words_pool": ["achiev", "action", "affect", "analysi", "assum", "automat", "bobrow", "cancel", "cell", "code", "collect", "compil", "count", "deduc", "deutsch", "discuss", "effici", "enabl", "execut", "featur", "find", "flow", "garbag", "global", "group", "implement", "improv", "inform", "optim", "orient", "overhead", "paper", "partial", "perform", "program", "propos", "reclam", "refer", "requir", "scheme", "shift", "shift", "shown", "sourc", "storag", "summar", "techniqu", "time", "transact", "barth"], "word_count": {"achiev": 1, "action": 2, "affect": 1, "analysi": 1, "assum": 1, "automat": 1, "bobrow": 1, "cancel": 1, "cell": 1, "code": 1, "collect": 1, "compil": 2, "count": 1, "deduc": 1, "deutsch": 1, "discuss": 1, "effici": 1, "enabl": 1, "execut": 1, "featur": 1, "find": 1, "flow": 1, "garbag": 1, "global": 1, "group": 1, "implement": 1, "improv": 1, "inform": 1, "optim": 1, "orient": 1, "overhead": 1, "paper": 2, "partial": 1, "perform": 1, "program": 2, "propos": 1, "reclam": 1, "refer": 1, "requir": 1, "scheme": 1, "shift": 1, "shown": 1, "sourc": 1, "storag": 1, "summar": 1, "techniqu": 1, "time": 2, "transact": 1, "barth": 1}}, "2945": {"id": "2945", "title": "Certification of Programs for Secure Information Flow", "abstract": "This paper presents a certification mechanism for verifying the secure flow of information  through a program.  Because it exploits the properties of a lattice structure among security classes,  the procedure is sufficiently simple that it can easily be included in the analysis phase of most existing  compilers.  Appropriate semantics are presented and proved correct.  An important application is the  confinement problem: The mechanism can prove that a program cannot cause supposedly nonconfidential results  to depend on confidential input data.", "authors": "Denning, D. E. Denning, P. J.", "words_pool": ["analysi", "applic", "certif", "class", "compil", "confidenti", "confin", "correct", "data", "depend", "easili", "exist", "exploit", "flow", "import", "includ", "inform", "input", "lattic", "mechan", "nonconfidenti", "paper", "phase", "present", "present", "problem", "procedur", "program", "program", "properti", "prove", "prove", "result", "secur", "secur", "semant", "simpl", "structur", "suffici", "supposedli", "verifi", "den", "den"], "word_count": {"analysi": 1, "applic": 1, "certif": 1, "class": 1, "compil": 1, "confidenti": 1, "confin": 1, "correct": 1, "data": 1, "depend": 1, "easili": 1, "exist": 1, "exploit": 1, "flow": 1, "import": 1, "includ": 1, "inform": 1, "input": 1, "lattic": 1, "mechan": 2, "nonconfidenti": 1, "paper": 1, "phase": 1, "present": 2, "problem": 1, "procedur": 1, "program": 2, "properti": 1, "prove": 2, "result": 1, "secur": 2, "semant": 1, "simpl": 1, "structur": 1, "suffici": 1, "supposedli": 1, "verifi": 1, "den": 1}}, "2946": {"id": "2946", "title": "An Alternative to Event Queues for Synchronization in Monitors", "abstract": "In the monitor concept, as proposed by Brinch Hansen and Hoare, event are used for synchronization.   This paper describes another synchronizing primitive which is nearly as expressive as the conditional  wait, but can be implemented more efficiently.  An implementation of this primitive in terms of P and  V operations is given together with a correctness proof.  Two examples are presented: the readers and  writers problem and the problem of information streams sharing a finite buffer pool.", "authors": "Kessels, J. L. W.", "words_pool": ["altern", "brinch", "buffer", "concept", "condit", "correct", "describ", "effici", "event", "exampl", "express", "finit", "hansen", "hoar", "implement", "implement", "inform", "monitor", "monitor", "nearli", "oper", "paper", "pool", "present", "primit", "problem", "proof", "propos", "queue", "reader", "share", "stream", "synchron", "synchron", "term", "wait", "writer", "kessel"], "word_count": {"altern": 1, "brinch": 1, "buffer": 1, "concept": 1, "condit": 1, "correct": 1, "describ": 1, "effici": 1, "event": 1, "exampl": 1, "express": 1, "finit": 1, "hansen": 1, "hoar": 1, "implement": 2, "inform": 1, "monitor": 1, "nearli": 1, "oper": 1, "paper": 1, "pool": 1, "present": 1, "primit": 2, "problem": 2, "proof": 1, "propos": 1, "queue": 1, "reader": 1, "share": 1, "stream": 1, "synchron": 2, "term": 1, "wait": 1, "writer": 1, "kessel": 1}}, "2947": {"id": "2947", "title": "SITAR: An Interactive Text Processing System for Small Computers", "abstract": "SITAR, a low-cost in teractive text handling and text analysis system for nontechnical users,  is in many ways comparable to in teractive bibliographical search and retrieval systems, but has several  additional features. It is implemented on a PDP/11 time-sharing computer invoked by a CRT with microprogrammed  editing functions.  It uses a simple command language designating a function, a file, and a search template  consisting of the textual string desired and strings delimiting the context in which the hit is to be  delivered.  Extensive experience with SITAR shows that the combined powers of simple commands, string  orientation, circular file structure, a CRT with local memory, and conversational computing produce a  system much more powerful than the sum of its parts.", "authors": "Schneider, B. R. Jr. Watts, R. M.", "words_pool": ["addit", "analysi", "bibliograph", "circular", "combin", "command", "command", "compar", "comput", "comput", "comput", "consist", "context", "convers", "cost", "crt", "delimit", "deliv", "design", "desir", "edit", "experi", "extens", "featur", "function", "function", "handl", "hit", "implement", "interact", "invok", "languag", "local", "low", "memori", "microprogram", "nontechn", "orient", "part", "pdp", "power", "power", "process", "produc", "retriev", "search", "share", "show", "simpl", "sitar", "small", "string", "string", "structur", "sum", "system", "system", "templat", "teract", "text", "textual", "time", "user", "way", "schneider", "jr", "watt"], "word_count": {"addit": 1, "analysi": 1, "bibliograph": 1, "circular": 1, "combin": 1, "command": 2, "compar": 1, "comput": 2, "consist": 1, "context": 1, "convers": 1, "cost": 1, "crt": 2, "delimit": 1, "deliv": 1, "design": 1, "desir": 1, "edit": 1, "experi": 1, "extens": 1, "featur": 1, "function": 2, "handl": 1, "hit": 1, "implement": 1, "interact": 1, "invok": 1, "languag": 1, "local": 1, "low": 1, "memori": 1, "microprogram": 1, "nontechn": 1, "orient": 1, "part": 1, "pdp": 1, "power": 2, "process": 1, "produc": 1, "retriev": 1, "search": 2, "share": 1, "show": 1, "simpl": 2, "sitar": 2, "small": 1, "string": 3, "structur": 1, "sum": 1, "system": 3, "templat": 1, "teract": 2, "text": 2, "textual": 1, "time": 1, "user": 1, "way": 1, "schneider": 1, "jr": 1, "watt": 1}}, "2948": {"id": "2948", "title": "A Terminal-Oriented Communication System", "abstract": "This paper describes a system for full-duplex communication between a time-shared computer  and its terminals.  The system consists of a communications computer directly connected to the time-shared  system, a number of small remote computers to which the terminals are attached, and connecting medium  speed telephone lines.  It can service a large number of terminals of various types.  The overall system  design is presented along with the algorithms used to solve three specific problems: local echoing, error  detection and correction on the telephone lines, and multiplexing of character output.", "authors": "Heckel, P. G. Lampson, B. W.", "words_pool": ["algorithm", "attach", "charact", "commun", "commun", "comput", "comput", "connect", "connect", "consist", "correct", "describ", "design", "detect", "directli", "duplex", "echo", "error", "full", "larg", "line", "local", "medium", "multiplex", "number", "orient", "output", "paper", "present", "problem", "remot", "servic", "share", "small", "solv", "specif", "speed", "system", "telephon", "termin", "termin", "time", "type", "heckel", "lampson"], "word_count": {"algorithm": 1, "attach": 1, "charact": 1, "commun": 2, "comput": 3, "connect": 2, "consist": 1, "correct": 1, "describ": 1, "design": 1, "detect": 1, "directli": 1, "duplex": 1, "echo": 1, "error": 1, "full": 1, "larg": 1, "line": 2, "local": 1, "medium": 1, "multiplex": 1, "number": 2, "orient": 1, "output": 1, "paper": 1, "present": 1, "problem": 1, "remot": 1, "servic": 1, "share": 2, "small": 1, "solv": 1, "specif": 1, "speed": 1, "system": 4, "telephon": 2, "termin": 3, "time": 2, "type": 1, "heckel": 1, "lampson": 1}}, "2949": {"id": "2949", "title": "A Correctness Proof of a Topology Information Main tenance Protocol for a Distributed Computer  Network", "abstract": "In order for the nodes of a distributed computer network to communicate, each node must have  information about the network's topology.  Since nodes and links sometimes crash, a scheme is needed  to update this information.  One of the major constrain ts on such a topology information scheme is that  it may not involve a central controller.  The Topology Information Protocol that was implemented on the  MERIT Computer Network is presented and explained; this protocol is quite general and could be implemented  on any computer network.  It is based on Baran's \"Hot Potato Heuristic Routing Doctrine.\"  A correctness  proof of this Topology Information Protocol is also presented.", "authors": "Tajibnapis, W. D.", "words_pool": ["baran", "base", "central", "commun", "comput", "constrain", "control", "correct", "crash", "distribut", "doctrin", "explain", "gener", "heurist", "hot", "implement", "inform", "involv", "link", "main", "major", "merit", "need", "network", "node", "node", "order", "potato", "present", "proof", "protocol", "rout", "scheme", "tenanc", "topolog", "ts", "updat", "tajibnapi"], "word_count": {"baran": 1, "base": 1, "central": 1, "commun": 1, "comput": 3, "constrain": 1, "control": 1, "correct": 1, "crash": 1, "distribut": 1, "doctrin": 1, "explain": 1, "gener": 1, "heurist": 1, "hot": 1, "implement": 2, "inform": 5, "involv": 1, "link": 1, "main": 1, "major": 1, "merit": 1, "need": 1, "network": 4, "node": 3, "order": 1, "potato": 1, "present": 2, "proof": 1, "protocol": 3, "rout": 1, "scheme": 2, "tenanc": 1, "topolog": 4, "ts": 1, "updat": 1, "tajibnapi": 1}}, "2950": {"id": "2950", "title": "A Unifying Approach to Scheduling", "abstract": "This paper presents a scheme for classifying scheduling algorithms based on an abstract model  of a scheduling system which formalizes the notion of priority.  Various classes of scheduling algorithms are defined and related to existing algorithms.  A criterion for the implementation efficiency of an  algorithm is developed and results in the definition of time-invariant algorithms, which include most  of the commonly implemented ones.  For time-invariant algorithms, the dependence of processing rates  on priorities is derived.  The abstract model provides a framework for implementing flexible schedulers  in real operating systems.  The policy-driven scheduler of Bernstein and Sharp is discussed as an example  of such an implementation", "authors": "Ruschitzka, M. Fabry, R. S.", "words_pool": ["abstract", "algorithm", "algorithm", "approach", "base", "bernstein", "class", "classifi", "commonli", "criterion", "defin", "definit", "depend", "deriv", "develop", "discuss", "driven", "effici", "exist", "flexibl", "formal", "framework", "implement", "implement", "implement", "includ", "invari", "model", "notion", "oper", "paper", "polici", "present", "prioriti", "prioriti", "process", "rate", "real", "relat", "result", "schedul", "schedul", "schedul", "scheme", "sharp", "system", "system", "time", "unifi", "ruschitzka", "fabri"], "word_count": {"abstract": 2, "algorithm": 6, "approach": 1, "base": 1, "bernstein": 1, "class": 1, "classifi": 1, "commonli": 1, "criterion": 1, "defin": 1, "definit": 1, "depend": 1, "deriv": 1, "develop": 1, "discuss": 1, "driven": 1, "effici": 1, "exist": 1, "flexibl": 1, "formal": 1, "framework": 1, "implement": 4, "includ": 1, "invari": 2, "model": 2, "notion": 1, "oper": 1, "paper": 1, "polici": 1, "present": 1, "prioriti": 2, "process": 1, "rate": 1, "real": 1, "relat": 1, "result": 1, "schedul": 5, "scheme": 1, "sharp": 1, "system": 2, "time": 2, "unifi": 1, "ruschitzka": 1, "fabri": 1}}, "2951": {"id": "2951", "title": "Dynamic Response Time Prediction for Computer Networks", "abstract": "If the ultimate aim of a computing network is resource sharing, then the human component as  well as the technical component of networking must be fully investigated to achieve this goal.  This  research is a first step toward assisting the user in participating in the vast store of resources available  on a network. Analytical, simulation, and statistical performance evaluation tools are employed to investigate  the feasibility of a dynamic response time monitor that is capable of providing comparative response  time information for users wishing to process various computing applications at some network computing  node.  The research clearly reveals that sufficient system data are currently obtainable, at least for  the five diverse ARPA network systems studied in detail, to describe and predict the response time for  network time-sharing systems as it depends on some measure of system activity or load level.", "authors": "Mamrak, S. A.", "words_pool": ["achiev", "activ", "aim", "analyt", "applic", "arpa", "assist", "capabl", "clearli", "compar", "compon", "comput", "comput", "data", "depend", "describ", "detail", "divers", "dynam", "employ", "evalu", "feasibl", "fulli", "goal", "human", "inform", "investig", "investig", "level", "load", "measur", "monitor", "network", "network", "network", "node", "obtain", "particip", "perform", "predict", "predict", "process", "provid", "research", "resourc", "resourc", "respons", "reveal", "share", "simul", "statist", "step", "store", "studi", "suffici", "system", "system", "technic", "time", "tool", "ultim", "user", "user", "vast", "wish", "mamrak"], "word_count": {"achiev": 1, "activ": 1, "aim": 1, "analyt": 1, "applic": 1, "arpa": 1, "assist": 1, "capabl": 1, "clearli": 1, "compar": 1, "compon": 2, "comput": 3, "data": 1, "depend": 1, "describ": 1, "detail": 1, "divers": 1, "dynam": 1, "employ": 1, "evalu": 1, "feasibl": 1, "fulli": 1, "goal": 1, "human": 1, "inform": 1, "investig": 2, "level": 1, "load": 1, "measur": 1, "monitor": 1, "network": 6, "node": 1, "obtain": 1, "particip": 1, "perform": 1, "predict": 1, "process": 1, "provid": 1, "research": 2, "resourc": 2, "respons": 3, "reveal": 1, "share": 2, "simul": 1, "statist": 1, "step": 1, "store": 1, "studi": 1, "suffici": 1, "system": 4, "technic": 1, "time": 4, "tool": 1, "ultim": 1, "user": 2, "vast": 1, "wish": 1, "mamrak": 1}}, "2952": {"id": "2952", "title": "Functions Realizable with Word-Parallel Logical and Two's-Complement Addition Instructions", "authors": "Warren, H. S. Jr.", "words_pool": ["addit", "complement", "function", "instruct", "logic", "parallel", "realiz", "word", "warren", "jr"], "word_count": {"addit": 1, "complement": 1, "function": 1, "instruct": 1, "logic": 1, "parallel": 1, "realiz": 1, "word": 1, "warren": 1, "jr": 1}}, "2953": {"id": "2953", "title": "Notes on Recursion Elimination", "abstract": "Various methods of recursion elimination are applied to the schematic recursive procedure:  proc S(x); px then N(x); S(fx); S(gx); M(x) fi.  Procedures with this general form arise in connection  with tree traversal and sorting algorithms.  Each method of recursion removal involves the use of one  or more stacks, and the solutions are compared on the basis of their running time.", "authors": "Bird, R. S.", "words_pool": ["algorithm", "appli", "aris", "basi", "compar", "connect", "elimin", "fi", "form", "fx", "gener", "gx", "involv", "method", "method", "note", "proc", "procedur", "procedur", "px", "recurs", "recurs", "remov", "run", "schemat", "solut", "sort", "stack", "time", "travers", "tree", "bird"], "word_count": {"algorithm": 1, "appli": 1, "aris": 1, "basi": 1, "compar": 1, "connect": 1, "elimin": 1, "fi": 1, "form": 1, "fx": 1, "gener": 1, "gx": 1, "involv": 1, "method": 2, "note": 1, "proc": 1, "procedur": 2, "px": 1, "recurs": 3, "remov": 1, "run": 1, "schemat": 1, "solut": 1, "sort": 1, "stack": 1, "time": 1, "travers": 1, "tree": 1, "bird": 1}}, "2954": {"id": "2954", "title": "A Bounded Storage Algorithm for Copying Cyclic Structures", "abstract": "A new algorithm is presented which copies cyclic list structures using bounded workspace and  linear time. Unlike a previous similar algorithm, this one makes no assumptions about the storage allocation  system in use and uses only operations likely to be available in a high-level language.  The distinctive  feature of this algorithm is a technique for traversing the structure twice, using the same spanning  tree in each case, first from left to right and then from right to left.", "authors": "Robson J. M.", "words_pool": ["algorithm", "alloc", "assumpt", "bound", "case", "copi", "copi", "cyclic", "distinct", "featur", "high", "languag", "left", "level", "like", "linear", "list", "make", "oper", "present", "previou", "similar", "span", "storag", "structur", "structur", "system", "techniqu", "time", "travers", "tree", "unlik", "workspac", "robson"], "word_count": {"algorithm": 3, "alloc": 1, "assumpt": 1, "bound": 1, "case": 1, "copi": 1, "cyclic": 1, "distinct": 1, "featur": 1, "high": 1, "languag": 1, "left": 2, "level": 1, "like": 1, "linear": 1, "list": 1, "make": 1, "oper": 1, "present": 1, "previou": 1, "similar": 1, "span": 1, "storag": 1, "structur": 2, "system": 1, "techniqu": 1, "time": 1, "travers": 1, "tree": 1, "unlik": 1, "workspac": 1, "robson": 1}}, "2955": {"id": "2955", "title": "Buddy Systems", "abstract": "Two algorithms are presented for implementing any of a class of buddy systems for dynamic storage  allocation.  Each buddy system corresponds to a set of recurrence relations which relate the block sizes  provided to each other. Analyses of the in ternal fragmentation of the binary buddy system, the Fibonacci  buddy system, and the weighted buddy system are given. Comparative simulation results are also presented  for in ternal, external, and total fragmentation.", "authors": "Peterson, J. L. Norman, T. A.", "words_pool": ["algorithm", "alloc", "analys", "binari", "block", "buddi", "class", "compar", "correspond", "dynam", "extern", "fibonacci", "fragment", "implement", "present", "provid", "recurr", "relat", "relat", "result", "set", "simul", "size", "storag", "system", "system", "ternal", "total", "weight", "peterson", "norman"], "word_count": {"algorithm": 1, "alloc": 1, "analys": 1, "binari": 1, "block": 1, "buddi": 5, "class": 1, "compar": 1, "correspond": 1, "dynam": 1, "extern": 1, "fibonacci": 1, "fragment": 2, "implement": 1, "present": 2, "provid": 1, "recurr": 1, "relat": 2, "result": 1, "set": 1, "simul": 1, "size": 1, "storag": 1, "system": 5, "ternal": 2, "total": 1, "weight": 1, "peterson": 1, "norman": 1}}, "2956": {"id": "2956", "title": "Some Ideas on Data Types in High-Level Languages", "abstract": "A number of issues are explored concerning the notion that a data type is a set of values together  with a set of primitive operations on those values.  Among these are the need for a notation for iterating  over the elements of any finite set (instead of the more narrow for i:= 1 to n notation), the use of  the domain of an array as a data type, the need for a simple notation for allowing types of parameters  to be themselves parameters (but in a restrictive fashion), and resulting problems with conversion of  values from one type to another.", "authors": "Gries, D. Gehani, N.", "words_pool": ["allow", "array", "concern", "convers", "data", "domain", "element", "explor", "fashion", "finit", "high", "idea", "issu", "iter", "languag", "level", "narrow", "need", "notat", "notion", "number", "oper", "paramet", "primit", "problem", "restrict", "result", "set", "simpl", "type", "type", "valu", "gri", "gehani"], "word_count": {"allow": 1, "array": 1, "concern": 1, "convers": 1, "data": 2, "domain": 1, "element": 1, "explor": 1, "fashion": 1, "finit": 1, "high": 1, "idea": 1, "issu": 1, "iter": 1, "languag": 1, "level": 1, "narrow": 1, "need": 2, "notat": 3, "notion": 1, "number": 1, "oper": 1, "paramet": 2, "primit": 1, "problem": 1, "restrict": 1, "result": 1, "set": 3, "simpl": 1, "type": 4, "valu": 3, "gri": 1, "gehani": 1}}, "2957": {"id": "2957", "title": "Database Abstractions: Aggregation", "abstract": "Aggregation is in troduced as an abstraction which is important in conceptualizing the real  world.  Aggregation transforms a relationship between objects into a higher-level object.  A new data  type, called aggregation, is developed which, under certain criteria of \"well-definedness,\" specifies  aggregation abstractions.  Relational databases defined as collections of aggregates are structured as  a hierarchy on n-ary relations.  To main tain well-definedness, update operations on such databases must  preserve two invariants.  Well-defined relations are distinct from relations in third normal form.  It  is shown that these notions are complementary and both are important in database design.  A top-down  methodology for database design is described which separates decisions concerning aggregate structure  from decisions concerning key identification.  It is suggested that aggregate types, and other types  which support real-world abstractions without in troducing implementation detail, should be incorporated  into programming languages.", "authors": "Smith, J. M. Smith, D. C. P.", "words_pool": ["abstract", "abstract", "aggreg", "aggreg", "aggreg", "ari", "call", "collect", "complementari", "conceptu", "concern", "criteria", "data", "databas", "databas", "decis", "defin", "defined", "design", "detail", "develop", "distinct", "form", "hierarchi", "higher", "identif", "implement", "import", "incorpor", "invari", "key", "languag", "level", "main", "methodolog", "normal", "notion", "object", "object", "oper", "preserv", "program", "real", "relat", "relat", "relationship", "separ", "shown", "specifi", "structur", "structur", "suggest", "support", "tain", "top", "transform", "troduc", "troduc", "type", "type", "updat", "world", "smith", "smith"], "word_count": {"abstract": 3, "aggreg": 7, "ari": 1, "call": 1, "collect": 1, "complementari": 1, "conceptu": 1, "concern": 2, "criteria": 1, "data": 1, "databas": 4, "decis": 2, "defin": 2, "defined": 2, "design": 2, "detail": 1, "develop": 1, "distinct": 1, "form": 1, "hierarchi": 1, "higher": 1, "identif": 1, "implement": 1, "import": 2, "incorpor": 1, "invari": 1, "key": 1, "languag": 1, "level": 1, "main": 1, "methodolog": 1, "normal": 1, "notion": 1, "object": 2, "oper": 1, "preserv": 1, "program": 1, "real": 2, "relat": 4, "relationship": 1, "separ": 1, "shown": 1, "specifi": 1, "structur": 2, "suggest": 1, "support": 1, "tain": 1, "top": 1, "transform": 1, "troduc": 2, "type": 3, "updat": 1, "world": 2, "smith": 1}}, "2958": {"id": "2958", "title": "Abstract Data Types and the Development of Data Structures", "abstract": "Abstract data types can play a significant role in the development of software that is reliable,  efficient, and flexible.  This paper presents and discusses the application of an algebraic technique  for the specification of abstract data types.  Among the examples presented is a top-down development  of a symbol table for a block structured language; a discussion of the proof of its correctness is given.   The paper also contains a brief discussion of the problems involved in constructing algebraic specifications  that are both consistent and complete.", "authors": "Guttag, J.", "words_pool": ["abstract", "algebra", "applic", "block", "complet", "consist", "construct", "correct", "data", "develop", "discuss", "discuss", "effici", "exampl", "flexibl", "involv", "languag", "paper", "play", "present", "present", "problem", "proof", "reliabl", "role", "signific", "softwar", "specif", "specif", "structur", "structur", "symbol", "tabl", "techniqu", "top", "type", "guttag"], "word_count": {"abstract": 2, "algebra": 2, "applic": 1, "block": 1, "complet": 1, "consist": 1, "construct": 1, "correct": 1, "data": 2, "develop": 2, "discuss": 3, "effici": 1, "exampl": 1, "flexibl": 1, "involv": 1, "languag": 1, "paper": 2, "play": 1, "present": 2, "problem": 1, "proof": 1, "reliabl": 1, "role": 1, "signific": 1, "softwar": 1, "specif": 2, "structur": 1, "symbol": 1, "tabl": 1, "techniqu": 1, "top": 1, "type": 2, "guttag": 1}}, "2959": {"id": "2959", "title": "The System for Business Automation (SBA): Programming Language", "abstract": "The system for business automation (SBA) is a system within which application experts-nonprogrammers-can  describe and execute their applications on a computer.  The user of SBA views his application as manipulation  of information in two-dimensional pictures of tables, business forms, and reports on a display terminal.   He can gradually automate this application by giving \"examples\" to the system of how he manually manipulates  the information.  The Query-by-Example database language is a subset of the SBA programming language.", "authors": "Zloof, M. M. de Jong, S. P.", "words_pool": ["applic", "applic", "autom", "autom", "busi", "comput", "databas", "describ", "dimension", "display", "exampl", "execut", "expert", "form", "give", "gradual", "inform", "languag", "manipul", "manipul", "manual", "nonprogramm", "pictur", "program", "queri", "report", "sba", "subset", "system", "tabl", "termin", "user", "view", "zloof", "de", "jong"], "word_count": {"applic": 4, "autom": 2, "busi": 2, "comput": 1, "databas": 1, "describ": 1, "dimension": 1, "display": 1, "exampl": 1, "execut": 1, "expert": 1, "form": 1, "give": 1, "gradual": 1, "inform": 2, "languag": 2, "manipul": 2, "manual": 1, "nonprogramm": 1, "pictur": 1, "program": 1, "queri": 1, "report": 1, "sba": 3, "subset": 1, "system": 3, "tabl": 1, "termin": 1, "user": 1, "view": 1, "zloof": 1, "de": 1, "jong": 1}}, "2960": {"id": "2960", "title": "Two Views of Data Abstraction", "authors": "Ledgard, H. F. Taylor, R. W.", "words_pool": ["abstract", "data", "view", "ledgard", "taylor"], "word_count": {"abstract": 1, "data": 1, "view": 1, "ledgard": 1, "taylor": 1}}, "2961": {"id": "2961", "title": "Experimental Investigations of the Utility of Detailed Flowcharts in Programming", "abstract": "This paper describes previous research on flowcharts and a series of controlled experiments  to test the utility of detailed flowcharts as an aid to program composition, comprehension, debugging,  and modification.  No statistically significant difference between flowchart and nonflowchart groups  has been shown, thereby calling into question the utility of detailed flowcharting.  A program of further  research is suggested.", "authors": "Shneiderman, B. Mayer, R. McKay, D. Heller, P.", "words_pool": ["aid", "call", "composit", "comprehens", "control", "debug", "describ", "detail", "differ", "experiment", "experi", "flowchart", "flowchart", "flowchart", "group", "investig", "modif", "nonflowchart", "paper", "previou", "program", "program", "question", "research", "seri", "shown", "signific", "statist", "suggest", "test", "util", "shneiderman", "mayer", "mckay", "heller"], "word_count": {"aid": 1, "call": 1, "composit": 1, "comprehens": 1, "control": 1, "debug": 1, "describ": 1, "detail": 2, "differ": 1, "experiment": 1, "experi": 1, "flowchart": 4, "group": 1, "investig": 1, "modif": 1, "nonflowchart": 1, "paper": 1, "previou": 1, "program": 2, "question": 1, "research": 2, "seri": 1, "shown": 1, "signific": 1, "statist": 1, "suggest": 1, "test": 1, "util": 2, "shneiderman": 1, "mayer": 1, "mckay": 1, "heller": 1}}, "2962": {"id": "2962", "title": "Production and Employment of Ph.D.'s in Computer Science-1976", "abstract": "Statistics are presented on the production and employment of Ph.D.'s in computer science for  the calendar year 1975-76.  Data include profiles of graduate students and of faculty at 60 Ph.D.-producing  departments as well as a breakdown of degrees granted by specialty areas.  Significant trends are noted  and comparisons with comparable data gathered for the 1974-75 calendar year are made.", "authors": "Taulbee, O. E. Conte, S. D.", "words_pool": ["area", "breakdown", "calendar", "compar", "comparison", "comput", "data", "degre", "depart", "employ", "faculti", "gather", "graduat", "grant", "includ", "made", "note", "ph", "present", "produc", "product", "profil", "scienc", "signific", "specialti", "statist", "student", "trend", "year", "taulbe", "cont"], "word_count": {"area": 1, "breakdown": 1, "calendar": 2, "compar": 1, "comparison": 1, "comput": 1, "data": 2, "degre": 1, "depart": 1, "employ": 1, "faculti": 1, "gather": 1, "graduat": 1, "grant": 1, "includ": 1, "made": 1, "note": 1, "ph": 2, "present": 1, "produc": 1, "product": 1, "profil": 1, "scienc": 1, "signific": 1, "specialti": 1, "statist": 1, "student": 1, "trend": 1, "year": 2, "taulbe": 1, "cont": 1}}, "2963": {"id": "2963", "title": "A Fast Algorithm for Computing Longest Common Subsequences", "abstract": "Previously published algorithms for finding the longest common subsequence of two sequences  of length n have had a best-case running time of O(n^2).  An algorithm for this problem is presented  which has a running time of O((r + n)log n), where r is the total number of ordered pairs of positions  at which the two sequences match.  Thus in the worst case the algorithm has a running time of O(n^2 log  n).  However, for those applications where most positions of one sequence match relatively few positions  in the other sequence, a running time of O(n log n) can be expected.", "authors": "Hunt, J. W. Szymanski, T. G.", "words_pool": ["algorithm", "algorithm", "applic", "case", "common", "comput", "expect", "fast", "find", "length", "log", "longest", "match", "number", "order", "pair", "posit", "present", "previous", "problem", "publish", "run", "sequenc", "sequenc", "subsequ", "subsequ", "time", "total", "worst", "hunt", "szymanski"], "word_count": {"algorithm": 3, "applic": 1, "case": 2, "common": 1, "comput": 1, "expect": 1, "fast": 1, "find": 1, "length": 1, "log": 3, "longest": 1, "match": 2, "number": 1, "order": 1, "pair": 1, "posit": 3, "present": 1, "previous": 1, "problem": 1, "publish": 1, "run": 4, "sequenc": 4, "subsequ": 1, "time": 4, "total": 1, "worst": 1, "hunt": 1, "szymanski": 1}}, "2964": {"id": "2964", "title": "An Approach to Optimal Design of Storage Parameters in Databases", "authors": "Milman, Y.", "words_pool": ["approach", "databas", "design", "optim", "paramet", "storag", "milman"], "word_count": {"approach": 1, "databas": 1, "design": 1, "optim": 1, "paramet": 1, "storag": 1, "milman": 1}}, "2965": {"id": "2965", "title": "An Optimal Evaluation of Boolean Expressions in an Online Query System", "authors": "Hanani, M. Z.", "words_pool": ["boolean", "evalu", "express", "onlin", "optim", "queri", "system", "hanani"], "word_count": {"boolean": 1, "evalu": 1, "express": 1, "onlin": 1, "optim": 1, "queri": 1, "system": 1, "hanani": 1}}, "2966": {"id": "2966", "title": "The Choice of Reference Poin ts in Best-Match File Searching", "abstract": "Improvements to the exhaustive search method of best-match file searching have previously been  achieved by doing a preprocessing step involving the calculation of distances from a reference poin t.    This paper discusses the proper choice of reference poin ts and extends the previous algorithm to use  more than one reference poin t.  It is shown that reference poin ts should be located outside of data clusters.   The results of computer simulations are presented which show that large improvements can be achieved  by the proper choice and location of multiple reference poin ts.", "authors": "Shapiro, M.", "words_pool": ["achiev", "algorithm", "calcul", "choic", "cluster", "comput", "data", "discuss", "distanc", "exhaust", "extend", "improv", "involv", "larg", "locat", "locat", "match", "method", "multipl", "paper", "poin", "preprocess", "present", "previou", "previous", "proper", "refer", "result", "search", "search", "show", "shown", "simul", "step", "ts", "shapiro"], "word_count": {"achiev": 2, "algorithm": 1, "calcul": 1, "choic": 2, "cluster": 1, "comput": 1, "data": 1, "discuss": 1, "distanc": 1, "exhaust": 1, "extend": 1, "improv": 2, "involv": 1, "larg": 1, "locat": 2, "match": 1, "method": 1, "multipl": 1, "paper": 1, "poin": 5, "preprocess": 1, "present": 1, "previou": 1, "previous": 1, "proper": 2, "refer": 5, "result": 1, "search": 2, "show": 1, "shown": 1, "simul": 1, "step": 1, "ts": 3, "shapiro": 1}}, "2967": {"id": "2967", "title": "A Comparison of Hardware and Software Associative Memories in the Context of Computer Graphics", "abstract": "The Associative Processing of Line Drawings (APLD) System utilizes a hardware associative memory  and creates, modifies, deletes, stores, and retrieves two-dimensional line drawings consisting of poin ts, lines, rectangles, and triangles. The APLD functions were duplicated on the TX-2 computer at M", "words_pool": ["apld", "associ", "comparison", "comput", "consist", "context", "creat", "delet", "dimension", "draw", "duplic", "function", "graphic", "hardwar", "line", "line", "memori", "memori", "modifi", "poin", "process", "rectangl", "retriev", "softwar", "store", "system", "triangl", "ts", "tx", "util"], "word_count": {"apld": 2, "associ": 2, "comparison": 1, "comput": 1, "consist": 1, "context": 1, "creat": 1, "delet": 1, "dimension": 1, "draw": 2, "duplic": 1, "function": 1, "graphic": 1, "hardwar": 1, "line": 3, "memori": 1, "modifi": 1, "poin": 1, "process": 1, "rectangl": 1, "retriev": 1, "softwar": 1, "store": 1, "system": 1, "triangl": 1, "ts": 1, "tx": 1, "util": 1}}, "2968": {"id": "2968", "title": "A Comparison of Tree-Balancing Algorithms", "abstract": "Several algorithms-height-balance (i.e. AVL and extensions), weight-balance (i.e. BB and WB),  and total restructuring-for building balanced binary search trees are compared.  The criteria for comparison  encompass theoretical aspects (e.g. path lengths) and implementation independent and machine/algorithm-dependent  measures (e.g. run time).  A detailed analysis of code is also presented at a level believed to be language-and  compiler-independent.  The quality of the resulting trees and the overhead spent on building them are  analyzed, and some guidelines are given for an efficient use of the methods.  If insertion and subsequent  queries are the only operations of in terest, then \"pure\" AVL trees present the overall best qualities.", "authors": "Baer, J. L. Schwab, B.", "words_pool": ["algorithm", "algorithm", "analysi", "analyz", "aspect", "avl", "balanc", "balanc", "balanc", "bb", "believ", "binari", "build", "code", "compar", "comparison", "compil", "criteria", "depend", "detail", "effici", "encompass", "extens", "guidelin", "height", "implement", "independ", "insert", "languag", "length", "level", "machin", "measur", "method", "oper", "overhead", "path", "present", "present", "pure", "qualiti", "qualiti", "queri", "restructur", "result", "run", "search", "spent", "subsequ", "terest", "theoret", "time", "total", "tree", "tree", "wb", "weight", "baer", "schwab"], "word_count": {"algorithm": 2, "analysi": 1, "analyz": 1, "aspect": 1, "avl": 2, "balanc": 3, "bb": 1, "believ": 1, "binari": 1, "build": 2, "code": 1, "compar": 1, "comparison": 1, "compil": 1, "criteria": 1, "depend": 1, "detail": 1, "effici": 1, "encompass": 1, "extens": 1, "guidelin": 1, "height": 1, "implement": 1, "independ": 2, "insert": 1, "languag": 1, "length": 1, "level": 1, "machin": 1, "measur": 1, "method": 1, "oper": 1, "overhead": 1, "path": 1, "present": 2, "pure": 1, "qualiti": 2, "queri": 1, "restructur": 1, "result": 1, "run": 1, "search": 1, "spent": 1, "subsequ": 1, "terest": 1, "theoret": 1, "time": 1, "total": 1, "tree": 3, "wb": 1, "weight": 1, "baer": 1, "schwab": 1}}, "2969": {"id": "2969", "title": "Optimal Program and Data Locations in Computer Networks", "abstract": "An optimization procedure for the allocation of program and data files in a computer network  is presented.  This algorithm takes into account the dependencies between files and programs such as  occur in real heterogeneous computer networks.  Insights into whether or not to convert programs from  one computer to another can also be gained from the model.  A search procedure for the file location  problem is described, along with an example and a possible application of the model.", "authors": "Morgan, H. L. Levin, K. D.", "words_pool": ["account", "algorithm", "alloc", "applic", "comput", "convert", "data", "depend", "gain", "heterogen", "insight", "locat", "locat", "model", "network", "network", "occur", "optim", "optim", "present", "problem", "procedur", "program", "program", "real", "search", "take", "morgan", "levin"], "word_count": {"account": 1, "algorithm": 1, "alloc": 1, "applic": 1, "comput": 3, "convert": 1, "data": 1, "depend": 1, "gain": 1, "heterogen": 1, "insight": 1, "locat": 1, "model": 2, "network": 2, "occur": 1, "optim": 1, "present": 1, "problem": 1, "procedur": 2, "program": 3, "real": 1, "search": 1, "take": 1, "morgan": 1, "levin": 1}}, "2970": {"id": "2970", "title": "Achieving Specific Accuracy in Simulation Output Analysis", "abstract": "This paper extends the use of the regenerative property of queueing systems in the analysis  of simulation output.  In particular, it describes a sequential estimation method which when used with  the regenerative property allows results to be obtained with specified statistical accuracy.  This method  includes a test to check the normality assumption on which the sequential procedure relies.  The paper  illustrates the method using the empty and idle state as the regenerative state.  A second example then  describes how using the most frequently entered state as the regenerative state reduces the chance of  making a costly error in a preliminary simulation run.  The paper also described how a variance reduction  method due to Page [9] can be used to obtain a specified accuracy with considerably fewer job completions  than are required when no variance reduction technique is applied.", "authors": "Fishman, G. S.", "words_pool": ["accuraci", "achiev", "analysi", "appli", "assumpt", "chanc", "check", "complet", "consider", "costli", "describ", "due", "empti", "enter", "error", "estim", "extend", "fewer", "frequent", "idl", "illustr", "includ", "job", "make", "method", "normal", "obtain", "obtain", "output", "page", "paper", "preliminari", "procedur", "properti", "queue", "reduc", "reduct", "regen", "reli", "requir", "result", "run", "sequenti", "simul", "specif", "state", "statist", "system", "techniqu", "test", "varianc", "fishman"], "word_count": {"accuraci": 2, "achiev": 1, "analysi": 1, "appli": 1, "assumpt": 1, "chanc": 1, "check": 1, "complet": 1, "consider": 1, "costli": 1, "describ": 2, "due": 1, "empti": 1, "enter": 1, "error": 1, "estim": 1, "extend": 1, "fewer": 1, "frequent": 1, "idl": 1, "illustr": 1, "includ": 1, "job": 1, "make": 1, "method": 4, "normal": 1, "obtain": 2, "output": 1, "page": 1, "paper": 3, "preliminari": 1, "procedur": 1, "properti": 2, "queue": 1, "reduc": 1, "reduct": 2, "regen": 4, "reli": 1, "requir": 1, "result": 1, "run": 1, "sequenti": 2, "simul": 2, "specif": 1, "state": 4, "statist": 1, "system": 1, "techniqu": 1, "test": 1, "varianc": 2, "fishman": 1}}, "2971": {"id": "2971", "title": "SP/k: A System for Teaching Computer Programming", "abstract": "SP/k is a compatible subset of the PL/I  language that has been designed for teaching programming.  The features of the SP/k language were chosen to encourage structured problem solving by computers, to  make the language easy to learn and use, to eliminate confusing and redundant constructs, and to make  the language easy to compile.  The resulting language is suitable for in troducing programming concepts  used in various applications, including business data processing, scientific calculations and non-numeric  computation.  SP/k is actually a sequence of language subsets called SP/1, SP/2,...SP/8.  Each subset  in troduces new programming language constructs while retaining all the constructs of preceding subsets.  Each subset is precisely defined and can be learned or implemented without the following subsets.", "authors": "Holt, R. C. Wortman, D. B. Barnard, D. T. Cordy, J. R.", "words_pool": ["actual", "applic", "busi", "calcul", "call", "chosen", "compat", "compil", "comput", "comput", "comput", "concept", "confus", "construct", "data", "defin", "design", "easi", "elimin", "encourag", "featur", "implement", "includ", "languag", "learn", "learn", "make", "non", "numer", "pl", "preced", "precis", "problem", "process", "program", "redund", "result", "retain", "scientif", "sequenc", "solv", "sp", "structur", "subset", "subset", "suitabl", "system", "teach", "troduc", "troduc", "holt", "wortman", "barnard", "cordi"], "word_count": {"actual": 1, "applic": 1, "busi": 1, "calcul": 1, "call": 1, "chosen": 1, "compat": 1, "compil": 1, "comput": 2, "concept": 1, "confus": 1, "construct": 3, "data": 1, "defin": 1, "design": 1, "easi": 2, "elimin": 1, "encourag": 1, "featur": 1, "implement": 1, "includ": 1, "languag": 7, "learn": 2, "make": 2, "non": 1, "numer": 1, "pl": 1, "preced": 1, "precis": 1, "problem": 1, "process": 1, "program": 3, "redund": 1, "result": 1, "retain": 1, "scientif": 1, "sequenc": 1, "solv": 1, "sp": 6, "structur": 1, "subset": 6, "suitabl": 1, "system": 1, "teach": 1, "troduc": 2, "holt": 1, "wortman": 1, "barnard": 1, "cordi": 1}}, "2972": {"id": "2972", "title": "Proof Techniques for Hierarchically Structured Programs", "abstract": "A method for describing and structuring programs that simplifies proofs of their correctness  is presented.  The method formally represents a program in terms of levels of abstraction, each level  of which can be described by a self-contained nonprocedural specification.  The proofs, like the programs,  are structured by levels.  Although only manual proofs are described in the paper, the method is also  applicable to semi-automatic and automatic proofs.  Preliminary results are encouraging, indicating that  the method can be applied to large programs, such as operating systems.", "authors": "Robinson, L. Levitt, K. N.", "words_pool": ["abstract", "applic", "appli", "automat", "contain", "correct", "describ", "encourag", "formal", "hierarch", "indic", "larg", "level", "level", "method", "nonprocedur", "oper", "paper", "preliminari", "present", "program", "program", "proof", "proof", "repres", "result", "semi", "simplifi", "specif", "structur", "structur", "system", "techniqu", "term", "robinson", "levitt"], "word_count": {"abstract": 1, "applic": 1, "appli": 1, "automat": 2, "contain": 1, "correct": 1, "describ": 1, "encourag": 1, "formal": 1, "hierarch": 1, "indic": 1, "larg": 1, "level": 3, "method": 4, "nonprocedur": 1, "oper": 1, "paper": 1, "preliminari": 1, "present": 1, "program": 4, "proof": 4, "repres": 1, "result": 1, "semi": 1, "simplifi": 1, "specif": 1, "structur": 2, "system": 1, "techniqu": 1, "term": 1, "robinson": 1, "levitt": 1}}, "2973": {"id": "2973", "title": "Sorting on a Mesh-Connected Parallel Computer", "abstract": "Two algorithms are presented for sorting n^2 elements on an n X n mesh-connected processor  array that require O(n) routing and comparison steps.  The best previous algorithm takes time O(n log  n).  The algorithms of this paper are shown to be optimal in time within small constant factors.  Extensions  to higher-dimensional arrays are also given.", "authors": "Thompson, C. D. Kung, H. T.", "words_pool": ["algorithm", "algorithm", "array", "array", "comparison", "comput", "connect", "constant", "dimension", "element", "extens", "factor", "higher", "log", "mesh", "optim", "paper", "parallel", "present", "previou", "processor", "requir", "rout", "shown", "small", "sort", "step", "take", "time", "thompson", "kung"], "word_count": {"algorithm": 3, "array": 2, "comparison": 1, "comput": 1, "connect": 1, "constant": 1, "dimension": 1, "element": 1, "extens": 1, "factor": 1, "higher": 1, "log": 1, "mesh": 1, "optim": 1, "paper": 1, "parallel": 1, "present": 1, "previou": 1, "processor": 1, "requir": 1, "rout": 1, "shown": 1, "small": 1, "sort": 1, "step": 1, "take": 1, "time": 2, "thompson": 1, "kung": 1}}, "2974": {"id": "2974", "title": "Comment on Weighted Increment Linear Search for Scatter Tables", "authors": "Bandyopadhyay, S. K.", "words_pool": ["comment", "increment", "linear", "scatter", "search", "tabl", "weight", "bandyopadhyay"], "word_count": {"comment": 1, "increment": 1, "linear": 1, "scatter": 1, "search": 1, "tabl": 1, "weight": 1, "bandyopadhyay": 1}}, "2975": {"id": "2975", "title": "Remark on Uniform Insertion in Structured Data Structures", "authors": "Hollander, C.R.", "words_pool": ["data", "insert", "remark", "structur", "structur", "uniform", "holland"], "word_count": {"data": 1, "insert": 1, "remark": 1, "structur": 2, "uniform": 1, "holland": 1}}, "2976": {"id": "2976", "title": "Approximating Block Accesses in Database Organizations", "authors": "Yao, S. B.", "words_pool": ["access", "approxim", "block", "databas", "organ", "yao"], "word_count": {"access": 1, "approxim": 1, "block": 1, "databas": 1, "organ": 1, "yao": 1}}, "2977": {"id": "2977", "title": "The Stage Hypothesis and the S-Curve: Some Contradictory Evidence", "abstract": "This paper presents the results of a study testing the s-shaped budget curve of Nolan's stage  model of computer development in an organization.  Research on the data processing budgets of California  counties fails to support the s-shaped curve or the use of budgets as a basis for a stage model.  However,  the results do not invalidate the concept of a stage model.  The analysis suggests an alternative model  of budget growth and a separation between models of budgeting growth and growth stages in the development  of the computer resource.", "authors": "Lucac, H. C. Jr. Sutton, J. A.", "words_pool": ["altern", "analysi", "basi", "budget", "budget", "budget", "california", "comput", "concept", "contradictori", "counti", "curv", "data", "develop", "evid", "fail", "growth", "hypothesi", "invalid", "model", "model", "nolan", "organ", "paper", "present", "process", "research", "resourc", "result", "separ", "shape", "stage", "stage", "studi", "suggest", "support", "test", "lucac", "jr", "sutton"], "word_count": {"altern": 1, "analysi": 1, "basi": 1, "budget": 5, "california": 1, "comput": 2, "concept": 1, "contradictori": 1, "counti": 1, "curv": 2, "data": 1, "develop": 2, "evid": 1, "fail": 1, "growth": 3, "hypothesi": 1, "invalid": 1, "model": 5, "nolan": 1, "organ": 1, "paper": 1, "present": 1, "process": 1, "research": 1, "resourc": 1, "result": 2, "separ": 1, "shape": 2, "stage": 4, "studi": 1, "suggest": 1, "support": 1, "test": 1, "lucac": 1, "jr": 1, "sutton": 1}}, "2978": {"id": "2978", "title": "Analysis of Design Alternatives for Virtual Memory Indexes", "abstract": "A class of index structures for use in a virtual memory environment is described.  Design alternatives  within this class of index structures are analyzed.  These alternatives include a choice of search strategy,  whether or not pages in the index are structured, and whether or not keys are compressed.  The average  cost of retrieving entries from these indexes is expressed as a wieghted sum of the cost of a basic key  comparison and the cost of crossing a page boundary in the index structure.  Formulas for the retrieval  costs for possible combinations of design alternatives are given.  These are used in numerical case studies  which compare the retrieval costs of the alternatives.  Qualitative comparisons of the main tenance costs  (insertion, deletion, reorganization) of the design alternatives are also included.", "authors": "Maruyama, K. Smith, S. E.", "words_pool": ["altern", "analysi", "analyz", "averag", "basic", "boundari", "case", "choic", "class", "combin", "compar", "comparison", "comparison", "compress", "cost", "cost", "cross", "delet", "design", "entri", "environ", "express", "formula", "includ", "includ", "index", "index", "insert", "key", "key", "main", "memori", "numer", "page", "page", "qualit", "reorgan", "retriev", "retriev", "search", "strategi", "structur", "structur", "structur", "studi", "sum", "tenanc", "virtual", "wieght", "maruyama", "smith"], "word_count": {"altern": 5, "analysi": 1, "analyz": 1, "averag": 1, "basic": 1, "boundari": 1, "case": 1, "choic": 1, "class": 2, "combin": 1, "compar": 1, "comparison": 2, "compress": 1, "cost": 6, "cross": 1, "delet": 1, "design": 3, "entri": 1, "environ": 1, "express": 1, "formula": 1, "includ": 2, "index": 5, "insert": 1, "key": 2, "main": 1, "memori": 1, "numer": 1, "page": 2, "qualit": 1, "reorgan": 1, "retriev": 3, "search": 1, "strategi": 1, "structur": 4, "studi": 1, "sum": 1, "tenanc": 1, "virtual": 1, "wieght": 1, "maruyama": 1, "smith": 1}}, "2979": {"id": "2979", "title": "Studies in Machine Cognition Using The Game of Poker", "abstract": "A progress report is presented of on-going research efforts concerning human decision making  under uncertainly and risk and human problem solving and learning processes on the one hand, and machine  learning, large scale programming systems, and novel programming techniques on the other.  There has  also been in terest in how humans make deductive and inductive inferences and form and optimize heuristic  rules, and how machines can reach similar results.  Although the vehicle of these investigations has  been the game of poker, a conceptual framework has been provided that should have a fairly wide range  of applicability.  The models of human judgment, choice, and decision making are incorporated in a large  scale complex program.  They represent both descriptive and normative theories of behavior. An in teractive  game environment has been recently established which, besides its usefulness for experiments in game  playing, enables humans to construct machine strategies \"on-line\" in a question answering, advice taking  mode.", "authors": "Findler, N. V.", "words_pool": ["advic", "answer", "applic", "behavior", "choic", "cognit", "complex", "conceptu", "concern", "construct", "decis", "deduct", "descript", "effort", "enabl", "environ", "establish", "experi", "fairli", "form", "framework", "game", "go", "hand", "heurist", "human", "human", "incorpor", "induct", "infer", "investig", "judgment", "larg", "learn", "line", "machin", "machin", "make", "make", "mode", "model", "norm", "optim", "play", "poker", "present", "problem", "process", "program", "program", "progress", "provid", "question", "rang", "reach", "recent", "report", "repres", "research", "result", "risk", "rule", "scale", "similar", "solv", "strategi", "studi", "system", "take", "techniqu", "teract", "terest", "theori", "uncertainli", "use", "vehicl", "wide", "findler"], "word_count": {"advic": 1, "answer": 1, "applic": 1, "behavior": 1, "choic": 1, "cognit": 1, "complex": 1, "conceptu": 1, "concern": 1, "construct": 1, "decis": 2, "deduct": 1, "descript": 1, "effort": 1, "enabl": 1, "environ": 1, "establish": 1, "experi": 1, "fairli": 1, "form": 1, "framework": 1, "game": 3, "go": 1, "hand": 1, "heurist": 1, "human": 5, "incorpor": 1, "induct": 1, "infer": 1, "investig": 1, "judgment": 1, "larg": 2, "learn": 2, "line": 1, "machin": 3, "make": 3, "mode": 1, "model": 1, "norm": 1, "optim": 1, "play": 1, "poker": 1, "present": 1, "problem": 1, "process": 1, "program": 3, "progress": 1, "provid": 1, "question": 1, "rang": 1, "reach": 1, "recent": 1, "report": 1, "repres": 1, "research": 1, "result": 1, "risk": 1, "rule": 1, "scale": 2, "similar": 1, "solv": 1, "strategi": 1, "studi": 1, "system": 1, "take": 1, "techniqu": 1, "teract": 1, "terest": 1, "theori": 1, "uncertainli": 1, "use": 1, "vehicl": 1, "wide": 1, "findler": 1}}, "2980": {"id": "2980", "title": "The Editing  of Picture Segmentations Using Local Analysis of Graphs", "abstract": "A major problem in picture processing is the elimination of the large number of spurious regions  that result from an initial segmentation by region growing techniques.  Such regions have been eliminated  either on the basis of semantic information or on the basis of size and contrast.  A scheme is presented  which performs eliminations on the basis of local properties of the region adjacency graph.  The scheme  is based on definitions of graph properties which are satisfied when a spurious region is present; then  editing is equivalent to fast graph operations.  A number of examples are shown.", "authors": "Tanimoto, S. L. Pavlidis, T.", "words_pool": ["adjac", "analysi", "base", "basi", "contrast", "definit", "edit", "elimin", "elimin", "elimin", "equival", "exampl", "fast", "graph", "graph", "grow", "inform", "initi", "larg", "local", "major", "number", "oper", "perform", "pictur", "present", "present", "problem", "process", "properti", "region", "region", "result", "satisfi", "scheme", "segment", "segment", "semant", "shown", "size", "spuriou", "techniqu", "tanimoto", "pavlidi"], "word_count": {"adjac": 1, "analysi": 1, "base": 1, "basi": 3, "contrast": 1, "definit": 1, "edit": 1, "elimin": 3, "equival": 1, "exampl": 1, "fast": 1, "graph": 3, "grow": 1, "inform": 1, "initi": 1, "larg": 1, "local": 1, "major": 1, "number": 2, "oper": 1, "perform": 1, "pictur": 1, "present": 2, "problem": 1, "process": 1, "properti": 2, "region": 5, "result": 1, "satisfi": 1, "scheme": 2, "segment": 1, "semant": 1, "shown": 1, "size": 1, "spuriou": 2, "techniqu": 1, "tanimoto": 1, "pavlidi": 1}}, "2981": {"id": "2981", "title": "Subgoal Induction", "abstract": "A proof method, subgoal induction, is presented as an alternative or supplement to the commonly  used inductive assertion method.  Its major virtue is that it can often be used to prove a loop's correctness  directly from its input-output specification without the use of an invariant.  The relation between subgoal  induction and other commonly used induction rules is explored and, in particular, it is shown that subgoal  induction can be viewed as a specialized form of computation induction.  A set of sufficient conditions  are presented which guarantee that an input-output specification is strong enough for the induction steps  of a proof by subgoal induction to be valid.", "authors": "Morris, J. H. Jr. Wegbreit, B.", "words_pool": ["altern", "assert", "commonli", "comput", "condit", "correct", "directli", "explor", "form", "guarante", "induct", "induct", "input", "invari", "loop", "major", "method", "output", "present", "proof", "prove", "relat", "rule", "set", "shown", "special", "specif", "step", "strong", "subgoal", "suffici", "supplement", "valid", "view", "virtu", "morri", "jr", "wegbreit"], "word_count": {"altern": 1, "assert": 1, "commonli": 2, "comput": 1, "condit": 1, "correct": 1, "directli": 1, "explor": 1, "form": 1, "guarante": 1, "induct": 8, "input": 2, "invari": 1, "loop": 1, "major": 1, "method": 2, "output": 2, "present": 2, "proof": 2, "prove": 1, "relat": 1, "rule": 1, "set": 1, "shown": 1, "special": 1, "specif": 2, "step": 1, "strong": 1, "subgoal": 4, "suffici": 1, "supplement": 1, "valid": 1, "view": 1, "virtu": 1, "morri": 1, "jr": 1, "wegbreit": 1}}, "2982": {"id": "2982", "title": "The Storage Requirement in Precedence Parsing", "authors": "Bertsch, E.", "words_pool": ["pars", "preced", "requir", "storag", "bertsch"], "word_count": {"pars": 1, "preced": 1, "requir": 1, "storag": 1, "bertsch": 1}}, "2983": {"id": "2983", "title": "A Comparison of Next-fit, First-fit, and Best-fit", "authors": "Bays, C.", "words_pool": ["comparison", "fit", "bay"], "word_count": {"comparison": 1, "fit": 3, "bay": 1}}, "2984": {"id": "2984", "title": "Cost/Utilization: A Measure of System Performance", "abstract": "A method is presented for evaluating computer system performance in terms of a cost/utilization  factor and a measure of imbalance.  These coefficients indicate the extent to which the total system  cost is effectively utilized.  The method includes a technique for the visual representation of system  performance.", "authors": "Borovits, I. Ein-Dor, P.", "words_pool": ["coeffici", "comput", "cost", "effect", "evalu", "extent", "factor", "imbal", "includ", "measur", "method", "perform", "present", "represent", "system", "techniqu", "term", "total", "util", "util", "visual", "borovit", "ein", "dor"], "word_count": {"coeffici": 1, "comput": 1, "cost": 2, "effect": 1, "evalu": 1, "extent": 1, "factor": 1, "imbal": 1, "includ": 1, "measur": 1, "method": 2, "perform": 2, "present": 1, "represent": 1, "system": 3, "techniqu": 1, "term": 1, "total": 1, "util": 2, "visual": 1, "borovit": 1, "ein": 1, "dor": 1}}, "2985": {"id": "2985", "title": "Effects of Chargeout on User/Manager Attitudes", "abstract": "The relationship of in ternal pricing systems for computer services (chargeout systems) and  user management attitudes about their computer-based information systems is investigated. Evidence is  provided that the relationship conforms to a general pattern that would be expected from the hypothesis  of the four stages of EDP growth [15].  The results also indicate that the chargeout systems characteristic  of advanced EDP stage environments are associated with relatively high levels of positive user attitudes  and marked increases in EDP training for users. Both factors are important to the user/manager involvement  necessary for effective control of computer-based systems.  Development and main tenance of computer-based  systems is asserted to be a category of organizational change.  A \"felt need\" for the change on the part  of the user/manager is prerequisite to any change taking place.  The research methods of behavioral science  are applied to investigate the user/manager environment and the effects of chargeout.", "authors": "Nolan, R. L.", "words_pool": ["advanc", "appli", "assert", "attitud", "base", "behavior", "categori", "chang", "characterist", "chargeout", "comput", "conform", "control", "develop", "edp", "effect", "effect", "environ", "environ", "evid", "expect", "factor", "felt", "gener", "growth", "high", "hypothesi", "import", "increas", "inform", "investig", "investig", "involv", "level", "main", "manag", "manag", "mark", "method", "need", "organiz", "part", "pattern", "place", "posit", "prerequisit", "price", "provid", "relationship", "research", "result", "scienc", "servic", "stage", "stage", "system", "take", "tenanc", "ternal", "train", "user", "user", "nolan"], "word_count": {"advanc": 1, "appli": 1, "assert": 1, "attitud": 2, "base": 3, "behavior": 1, "categori": 1, "chang": 3, "characterist": 1, "chargeout": 3, "comput": 4, "conform": 1, "control": 1, "develop": 1, "edp": 3, "effect": 2, "environ": 2, "evid": 1, "expect": 1, "factor": 1, "felt": 1, "gener": 1, "growth": 1, "high": 1, "hypothesi": 1, "import": 1, "increas": 1, "inform": 1, "investig": 2, "involv": 1, "level": 1, "main": 1, "manag": 4, "mark": 1, "method": 1, "need": 1, "organiz": 1, "part": 1, "pattern": 1, "place": 1, "posit": 1, "prerequisit": 1, "price": 1, "provid": 1, "relationship": 2, "research": 1, "result": 1, "scienc": 1, "servic": 1, "stage": 2, "system": 6, "take": 1, "tenanc": 1, "ternal": 1, "train": 1, "user": 6, "nolan": 1}}, "2986": {"id": "2986", "title": "Operations on Sparse Relations", "abstract": "Various computations on relations, Boolean matrices, or directed graphs, such as the computation  of precedence relations for a context-free grammar, can be done by a practical algorithm that is asymptotically  faster than those in common use.  For example, how to compute operator precedence or Wirth-Weber precedence  relations in O(n^2) steps is shown, as well as how to compute linear precedence functions in O(n^2) steps  is shown, as well as how to compute linear precedence functions in O(n) steps, where n is the size of  a grammer.  The heart of the algorithms is a general theorem giving sufficient conditions under which  an expression whose operands are sparse relations and whose operators are composition, transitive closure,  union, and inverse, can be computed efficiently.", "authors": "Hunt, H. B. III Szymanski, T. G. Ullman, J. D.", "words_pool": ["algorithm", "algorithm", "asymptot", "boolean", "closur", "common", "composit", "comput", "comput", "comput", "comput", "condit", "context", "direct", "effici", "express", "faster", "free", "function", "gener", "give", "grammar", "grammer", "graph", "heart", "invers", "linear", "matric", "operand", "oper", "oper", "oper", "practic", "preced", "relat", "shown", "size", "spars", "step", "suffici", "theorem", "transit", "union", "weber", "wirth", "hunt", "iii", "szymanski", "ullman"], "word_count": {"algorithm": 2, "asymptot": 1, "boolean": 1, "closur": 1, "common": 1, "composit": 1, "comput": 6, "condit": 1, "context": 1, "direct": 1, "effici": 1, "express": 1, "faster": 1, "free": 1, "function": 2, "gener": 1, "give": 1, "grammar": 1, "grammer": 1, "graph": 1, "heart": 1, "invers": 1, "linear": 2, "matric": 1, "operand": 1, "oper": 2, "practic": 1, "preced": 5, "relat": 4, "shown": 2, "size": 1, "spars": 1, "step": 3, "suffici": 1, "theorem": 1, "transit": 1, "union": 1, "weber": 1, "wirth": 1, "hunt": 1, "iii": 1, "szymanski": 1, "ullman": 1}}, "2987": {"id": "2987", "title": "Representation of Many-Sided Polygons and Polygonal Lines for Rapid Processing", "abstract": "A representation for polygons and polygonal lines is described which allows sets of consecutive  sides to be collectively examined.  The set of sides are arranged in a binary tree hierarchy by inclusion.   A fast algorithm for testing the inclusion of a poin t in a many-sided polygon is given.  The speed of  the algorithm is discussed for both ideal and practical examples.  It is shown that the poin ts of intersection  of two polygonal lines can be located by what is essentially a binary tree search.  The algorithm and  a practical example are discussed.  The representation overcomes many of the disadvantages associated  with the various fixed-grid methods for representing curves and regions", "authors": "Burton W.", "words_pool": ["algorithm", "arrang", "binari", "collect", "consecut", "curv", "disadvantag", "discuss", "essenti", "examin", "exampl", "fast", "fix", "grid", "hierarchi", "ideal", "inclus", "intersect", "line", "locat", "method", "overcom", "poin", "polygon", "polygon", "polygon", "practic", "process", "rapid", "region", "represent", "repres", "search", "set", "set", "shown", "side", "side", "speed", "test", "tree", "ts", "burton"], "word_count": {"algorithm": 3, "arrang": 1, "binari": 2, "collect": 1, "consecut": 1, "curv": 1, "disadvantag": 1, "discuss": 2, "essenti": 1, "examin": 1, "exampl": 1, "fast": 1, "fix": 1, "grid": 1, "hierarchi": 1, "ideal": 1, "inclus": 2, "intersect": 1, "line": 2, "locat": 1, "method": 1, "overcom": 1, "poin": 2, "polygon": 4, "practic": 2, "process": 1, "rapid": 1, "region": 1, "represent": 2, "repres": 1, "search": 1, "set": 2, "shown": 1, "side": 3, "speed": 1, "test": 1, "tree": 2, "ts": 1, "burton": 1}}, "2988": {"id": "2988", "title": "Memory Management and Response Time", "abstract": "This paper presents a computationally tractable methodology for including accurately the effects  of finite memory size and workload memory requirements in queueing network models of computer systems.   Empirical analyses and analytic studies based on applying this methodology to an actual multiaccess  in teractive system are reported.  Relations between workload variables such as memory requirement distribution  and job swap time, and performance measures such as response time and memory utilization are graphically  displayed. A multiphase, analytically soluble model is proposed as being broadly applicable to the analysis  of in teractive computer systems which use nonpaged memories.", "authors": "Brown, R. M. Browne, J. C. Chandy, K. M.", "words_pool": ["accur", "actual", "analys", "analysi", "analyt", "analyt", "applic", "appli", "base", "broadli", "comput", "comput", "display", "distribut", "effect", "empir", "finit", "graphic", "includ", "job", "manag", "measur", "memori", "memori", "methodolog", "model", "model", "multiaccess", "multiphas", "network", "nonpag", "paper", "perform", "present", "propos", "queue", "relat", "report", "requir", "requir", "respons", "size", "solubl", "studi", "swap", "system", "system", "teract", "time", "tractabl", "util", "variabl", "workload", "brown", "brown", "chandi"], "word_count": {"accur": 1, "actual": 1, "analys": 1, "analysi": 1, "analyt": 2, "applic": 1, "appli": 1, "base": 1, "broadli": 1, "comput": 3, "display": 1, "distribut": 1, "effect": 1, "empir": 1, "finit": 1, "graphic": 1, "includ": 1, "job": 1, "manag": 1, "measur": 1, "memori": 5, "methodolog": 2, "model": 2, "multiaccess": 1, "multiphas": 1, "network": 1, "nonpag": 1, "paper": 1, "perform": 1, "present": 1, "propos": 1, "queue": 1, "relat": 1, "report": 1, "requir": 2, "respons": 1, "size": 1, "solubl": 1, "studi": 1, "swap": 1, "system": 3, "teract": 2, "time": 2, "tractabl": 1, "util": 1, "variabl": 1, "workload": 2, "brown": 1, "chandi": 1}}, "2989": {"id": "2989", "title": "Empirical Evaluation of Some Features of Instruction Set Processor Architectures", "abstract": "This paper presents methods for empirical evaluation of features of Instruction Set Processors  (ISPs).  ISP features are evaluated in terms of the time used or saved by having or not having the feature.   The methods are based on analysis of traces of program executions.  The concept of a register life is  in troduced, and used to answer questions like: How many registers are used simultaneously? How many would  be sufficient all of the time? Most of the time? What would the overhead be if the number of registers  were reduced? What are registers used for during their lives? The paper also discusses the problem of  detecting desirable but non-existing instructions. Other problems are briefly discussed.  Experimental  results are presented, obtained by analyzing 41 programs running on the DEC system 10 ISP.", "authors": "Lunde, A.", "words_pool": ["analysi", "analyz", "answer", "architectur", "base", "briefli", "concept", "dec", "desir", "detect", "discuss", "discuss", "empir", "evalu", "evalu", "execut", "exist", "experiment", "featur", "featur", "instruct", "instruct", "isp", "isp", "life", "live", "method", "non", "number", "obtain", "overhead", "paper", "present", "present", "problem", "problem", "processor", "processor", "program", "program", "question", "reduc", "regist", "regist", "result", "run", "save", "set", "simultan", "suffici", "system", "term", "time", "trace", "troduc", "lund"], "word_count": {"analysi": 1, "analyz": 1, "answer": 1, "architectur": 1, "base": 1, "briefli": 1, "concept": 1, "dec": 1, "desir": 1, "detect": 1, "discuss": 2, "empir": 1, "evalu": 2, "execut": 1, "exist": 1, "experiment": 1, "featur": 3, "instruct": 2, "isp": 3, "life": 1, "live": 1, "method": 2, "non": 1, "number": 1, "obtain": 1, "overhead": 1, "paper": 2, "present": 2, "problem": 2, "processor": 1, "program": 2, "question": 1, "reduc": 1, "regist": 4, "result": 1, "run": 1, "save": 1, "set": 1, "simultan": 1, "suffici": 1, "system": 1, "term": 1, "time": 3, "trace": 1, "troduc": 1, "lund": 1}}, "2990": {"id": "2990", "title": "Effective Information Retrieval Using Term Accuracy", "abstract": "The performance of information retrieval systems can be evaluated in a number of different  ways.  Much of the published evaluation work is based on measuring the retrieval performance of an average  user query.  Unfortunately, formal proofs are difficult to construct for the average case.  In the present  study, retrieval evaluation is based on optimizing the performance of a specific user query.  The concept  of query term accuracy is in troduced as the probability of occurrence of a query term in the documents  relevant to that query.  By relating term accuracy to the frequency of occurrence of the term in the  documents of a collection it is possible to give formal proofs of the effectiveness with respect to a  given user query of a number of automatic indexing systems that have been used successfully in experimental  situations.  Among these are inverse document frequency weighting, thesaurus construction, and phrase  generation.", "authors": "Yu, C. T. Salton, G.", "words_pool": ["accuraci", "automat", "averag", "base", "case", "collect", "concept", "construct", "construct", "difficult", "document", "document", "effect", "effect", "evalu", "evalu", "experiment", "formal", "frequenc", "gener", "give", "index", "inform", "invers", "measur", "number", "occurr", "optim", "perform", "phrase", "present", "probabl", "proof", "publish", "queri", "relat", "relev", "respect", "retriev", "situat", "specif", "studi", "success", "system", "term", "thesauru", "troduc", "unfortun", "user", "way", "weight", "work", "yu", "salton"], "word_count": {"accuraci": 2, "automat": 1, "averag": 2, "base": 2, "case": 1, "collect": 1, "concept": 1, "construct": 2, "difficult": 1, "document": 3, "effect": 1, "evalu": 3, "experiment": 1, "formal": 2, "frequenc": 2, "gener": 1, "give": 1, "index": 1, "inform": 1, "invers": 1, "measur": 1, "number": 2, "occurr": 2, "optim": 1, "perform": 3, "phrase": 1, "present": 1, "probabl": 1, "proof": 2, "publish": 1, "queri": 6, "relat": 1, "relev": 1, "respect": 1, "retriev": 3, "situat": 1, "specif": 1, "studi": 1, "success": 1, "system": 2, "term": 4, "thesauru": 1, "troduc": 1, "unfortun": 1, "user": 3, "way": 1, "weight": 1, "work": 1, "yu": 1, "salton": 1}}, "2991": {"id": "2991", "title": "Improving the Access Time for Random Access Files", "abstract": "Clustering in the key set is decreased by smoothing the key-to-address transformation, and  by adding shadow buckets to an open chaining file.  The keys are pre-hashed before the address division,  to remove the effect of sequential properties in the key set.  Shadow buckets in the key search sequence  reduce the effect of nonuniformity in file loading, and decrease the number of maximum probes needed  to locate a record.  The combined effects of these techniques lead to improved file performance for secondary  storage devices, as shown by empirical studies.", "authors": "Clapson, P.", "words_pool": ["access", "ad", "address", "bucket", "chain", "cluster", "combin", "decreas", "decreas", "devic", "divis", "effect", "effect", "empir", "hash", "improv", "improv", "key", "key", "lead", "load", "locat", "maximum", "need", "nonuniform", "number", "open", "perform", "pre", "probe", "properti", "random", "record", "reduc", "remov", "search", "secondari", "sequenc", "sequenti", "set", "shadow", "shown", "smooth", "storag", "studi", "techniqu", "time", "transform", "clapson"], "word_count": {"access": 2, "ad": 1, "address": 2, "bucket": 2, "chain": 1, "cluster": 1, "combin": 1, "decreas": 2, "devic": 1, "divis": 1, "effect": 3, "empir": 1, "hash": 1, "improv": 1, "key": 5, "lead": 1, "load": 1, "locat": 1, "maximum": 1, "need": 1, "nonuniform": 1, "number": 1, "open": 1, "perform": 1, "pre": 1, "probe": 1, "properti": 1, "random": 1, "record": 1, "reduc": 1, "remov": 1, "search": 1, "secondari": 1, "sequenc": 1, "sequenti": 1, "set": 2, "shadow": 2, "shown": 1, "smooth": 1, "storag": 1, "studi": 1, "techniqu": 1, "time": 1, "transform": 1, "clapson": 1}}, "2992": {"id": "2992", "title": "A Numbering System for Binary Trees", "authors": "Knott, G. D.", "words_pool": ["binari", "number", "system", "tree", "knott"], "word_count": {"binari": 1, "number": 1, "system": 1, "tree": 1, "knott": 1}}, "2993": {"id": "2993", "title": "Occurrences of Cycling and Other Phenomena Arising in a Class of Linear Programming Models", "abstract": "An investigation into the average queue size for a certain class of queues has resulted in  the formulation of linear programming problems which are ill-conditioned in some cases.  In attempting  to solve these linear programming models, using IBM's MPS package, instances of cycling were encountered.   Small perturbations in the input data resulted in problems which did not cycle.  This fact, plus several  other observed phenomena suggest that the primary reason that cycling is not known to occur more frequently  is the round-off errors in the computations perturb the problem sufficiently to prevent cycling (or at  least to prevent indefinite cycling).  In one case maximizing and minimizing an objective function subject  to the same constrain t set was attempted, but MPS solved only one of these while giving an indication  of infeasibility for the other.", "authors": "Kotiah, T. C. T. Steinberg, D. I.", "words_pool": ["aris", "attempt", "attempt", "averag", "case", "case", "class", "comput", "condit", "constrain", "cycl", "cycl", "data", "encount", "error", "fact", "formul", "frequent", "function", "give", "ibm", "ill", "indefinit", "indic", "infeas", "input", "instanc", "investig", "known", "linear", "maxim", "minim", "model", "mp", "object", "observ", "occur", "occurr", "packag", "perturb", "perturb", "phenomena", "prevent", "primari", "problem", "problem", "program", "queue", "queue", "reason", "result", "round", "set", "size", "small", "solv", "solv", "subject", "suffici", "suggest", "kotiah", "steinberg"], "word_count": {"aris": 1, "attempt": 2, "averag": 1, "case": 2, "class": 1, "comput": 1, "condit": 1, "constrain": 1, "cycl": 5, "data": 1, "encount": 1, "error": 1, "fact": 1, "formul": 1, "frequent": 1, "function": 1, "give": 1, "ibm": 1, "ill": 1, "indefinit": 1, "indic": 1, "infeas": 1, "input": 1, "instanc": 1, "investig": 1, "known": 1, "linear": 2, "maxim": 1, "minim": 1, "model": 1, "mp": 2, "object": 1, "observ": 1, "occur": 1, "occurr": 1, "packag": 1, "perturb": 2, "phenomena": 1, "prevent": 2, "primari": 1, "problem": 3, "program": 2, "queue": 2, "reason": 1, "result": 2, "round": 1, "set": 1, "size": 1, "small": 1, "solv": 2, "subject": 1, "suffici": 1, "suggest": 1, "kotiah": 1, "steinberg": 1}}, "2994": {"id": "2994", "title": "A Linear Algorithm for Incremental Digital Display of Circular Arcs", "abstract": "Circular arcs can be drawn on an incremental display device such as a cathode ray tube, digital  plotter, or matrix prin ter using only sign testing and elementary addition and subtraction.  This paper  describes methodology for producing dot or step patterns closet to the true circle.", "authors": "Bresenham, J.", "words_pool": ["addit", "algorithm", "arc", "cathod", "circl", "circular", "closet", "describ", "devic", "digit", "display", "dot", "drawn", "elementari", "increment", "linear", "matrix", "methodolog", "paper", "pattern", "plotter", "prin", "produc", "ray", "sign", "step", "subtract", "ter", "test", "true", "tube", "bresenham"], "word_count": {"addit": 1, "algorithm": 1, "arc": 1, "cathod": 1, "circl": 1, "circular": 1, "closet": 1, "describ": 1, "devic": 1, "digit": 1, "display": 1, "dot": 1, "drawn": 1, "elementari": 1, "increment": 1, "linear": 1, "matrix": 1, "methodolog": 1, "paper": 1, "pattern": 1, "plotter": 1, "prin": 1, "produc": 1, "ray": 1, "sign": 1, "step": 1, "subtract": 1, "ter": 1, "test": 1, "true": 1, "tube": 1, "bresenham": 1}}, "2995": {"id": "2995", "title": "Decomposability, Instabilities, and Saturation in Multiprogramming Systems (Corrigendum)", "authors": "Courtois, P. J.", "words_pool": ["corrigendum", "decompos", "instabl", "multiprogram", "satur", "system", "courtoi"], "word_count": {"corrigendum": 1, "decompos": 1, "instabl": 1, "multiprogram": 1, "satur": 1, "system": 1, "courtoi": 1}}, "2996": {"id": "2996", "title": "Transient-Free Working-Set Statistics", "abstract": "Transient-free average working set size and transient-free missing-page rate for a finite sample  of a reference string are defined.  Use of these statistics is appropriate if the contents of the working  set at the start of the recorded string are unknown.  If a certain stationarity condition holds, these  statistics provide unbiased estimates of expected working-set sizes, missing-page probabilities, and  in terreference distance probabilities.  Two other pairs of estimators are shown to be biased.  Expressions  for the transient-free statistics are obtained in terms of in terval statistics. Several methods of computation  are discussed, the usefulness of each depending on length of the sample, number of distinct references,  and the amount of main storage available to the computer performing the calculations.  In particular,  methods are described for handling long strings containing many distinct page names.", "authors": "Easton, M. C. Bennett, B. T.", "words_pool": ["amount", "averag", "bias", "calcul", "comput", "comput", "condit", "content", "defin", "depend", "discuss", "distanc", "distinct", "estim", "estim", "expect", "express", "finit", "free", "handl", "hold", "length", "long", "main", "method", "miss", "name", "number", "obtain", "page", "pair", "perform", "probabl", "provid", "rate", "record", "refer", "refer", "sampl", "set", "shown", "size", "size", "start", "stationar", "statist", "storag", "string", "string", "term", "terrefer", "terval", "transient", "unbias", "unknown", "use", "work", "easton", "bennett"], "word_count": {"amount": 1, "averag": 1, "bias": 1, "calcul": 1, "comput": 2, "condit": 1, "content": 1, "defin": 1, "depend": 1, "discuss": 1, "distanc": 1, "distinct": 2, "estim": 2, "expect": 1, "express": 1, "finit": 1, "free": 3, "handl": 1, "hold": 1, "length": 1, "long": 1, "main": 1, "method": 2, "miss": 2, "name": 1, "number": 1, "obtain": 1, "page": 3, "pair": 1, "perform": 1, "probabl": 2, "provid": 1, "rate": 1, "record": 1, "refer": 2, "sampl": 2, "set": 3, "shown": 1, "size": 2, "start": 1, "stationar": 1, "statist": 4, "storag": 1, "string": 3, "term": 1, "terrefer": 1, "terval": 1, "transient": 3, "unbias": 1, "unknown": 1, "use": 1, "work": 3, "easton": 1, "bennett": 1}}, "2997": {"id": "2997", "title": "Convex Hulls of Finite Sets of Poin ts in Two and Three Dimensions", "abstract": "The convex hulls of sets of n poin ts in two and three dimensions can be determined with O(n  log n) operations.  The presented algorithms use the \"divide and conquer\" technique and recursively apply  a merge procedure for two nonin tersecting convex hulls.  Since any convex hull algorithm requires at  least O(n log n) operations, the time complexity of the proposed algorithms is optimal within a multiplicative  constant.", "authors": "Preparata, F. P. Hong, S. J.", "words_pool": ["algorithm", "algorithm", "appli", "complex", "conquer", "constant", "convex", "determin", "dimens", "divid", "finit", "hull", "hull", "log", "merg", "multipl", "nonin", "oper", "optim", "poin", "present", "procedur", "propos", "recurs", "requir", "set", "techniqu", "tersect", "time", "ts", "preparata", "hong"], "word_count": {"algorithm": 3, "appli": 1, "complex": 1, "conquer": 1, "constant": 1, "convex": 3, "determin": 1, "dimens": 1, "divid": 1, "finit": 1, "hull": 3, "log": 2, "merg": 1, "multipl": 1, "nonin": 1, "oper": 2, "optim": 1, "poin": 1, "present": 1, "procedur": 1, "propos": 1, "recurs": 1, "requir": 1, "set": 1, "techniqu": 1, "tersect": 1, "time": 1, "ts": 1, "preparata": 1, "hong": 1}}, "2998": {"id": "2998", "title": "An Empirical Study of List Structure in Lisp", "abstract": "Static measurements of the list structure of five large Lisp programs are reported and analyzed  in this paper.  These measurements reveal substantial regularity, or predictability, among poin ters to  atoms and especially among poin ters to lists.  Pointers to atoms are found to obey, roughly, Zipf's law,  which governs word frequencies in natural languages; poin ters to lists usually poin t to a location physically  nearby in memory.  The use of such regularities in the space-efficient representation of list structure  is discussed.  Linearization of lists, whereby successive cdrs (or cars) are placed in consecutive memory  locations whenever possible, greatly strengthens the observed regularity of list structure.  It is shown  that under some reasonable assumptions, the entropy or information content of a car-cdr pair in the programs  measured is about 10 to 15 bits before linearization, and about 7 to 12 bits after.", "authors": "Clark, D. W. Green, C. C.", "words_pool": ["analyz", "assumpt", "atom", "bit", "car", "car", "cdr", "cdr", "consecut", "content", "discuss", "effici", "empir", "entropi", "especi", "found", "frequenc", "govern", "greatli", "inform", "languag", "larg", "law", "linear", "lisp", "list", "list", "locat", "locat", "measur", "measur", "memori", "natur", "nearbi", "obey", "observ", "pair", "paper", "physic", "poin", "pointer", "predict", "program", "reason", "regular", "regular", "report", "represent", "reveal", "roughli", "shown", "space", "static", "strengthen", "structur", "studi", "substanti", "success", "ter", "word", "zipf", "clark", "green"], "word_count": {"analyz": 1, "assumpt": 1, "atom": 2, "bit": 2, "car": 2, "cdr": 2, "consecut": 1, "content": 1, "discuss": 1, "effici": 1, "empir": 1, "entropi": 1, "especi": 1, "found": 1, "frequenc": 1, "govern": 1, "greatli": 1, "inform": 1, "languag": 1, "larg": 1, "law": 1, "linear": 2, "lisp": 1, "list": 6, "locat": 2, "measur": 3, "memori": 2, "natur": 1, "nearbi": 1, "obey": 1, "observ": 1, "pair": 1, "paper": 1, "physic": 1, "poin": 4, "pointer": 1, "predict": 1, "program": 2, "reason": 1, "regular": 3, "report": 1, "represent": 1, "reveal": 1, "roughli": 1, "shown": 1, "space": 1, "static": 1, "strengthen": 1, "structur": 3, "studi": 1, "substanti": 1, "success": 1, "ter": 3, "word": 1, "zipf": 1, "clark": 1, "green": 1}}, "2999": {"id": "2999", "title": "An Approach to Multidimensional Data Array Processing by Computer", "abstract": "Some recent work on the development of general-purpose computer-based statistical and data  processing capabilities for handling multidimensional arrays of data is presented. Attention is first  given to some of the general problems of multidimensional table and array processing.  This is followed  by a summary of some recent developments in array processing capabilities at the World Bank, in particular,  the system identified as WRAPS(World Bank Retrieval and Array Processing System).", "authors": "Muller, M. E.", "words_pool": ["approach", "array", "array", "attent", "bank", "base", "capabl", "comput", "data", "develop", "develop", "gener", "handl", "identifi", "multidimension", "present", "problem", "process", "purpos", "recent", "retriev", "statist", "summari", "system", "tabl", "work", "world", "wrap", "muller"], "word_count": {"approach": 1, "array": 4, "attent": 1, "bank": 2, "base": 1, "capabl": 2, "comput": 1, "data": 2, "develop": 2, "gener": 2, "handl": 1, "identifi": 1, "multidimension": 2, "present": 1, "problem": 1, "process": 4, "purpos": 1, "recent": 2, "retriev": 1, "statist": 1, "summari": 1, "system": 2, "tabl": 1, "work": 1, "world": 2, "wrap": 1, "muller": 1}}, "3000": {"id": "3000", "title": "Segment Sizes and Lifetimes in Algol 60 Programs", "abstract": "The characteristics of the virtual memory requirements of a sample of Algol 60 programs have  been measured.  Distributions are presented for thesizes of memory requests and for their holding times  (lifetimes).  The results are presented in terms of Johnston's contour model and a simple abstract machine.   They provide new empirical evidence of certain aspects of the construction and behavior of real programs,  and some of their implications for the design of virtual memory systems are presented and discussed.", "authors": "Batson, A. P. Brundage, R. E.", "words_pool": ["abstract", "algol", "aspect", "behavior", "characterist", "construct", "contour", "design", "discuss", "distribut", "empir", "evid", "hold", "implic", "johnston", "lifetim", "machin", "measur", "memori", "model", "present", "program", "provid", "real", "request", "requir", "result", "sampl", "segment", "simpl", "size", "system", "term", "thesiz", "time", "virtual", "batson", "brundag"], "word_count": {"abstract": 1, "algol": 1, "aspect": 1, "behavior": 1, "characterist": 1, "construct": 1, "contour": 1, "design": 1, "discuss": 1, "distribut": 1, "empir": 1, "evid": 1, "hold": 1, "implic": 1, "johnston": 1, "lifetim": 1, "machin": 1, "measur": 1, "memori": 3, "model": 1, "present": 3, "program": 2, "provid": 1, "real": 1, "request": 1, "requir": 1, "result": 1, "sampl": 1, "segment": 1, "simpl": 1, "size": 1, "system": 1, "term": 1, "thesiz": 1, "time": 1, "virtual": 2, "batson": 1, "brundag": 1}}, "3001": {"id": "3001", "title": "Detection of Combined Occurrences", "abstract": "In this paper it is supposed that the variables X1,...,Xn each have finite range with the variable  Xi taking on Pi possible values and that the values of the variables are changing with time.  It is supposed  further that it is desired to detect occurrences in which some subset of the variables achieve particular  values.  Finally, it is supposed that the problem involves the detection of a large number of combined  occurrences for a large number of changes of values of variables.  Two efficient solutions for this problem  are described.  Both methods have the unusual property of being faster for systems where the sum P1 + ...  + Pn is larger. The first solution is error-free and suitable for most cases.  The second solution  is slightly more elegant and allows negation as well as conjunction, but is subject to the possibility  of errors.  An error analysis is given for the second method and an empirical study is reported.", "authors": "Zobrist, A. L. Carlson, F. R. Jr.", "words_pool": ["achiev", "analysi", "case", "chang", "combin", "conjunct", "desir", "detect", "detect", "effici", "eleg", "empir", "error", "error", "faster", "final", "finit", "free", "involv", "larg", "larger", "method", "method", "negat", "number", "occurr", "p1", "paper", "pi", "pn", "possibl", "problem", "properti", "rang", "report", "slightli", "solut", "solut", "studi", "subject", "subset", "suitabl", "sum", "suppos", "system", "take", "time", "unusu", "valu", "variabl", "variabl", "x1", "xi", "xn", "zobrist", "carlson", "jr"], "word_count": {"achiev": 1, "analysi": 1, "case": 1, "chang": 1, "combin": 1, "conjunct": 1, "desir": 1, "detect": 2, "effici": 1, "eleg": 1, "empir": 1, "error": 3, "faster": 1, "final": 1, "finit": 1, "free": 1, "involv": 1, "larg": 2, "larger": 1, "method": 2, "negat": 1, "number": 2, "occurr": 2, "p1": 1, "paper": 1, "pi": 1, "pn": 1, "possibl": 1, "problem": 2, "properti": 1, "rang": 1, "report": 1, "slightli": 1, "solut": 3, "studi": 1, "subject": 1, "subset": 1, "suitabl": 1, "sum": 1, "suppos": 3, "system": 1, "take": 1, "time": 1, "unusu": 1, "valu": 4, "variabl": 5, "x1": 1, "xi": 1, "xn": 1, "zobrist": 1, "carlson": 1, "jr": 1}}, "3002": {"id": "3002", "title": "A Record and File Partitioning Model", "abstract": "One of the main objectives in the design of a file system is the reduction of storage and data  transfer costs.  This paper presents a model in which several  requests access the file system, and each  request requires information from one or more variable length data-items.  The probabilities of access  and the distribution of each data-item's length are assumed to be known, and to be mutually independent.  The file system uses one or more storage devices, and each record may be partitioned into subrecords  that are stored on different devices.  One of the subrecords is designated as the primary record; when  a request for a record is made, the primary record is first accessed, and other subrecords are accessed  only if the pertinent information is not stored in the primary record.  The model that is presented in  this paper, both as a nonlinear programming model and a mixed integer programming model, is a very general  one; several types of file systems may be derived from it by an appropriate selection of its parameters.   This model has already been used in the optimization of library routines' storage at a large scale operating  system.", "authors": "Babad, J. M.", "words_pool": ["access", "access", "assum", "cost", "data", "deriv", "design", "design", "devic", "distribut", "gener", "independ", "inform", "integ", "item", "item", "known", "larg", "length", "librari", "made", "main", "mix", "model", "mutual", "nonlinear", "object", "oper", "optim", "paper", "paramet", "partit", "partit", "pertin", "present", "present", "primari", "probabl", "program", "record", "reduct", "request", "request", "requir", "routin", "scale", "select", "storag", "store", "subrecord", "system", "system", "transfer", "type", "variabl", "babad"], "word_count": {"access": 4, "assum": 1, "cost": 1, "data": 3, "deriv": 1, "design": 2, "devic": 2, "distribut": 1, "gener": 1, "independ": 1, "inform": 2, "integ": 1, "item": 2, "known": 1, "larg": 1, "length": 2, "librari": 1, "made": 1, "main": 1, "mix": 1, "model": 5, "mutual": 1, "nonlinear": 1, "object": 1, "oper": 1, "optim": 1, "paper": 2, "paramet": 1, "partit": 1, "pertin": 1, "present": 2, "primari": 3, "probabl": 1, "program": 2, "record": 5, "reduct": 1, "request": 3, "requir": 1, "routin": 1, "scale": 1, "select": 1, "storag": 3, "store": 2, "subrecord": 3, "system": 5, "transfer": 1, "type": 1, "variabl": 1, "babad": 1}}, "3003": {"id": "3003", "title": "A Survey of the Literature in Computer Science Education Since Curriculum '68", "abstract": "A bibliography of approximately two hundred references in computer science education appearing  in the literature since the publication of \"Curriculum '68\" is presented.  The bibliography itself is  preceded by brief descriptive materials organizing the references into the categories of survey reports,  activities of professional organizations, philosophy of programs, description of  programs, description  of courses and other materials.", "authors": "Austing, R. H. Barnes, B. H.", "words_pool": ["activ", "appear", "approxim", "bibliographi", "categori", "comput", "cours", "curriculum", "descript", "descript", "educ", "hundr", "literatur", "materi", "organ", "organ", "philosophi", "preced", "present", "profession", "program", "public", "refer", "report", "scienc", "survey", "aust", "barn"], "word_count": {"activ": 1, "appear": 1, "approxim": 1, "bibliographi": 2, "categori": 1, "comput": 1, "cours": 1, "curriculum": 1, "descript": 3, "educ": 1, "hundr": 1, "literatur": 1, "materi": 2, "organ": 2, "philosophi": 1, "preced": 1, "present": 1, "profession": 1, "program": 2, "public": 1, "refer": 2, "report": 1, "scienc": 1, "survey": 1, "aust": 1, "barn": 1}}, "3004": {"id": "3004", "title": "Structured Programming in Cobol: An Approach for Application Programmers", "abstract": "Techniques for designing and writing Cobol programs are presented.  Previous work in structured  programming is drawn upon and adapted.  The presentation is informal: the terminology is nonmathematical  as far as possible, no theorems are proved, and examples are used frequently.  Top-down program design  is implemented through the use of structured flowcharts, disciplined specifications, and step by step  verification.  A well-formed Cobol program is defined.  The proper use of the GO TO and other Cobol coding  practices are discussed.", "authors": "Van Gelder, A.", "words_pool": ["adapt", "applic", "approach", "cobol", "code", "defin", "design", "design", "disciplin", "discuss", "drawn", "exampl", "flowchart", "form", "frequent", "implement", "inform", "nonmathemat", "practic", "present", "present", "previou", "program", "programm", "program", "program", "proper", "prove", "specif", "step", "structur", "techniqu", "terminolog", "theorem", "top", "verif", "work", "write", "van", "gelder"], "word_count": {"adapt": 1, "applic": 1, "approach": 1, "cobol": 3, "code": 1, "defin": 1, "design": 2, "disciplin": 1, "discuss": 1, "drawn": 1, "exampl": 1, "flowchart": 1, "form": 1, "frequent": 1, "implement": 1, "inform": 1, "nonmathemat": 1, "practic": 1, "present": 2, "previou": 1, "program": 4, "programm": 1, "proper": 1, "prove": 1, "specif": 1, "step": 2, "structur": 2, "techniqu": 1, "terminolog": 1, "theorem": 1, "top": 1, "verif": 1, "work": 1, "write": 1, "van": 1, "gelder": 1}}, "3005": {"id": "3005", "title": "Implications of Structured Programming for Machine Architecture", "abstract": "Based on an empirical study of more than 10,000 lines of program text written in a GOTO-less  language, a machine architecture specifically designed for structured programs is proposed.  Since assignment,  CALL, RETURN, and IF statements together account for 93 percent of all executable statements, special  care is given to ensure that these statements can be implemented efficiently.  A highly compact instruction  encoding scheme is presented, which can reduce program size by a factor of 3.  Unlike a Huffman code,  which utilizes variable length fields, this method uses only fixed length (1-byte) op code and address  fields.  The most frequent instructions consist of a single 1-byte field.  As a consequence, instruction  decoding time is minimized, and the machine is efficient with respect to both space and time.", "authors": "Tanenbaum, A.S.", "words_pool": ["account", "address", "architectur", "assign", "base", "byte", "call", "care", "code", "compact", "consequ", "consist", "decod", "design", "effici", "effici", "empir", "encod", "ensur", "execut", "factor", "field", "field", "fix", "frequent", "goto", "highli", "huffman", "implement", "implic", "instruct", "instruct", "languag", "length", "line", "machin", "method", "minim", "op", "percent", "present", "program", "program", "program", "propos", "reduc", "respect", "scheme", "singl", "size", "space", "special", "specif", "statement", "structur", "studi", "text", "time", "unlik", "util", "variabl", "written", "tanenbaum"], "word_count": {"account": 1, "address": 1, "architectur": 1, "assign": 1, "base": 1, "byte": 2, "call": 1, "care": 1, "code": 2, "compact": 1, "consequ": 1, "consist": 1, "decod": 1, "design": 1, "effici": 2, "empir": 1, "encod": 1, "ensur": 1, "execut": 1, "factor": 1, "field": 3, "fix": 1, "frequent": 1, "goto": 1, "highli": 1, "huffman": 1, "implement": 1, "implic": 1, "instruct": 3, "languag": 1, "length": 2, "line": 1, "machin": 2, "method": 1, "minim": 1, "op": 1, "percent": 1, "present": 1, "program": 3, "propos": 1, "reduc": 1, "respect": 1, "scheme": 1, "singl": 1, "size": 1, "space": 1, "special": 1, "specif": 1, "statement": 3, "structur": 1, "studi": 1, "text": 1, "time": 2, "unlik": 1, "util": 1, "variabl": 1, "written": 1, "tanenbaum": 1}}, "3006": {"id": "3006", "title": "Anomalies with Variable Partition Paging Algorithms", "abstract": "Five types of anomalous behavior which may occur in paged virtual memory operating systems  a redefined.  One type of anomaly, for example, concerns the fact that, with certain reference strings  and paging algorithms, an increase in mean memory allocation may result in an increase in fault rate.   Two paging algorithms, are examined in terms of their anomaly potential, and reference string examples  of various anomalies are presented.  Two paging algorithm properties, the inclusion property and the  generalized inclusion property, are discussed and the anomaly implications of these properties presented.", "authors": ". Graham, G.S. Gupta, R", "words_pool": ["algorithm", "algorithm", "alloc", "anomali", "anomal", "anomali", "behavior", "concern", "discuss", "examin", "exampl", "fact", "fault", "gener", "implic", "inclus", "increas", "mean", "memori", "occur", "oper", "page", "page", "partit", "potenti", "present", "properti", "properti", "rate", "redefin", "refer", "result", "string", "string", "system", "term", "type", "type", "variabl", "virtual", "graham", "gupta"], "word_count": {"algorithm": 3, "alloc": 1, "anomali": 4, "anomal": 1, "behavior": 1, "concern": 1, "discuss": 1, "examin": 1, "exampl": 1, "fact": 1, "fault": 1, "gener": 1, "implic": 1, "inclus": 2, "increas": 2, "mean": 1, "memori": 2, "occur": 1, "oper": 1, "page": 4, "partit": 1, "potenti": 1, "present": 2, "properti": 4, "rate": 1, "redefin": 1, "refer": 2, "result": 1, "string": 2, "system": 1, "term": 1, "type": 2, "variabl": 1, "virtual": 1, "graham": 1, "gupta": 1}}, "3007": {"id": "3007", "title": "Complexity of Computations (Corrigendum)", "authors": "Rabin, M.O.", "words_pool": ["complex", "comput", "corrigendum", "rabin"], "word_count": {"complex": 1, "comput": 1, "corrigendum": 1, "rabin": 1}}, "3008": {"id": "3008", "title": "Preserving Average Proximity in Arrays", "abstract": "Programmers and data structure designers are often forced to choose between alternative structures.   In storing these structures, preserving logical adjacencies or \"proximity\" is usually an important consideration.   The combinatorial problem of storing arrays as various kinds of list structures is examined.  Embeddings  of graphs are used to model the loss of proximity involved in such storage schemes, and an elementary  proof that arrays cannot be stored as linear lists with bounded loss of proximity is presented.  Average  loss of proximity is then considered, and it is shown that arrays cannot be stored as linear lists with  only bounded loss of average proximity, but can be so stored in binary trees.  The former result implies,  for instance, that row major order is an asymptotically optimal storage strategy for arrays.", "authors": ". Eisenstat, S", "words_pool": ["adjac", "altern", "array", "asymptot", "averag", "binari", "bound", "choos", "combinatori", "consider", "consid", "data", "design", "elementari", "embed", "examin", "forc", "graph", "impli", "import", "instanc", "involv", "kind", "linear", "list", "list", "logic", "loss", "major", "model", "optim", "order", "present", "preserv", "problem", "programm", "proof", "proxim", "result", "row", "scheme", "shown", "storag", "store", "store", "strategi", "structur", "structur", "tree", "eisenstat"], "word_count": {"adjac": 1, "altern": 1, "array": 4, "asymptot": 1, "averag": 2, "binari": 1, "bound": 2, "choos": 1, "combinatori": 1, "consider": 1, "consid": 1, "data": 1, "design": 1, "elementari": 1, "embed": 1, "examin": 1, "forc": 1, "graph": 1, "impli": 1, "import": 1, "instanc": 1, "involv": 1, "kind": 1, "linear": 2, "list": 3, "logic": 1, "loss": 4, "major": 1, "model": 1, "optim": 1, "order": 1, "present": 1, "preserv": 1, "problem": 1, "programm": 1, "proof": 1, "proxim": 5, "result": 1, "row": 1, "scheme": 1, "shown": 1, "storag": 2, "store": 5, "strategi": 1, "structur": 4, "tree": 1, "eisenstat": 1}}, "3009": {"id": "3009", "title": "Insertions and Deletions In One-Sided Height-Balanced Trees", "abstract": "Recently Hirschberg has established that insertions into one-sided height-balanced trees can  be done in 0(log^2N) steps.  It is proved here that deletions can also be performed in 0(log^2N) steps,  which answers the open problem posed by Hirschberg.", "authors": "Kosaraju, S.R.", "words_pool": ["2n", "answer", "balanc", "delet", "establish", "height", "hirschberg", "insert", "log", "open", "perform", "pose", "problem", "prove", "recent", "side", "step", "tree", "kosaraju"], "word_count": {"2n": 2, "answer": 1, "balanc": 1, "delet": 1, "establish": 1, "height": 1, "hirschberg": 2, "insert": 1, "log": 2, "open": 1, "perform": 1, "pose": 1, "problem": 1, "prove": 1, "recent": 1, "side": 1, "step": 2, "tree": 1, "kosaraju": 1}}, "3010": {"id": "3010", "title": "Value Orientation of Computer Science Students", "abstract": "Technological and nontechnological value orientations are investigated with special attention  to the complexity of value structures.  Computer science students, who are closely associated with technology,  contrast with social science students, who are often technologically aloof.  This is confirmed by the  value ratings of 313 students at the University of Minnesota in 1972.  Computer science majors were found  to have a more complex value structure than social science majors.", "authors": "Anderson, R.E.", "words_pool": ["aloof", "attent", "close", "complex", "complex", "comput", "confirm", "contrast", "found", "investig", "major", "minnesota", "nontechnolog", "orient", "orient", "rate", "scienc", "social", "special", "structur", "structur", "student", "technolog", "technolog", "technolog", "univers", "anderson"], "word_count": {"aloof": 1, "attent": 1, "close": 1, "complex": 2, "comput": 2, "confirm": 1, "contrast": 1, "found": 1, "investig": 1, "major": 2, "minnesota": 1, "nontechnolog": 1, "orient": 1, "rate": 1, "scienc": 4, "social": 2, "special": 1, "structur": 2, "student": 3, "technolog": 3, "univers": 1, "anderson": 1}}, "3011": {"id": "3011", "title": "Management Utilization of Computers in American Local Governments", "abstract": "Traditional concepts of management information systems (MIS) bear little relation to the information  systems currently in use by top management in most US local governments.  What exists is management-oriented  computing, involving the use of relatively unsophisticated applications.  Despite the unsophisticated  nature of these systems, management use of computing is surprisingly common, but also varied in its extent  among local governments.  Management computing is most prevalent in those governments with professional  management practices where top management is supportive of computing and tends to control computing decisions  and where department users have less control over design and implementation activities.  Finally, management  computing clearly has impacts for top managers, mostly involving improvements in decision information.", "authors": "Dutton, W.H. Kraemer, K.L.", "words_pool": ["activ", "american", "applic", "bear", "clearli", "common", "comput", "comput", "concept", "control", "decis", "decis", "depart", "design", "despit", "exist", "extent", "final", "govern", "impact", "implement", "improv", "inform", "involv", "local", "manag", "manag", "mi", "natur", "orient", "practic", "preval", "profession", "relat", "support", "surprisingli", "system", "tend", "top", "tradit", "unsophist", "user", "util", "vari", "dutton", "kraemer"], "word_count": {"activ": 1, "american": 1, "applic": 1, "bear": 1, "clearli": 1, "common": 1, "comput": 6, "concept": 1, "control": 2, "decis": 2, "depart": 1, "design": 1, "despit": 1, "exist": 1, "extent": 1, "final": 1, "govern": 3, "impact": 1, "implement": 1, "improv": 1, "inform": 3, "involv": 2, "local": 2, "manag": 9, "mi": 1, "natur": 1, "orient": 1, "practic": 1, "preval": 1, "profession": 1, "relat": 1, "support": 1, "surprisingli": 1, "system": 3, "tend": 1, "top": 3, "tradit": 1, "unsophist": 2, "user": 1, "util": 1, "vari": 1, "dutton": 1, "kraemer": 1}}, "3012": {"id": "3012", "title": "The Use of an Interactive Information Storage and Retrieval System in Medical Research", "abstract": "This paper presents the results of a study of the use of an interactive computerized storage  and retrieval system.  A monitor built into the computer system provided usage data for the study.  Additional  data on user reactions were gathe red from a questionnaire.  The results show the important role played  by frequently chosen laboratory reference leaders in influencing the use of this system.  The implications  of the study for the design of similar systems are discussed.", "authors": "Lucas, H", "words_pool": ["addit", "built", "chosen", "comput", "computer", "data", "design", "discuss", "frequent", "gath", "implic", "import", "influenc", "inform", "interact", "laboratori", "leader", "medic", "monitor", "paper", "play", "present", "provid", "questionnair", "reaction", "red", "refer", "research", "result", "retriev", "role", "show", "similar", "storag", "studi", "system", "system", "usag", "user", "luca"], "word_count": {"addit": 1, "built": 1, "chosen": 1, "comput": 1, "computer": 1, "data": 2, "design": 1, "discuss": 1, "frequent": 1, "gath": 1, "implic": 1, "import": 1, "influenc": 1, "inform": 1, "interact": 1, "laboratori": 1, "leader": 1, "medic": 1, "monitor": 1, "paper": 1, "play": 1, "present": 1, "provid": 1, "questionnair": 1, "reaction": 1, "red": 1, "refer": 1, "research": 1, "result": 2, "retriev": 1, "role": 1, "show": 1, "similar": 1, "storag": 1, "studi": 3, "system": 4, "usag": 1, "user": 1, "luca": 1}}, "3013": {"id": "3013", "title": "Some New Methods of Detecting Step Edges in Digital Pictures", "abstract": "This note describes two operators that respond to step edges, but not to ramps.  The first  is similar to the digital Laplacian, but uses the max, rather than the sum, of the x and y second differences.   The second uses the difference between the mean and median gray levels in a neighborhood.  The outputs  obtained from these operators applied to a set of test pictures are compared with each other and with  the standard digital Laplacian and gradient.  A third operator, which uses the distance between the center  and centroid of a neighborhood as an edge value, is also briefly considered; it turns out to be equivalent  to one of the standard digital approximations to the gradient.", "authors": "Schachter, B.J. Rosenfeld, A.", "words_pool": ["appli", "approxim", "briefli", "center", "centroid", "compar", "consid", "describ", "detect", "differ", "differ", "digit", "distanc", "edg", "edg", "equival", "gradient", "gray", "laplacian", "level", "max", "mean", "median", "method", "neighborhood", "note", "obtain", "oper", "oper", "output", "pictur", "ramp", "respond", "set", "similar", "standard", "step", "sum", "test", "turn", "schachter", "rosenfeld"], "word_count": {"appli": 1, "approxim": 1, "briefli": 1, "center": 1, "centroid": 1, "compar": 1, "consid": 1, "describ": 1, "detect": 1, "differ": 2, "digit": 3, "distanc": 1, "edg": 2, "equival": 1, "gradient": 2, "gray": 1, "laplacian": 2, "level": 1, "max": 1, "mean": 1, "median": 1, "method": 1, "neighborhood": 2, "note": 1, "obtain": 1, "oper": 3, "output": 1, "pictur": 1, "ramp": 1, "respond": 1, "set": 1, "similar": 1, "standard": 2, "step": 1, "sum": 1, "test": 1, "turn": 1, "schachter": 1, "rosenfeld": 1}}, "3014": {"id": "3014", "title": "Is \"Sometime\" Sometimes Better than \"Always\"? (Intermittent Assertions in Proving Program Correctness)", "abstract": "This paper explores a technique for proving the correctness and termination of programs simultaneously.   This approach, the intermittent-assertion method, involves documenting the program with assertions that  must be true at some time when control passes through the corresponding point, but that need not be true  every time.  The method, introduced by Burstall, promises to provide a valuable complement to the more  conventional methods.  The intermittent-assertion method is presented with a number of examples of correctness  and termination proofs.  Some of these proofs are markedly simpler than their conventional counterparts.   On the other hand, it is shown that a proof of correctness or termination by any of the conventional  techniques can be rephrased directly as a proof using intermittent assertions.  Finally, it is shown  how the intermittent-assertion method can be applied to prove the validity of program transformations  and the correctness of continuously operating programs.", "authors": "Manna, Z. Waldinger, R.", "words_pool": ["appli", "approach", "assert", "assert", "burstal", "complement", "continu", "control", "convent", "correct", "counterpart", "directli", "document", "exampl", "explor", "final", "hand", "intermitt", "introduc", "involv", "markedli", "method", "method", "need", "number", "oper", "paper", "pass", "point", "present", "program", "program", "promis", "proof", "proof", "prove", "provid", "prove", "rephras", "shown", "simpler", "simultan", "techniqu", "techniqu", "termin", "time", "transform", "true", "valid", "valuabl", "manna", "walding"], "word_count": {"appli": 1, "approach": 1, "assert": 5, "burstal": 1, "complement": 1, "continu": 1, "control": 1, "convent": 3, "correct": 4, "counterpart": 1, "directli": 1, "document": 1, "exampl": 1, "explor": 1, "final": 1, "hand": 1, "intermitt": 4, "introduc": 1, "involv": 1, "markedli": 1, "method": 5, "need": 1, "number": 1, "oper": 1, "paper": 1, "pass": 1, "point": 1, "present": 1, "program": 4, "promis": 1, "proof": 4, "prove": 2, "provid": 1, "rephras": 1, "shown": 2, "simpler": 1, "simultan": 1, "techniqu": 2, "termin": 3, "time": 2, "transform": 1, "true": 2, "valid": 1, "valuabl": 1, "manna": 1, "walding": 1}}, "3015": {"id": "3015", "title": ". Lent, A. Lutz, P.H.", "abstract": "The problem of recovering an image (a function of two variables) from experimentally available  integrals of its grayness over thin strips is of great importance in a large number of scientific areas.   An important version of the problem in medicine is that of obtaining the exact density distribution  within the human body from X-ray projections.One approach that has been taken to solve this problem  consists of translating the available information into a system of linear inequalities.  The size and  the sparsity of the resulting system (typically, 25,000 inequalities with fewer than 1 percent of the  coefficients nonzero) makes methods using successive relaxations computationally attractive, as compared  to other ways of solving systems of inequalities.  In this paper, it is shown that, for a consistent  system of linear inequalities, any sequence of relaxarion parameters lying strictly between 0 and 2 generates  a sequence of vectors which converges to a solution.  Under the same assumptions, for a system of linear  equations, the relaxation method converges to the minimum norm solution.  Previously proposed techniques are shown to be special cases of our procedure with different choices of relaxation parameters.  The  practical consequences for image reconstruction of the choice of the relaxation parameters are discussed.", "authors": "Herman, G", "words_pool": ["approach", "area", "assumpt", "attract", "bodi", "case", "choic", "choic", "coeffici", "compar", "comput", "consequ", "consist", "consist", "converg", "densiti", "discuss", "distribut", "equat", "exact", "experiment", "fewer", "function", "gener", "gray", "great", "human", "imag", "import", "import", "inequ", "inform", "integr", "larg", "lent", "linear", "lutz", "lie", "make", "medicin", "method", "method", "minimum", "nonzero", "norm", "number", "obtain", "paper", "paramet", "percent", "practic", "previous", "problem", "procedur", "project", "propos", "ray", "reconstruct", "recov", "relaxarion", "relax", "relax", "result", "scientif", "sequenc", "shown", "size", "solut", "solv", "solv", "sparsiti", "special", "strictli", "strip", "success", "system", "system", "techniqu", "thin", "translat", "typic", "variabl", "vector", "version", "way", "herman"], "word_count": {"approach": 1, "area": 1, "assumpt": 1, "attract": 1, "bodi": 1, "case": 1, "choic": 2, "coeffici": 1, "compar": 1, "comput": 1, "consequ": 1, "consist": 2, "converg": 2, "densiti": 1, "discuss": 1, "distribut": 1, "equat": 1, "exact": 1, "experiment": 1, "fewer": 1, "function": 1, "gener": 1, "gray": 1, "great": 1, "human": 1, "imag": 2, "import": 2, "inequ": 4, "inform": 1, "integr": 1, "larg": 1, "lent": 1, "linear": 3, "lutz": 1, "lie": 1, "make": 1, "medicin": 1, "method": 2, "minimum": 1, "nonzero": 1, "norm": 1, "number": 1, "obtain": 1, "paper": 1, "paramet": 3, "percent": 1, "practic": 1, "previous": 1, "problem": 3, "procedur": 1, "project": 1, "propos": 1, "ray": 1, "reconstruct": 1, "recov": 1, "relaxarion": 1, "relax": 4, "result": 1, "scientif": 1, "sequenc": 2, "shown": 2, "size": 1, "solut": 2, "solv": 2, "sparsiti": 1, "special": 1, "strictli": 1, "strip": 1, "success": 1, "system": 5, "techniqu": 1, "thin": 1, "translat": 1, "typic": 1, "variabl": 1, "vector": 1, "version": 1, "way": 1, "herman": 1}}, "3016": {"id": "3016", "title": "A Comparison of Numerical Techniques in Markov Modeling", "abstract": "This paper presents several numerical methods which may be used to obtain the stationary probability  vectors of Markovian models.  An example of a nearly decomposable system is considered, and the results  obtained by the different methods examined.  A post mortem reveals why standard techniques often fail  to yield the correct results.  Finally, a means of estimating the error inherent in the decomposition  of certain models is presented.", "authors": "Stewart, W.J.", "words_pool": ["comparison", "consid", "correct", "decompos", "decomposit", "error", "estim", "examin", "fail", "final", "inher", "markov", "markovian", "mean", "method", "model", "model", "mortem", "nearli", "numer", "obtain", "obtain", "paper", "post", "present", "present", "probabl", "result", "reveal", "standard", "stationari", "system", "techniqu", "vector", "yield", "stewart"], "word_count": {"comparison": 1, "consid": 1, "correct": 1, "decompos": 1, "decomposit": 1, "error": 1, "estim": 1, "examin": 1, "fail": 1, "final": 1, "inher": 1, "markov": 1, "markovian": 1, "mean": 1, "method": 2, "model": 2, "mortem": 1, "nearli": 1, "numer": 1, "obtain": 2, "paper": 1, "post": 1, "present": 2, "probabl": 1, "result": 2, "reveal": 1, "standard": 1, "stationari": 1, "system": 1, "techniqu": 1, "vector": 1, "yield": 1, "stewart": 1}}, "3017": {"id": "3017", "title": "B-trees Re-examined", "abstract": "The B-tree and its variants have, with increasing frequency, been proposed as a basic storage  structure for multiuser database applications.  Here, three potential problems which must be dealt with  in such a structure that do not arise in more traditional static directory structures are indicated.   One problem is a possible performance penalty.", "authors": "Held, G. Stonebraker, M.", "words_pool": ["applic", "aris", "basic", "databas", "dealt", "directori", "examin", "frequenc", "increas", "multius", "penalti", "perform", "potenti", "problem", "problem", "propos", "re", "static", "storag", "structur", "structur", "tradit", "tree", "tree", "variant", "held", "stonebrak"], "word_count": {"applic": 1, "aris": 1, "basic": 1, "databas": 1, "dealt": 1, "directori": 1, "examin": 1, "frequenc": 1, "increas": 1, "multius": 1, "penalti": 1, "perform": 1, "potenti": 1, "problem": 2, "propos": 1, "re": 1, "static": 1, "storag": 1, "structur": 3, "tradit": 1, "tree": 1, "variant": 1, "held": 1, "stonebrak": 1}}, "3018": {"id": "3018", "title": ". Stockmeyer, L.J. Wong, C", "abstract": "Kellerman has presented a method for determining keyword conflicts and described a heuristic  algorithm which solves a certain combinatorial optimization problem in connection with this method.   This optimization problem is here shown to be equivalent to the problem of covering the edges of a graph  by complete subgraphs with the objective of minimizing the number of complete subgraphs.  A relationship  between this edge-clique-cover problem and the graph coloring problem is established which allows algorithms  for either one of these problems to be constructed from algorithm for the other.  As consequences of  this relationship, the keyword conflict problem and the edge-clique-cover problem are shown to be NP-complete,  and if P=/NP then they do not admit polynomial-time approximation algorithms which always produce solutions  within a factor less than 2 from the optimum.", "authors": "Kou, L", "words_pool": ["admit", "algorithm", "algorithm", "approxim", "cliqu", "color", "combinatori", "complet", "conflict", "conflict", "connect", "consequ", "construct", "cover", "cover", "determin", "edg", "edg", "equival", "establish", "factor", "graph", "heurist", "kellerman", "keyword", "method", "minim", "np", "number", "object", "optim", "optimum", "polynomi", "present", "problem", "problem", "produc", "relationship", "shown", "solut", "solv", "stockmey", "subgraph", "time", "wong", "kou"], "word_count": {"admit": 1, "algorithm": 4, "approxim": 1, "cliqu": 2, "color": 1, "combinatori": 1, "complet": 3, "conflict": 2, "connect": 1, "consequ": 1, "construct": 1, "cover": 3, "determin": 1, "edg": 3, "equival": 1, "establish": 1, "factor": 1, "graph": 2, "heurist": 1, "kellerman": 1, "keyword": 2, "method": 2, "minim": 1, "np": 2, "number": 1, "object": 1, "optim": 2, "optimum": 1, "polynomi": 1, "present": 1, "problem": 8, "produc": 1, "relationship": 2, "shown": 2, "solut": 1, "solv": 1, "stockmey": 1, "subgraph": 2, "time": 1, "wong": 1, "kou": 1}}, "3019": {"id": "3019", "title": "The GRE Advanced Test in Computer Science", "authors": "Austing, R.H.", "words_pool": ["advanc", "comput", "gre", "scienc", "test", "aust"], "word_count": {"advanc": 1, "comput": 1, "gre": 1, "scienc": 1, "test": 1, "aust": 1}}, "3020": {"id": "3020", "title": "Systematic Recursion Removal", "abstract": "The recursion removal algorithm presented by Strong and Walker is amplified and applied to  a relatively complex PL/I program.  The aim is to demonstrate systematic recursion-removal techniques  on something more complex than Knuth's \"sturdy toddler\" and to obtain measurements of the cost of procedure  linkage in PL/I and the savings achievable via procedure integration in the presence of recursion.  First,  the paper describes the recursion-removal process and the example on which it will be illustrated.  Recursion  removal is then applied to the two major parts of this example and the final result of the process is  displayed.  Our performance comparison results are presented and our conclusions are briefly discussed.", "authors": ". Strong, H.R.", "words_pool": ["achiev", "aim", "algorithm", "amplifi", "appli", "briefli", "comparison", "complex", "conclus", "cost", "demonstr", "describ", "discuss", "display", "final", "illustr", "integr", "knuth", "linkag", "major", "measur", "obtain", "paper", "part", "perform", "pl", "presenc", "present", "procedur", "process", "program", "recurs", "remov", "result", "result", "save", "strong", "sturdi", "systemat", "techniqu", "toddler", "walker", "strong"], "word_count": {"achiev": 1, "aim": 1, "algorithm": 1, "amplifi": 1, "appli": 2, "briefli": 1, "comparison": 1, "complex": 2, "conclus": 1, "cost": 1, "demonstr": 1, "describ": 1, "discuss": 1, "display": 1, "final": 1, "illustr": 1, "integr": 1, "knuth": 1, "linkag": 1, "major": 1, "measur": 1, "obtain": 1, "paper": 1, "part": 1, "perform": 1, "pl": 2, "presenc": 1, "present": 2, "procedur": 2, "process": 2, "program": 1, "recurs": 5, "remov": 4, "result": 2, "save": 1, "strong": 1, "sturdi": 1, "systemat": 1, "techniqu": 1, "toddler": 1, "walker": 1}}, "3021": {"id": "3021", "title": "A Method for Obtaining Digital Signatures and Public-Key Cryptosystems", "abstract": "An encryption method is presented with the novel property that publicly revealing an encryption  key does not thereby reveal the corresponding decryption key.  This has two important consequences: (1)  Couriers or other secure means are not needed to transmit keys, since a message can be enciphered using  an encryption key publicly revealed by the intended recipient.  Only he can decipher the message, since  only he knows the corresponding decryption key.  (2) A message can be \"signed\" using a privately held  decryption key.  Anyone can verify this signature using the corresponding publicly revealed encryption  key.  Signatures cannot be forged, and a signer cannot later deny the validity of his signature.  This  has obvious applications in \"electronic mail\" and \"electronic funds transfer\" systems.  A message is  encrypted by representing it as a number M, raising M to a publicly specified power e, and then taking  the remainder when the result is divided by the publicly specified product, n, of two large secret prime  numbers p and q.  Decryption is similar;only a different, secret, power d is used, where e * d = 1 (mod(p-1)  * (q-1)).  the security of the system rests in part on the difficulty of factoring the published divisor,  n.", "authors": "Rivest, R.L. Shamir, A. Adleman, L.", "words_pool": ["applic", "consequ", "courier", "cryptosystem", "deciph", "decrypt", "deni", "difficulti", "digit", "divid", "divisor", "electron", "enciph", "encrypt", "encrypt", "factor", "forg", "fund", "held", "import", "intend", "key", "key", "know", "larg", "later", "mail", "mean", "messag", "method", "mod", "need", "number", "number", "obtain", "obviou", "part", "power", "present", "prime", "privat", "product", "properti", "public", "publicli", "publish", "rais", "recipi", "remaind", "repres", "rest", "result", "reveal", "reveal", "reveal", "secret", "secur", "secur", "signatur", "signatur", "sign", "signer", "similar", "system", "system", "take", "transfer", "transmit", "valid", "verifi", "rivest", "shamir", "adleman"], "word_count": {"applic": 1, "consequ": 1, "courier": 1, "cryptosystem": 1, "deciph": 1, "decrypt": 4, "deni": 1, "difficulti": 1, "digit": 1, "divid": 1, "divisor": 1, "electron": 2, "enciph": 1, "encrypt": 5, "factor": 1, "forg": 1, "fund": 1, "held": 1, "import": 1, "intend": 1, "key": 7, "know": 1, "larg": 1, "later": 1, "mail": 1, "mean": 1, "messag": 4, "method": 1, "mod": 1, "need": 1, "number": 2, "obtain": 1, "obviou": 1, "part": 1, "power": 2, "present": 1, "prime": 1, "privat": 1, "product": 1, "properti": 1, "public": 1, "publicli": 5, "publish": 1, "rais": 1, "recipi": 1, "remaind": 1, "repres": 1, "rest": 1, "result": 1, "reveal": 4, "secret": 2, "secur": 2, "signatur": 3, "sign": 1, "signer": 1, "similar": 1, "system": 2, "take": 1, "transfer": 1, "transmit": 1, "valid": 1, "verifi": 1, "rivest": 1, "shamir": 1, "adleman": 1}}, "3022": {"id": "3022", "title": "Computer Science Faculties: The Current Status of Minorities and Women", "abstract": "The results of a survey conducted in the fall of 1975 to determine the status of women and  minority faculty members in academic computer science are presented.  Faculty members were compared with  respect to professional background, salaries, teaching load, publication records, and research grants.   Analysis of the data indicated that the over-all verdict is one of general equality among women, minorities,  and men.", "authors": ". Montanelli, R.G.Jr.", "words_pool": ["academ", "analysi", "background", "compar", "comput", "conduct", "data", "determin", "equal", "faculti", "faculti", "fall", "gener", "grant", "load", "member", "men", "minor", "minor", "present", "profession", "public", "record", "research", "respect", "result", "salari", "scienc", "statu", "survey", "teach", "verdict", "women", "montanelli", "jr"], "word_count": {"academ": 1, "analysi": 1, "background": 1, "compar": 1, "comput": 1, "conduct": 1, "data": 1, "determin": 1, "equal": 1, "faculti": 2, "fall": 1, "gener": 1, "grant": 1, "load": 1, "member": 2, "men": 1, "minor": 2, "present": 1, "profession": 1, "public": 1, "record": 1, "research": 1, "respect": 1, "result": 1, "salari": 1, "scienc": 1, "statu": 1, "survey": 1, "teach": 1, "verdict": 1, "women": 2, "montanelli": 1, "jr": 1}}, "3023": {"id": "3023", "title": "Architecture of the IBM System/370", "abstract": "This paper discusses the design considerations for the architectural extensions that distinguish  System/370 from System/360.  It comments on some experiences with the original objectives for System/360  and on the efforts to achieve them, and it describes the reasons and objectives for extending the architecture.  It covers virtual storage, program control, data-manipulation instructions, timing facilities, multiprocessing,  debugging and monitoring, error handling, and input/output operations.  A final section tabulates some  of the important parameters of the various IBM machines which implement the architecture.", "authors": "Case, R.P. Padges, A.", "words_pool": ["achiev", "architectur", "architectur", "comment", "consider", "control", "cover", "data", "debug", "describ", "design", "discuss", "distinguish", "effort", "error", "experi", "extend", "extens", "facil", "final", "handl", "ibm", "implement", "import", "input", "instruct", "machin", "manipul", "monitor", "multiprocess", "object", "oper", "origin", "output", "paper", "paramet", "program", "reason", "section", "storag", "system", "tabul", "time", "virtual", "case", "padg"], "word_count": {"achiev": 1, "architectur": 3, "comment": 1, "consider": 1, "control": 1, "cover": 1, "data": 1, "debug": 1, "describ": 1, "design": 1, "discuss": 1, "distinguish": 1, "effort": 1, "error": 1, "experi": 1, "extend": 1, "extens": 1, "facil": 1, "final": 1, "handl": 1, "ibm": 1, "implement": 1, "import": 1, "input": 1, "instruct": 1, "machin": 1, "manipul": 1, "monitor": 1, "multiprocess": 1, "object": 2, "oper": 1, "origin": 1, "output": 1, "paper": 1, "paramet": 1, "program": 1, "reason": 1, "section": 1, "storag": 1, "system": 3, "tabul": 1, "time": 1, "virtual": 1, "case": 1, "padg": 1}}, "3024": {"id": "3024", "title": "The CRAY-1 Computer System", "abstract": "This paper describes the CRAY-1, discusses the evolution of its architecture, and gives an  account of some of the problems that were overcome during its manufacture.  The CRAY-1 is the only computer  to have been built to date that satisfies ERDA's Class VI requirement (a computer capable of processing  from 20 to 60 million floating point operations per second) [1].  The CRAY-1's Fortran compiler (CFT)  is designed to give the scientific user immediate access to the benefits of the CRAY-1's vector processing  architecture.  An optimizing compiler, CFT, \"vectorizes\" innermost DO loops.  Compatible with the ANSI  1966 Fortran Standard and with many commonly supported Fortran extensions, CFT does not require any source  program modifications or the use of additional nonstandard Fortran statements to achieve vectorization.   Thus the user's investment of hundreds of man months of effort to develop Fortran programs for other  contemporary computers is protected.", "authors": "Russell, R.M.", "words_pool": ["access", "account", "achiev", "addit", "ansi", "architectur", "benefit", "built", "capabl", "cft", "class", "commonli", "compat", "compil", "comput", "comput", "contemporari", "cray", "date", "describ", "design", "develop", "discuss", "effort", "erda", "evolut", "extens", "float", "fortran", "give", "hundr", "innermost", "invest", "loop", "man", "manufactur", "million", "modif", "month", "nonstandard", "oper", "optim", "overcom", "paper", "point", "problem", "process", "program", "program", "protect", "requir", "requir", "satisfi", "scientif", "sourc", "standard", "statement", "support", "system", "user", "vector", "vector", "vector", "vi", "russel"], "word_count": {"access": 1, "account": 1, "achiev": 1, "addit": 1, "ansi": 1, "architectur": 2, "benefit": 1, "built": 1, "capabl": 1, "cft": 3, "class": 1, "commonli": 1, "compat": 1, "compil": 2, "comput": 3, "contemporari": 1, "cray": 4, "date": 1, "describ": 1, "design": 1, "develop": 1, "discuss": 1, "effort": 1, "erda": 1, "evolut": 1, "extens": 1, "float": 1, "fortran": 5, "give": 1, "hundr": 1, "innermost": 1, "invest": 1, "loop": 1, "man": 1, "manufactur": 1, "million": 1, "modif": 1, "month": 1, "nonstandard": 1, "oper": 1, "optim": 1, "overcom": 1, "paper": 1, "point": 1, "problem": 1, "process": 2, "program": 2, "protect": 1, "requir": 2, "satisfi": 1, "scientif": 1, "sourc": 1, "standard": 1, "statement": 1, "support": 1, "system": 1, "user": 2, "vector": 3, "vi": 1, "russel": 1}}, "3025": {"id": "3025", "title": "The Evolution of the DEC system 10", "abstract": "The DEC system 10, also known as the PDP-10, evolved from the PDP-6 (circa 1963) over five generations  of implementations to presently include systems covering a price range of five to one.  The origin and  evolution of the hardware, operating system, and languages are described in terms of technological change,  user requirements, and user developments. The PDP-10's contributions to computing technology include:  accelerating the transition from batch oriented to time sharing computing systems; transferring hardware  technology within DEC (and elsewhere) to minicomputer design and manufacturing; supporting minicomputer  hardware and software development; and serving as a model for single user and timeshared interactive  minicomputer/microcomputer systems.", "authors": "Bell, C.G. Kotok, A. Hastings, T", "words_pool": ["acceler", "batch", "chang", "circa", "comput", "contribut", "cover", "dec", "design", "develop", "develop", "evolut", "evolv", "gener", "hardwar", "implement", "includ", "interact", "known", "languag", "manufactur", "microcomput", "minicomput", "model", "oper", "orient", "origin", "pdp", "present", "price", "rang", "requir", "serv", "share", "singl", "softwar", "support", "system", "system", "technolog", "technolog", "term", "time", "timeshar", "transfer", "transit", "user", "bell", "kotok", "hast"], "word_count": {"acceler": 1, "batch": 1, "chang": 1, "circa": 1, "comput": 2, "contribut": 1, "cover": 1, "dec": 2, "design": 1, "develop": 2, "evolut": 1, "evolv": 1, "gener": 1, "hardwar": 3, "implement": 1, "includ": 2, "interact": 1, "known": 1, "languag": 1, "manufactur": 1, "microcomput": 1, "minicomput": 3, "model": 1, "oper": 1, "orient": 1, "origin": 1, "pdp": 3, "present": 1, "price": 1, "rang": 1, "requir": 1, "serv": 1, "share": 1, "singl": 1, "softwar": 1, "support": 1, "system": 5, "technolog": 3, "term": 1, "time": 1, "timeshar": 1, "transfer": 1, "transit": 1, "user": 3, "bell": 1, "kotok": 1, "hast": 1}}, "3026": {"id": "3026", "title": "The Evolution of the Sperry Univac 1100 Series: A His tory, Analysis, and Projection", "abstract": "The 1100 series systems are Sperry Univac's large-scale main frame computer systems.  Beginning  with the 1107 in 1962, the 1100 series has progressed through a succession of eight compatible computer  models to the latest system, the 1100/80, introduced in 1977.  The 1100 series hardware architecture  is based on a 36-bit word, ones complement structure which obtains one operand from storage and one from  a high-speed register, or two operands from high-speed registers.  The 1100 Operating System is designed  to support a symmetrical multiprocessor configuration simultaneously providing multiprogrammed batch,  timesharing, and transaction environments.", "authors": ".", "words_pool": ["analysi", "architectur", "base", "batch", "begin", "bit", "compat", "complement", "comput", "configur", "design", "environ", "evolut", "frame", "hardwar", "high", "introduc", "larg", "latest", "main", "model", "multiprocessor", "multiprogram", "obtain", "operand", "operand", "oper", "progress", "project", "provid", "regist", "regist", "scale", "seri", "simultan", "speed", "sperri", "storag", "structur", "success", "support", "symmetr", "system", "system", "timeshar", "tori", "transact", "univac", "word"], "word_count": {"analysi": 1, "architectur": 1, "base": 1, "batch": 1, "begin": 1, "bit": 1, "compat": 1, "complement": 1, "comput": 2, "configur": 1, "design": 1, "environ": 1, "evolut": 1, "frame": 1, "hardwar": 1, "high": 2, "introduc": 1, "larg": 1, "latest": 1, "main": 1, "model": 1, "multiprocessor": 1, "multiprogram": 1, "obtain": 1, "operand": 2, "oper": 1, "progress": 1, "project": 1, "provid": 1, "regist": 2, "scale": 1, "seri": 3, "simultan": 1, "speed": 2, "sperri": 1, "storag": 1, "structur": 1, "success": 1, "support": 1, "symmetr": 1, "system": 4, "timeshar": 1, "tori": 1, "transact": 1, "univac": 1, "word": 1}}, "3027": {"id": "3027", "title": "The Development of the MU5 Computer System", "abstract": "Following a brief outline of the background of the MU5 project, the aims and ideas for MU5  are discussed.  A description is then given of the instruction set, which includes a number of features  conducive to the production of efficient compiled code from high-level language source programs.  The  design of the processor is then traced from the initial ideas for an associatively addressed \"name store\"  to the final multistage pipeline structure involving a prediction mechanism for instruction prefetching  and a function queue for array element accessing.  An overall view of the complete MU5 complex is presented  together with a brief indication of its performance.", "authors": "Ibbett, R", "words_pool": ["access", "address", "aim", "array", "associ", "background", "code", "compil", "complet", "complex", "comput", "conduc", "descript", "design", "develop", "discuss", "effici", "element", "featur", "final", "function", "high", "idea", "includ", "indic", "initi", "instruct", "involv", "languag", "level", "mechan", "mu5", "multistag", "number", "outlin", "perform", "pipelin", "predict", "prefetch", "present", "processor", "product", "program", "project", "queue", "set", "sourc", "store", "structur", "system", "trace", "view", "ibbett"], "word_count": {"access": 1, "address": 1, "aim": 1, "array": 1, "associ": 1, "background": 1, "code": 1, "compil": 1, "complet": 1, "complex": 1, "comput": 1, "conduc": 1, "descript": 1, "design": 1, "develop": 1, "discuss": 1, "effici": 1, "element": 1, "featur": 1, "final": 1, "function": 1, "high": 1, "idea": 2, "includ": 1, "indic": 1, "initi": 1, "instruct": 2, "involv": 1, "languag": 1, "level": 1, "mechan": 1, "mu5": 3, "multistag": 1, "number": 1, "outlin": 1, "perform": 1, "pipelin": 1, "predict": 1, "prefetch": 1, "present": 1, "processor": 1, "product": 1, "program": 1, "project": 1, "queue": 1, "set": 1, "sourc": 1, "store": 1, "structur": 1, "system": 1, "trace": 1, "view": 1, "ibbett": 1}}, "3028": {"id": "3028", "title": "The Manchester Mark I and Atlas: A His torical Perspective", "abstract": "In 30 years of computer design at Manchester University two systems stand out: the Mark I (developed  over the period 1946-49) and the Atlas (1955-62).  This paper places each computer in its his torical  context and then describes the architecture and system software in present-day terminology.  Several  design concepts such as address-generation and store management have evolved in the progression from  Mark I to Atlas.  The wider impact of Manchester innovations in these and other areas is discussed, and  the contemporary performance of the Mark I and Atlas is evaluated.", "authors": "Lavington, S.H.", "words_pool": ["address", "architectur", "area", "atla", "comput", "concept", "contemporari", "context", "day", "describ", "design", "develop", "discuss", "evalu", "evolv", "gener", "impact", "innov", "manag", "manchest", "mark", "paper", "perform", "period", "perspect", "place", "present", "progress", "softwar", "stand", "store", "system", "system", "terminolog", "toric", "univers", "wider", "year", "lavington"], "word_count": {"address": 1, "architectur": 1, "area": 1, "atla": 3, "comput": 2, "concept": 1, "contemporari": 1, "context": 1, "day": 1, "describ": 1, "design": 2, "develop": 1, "discuss": 1, "evalu": 1, "evolv": 1, "gener": 1, "impact": 1, "innov": 1, "manag": 1, "manchest": 2, "mark": 3, "paper": 1, "perform": 1, "period": 1, "perspect": 1, "place": 1, "present": 1, "progress": 1, "softwar": 1, "stand": 1, "store": 1, "system": 2, "terminolog": 1, "toric": 1, "univers": 1, "wider": 1, "year": 1, "lavington": 1}}, "3029": {"id": "3029", "title": "Foreword to the Special Issue on Computer Architecture", "authors": "Fuller,S.H.", "words_pool": ["architectur", "comput", "foreword", "issu", "special", "fuller"], "word_count": {"architectur": 1, "comput": 1, "foreword": 1, "issu": 1, "special": 1, "fuller": 1}}, "3030": {"id": "3030", "title": "An Example of Hierarchical Design and Proof", "abstract": "Hierarchical programming is being increasingly recognized as helpful in the construction of  large programs.  Users of hierarchical techniques claim or predict substantial increases in productivity  and in the reliability of the programs produced.  In this paper we describe a formal method for hierarchical  program specification, implementation, and proof.  We apply this method to a significant list processing  problem and also discuss a number of extensions to current programming languages that ease hierarchical  program design and proof.", "authors": "Spitzen, J.M. Levitt, K", "words_pool": ["appli", "claim", "construct", "describ", "design", "discuss", "eas", "extens", "formal", "help", "hierarch", "implement", "increas", "increasingli", "languag", "larg", "list", "method", "number", "paper", "predict", "problem", "process", "produc", "product", "program", "program", "program", "proof", "recogn", "reliabl", "signific", "specif", "substanti", "techniqu", "user", "spitzen", "levitt"], "word_count": {"appli": 1, "claim": 1, "construct": 1, "describ": 1, "design": 1, "discuss": 1, "eas": 1, "extens": 1, "formal": 1, "help": 1, "hierarch": 4, "implement": 1, "increas": 1, "increasingli": 1, "languag": 1, "larg": 1, "list": 1, "method": 2, "number": 1, "paper": 1, "predict": 1, "problem": 1, "process": 1, "produc": 1, "product": 1, "program": 6, "proof": 2, "recogn": 1, "reliabl": 1, "signific": 1, "specif": 1, "substanti": 1, "techniqu": 1, "user": 1, "spitzen": 1, "levitt": 1}}, "3031": {"id": "3031", "title": "Abstract Data Types and Software Validation", "abstract": "A data abstraction can be naturally specified using algebraic axioms.  The virtue of these  axioms is that they permit a representation-independent formal specification of a data type.  An example  is given which shows how to employ algebraic axioms at successive levels of implementation.  The  major  thrust of the paper is twofold.  First, it is shown how the use of algebraic axiomatizations can simplify  the process of proving the correctness of an implementation of an abstract data type.  Second, semi-automatic  tools are described which can be used both to automate such proofs of correctness and to derive an immediate  implementation from the axioms.  This implementation allows for limited testing of programs at design  time, before a conventional implementation is accomplished.", "authors": "Guttag, J.V. Horowitz, E. Musser, D.R.", "words_pool": ["abstract", "abstract", "accomplish", "algebra", "autom", "automat", "axiomat", "axiom", "convent", "correct", "data", "deriv", "design", "employ", "formal", "implement", "independ", "level", "limit", "major", "natur", "paper", "permit", "process", "program", "proof", "prove", "represent", "semi", "shown", "show", "simplifi", "softwar", "specif", "success", "test", "thrust", "time", "tool", "twofold", "type", "type", "valid", "virtu", "guttag", "horowitz", "musser"], "word_count": {"abstract": 2, "accomplish": 1, "algebra": 3, "autom": 1, "automat": 1, "axiomat": 1, "axiom": 4, "convent": 1, "correct": 2, "data": 3, "deriv": 1, "design": 1, "employ": 1, "formal": 1, "implement": 5, "independ": 1, "level": 1, "limit": 1, "major": 1, "natur": 1, "paper": 1, "permit": 1, "process": 1, "program": 1, "proof": 1, "prove": 1, "represent": 1, "semi": 1, "shown": 1, "show": 1, "simplifi": 1, "softwar": 1, "specif": 1, "success": 1, "test": 1, "thrust": 1, "time": 1, "tool": 1, "twofold": 1, "type": 2, "valid": 1, "virtu": 1, "guttag": 1, "horowitz": 1, "musser": 1}}, "3032": {"id": "3032", "title": "Reverse Path Forwarding of Broadcast Packets", "abstract": "A broadcast packet is for delivery to all nodes of a network.  Algorithms for accomplishing  this delivery through a store-and-forward packet switching  computer network include (1) transmission  of separately addressed packets. (2) multidestination addressing, (3) hot potato forwarding,(4) spanning  tree forwarding, and (5) source based forwarding.  To this list of algorithms we add (6) reverse path  forwarding, a broadcast routing method which exploits routing procedures and data structures already  available for packet switching.  Reverse path forwarding is a practical algorithm for broadcast routing   in store-and-forward packet switching computer networks.  The algorithm is described as being practical   because it is not optimal according to metrics developed for its analysis in this paper, and also because  it can be implemented in existing networks with less complexity than that required for the known alternatives.", "authors": "Dalal, Y", "words_pool": ["accomplish", "accord", "add", "address", "address", "algorithm", "algorithm", "altern", "analysi", "base", "broadcast", "complex", "comput", "data", "deliveri", "develop", "exist", "exploit", "forward", "forward", "hot", "implement", "includ", "known", "list", "method", "metric", "multidestin", "network", "network", "node", "optim", "packet", "packet", "paper", "path", "potato", "practic", "procedur", "requir", "revers", "rout", "separ", "sourc", "span", "store", "structur", "switch", "transmiss", "tree", "dalal"], "word_count": {"accomplish": 1, "accord": 1, "add": 1, "address": 2, "algorithm": 4, "altern": 1, "analysi": 1, "base": 1, "broadcast": 3, "complex": 1, "comput": 2, "data": 1, "deliveri": 2, "develop": 1, "exist": 1, "exploit": 1, "forward": 7, "hot": 1, "implement": 1, "includ": 1, "known": 1, "list": 1, "method": 1, "metric": 1, "multidestin": 1, "network": 4, "node": 1, "optim": 1, "packet": 5, "paper": 1, "path": 2, "potato": 1, "practic": 2, "procedur": 1, "requir": 1, "revers": 2, "rout": 3, "separ": 1, "sourc": 1, "span": 1, "store": 2, "structur": 1, "switch": 3, "transmiss": 1, "tree": 1, "dalal": 1}}, "3033": {"id": "3033", "title": "Optimizing Decision Trees Through Heuristically Guided Search", "abstract": "Optimal decision table conversion has been tackled in the literature using two approaches,  dynamic programming and branch-and-bound.  The former technique is quite effective, but its time and  space requirements are independent of how \"easy\" the given table is.  Furthermore, it cannot be used  to produce good, quasi optimal solutions.  The branch-and-bound technique uses a good heuristic to direct  the search, but is cluttered up by an enormous search space, since the number of solutions increases  with the number of test variables according to a double  exponential.  In this paper we suggest a heuristically  guided top-down search algorithm which, like dynamic programming, recognizes identical subproblems but  which can be used to find both optimal and quasi optimal solutions.  The heuristic search method introduced  in this paper combines the positive aspects of the above two techniques.  Compressed tables with a large  number of variables can be handled without deriving expanded tables first.", "authors": "Martelli, A. Montanari, U.", "words_pool": ["accord", "algorithm", "approach", "aspect", "bound", "branch", "clutter", "combin", "compress", "convers", "decis", "deriv", "direct", "doubl", "dynam", "easi", "effect", "enorm", "expand", "exponenti", "find", "good", "guid", "handl", "heurist", "heurist", "ident", "increas", "independ", "introduc", "larg", "literatur", "method", "number", "optim", "optim", "paper", "posit", "produc", "program", "quasi", "recogn", "requir", "search", "solut", "space", "subproblem", "suggest", "tabl", "tabl", "tackl", "techniqu", "techniqu", "test", "time", "top", "tree", "variabl", "martelli", "montanari"], "word_count": {"accord": 1, "algorithm": 1, "approach": 1, "aspect": 1, "bound": 2, "branch": 2, "clutter": 1, "combin": 1, "compress": 1, "convers": 1, "decis": 1, "deriv": 1, "direct": 1, "doubl": 1, "dynam": 2, "easi": 1, "effect": 1, "enorm": 1, "expand": 1, "exponenti": 1, "find": 1, "good": 2, "guid": 1, "handl": 1, "heurist": 3, "ident": 1, "increas": 1, "independ": 1, "introduc": 1, "larg": 1, "literatur": 1, "method": 1, "number": 3, "optim": 4, "paper": 2, "posit": 1, "produc": 1, "program": 2, "quasi": 2, "recogn": 1, "requir": 1, "search": 4, "solut": 3, "space": 2, "subproblem": 1, "suggest": 1, "tabl": 4, "tackl": 1, "techniqu": 3, "test": 1, "time": 1, "top": 1, "tree": 1, "variabl": 2, "martelli": 1, "montanari": 1}}, "3034": {"id": "3034", "title": "Detection of Logical Errors in Decision Table Programs", "abstract": "In this paper an algorithm to detect logical errors in a limited-entry decision table and in  loop-free programs with embedded decision tables is developed.  All the conditions in the decision tables  are assumed to be inequalities or equalities relating linear expressions.  It is also assumed that actions  in a decision table are linear in variables which occur in the condition stub of the decision table (or  tables) to which control is transferred from the table.  The algorithm is based on determining whether  a set of linear inequalities has or does not have a solution.  The algorithm described in the paper is  implemented in Fortran IV.", "authors": "Ibramsha, M. Rajaraman, V.", "words_pool": ["action", "algorithm", "assum", "base", "condit", "condit", "control", "decis", "detect", "detect", "determin", "develop", "embed", "entri", "equal", "error", "express", "fortran", "free", "implement", "inequ", "iv", "limit", "linear", "logic", "loop", "occur", "paper", "program", "relat", "set", "solut", "stub", "tabl", "tabl", "transfer", "variabl", "ibramsha", "rajaraman"], "word_count": {"action": 1, "algorithm": 3, "assum": 2, "base": 1, "condit": 2, "control": 1, "decis": 5, "detect": 1, "determin": 1, "develop": 1, "embed": 1, "entri": 1, "equal": 1, "error": 1, "express": 1, "fortran": 1, "free": 1, "implement": 1, "inequ": 2, "iv": 1, "limit": 1, "linear": 3, "logic": 1, "loop": 1, "occur": 1, "paper": 2, "program": 1, "relat": 1, "set": 1, "solut": 1, "stub": 1, "tabl": 7, "transfer": 1, "variabl": 1, "ibramsha": 1, "rajaraman": 1}}, "3035": {"id": "3035", "title": ".", "abstract": "The findings of a study designed to address the pressing problems associated with the strategic  planning of the computing effort in higher education are presented here.  A planning methodology was  developed and tested through implementation at a university.  Two years after the methodology was implemented,  the effectiveness of the planning methodology was assessed in terms of the improvement of the delivery  of computing services to the major institutional roles of instruction, research, and administration.   Two control institutions were employed to contrast the improvements at the test institution.  The results  of the research indicate the planning methodology significantly enhanced the delivery of computing services.", "authors": "Wetherbe, J", "words_pool": ["address", "administr", "assess", "comput", "contrast", "control", "deliveri", "design", "develop", "educ", "effect", "effort", "employ", "enhanc", "find", "higher", "implement", "implement", "improv", "improv", "institut", "institut", "institut", "instruct", "major", "methodolog", "plan", "present", "press", "problem", "research", "result", "role", "servic", "significantli", "strateg", "studi", "term", "test", "test", "univers", "year", "wetherb"], "word_count": {"address": 1, "administr": 1, "assess": 1, "comput": 3, "contrast": 1, "control": 1, "deliveri": 2, "design": 1, "develop": 1, "educ": 1, "effect": 1, "effort": 1, "employ": 1, "enhanc": 1, "find": 1, "higher": 1, "implement": 2, "improv": 2, "institut": 3, "instruct": 1, "major": 1, "methodolog": 4, "plan": 4, "present": 1, "press": 1, "problem": 1, "research": 2, "result": 1, "role": 1, "servic": 2, "significantli": 1, "strateg": 1, "studi": 1, "term": 1, "test": 2, "univers": 1, "year": 1, "wetherb": 1}}, "3036": {"id": "3036", "title": "The Selection of Optimal Tab Settings", "abstract": "A new generation of computer terminals allows tab settings to be selected and set by the computer.   This feature can be used to reduce the number of characters that are needed to represent a document  for transmission and printing.  In this note, an algorithm is given for selecting the optimal set of  tab stops for minimizing the number of characters transmitted.  An implementation of the algorithm has  reduced the number of characters transmitted by from 7 to 30 percent, but requires a prepass through  the document to compute a matrix used in determining the optimal set tab stops.  The use of fixed tab  stops, as a heuristic alternative, can achieve about 80 percent of optimal with no prepass.", "authors": "Peterson, J.L. Bitner, J.R. Howard, J.H.", "words_pool": ["achiev", "algorithm", "altern", "charact", "comput", "comput", "determin", "document", "featur", "fix", "gener", "heurist", "implement", "matrix", "minim", "need", "note", "number", "optim", "percent", "prepass", "print", "reduc", "reduc", "repres", "requir", "select", "select", "select", "set", "set", "stop", "tab", "termin", "transmiss", "transmit", "peterson", "bitner", "howard"], "word_count": {"achiev": 1, "algorithm": 2, "altern": 1, "charact": 3, "comput": 3, "determin": 1, "document": 2, "featur": 1, "fix": 1, "gener": 1, "heurist": 1, "implement": 1, "matrix": 1, "minim": 1, "need": 1, "note": 1, "number": 3, "optim": 3, "percent": 2, "prepass": 2, "print": 1, "reduc": 2, "repres": 1, "requir": 1, "select": 2, "set": 4, "stop": 3, "tab": 4, "termin": 1, "transmiss": 1, "transmit": 2, "peterson": 1, "bitner": 1, "howard": 1}}, "3037": {"id": "3037", "title": "A Linear Sieve Algorithm for Finding Prime Numbers", "abstract": "A new algorithm is presented for finding all primes between 2 and n.  The algorithm executes  in time proportional to n (assuming that multiplication of integers not larger than n can be performed  in unit time).  The method has the same arithmetic complexity as the algorithm presented by Mairson [6];  however, our version is perhaps simpler and more elegant.  It is also easily extended to find the prime  factorization of all integers between 2 and n in time proportional to n.", "authors": "Gries, D. Misra, J.", "words_pool": ["algorithm", "arithmet", "assum", "complex", "easili", "eleg", "execut", "extend", "factor", "find", "find", "integ", "larger", "linear", "mairson", "method", "multipl", "number", "perform", "present", "prime", "prime", "proport", "siev", "simpler", "time", "unit", "version", "gri", "misra"], "word_count": {"algorithm": 3, "arithmet": 1, "assum": 1, "complex": 1, "easili": 1, "eleg": 1, "execut": 1, "extend": 1, "factor": 1, "find": 2, "integ": 2, "larger": 1, "linear": 1, "mairson": 1, "method": 1, "multipl": 1, "number": 1, "perform": 1, "present": 2, "prime": 2, "proport": 2, "siev": 1, "simpler": 1, "time": 3, "unit": 1, "version": 1, "gri": 1, "misra": 1}}, "3038": {"id": "3038", "title": "Using Encryption for Authentication in Large Networks of Computers", "abstract": "Use of encryption to achieve authenticated communication in computer networks is discussed.   Example protocols are presented for the establishment of authenticated connections, for the management  of authenticated mail, and for signature verification and document integrity guarantee.  Both conventional  and public-key encryption algorithms are considered as the basis for protocols.", "authors": "Needham, R.M. Schroeder, M.D.", "words_pool": ["achiev", "algorithm", "authent", "authent", "basi", "commun", "comput", "comput", "connect", "consid", "convent", "discuss", "document", "encrypt", "establish", "guarante", "integr", "key", "larg", "mail", "manag", "network", "present", "protocol", "public", "signatur", "verif", "needham", "schroeder"], "word_count": {"achiev": 1, "algorithm": 1, "authent": 3, "basi": 1, "commun": 1, "comput": 1, "connect": 1, "consid": 1, "convent": 1, "discuss": 1, "document": 1, "encrypt": 2, "establish": 1, "guarante": 1, "integr": 1, "key": 1, "larg": 1, "mail": 1, "manag": 1, "network": 1, "present": 1, "protocol": 2, "public": 1, "signatur": 1, "verif": 1, "needham": 1, "schroeder": 1}}, "3039": {"id": "3039", "title": "On-the-Fly Garbage Collection: An Exercise in Cooperation", "abstract": ". Lamport, L. Martin, A.J. Scholten, C.S. Steffens, E.F.M.", "authors": "Dijkstra, E", "words_pool": ["collect", "cooper", "exercis", "fli", "garbag", "lamport", "martin", "scholten", "steffen", "dijkstra"], "word_count": {"collect": 1, "cooper": 1, "exercis": 1, "fli": 1, "garbag": 1, "lamport": 1, "martin": 1, "scholten": 1, "steffen": 1, "dijkstra": 1}}, "3040": {"id": "3040", "title": "Synthesizing Constraint Expressions", "abstract": "A constraint network representation is presented for a combinatorial search problem: finding  values for a set of variables subject to a set of constraints.  A theory of consistency levels in such  networks is formulated, which is related to problems of backtrack tree search efficiency.  An algorithm  is developed that can achieve any level of consistency desired, in order to preprocess the problem for  subsequent backtrack search, or to function as an alternative to backtrack search by explicitly determining  all solutions.", "authors": "Freuder, E", "words_pool": ["achiev", "algorithm", "altern", "backtrack", "combinatori", "consist", "constraint", "constraint", "desir", "determin", "develop", "effici", "explicitli", "express", "find", "formul", "function", "level", "level", "network", "network", "order", "preprocess", "present", "problem", "problem", "relat", "represent", "search", "set", "solut", "subject", "subsequ", "synthes", "theori", "tree", "valu", "variabl", "freuder"], "word_count": {"achiev": 1, "algorithm": 1, "altern": 1, "backtrack": 3, "combinatori": 1, "consist": 2, "constraint": 2, "desir": 1, "determin": 1, "develop": 1, "effici": 1, "explicitli": 1, "express": 1, "find": 1, "formul": 1, "function": 1, "level": 2, "network": 2, "order": 1, "preprocess": 1, "present": 1, "problem": 3, "relat": 1, "represent": 1, "search": 4, "set": 2, "solut": 1, "subject": 1, "subsequ": 1, "synthes": 1, "theori": 1, "tree": 1, "valu": 1, "variabl": 1, "freuder": 1}}, "3041": {"id": "3041", "title": "Median Split Trees: A Fast Lookup Technique for Frequently Occuring Keys", "abstract": "Split trees are a new technique for searching sets of keys with highly skewed frequency distributions.   A split tree is a binary search tree each node of which contains two key values-a node value which is  a maximally frequent key in that subtree, and a split value which partitions the remaining keys (with  respect to their lexical ordering) between the left and right subtrees.  A median split tree (MST) uses  the lexical median of a node's descendents as its split value to force the search tree to be perfectly  balanced, achieving both a space efficient representation of the tree and high search speed.  Unlike  frequency ordered binary search trees, the cost of a successful search of an MST is log n bounded and  very stable around minimal values.  Further, an MST can be built for a given key ordering and set of  frequencies in time n log n, as opposed to n2 for an optimum binary search tree.  A discussion of the  application of MST's to dictionary lookup for English is presented, and the performance obtained is contrasted  with that of other techniques.", "authors": ".", "words_pool": ["achiev", "applic", "balanc", "binari", "bound", "built", "contrast", "cost", "descend", "dictionari", "discuss", "distribut", "effici", "english", "fast", "forc", "frequenc", "frequenc", "frequent", "frequent", "high", "highli", "key", "key", "left", "lexic", "log", "lookup", "maxim", "median", "minim", "mst", "n2", "node", "obtain", "occur", "oppos", "optimum", "order", "order", "partit", "perfectli", "perform", "present", "remain", "represent", "respect", "search", "search", "set", "set", "skew", "space", "speed", "split", "stabl", "subtre", "subtre", "success", "techniqu", "techniqu", "time", "tree", "tree", "unlik", "valu"], "word_count": {"achiev": 1, "applic": 1, "balanc": 1, "binari": 3, "bound": 1, "built": 1, "contrast": 1, "cost": 1, "descend": 1, "dictionari": 1, "discuss": 1, "distribut": 1, "effici": 1, "english": 1, "fast": 1, "forc": 1, "frequenc": 3, "frequent": 1, "high": 1, "highli": 1, "key": 5, "left": 1, "lexic": 2, "log": 2, "lookup": 1, "maxim": 1, "median": 2, "minim": 1, "mst": 4, "n2": 1, "node": 3, "obtain": 1, "occur": 1, "oppos": 1, "optimum": 1, "order": 3, "partit": 1, "perfectli": 1, "perform": 1, "present": 1, "remain": 1, "represent": 1, "respect": 1, "search": 7, "set": 2, "skew": 1, "space": 1, "speed": 1, "split": 5, "stabl": 1, "subtre": 2, "success": 1, "techniqu": 2, "time": 1, "tree": 8, "unlik": 1, "valu": 2}}, "3042": {"id": "3042", "title": "Power Trees", "abstract": "The new class of Pk trees is presented, where height balance is maintained for the nodes Iying  on particular paths.  The number of nodes of a Pk tree asymptotically grows as a power of the height,  in the worst case.  A procedure for node insertion is given, and the class of trees  considered is restricted  to IPk trees, which are buildable by such a procedure.  The average behavior of such trees, studied by  an extensive set of simulation runs, is close to that of AVL trees.  In particular, the family of IPO  trees whose main advantage is the reduced number of restructurings required after node insertion, is  analyzed.", "authors": "Luccio, F. Pagli, L.", "words_pool": ["advantag", "analyz", "asymptot", "averag", "avl", "balanc", "behavior", "buildabl", "case", "class", "close", "consid", "extens", "famili", "grow", "height", "insert", "ipk", "ipo", "iye", "main", "maintain", "node", "node", "number", "path", "pk", "power", "present", "procedur", "reduc", "requir", "restrict", "restructur", "run", "set", "simul", "studi", "tree", "tree", "worst", "luccio", "pagli"], "word_count": {"advantag": 1, "analyz": 1, "asymptot": 1, "averag": 1, "avl": 1, "balanc": 1, "behavior": 1, "buildabl": 1, "case": 1, "class": 2, "close": 1, "consid": 1, "extens": 1, "famili": 1, "grow": 1, "height": 2, "insert": 2, "ipk": 1, "ipo": 1, "iye": 1, "main": 1, "maintain": 1, "node": 4, "number": 2, "path": 1, "pk": 2, "power": 1, "present": 1, "procedur": 2, "reduc": 1, "requir": 1, "restrict": 1, "restructur": 1, "run": 1, "set": 1, "simul": 1, "studi": 1, "tree": 7, "worst": 1, "luccio": 1, "pagli": 1}}, "3043": {"id": "3043", "title": "Distributed Processes: A Concurrent Programming Concept", "abstract": "A language concept for concurrent processes without common variables is introduced.  These  processes communicate and synchronize by means of procedure calls and guarded regions.  This concept  is proposed for real-time applications controlled by microcomputer networks with distributed storage.   The paper gives several examples of distributed processes and shows that they include procedures, coroutines,  classes, monitors, processes, semaphores, buffers, path expressions, and input/output as special cases.", "authors": "Hansen, P.", "words_pool": ["applic", "buffer", "call", "case", "class", "common", "commun", "concept", "concurr", "control", "coroutin", "distribut", "exampl", "express", "guard", "includ", "input", "introduc", "languag", "mean", "microcomput", "monitor", "network", "output", "paper", "path", "procedur", "procedur", "process", "program", "propos", "real", "region", "semaphor", "show", "special", "storag", "synchron", "time", "variabl", "hansen"], "word_count": {"applic": 1, "buffer": 1, "call": 1, "case": 1, "class": 1, "common": 1, "commun": 1, "concept": 2, "concurr": 1, "control": 1, "coroutin": 1, "distribut": 2, "exampl": 1, "express": 1, "guard": 1, "includ": 1, "input": 1, "introduc": 1, "languag": 1, "mean": 1, "microcomput": 1, "monitor": 1, "network": 1, "output": 1, "paper": 1, "path": 1, "procedur": 2, "process": 4, "program": 1, "propos": 1, "real": 1, "region": 1, "semaphor": 1, "show": 1, "special": 1, "storag": 1, "synchron": 1, "time": 1, "variabl": 1, "hansen": 1}}, "3044": {"id": "3044", "title": "A Note on Conditional Expressions", "abstract": "Evaluation of a conditional expression may succeed even when the \"deciding predicate\" diverges  and the alternatives are records (or nodes) whose fields have different content.", "authors": "Friedman, D.P. Wise, D.S.", "words_pool": ["altern", "condit", "content", "decid", "diverg", "evalu", "express", "express", "field", "node", "note", "predic", "record", "succeed", "friedman", "wise"], "word_count": {"altern": 1, "condit": 1, "content": 1, "decid": 1, "diverg": 1, "evalu": 1, "express": 1, "field": 1, "node": 1, "note": 1, "predic": 1, "record": 1, "succeed": 1, "friedman": 1, "wise": 1}}, "3045": {"id": "3045", "title": "A Simple Recovery-Only Procedure For SImple Precedence Parsers", "abstract": "A simple method is described enabling simple precedence parsers to recover from syntax errors.   No attempt to repair errors is made, yet parsing and most semantic processing can continue.  The result  is a good \"first approximation\" to syntax error handling with negligible increase in parsing time, space,  and complexity of both the parser and its table generator.", "authors": "Ripley, D.G.", "words_pool": ["approxim", "attempt", "complex", "continu", "enabl", "error", "error", "gener", "good", "handl", "increas", "made", "method", "neglig", "parser", "parser", "pars", "preced", "procedur", "process", "recov", "recoveri", "repair", "result", "semant", "simpl", "space", "syntax", "tabl", "time", "ripley"], "word_count": {"approxim": 1, "attempt": 1, "complex": 1, "continu": 1, "enabl": 1, "error": 3, "gener": 1, "good": 1, "handl": 1, "increas": 1, "made": 1, "method": 1, "neglig": 1, "parser": 2, "pars": 2, "preced": 1, "procedur": 1, "process": 1, "recov": 1, "recoveri": 1, "repair": 1, "result": 1, "semant": 1, "simpl": 2, "space": 1, "syntax": 2, "tabl": 1, "time": 1, "ripley": 1}}, "3046": {"id": "3046", "title": "Computer Generation of Gamma Random Variables - II", "abstract": "A rejection method is proposed for generating gamma variates with nonintegral shape parameter  a, a > 1. This method is similar to other methods given by Fishman, Wallace, and Tadikamalla and is faster  than these methods for a> 2.  The core storage requirements and the programming effort for the proposed  method are similar to those of Wallace's or Tadikamalla's methods.  The computational times for the proposed  method remain fairly constant for medium and large values of a and are superior to times obtained by  Ahrens and Dieter's method for all values of a.  The proposed method is simpler than Ahrens and Dieter's  method.", "authors": "Tadikamalla, P.R.", "words_pool": ["ahren", "comput", "comput", "constant", "core", "dieter", "effort", "fairli", "faster", "fishman", "gamma", "gener", "gener", "ii", "larg", "medium", "method", "method", "nonintegr", "obtain", "paramet", "program", "propos", "random", "reject", "remain", "requir", "shape", "similar", "simpler", "storag", "superior", "tadikamalla", "time", "valu", "variabl", "variat", "wallac", "tadikamalla"], "word_count": {"ahren": 2, "comput": 1, "constant": 1, "core": 1, "dieter": 2, "effort": 1, "fairli": 1, "faster": 1, "fishman": 1, "gamma": 1, "gener": 1, "ii": 1, "larg": 1, "medium": 1, "method": 10, "nonintegr": 1, "obtain": 1, "paramet": 1, "program": 1, "propos": 4, "random": 1, "reject": 1, "remain": 1, "requir": 1, "shape": 1, "similar": 2, "simpler": 1, "storag": 1, "superior": 1, "tadikamalla": 2, "time": 2, "valu": 2, "variabl": 1, "variat": 1, "wallac": 2}}, "3047": {"id": "3047", "title": "Using Synthetic Images to Register Real Images with Surface Models", "abstract": "A number of image analysis tasks can benefit from registration of the image with a model of  the surface being imaged.  Automatic navigation using visible light or radar images requires exact alignment  of such images with digital terrain models.  In addition, automatic classification of terrain, using  satellite imagery, requires such alignment to deal correctly with the effects of varying sun angle and  surface slope.  Even inspection techniques for certain industrial parts may be improved by this means.  We achieve the required alignment by matching the real image with a synthetic image obtained from a surface  model and known positions of the light sources.  The synthetic image intensity is calculated using the  reflectance map, a convenient way of describing surface reflection as a function of surface gradient.   We illustrate the technique using LANDSAT images and digital terrain models.", "authors": "Horn, B", "words_pool": ["achiev", "addit", "align", "analysi", "angl", "automat", "benefit", "calcul", "classif", "conveni", "correctli", "deal", "describ", "digit", "effect", "exact", "function", "gradient", "illustr", "imag", "imag", "imageri", "imag", "improv", "industri", "inspect", "intens", "known", "landsat", "light", "map", "match", "mean", "model", "model", "navig", "number", "obtain", "part", "posit", "radar", "real", "reflect", "reflect", "regist", "registr", "requir", "requir", "satellit", "slope", "sourc", "sun", "surfac", "synthet", "task", "techniqu", "techniqu", "terrain", "vari", "visibl", "horn"], "word_count": {"achiev": 1, "addit": 1, "align": 3, "analysi": 1, "angl": 1, "automat": 2, "benefit": 1, "calcul": 1, "classif": 1, "conveni": 1, "correctli": 1, "deal": 1, "describ": 1, "digit": 2, "effect": 1, "exact": 1, "function": 1, "gradient": 1, "illustr": 1, "imag": 9, "imageri": 1, "improv": 1, "industri": 1, "inspect": 1, "intens": 1, "known": 1, "landsat": 1, "light": 2, "map": 1, "match": 1, "mean": 1, "model": 4, "navig": 1, "number": 1, "obtain": 1, "part": 1, "posit": 1, "radar": 1, "real": 1, "reflect": 2, "regist": 1, "registr": 1, "requir": 3, "satellit": 1, "slope": 1, "sourc": 1, "sun": 1, "surfac": 5, "synthet": 2, "task": 1, "techniqu": 2, "terrain": 3, "vari": 1, "visibl": 1, "horn": 1}}, "3048": {"id": "3048", "title": "Performance Evaluation of Highly Concurrent Computers by Deterministic Simulation", "abstract": "Simulation is presented as a practical technique for performance evaluation of alternative  configurations of highly concurrent computers.  A technique is described for constructing a detailed  deterministic simulation model of a system.  In the model a control stream replaces the instruction and  data streams of the real system.  Simulation of the system model yields the timing and resource usage  statistics needed for performance evaluation, without the necessity of emulating the system.  As a case  study, the implementation of a simulator of a model of the CPU-memory subsystem of the IBM 360/91 is  described.  The results of evaluating some alternative system designs are discussed.  The experiments  reveal that, for the case study, the major bottlenecks in the system are the memory unit and the fixed  point unit.  Further, it appears that many of the sophisticated pipelining and buffering technique simplemented  in the architecture of the IBM 360/91 are of little value when high-speed (cache) memory is used, as  in the IBM 360/195.", "authors": "Kumar, B. Davidson, E.S.", "words_pool": ["altern", "appear", "architectur", "bottleneck", "buffer", "cach", "case", "comput", "concurr", "configur", "construct", "control", "cpu", "data", "design", "detail", "determinist", "discuss", "emul", "evalu", "evalu", "experi", "fix", "high", "highli", "ibm", "implement", "instruct", "major", "memori", "model", "necess", "need", "perform", "pipelin", "point", "practic", "present", "real", "replac", "resourc", "result", "reveal", "simplement", "simul", "simul", "sophist", "speed", "statist", "stream", "stream", "studi", "subsystem", "system", "techniqu", "time", "unit", "usag", "yield", "kumar", "davidson"], "word_count": {"altern": 2, "appear": 1, "architectur": 1, "bottleneck": 1, "buffer": 1, "cach": 1, "case": 2, "comput": 1, "concurr": 1, "configur": 1, "construct": 1, "control": 1, "cpu": 1, "data": 1, "design": 1, "detail": 1, "determinist": 1, "discuss": 1, "emul": 1, "evalu": 3, "experi": 1, "fix": 1, "high": 1, "highli": 1, "ibm": 3, "implement": 1, "instruct": 1, "major": 1, "memori": 3, "model": 4, "necess": 1, "need": 1, "perform": 2, "pipelin": 1, "point": 1, "practic": 1, "present": 1, "real": 1, "replac": 1, "resourc": 1, "result": 1, "reveal": 1, "simplement": 1, "simul": 4, "sophist": 1, "speed": 1, "statist": 1, "stream": 2, "studi": 2, "subsystem": 1, "system": 6, "techniqu": 3, "time": 1, "unit": 2, "usag": 1, "yield": 1, "kumar": 1, "davidson": 1}}, "3049": {"id": "3049", "title": "A Simply Extended and Modified Batch Environment Graphical System (SEMBEGS)", "abstract": ".", "authors": "Wendorf, J", "words_pool": ["batch", "environ", "extend", "graphic", "modifi", "sembeg", "simpli", "system", "wendorf"], "word_count": {"batch": 1, "environ": 1, "extend": 1, "graphic": 1, "modifi": 1, "sembeg": 1, "simpli": 1, "system": 1, "wendorf": 1}}, "3050": {"id": "3050", "title": "Systems Design Education: A Gaming Approach", "abstract": "One of the problems facing managers of computer installations is the problem of configuring  the computer system to meet the demands made by the mix of jobs that the computer center must service.   This paper presents a management game that allows the player to configure a computer system to meet  a hypothetical job mix is under the control of a game administrator and can be varied to simulate a variety  of real-world situations (I/O bound jobs, compute bound jobs, etc.).  The player of the game receives  a set of detailed reports on the cost of his choices and a simulated run of the center operating under  his choices.", "authors": "Lyons, N.R.", "words_pool": ["administr", "approach", "bound", "center", "choic", "comput", "comput", "configur", "configur", "control", "cost", "demand", "design", "detail", "educ", "face", "game", "game", "hypothet", "instal", "job", "job", "made", "manag", "manag", "meet", "mix", "oper", "paper", "player", "present", "problem", "problem", "real", "receiv", "report", "run", "servic", "set", "simul", "simul", "situat", "system", "system", "vari", "varieti", "world", "lyon"], "word_count": {"administr": 1, "approach": 1, "bound": 2, "center": 2, "choic": 2, "comput": 5, "configur": 2, "control": 1, "cost": 1, "demand": 1, "design": 1, "detail": 1, "educ": 1, "face": 1, "game": 3, "hypothet": 1, "instal": 1, "job": 4, "made": 1, "manag": 2, "meet": 2, "mix": 2, "oper": 1, "paper": 1, "player": 2, "present": 1, "problem": 2, "real": 1, "receiv": 1, "report": 1, "run": 1, "servic": 1, "set": 1, "simul": 2, "situat": 1, "system": 2, "vari": 1, "varieti": 1, "world": 1, "lyon": 1}}, "3051": {"id": "3051", "title": "A Comparison of Heaps and the TL Structure for the SImulation Event Set", "abstract": "None", "authors": "Franta, W.R. Maly, K.", "words_pool": ["comparison", "event", "heap", "set", "simul", "structur", "tl", "franta", "mali"], "word_count": {"comparison": 1, "event": 1, "heap": 1, "set": 1, "simul": 1, "structur": 1, "tl": 1, "franta": 1, "mali": 1}}, "3052": {"id": "3052", "title": "Cold-Start vs. Warm-Start Miss Ratios", "abstract": "In a two-level computer storage hierarchy, miss ratio measurements are often made from a \"cold  start,\" that is made with the first-level  store initially empty.  For large capacities the effect on  the measured miss ratio of the misses incurred while filling the first-level store can be significant,  even for long reference strings.  Use of \"warm-start\" rather than \"cold-start\" miss ratios cast doubt  on the widespread belief that the observed \"S-shape\" of lifetime (reciprocal of miss ratio) versus capacity  curve indicates a property of behavior of programs that maintain a constant number of pages in main storage.   On the other hand, if cold-start miss ratios are measured as a function of capacity and measurement  length, then they are useful in studying systems in which operation of a program is periodically interrupted  by task switches.  It is shown how to obtain, under simple assumptions, the cache miss ratio for multiprogramming  from cold-start miss ratio values and how to obtain approximate cold-start miss ratios from warm-start  miss ratios.", "authors": "Easton, M", "words_pool": ["approxim", "assumpt", "behavior", "belief", "cach", "capac", "capac", "cast", "cold", "comput", "constant", "curv", "doubt", "effect", "empti", "fill", "function", "hand", "hierarchi", "incur", "initi", "interrupt", "larg", "length", "level", "lifetim", "long", "made", "main", "maintain", "measur", "measur", "measur", "miss", "miss", "multiprogram", "number", "observ", "obtain", "oper", "page", "period", "program", "program", "properti", "ratio", "ratio", "reciproc", "refer", "shape", "shown", "signific", "simpl", "start", "storag", "store", "string", "studi", "switch", "system", "task", "valu", "versu", "warm", "widespread", "easton"], "word_count": {"approxim": 1, "assumpt": 1, "behavior": 1, "belief": 1, "cach": 1, "capac": 3, "cast": 1, "cold": 5, "comput": 1, "constant": 1, "curv": 1, "doubt": 1, "effect": 1, "empti": 1, "fill": 1, "function": 1, "hand": 1, "hierarchi": 1, "incur": 1, "initi": 1, "interrupt": 1, "larg": 1, "length": 1, "level": 3, "lifetim": 1, "long": 1, "made": 2, "main": 1, "maintain": 1, "measur": 4, "miss": 10, "multiprogram": 1, "number": 1, "observ": 1, "obtain": 2, "oper": 1, "page": 1, "period": 1, "program": 2, "properti": 1, "ratio": 9, "reciproc": 1, "refer": 1, "shape": 1, "shown": 1, "signific": 1, "simpl": 1, "start": 7, "storag": 2, "store": 2, "string": 1, "studi": 1, "switch": 1, "system": 1, "task": 1, "valu": 1, "versu": 1, "warm": 2, "widespread": 1, "easton": 1}}, "3053": {"id": "3053", "title": "Packed Scatter Tables", "abstract": "Scatter tables for open addressing benefit from recursive entry displacements, cutoffs for  unsuccessful searches, and auxiliary cost functions.  Compared with conventional methods, the new techniques  provide substantially improved tables that resemble exact-solution optimal packings.  The displacements  are depth-limited approximations to an enumerative (exhaustive) optimization, although packing costs  remain linear-O(n)-with table size n.  The techniques are primarily suited for important fixed (but possibly  quite large) tables for which reference frequencies may be known: op-code tables,spelling dictionaries,  access arrays.  Introduction of frequency weights further improves retrievals, but the enhancement may  degrade cutoffs.", "authors": "Lyon, G.", "words_pool": ["access", "address", "approxim", "array", "auxiliari", "benefit", "code", "compar", "convent", "cost", "cost", "cutoff", "degrad", "depth", "dictionari", "displac", "enhanc", "entri", "enum", "exact", "exhaust", "fix", "frequenc", "frequenc", "function", "import", "improv", "improv", "introduct", "known", "larg", "limit", "linear", "method", "op", "open", "optim", "optim", "pack", "pack", "pack", "possibl", "primarili", "provid", "recurs", "refer", "remain", "resembl", "retriev", "scatter", "search", "size", "solut", "spell", "substanti", "suit", "tabl", "tabl", "techniqu", "unsuccess", "weight", "lyon"], "word_count": {"access": 1, "address": 1, "approxim": 1, "array": 1, "auxiliari": 1, "benefit": 1, "code": 1, "compar": 1, "convent": 1, "cost": 2, "cutoff": 2, "degrad": 1, "depth": 1, "dictionari": 1, "displac": 2, "enhanc": 1, "entri": 1, "enum": 1, "exact": 1, "exhaust": 1, "fix": 1, "frequenc": 2, "function": 1, "import": 1, "improv": 2, "introduct": 1, "known": 1, "larg": 1, "limit": 1, "linear": 1, "method": 1, "op": 1, "open": 1, "optim": 2, "pack": 2, "possibl": 1, "primarili": 1, "provid": 1, "recurs": 1, "refer": 1, "remain": 1, "resembl": 1, "retriev": 1, "scatter": 1, "search": 1, "size": 1, "solut": 1, "spell": 1, "substanti": 1, "suit": 1, "tabl": 5, "techniqu": 2, "unsuccess": 1, "weight": 1, "lyon": 1}}, "3054": {"id": "3054", "title": "Implementing Quicksort Programs", "abstract": "This paper is a practical study of how to implement the Quicksort sorting algorithm and its  best variants on real computers, including how to apply various code optimization techniques.  A detailed  implementation combining the most effective improvements to Quicksort is given, along with a discussion  of how to implement it in assembly language.  Analytic results describing the performance of the programs  are summarized.  A variety of special situations are considered from a practical standpoint to illustrate  Quicksort's wide applicability as an internal sorting method which requires negligible extra storage.", "authors": "Sedgewick, R.", "words_pool": ["algorithm", "analyt", "applic", "appli", "assembl", "code", "combin", "comput", "consid", "describ", "detail", "discuss", "effect", "extra", "illustr", "implement", "implement", "implement", "improv", "includ", "intern", "languag", "method", "neglig", "optim", "paper", "perform", "practic", "program", "quicksort", "real", "requir", "result", "situat", "sort", "special", "standpoint", "storag", "studi", "summar", "techniqu", "variant", "varieti", "wide", "sedgewick"], "word_count": {"algorithm": 1, "analyt": 1, "applic": 1, "appli": 1, "assembl": 1, "code": 1, "combin": 1, "comput": 1, "consid": 1, "describ": 1, "detail": 1, "discuss": 1, "effect": 1, "extra": 1, "illustr": 1, "implement": 3, "improv": 1, "includ": 1, "intern": 1, "languag": 1, "method": 1, "neglig": 1, "optim": 1, "paper": 1, "perform": 1, "practic": 2, "program": 1, "quicksort": 3, "real": 1, "requir": 1, "result": 1, "situat": 1, "sort": 2, "special": 1, "standpoint": 1, "storag": 1, "studi": 1, "summar": 1, "techniqu": 1, "variant": 1, "varieti": 1, "wide": 1, "sedgewick": 1}}, "3055": {"id": "3055", "title": "An Analysis of Algorithms for the Dutch National Flag Problem", "abstract": "Solutions to the Dutch National Flag Problem have been given by Dijkstra [1] and Meyer [3].   Dijkstra starts with a simple program and arrives at an improved program by refinement.  Both of the  algorithms given by Dijkstra are shown to have an expected number of swaps which is 2/3N + 0(1) and that  these values differ at most by 1/3 of a swap and asymptotically by 1/4 of a swap.  The algorithm of Meyer  is shown to have expected swap complexity 5/9N.", "authors": "McMaster, C.L.", "words_pool": ["3n", "9n", "algorithm", "algorithm", "analysi", "arriv", "asymptot", "complex", "differ", "dijkstra", "dutch", "expect", "flag", "improv", "meyer", "nation", "number", "problem", "program", "refin", "shown", "simpl", "solut", "start", "swap", "swap", "valu", "mcmaster"], "word_count": {"3n": 1, "9n": 1, "algorithm": 2, "analysi": 1, "arriv": 1, "asymptot": 1, "complex": 1, "differ": 1, "dijkstra": 3, "dutch": 1, "expect": 2, "flag": 1, "improv": 1, "meyer": 2, "nation": 1, "number": 1, "problem": 1, "program": 2, "refin": 1, "shown": 2, "simpl": 1, "solut": 1, "start": 1, "swap": 4, "valu": 1, "mcmaster": 1}}, "3056": {"id": "3056", "title": "Counting Large Numbers of Events in Small Registers", "abstract": "It is possible to use a small counter to keep approximate counts of large numbers.  The resulting  expected error can be rather precisely controlled.  An example is given in which 8-bit counters (bytes)  are used to keep track of as many as 130,000 events with a relative error which is substantially independent  of the number n of events.  This relative error can be expected to be 24 percent or less 95 percent of  the time (i.e.o = n/8).  The techniques could be used to advantage in multichannel counting hardware  or software used for the monitoring of experiments or processes.", "authors": "Morris, R.", "words_pool": ["advantag", "approxim", "bit", "byte", "control", "counter", "counter", "count", "count", "error", "event", "expect", "experi", "hardwar", "independ", "larg", "monitor", "multichannel", "number", "number", "percent", "precis", "process", "regist", "rel", "result", "small", "softwar", "substanti", "techniqu", "time", "track", "morri"], "word_count": {"advantag": 1, "approxim": 1, "bit": 1, "byte": 1, "control": 1, "counter": 2, "count": 2, "error": 3, "event": 2, "expect": 2, "experi": 1, "hardwar": 1, "independ": 1, "larg": 1, "monitor": 1, "multichannel": 1, "number": 2, "percent": 2, "precis": 1, "process": 1, "regist": 1, "rel": 2, "result": 1, "small": 1, "softwar": 1, "substanti": 1, "techniqu": 1, "time": 1, "track": 1, "morri": 1}}, "3057": {"id": "3057", "title": "Optimal His togram Matching by Monotone Gray Level Transformation", "abstract": ".", "authors": "Chang, S", "words_pool": ["gray", "level", "match", "monoton", "optim", "togram", "transform", "chang"], "word_count": {"gray": 1, "level": 1, "match": 1, "monoton": 1, "optim": 1, "togram": 1, "transform": 1, "chang": 1}}, "3058": {"id": "3058", "title": "Jump Searching: A Fast Sequential Search Technique", "abstract": "When sequential file structures must be used and binary searching is not feasible, jump searching  becomes an appealing alternative.  This paper explores variants of the classic jump searching scheme  where the optimum jump size is the square root of the number of records.  Multiple level and variable  size jump strategies are explored, appropriate applications are discussed and performance is evaluated.", "authors": "Shneiderman, B.", "words_pool": ["altern", "appeal", "applic", "binari", "classic", "discuss", "evalu", "explor", "explor", "fast", "feasibl", "jump", "level", "multipl", "number", "optimum", "paper", "perform", "record", "root", "scheme", "search", "search", "sequenti", "size", "squar", "strategi", "structur", "techniqu", "variabl", "variant", "shneiderman"], "word_count": {"altern": 1, "appeal": 1, "applic": 1, "binari": 1, "classic": 1, "discuss": 1, "evalu": 1, "explor": 2, "fast": 1, "feasibl": 1, "jump": 4, "level": 1, "multipl": 1, "number": 1, "optimum": 1, "paper": 1, "perform": 1, "record": 1, "root": 1, "scheme": 1, "search": 3, "sequenti": 1, "size": 2, "squar": 1, "strategi": 1, "structur": 1, "techniqu": 1, "variabl": 1, "variant": 1, "shneiderman": 1}}, "3059": {"id": "3059", "title": "Models for Parallel Processing WIthin Programs: Application to CPU:I/O and I/O:I/O Overlap", "abstract": "Approximate queueing models for internal parallel processing by individual programs in a multiprogrammed  system are developed in this paper.  The solution technique is developed by network decomposition.  The  models are formulated in terms of CPU:I/O and I/O:I/O overlap and applied to the analysis of these problems.   The percentage performance improvement from CPU:I/O overlap is found to be greatest for systems which  are in approximate CPU:I/O utilization balance and for low degrees of multiprogramming.  The percentage  improvement from I/O:I/O overlap is found to be greatest for systemtems in which the I/O system is more  utilized than the CPU.", "authors": "Towsley, D. Chandy, K.M. Browne, J", "words_pool": ["analysi", "applic", "appli", "approxim", "balanc", "cpu", "decomposit", "degre", "develop", "formul", "found", "greatest", "improv", "individu", "intern", "low", "model", "multiprogram", "multiprogram", "network", "overlap", "paper", "parallel", "percentag", "perform", "problem", "process", "program", "queue", "solut", "system", "system", "systemtem", "techniqu", "term", "util", "util", "towsley", "chandi", "brown"], "word_count": {"analysi": 1, "applic": 1, "appli": 1, "approxim": 2, "balanc": 1, "cpu": 4, "decomposit": 1, "degre": 1, "develop": 2, "formul": 1, "found": 2, "greatest": 2, "improv": 2, "individu": 1, "intern": 1, "low": 1, "model": 2, "multiprogram": 2, "network": 1, "overlap": 3, "paper": 1, "parallel": 1, "percentag": 2, "perform": 1, "problem": 1, "process": 1, "program": 1, "queue": 1, "solut": 1, "system": 3, "systemtem": 1, "techniqu": 1, "term": 1, "util": 2, "towsley": 1, "chandi": 1, "brown": 1}}, "3060": {"id": "3060", "title": "Fortran 77", "abstract": "There is a new standard Fortran.  The official title is \"American National Standard Programming  Language Fortran, X3.9-1978,\" but it is more commonly referred to as \"Fortran 77,\" since its development  was completed in 1977.  It replaces the Fortran standard designated X3.9-1966.  This paper describes  many of the features of Fortran 77 and also provides some information about how and why the standard  was developed.", "authors": "Brainerd, W.", "words_pool": ["american", "commonli", "complet", "describ", "design", "develop", "develop", "featur", "fortran", "inform", "languag", "nation", "offici", "paper", "program", "refer", "replac", "standard", "titl", "x3", "brainerd"], "word_count": {"american": 1, "commonli": 1, "complet": 1, "describ": 1, "design": 1, "develop": 2, "featur": 1, "fortran": 5, "inform": 1, "languag": 1, "nation": 1, "offici": 1, "paper": 1, "program": 1, "refer": 1, "replac": 1, "standard": 4, "titl": 1, "x3": 2, "brainerd": 1}}, "3061": {"id": "3061", "title": "Simulations of Dynamic Sequential Search Algorithms", "abstract": "None", "authors": "Tenenbaum, A.", "words_pool": ["algorithm", "dynam", "search", "sequenti", "simul", "tenenbaum"], "word_count": {"algorithm": 1, "dynam": 1, "search": 1, "sequenti": 1, "simul": 1, "tenenbaum": 1}}, "3062": {"id": "3062", "title": "Real Time Plotting of Approximate Contour Maps", "abstract": "None", "authors": ".", "words_pool": ["approxim", "contour", "map", "plot", "real", "time"], "word_count": {"approxim": 1, "contour": 1, "map": 1, "plot": 1, "real": 1, "time": 1}}, "3063": {"id": "3063", "title": "A Note on Virtual Memory Indexes", "abstract": "None", "authors": "Maly, K.", "words_pool": ["index", "memori", "note", "virtual", "mali"], "word_count": {"index": 1, "memori": 1, "note": 1, "virtual": 1, "mali": 1}}, "3064": {"id": "3064", "title": "Event Manipulation for Discrete Simulations Requiring Large Numbers of Events", "abstract": "The event-manipulation system presented here consists of two major parts.  The first part addresses  the familiar problem of event scheduling efficiency when the number of scheduled events grows large.   The second part deals with the less apparent problem of providing efficiency and flexibility as scheduled  events are accessed to be executed.  Additional features and problems dealt with include the proper handling  of simultaneous events; that certain events must be created, scheduled, and executed at the same points  in simulated time; that infinite loops caused by the concatenation of such \"zero-time\" events are possible  and must be diagnosed; that maintaining various event counts is practical and economical; and that a  capability for handling  \"time-displaceable\" events is desirable and possible.", "authors": "Ulrich, E.G.", "words_pool": ["access", "addit", "address", "appar", "capabl", "caus", "concaten", "consist", "count", "creat", "deal", "dealt", "desir", "diagnos", "discret", "displac", "econom", "effici", "event", "event", "execut", "familiar", "featur", "flexibl", "grow", "handl", "includ", "infinit", "larg", "loop", "maintain", "major", "manipul", "number", "number", "part", "part", "point", "practic", "present", "problem", "problem", "proper", "provid", "requir", "schedul", "schedul", "simul", "simul", "simultan", "system", "time", "ulrich"], "word_count": {"access": 1, "addit": 1, "address": 1, "appar": 1, "capabl": 1, "caus": 1, "concaten": 1, "consist": 1, "count": 1, "creat": 1, "deal": 1, "dealt": 1, "desir": 1, "diagnos": 1, "discret": 1, "displac": 1, "econom": 1, "effici": 2, "event": 9, "execut": 2, "familiar": 1, "featur": 1, "flexibl": 1, "grow": 1, "handl": 2, "includ": 1, "infinit": 1, "larg": 1, "loop": 1, "maintain": 1, "major": 1, "manipul": 1, "number": 1, "part": 3, "point": 1, "practic": 1, "present": 1, "problem": 3, "proper": 1, "provid": 1, "requir": 1, "schedul": 4, "simul": 1, "simultan": 1, "system": 1, "time": 3, "ulrich": 1}}, "3065": {"id": "3065", "title": ". Six, H", "abstract": ". Wood, D.", "authors": "Ottmann, T", "words_pool": ["wood", "ottmann"], "word_count": {"wood": 1, "ottmann": 1}}, "3066": {"id": "3066", "title": "A Controlled Experiment in Program Testing and Code Walkthroughs/Inspections", "abstract": "This paper describes an experiment in program testing, employing 59 highly experienced data  processing professionals using seven methods to test a small PL/I program.  The results show that the  popular code walk through/inspection method was as effective as other computer-based methods in finding  errors and that the most effective methods (in terms of errors found and cost) employed pairs of subjects  who tested the program independently and then pooled their findings.  The study also shows that there  is a tremendous amount of variability among subjects and that the ability to detect certain types of  errors varies from method to method.", "authors": "Myers, G.J.", "words_pool": ["abil", "amount", "base", "code", "comput", "control", "cost", "data", "describ", "detect", "effect", "employ", "employ", "error", "experienc", "experi", "find", "find", "found", "highli", "independ", "inspect", "inspect", "method", "method", "pair", "paper", "pl", "pool", "popular", "process", "profession", "program", "result", "show", "show", "small", "studi", "subject", "term", "test", "test", "test", "tremend", "type", "variabl", "vari", "walk", "walkthrough", "myer"], "word_count": {"abil": 1, "amount": 1, "base": 1, "code": 1, "comput": 1, "control": 1, "cost": 1, "data": 1, "describ": 1, "detect": 1, "effect": 2, "employ": 2, "error": 3, "experienc": 1, "experi": 1, "find": 2, "found": 1, "highli": 1, "independ": 1, "inspect": 1, "method": 6, "pair": 1, "paper": 1, "pl": 1, "pool": 1, "popular": 1, "process": 1, "profession": 1, "program": 3, "result": 1, "show": 2, "small": 1, "studi": 1, "subject": 2, "term": 1, "test": 3, "tremend": 1, "type": 1, "variabl": 1, "vari": 1, "walk": 1, "walkthrough": 1, "myer": 1}}, "3067": {"id": "3067", "title": "Generalized Working Sets for Segment Reference Strings", "abstract": "The working-set concept is extended for programs that reference segments of different sizes.   The generalized working-set policy (GWS) keeps as its resident set those segments whose retention costs  do not exceed their retrieval costs.  The GWS is a model for the entire class of demand-fetching memory  policies that satisfy a resident-set inclusion property.  A generalized optimal policy (GOPT) is also  defined; at its operating points it minimizes aggregated retention and swapping costs.  Special cases  of the cost structure allow GWS and GOPT to simulate any known stack algorithm, the working set, and  VMIN.  Efficient procedures for computing demand curves showing swapping load as a function of memory  usage are developed for GWS and GOPT policies.  Empirical data from an actual system are included.", "authors": "Denning, P.J. Slutz, D.R.", "words_pool": ["actual", "aggreg", "algorithm", "allow", "case", "class", "comput", "concept", "cost", "cost", "curv", "data", "defin", "demand", "develop", "effici", "empir", "entir", "exceed", "extend", "fetch", "function", "gener", "gopt", "gw", "includ", "inclus", "keep", "known", "load", "memori", "minim", "model", "oper", "optim", "point", "polici", "polici", "procedur", "program", "properti", "refer", "resid", "retent", "retriev", "satisfi", "segment", "segment", "set", "set", "show", "simul", "size", "special", "stack", "string", "structur", "swap", "system", "usag", "vmin", "work", "den", "slutz"], "word_count": {"actual": 1, "aggreg": 1, "algorithm": 1, "allow": 1, "case": 1, "class": 1, "comput": 1, "concept": 1, "cost": 4, "curv": 1, "data": 1, "defin": 1, "demand": 2, "develop": 1, "effici": 1, "empir": 1, "entir": 1, "exceed": 1, "extend": 1, "fetch": 1, "function": 1, "gener": 2, "gopt": 3, "gw": 4, "includ": 1, "inclus": 1, "keep": 1, "known": 1, "load": 1, "memori": 2, "minim": 1, "model": 1, "oper": 1, "optim": 1, "point": 1, "polici": 4, "procedur": 1, "program": 1, "properti": 1, "refer": 1, "resid": 2, "retent": 2, "retriev": 1, "satisfi": 1, "segment": 2, "set": 5, "show": 1, "simul": 1, "size": 1, "special": 1, "stack": 1, "string": 1, "structur": 1, "swap": 2, "system": 1, "usag": 1, "vmin": 1, "work": 3, "den": 1, "slutz": 1}}, "3068": {"id": "3068", "title": "A Model for Verification of Data Security in Operating Systems", "abstract": "Program verification applied to kernel architectures forms a promising method for providing  uncircumventably secure, shared computer systems.  A precise definition of data security is developed  here in terms of a general model for operating systems.  This model is suitable as a basis for verifying  many of those properties of an operating system which are necessary to assure reliable enforcement of  security.  The application of this approach to the UCLA secure operating system is also discussed.", "authors": ".", "words_pool": ["applic", "appli", "approach", "architectur", "assur", "basi", "comput", "data", "definit", "develop", "discuss", "enforc", "form", "gener", "kernel", "method", "model", "oper", "precis", "program", "promis", "properti", "provid", "reliabl", "secur", "secur", "share", "suitabl", "system", "system", "term", "ucla", "uncircumvent", "verif", "verifi"], "word_count": {"applic": 1, "appli": 1, "approach": 1, "architectur": 1, "assur": 1, "basi": 1, "comput": 1, "data": 1, "definit": 1, "develop": 1, "discuss": 1, "enforc": 1, "form": 1, "gener": 1, "kernel": 1, "method": 1, "model": 2, "oper": 3, "precis": 1, "program": 1, "promis": 1, "properti": 1, "provid": 1, "reliabl": 1, "secur": 4, "share": 1, "suitabl": 1, "system": 4, "term": 1, "ucla": 1, "uncircumvent": 1, "verif": 1, "verifi": 1}}, "3069": {"id": "3069", "title": "A Practical Interprocedural Data Flow Analysis Algorithm", "abstract": "A new interprocedural  data flow analysis algorithm is presented and analyzed.  The algorithm  associates with each procedure in a program information about which variables may be modified, which  may be used, and which are possibly preserved by a call on the procedure, and all of its subcalls.  The  algorithm is sufficiently powerful to be used on recursive programs and to deal with the sharing of variables  which arises through reference parameters.  The algorithm is unique in that it can compute all of this  information in a single pass, not requiring a prepass to compute calling relationships or sharing patterns.   The algorithm is asymptotically optimal in time complexity.  It has been implemented and is practical  even on programs which are quite large.", "authors": "Barth, J.M.", "words_pool": ["algorithm", "analysi", "analyz", "aris", "associ", "asymptot", "call", "call", "complex", "comput", "data", "deal", "flow", "implement", "inform", "interprocedur", "larg", "modifi", "optim", "paramet", "pass", "pattern", "possibl", "power", "practic", "prepass", "present", "preserv", "procedur", "program", "program", "recurs", "refer", "relationship", "requir", "share", "singl", "subcal", "suffici", "time", "uniqu", "variabl", "barth"], "word_count": {"algorithm": 5, "analysi": 1, "analyz": 1, "aris": 1, "associ": 1, "asymptot": 1, "call": 2, "complex": 1, "comput": 2, "data": 1, "deal": 1, "flow": 1, "implement": 1, "inform": 2, "interprocedur": 1, "larg": 1, "modifi": 1, "optim": 1, "paramet": 1, "pass": 1, "pattern": 1, "possibl": 1, "power": 1, "practic": 1, "prepass": 1, "present": 1, "preserv": 1, "procedur": 2, "program": 3, "recurs": 1, "refer": 1, "relationship": 1, "requir": 1, "share": 2, "singl": 1, "subcal": 1, "suffici": 1, "time": 1, "uniqu": 1, "variabl": 2, "barth": 1}}, "3070": {"id": "3070", "title": "Hybrid Simulation Models of Computer Systems", "abstract": "This paper describes the structure and operation of a hybrid simulation model in which both  discrete-event simulation and analytic techniques are combined to produce efficient yet accurate system  models.  In an example based on a simple hypothetical computer system, discrete-event simulation is used  to model the arrival and activation of jobs, and a central-server queueing network models the use of  system processors.  The accuracy and efficiency of the hybrid technique are demonstrated by comparing  the result and computational costs of the hybrid model of the example with those of an equivalent simulation-only  model.", "authors": "Schwetman, H.D.", "words_pool": ["accuraci", "accur", "activ", "analyt", "arriv", "base", "central", "combin", "compar", "comput", "comput", "cost", "demonstr", "describ", "discret", "effici", "effici", "equival", "event", "hybrid", "hypothet", "job", "model", "model", "network", "oper", "paper", "processor", "produc", "queue", "result", "server", "simpl", "simul", "structur", "system", "system", "techniqu", "techniqu", "schwetman"], "word_count": {"accuraci": 1, "accur": 1, "activ": 1, "analyt": 1, "arriv": 1, "base": 1, "central": 1, "combin": 1, "compar": 1, "comput": 2, "cost": 1, "demonstr": 1, "describ": 1, "discret": 2, "effici": 2, "equival": 1, "event": 2, "hybrid": 3, "hypothet": 1, "job": 1, "model": 6, "network": 1, "oper": 1, "paper": 1, "processor": 1, "produc": 1, "queue": 1, "result": 1, "server": 1, "simpl": 1, "simul": 4, "structur": 1, "system": 3, "techniqu": 2, "schwetman": 1}}, "3071": {"id": "3071", "title": "An Algorithm Using Symbolic Techniques for the Bel-Petrov Classification of Gravitational Fields", "abstract": "In this note, an algorithm is presented for the symbolic calculation of certain algebraic invariants  of the Weyl tensor which permits the determination of the Bel-Petrov types of a gravitational field.   This algorithm, although more specialized than that of D'Inverno and Russell-Clark, requires neither  the use of a special coordinate system nor the spin coefficient formalism.  The algorithm has been implemented  in FORMAC and is designed to complete the classification scheme proposed by Petrov in his book.  An appendix  contains examples illustrating the use of the algorithm.", "authors": ". Zund, J.D.", "words_pool": ["algebra", "algorithm", "appendix", "bel", "book", "calcul", "clark", "classif", "coeffici", "complet", "coordin", "design", "determin", "exampl", "field", "field", "formac", "formal", "gravit", "illustr", "implement", "invari", "inverno", "note", "permit", "petrov", "present", "propos", "requir", "russel", "scheme", "special", "special", "spin", "symbol", "system", "techniqu", "tensor", "type", "weyl", "zund"], "word_count": {"algebra": 1, "algorithm": 4, "appendix": 1, "bel": 1, "book": 1, "calcul": 1, "clark": 1, "classif": 1, "coeffici": 1, "complet": 1, "coordin": 1, "design": 1, "determin": 1, "exampl": 1, "field": 1, "formac": 1, "formal": 1, "gravit": 1, "illustr": 1, "implement": 1, "invari": 1, "inverno": 1, "note": 1, "permit": 1, "petrov": 2, "present": 1, "propos": 1, "requir": 1, "russel": 1, "scheme": 1, "special": 2, "spin": 1, "symbol": 1, "system": 1, "techniqu": 1, "tensor": 1, "type": 1, "weyl": 1, "zund": 1}}, "3072": {"id": "3072", "title": "Feedback Coupled Resource Allocation Policies in the Multiprogramming- Multiprocessor Computer  System", "abstract": "Model studies of some integrated, feedback-driven scheduling systems for multiprogrammed- multiprocessor  computer systems are presented.  The basic control variables used are the data-flow rates for the processes  executing on the CPU.  The model systems feature simulated continuous-flow and preempt-resume scheduling  of input-output activity.  Attention is given to the amount of memory resource required for effective  processing of the I/O activity (buffer space assignment).  The model studies used both distribution-driven  and trace-driven techniques.  Even relatively simple dynamic schedulers are shown to improve system performance  (as measured by user CPU time) over that given by optimal or near-optimal static schedulers imbeded  in identical system structures and workload environments.  The improvement is greatest under a heavy  I/O demand workload.", "authors": "Brice, R.S. Browne, J", "words_pool": ["activ", "alloc", "amount", "assign", "attent", "basic", "buffer", "comput", "continu", "control", "coupl", "cpu", "data", "demand", "distribut", "driven", "dynam", "effect", "environ", "execut", "featur", "feedback", "flow", "greatest", "heavi", "ident", "imbed", "improv", "improv", "input", "integr", "measur", "memori", "model", "multiprocessor", "multiprogram", "multiprogram", "optim", "output", "perform", "polici", "preempt", "present", "process", "process", "rate", "requir", "resourc", "resum", "schedul", "schedul", "shown", "simpl", "simul", "space", "static", "structur", "studi", "system", "system", "techniqu", "time", "trace", "user", "variabl", "workload", "brice", "brown"], "word_count": {"activ": 2, "alloc": 1, "amount": 1, "assign": 1, "attent": 1, "basic": 1, "buffer": 1, "comput": 1, "continu": 1, "control": 1, "coupl": 1, "cpu": 2, "data": 1, "demand": 1, "distribut": 1, "driven": 3, "dynam": 1, "effect": 1, "environ": 1, "execut": 1, "featur": 1, "feedback": 1, "flow": 2, "greatest": 1, "heavi": 1, "ident": 1, "imbed": 1, "improv": 2, "input": 1, "integr": 1, "measur": 1, "memori": 1, "model": 3, "multiprocessor": 1, "multiprogram": 1, "optim": 2, "output": 1, "perform": 1, "polici": 1, "preempt": 1, "present": 1, "process": 2, "rate": 1, "requir": 1, "resourc": 1, "resum": 1, "schedul": 4, "shown": 1, "simpl": 1, "simul": 1, "space": 1, "static": 1, "structur": 1, "studi": 2, "system": 5, "techniqu": 1, "time": 1, "trace": 1, "user": 1, "variabl": 1, "workload": 2, "brice": 1, "brown": 1}}, "3073": {"id": "3073", "title": "Communicating Sequential Processes", "abstract": "This paper suggests that input and output are basic primitives of programming and that parallel  composition of communicating sequential processes is a fundamental program structuring method.  When  combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile.   Their use is illustrated by sample solutions of a variety of familiar programming exercises.", "authors": ".R.", "words_pool": ["basic", "combin", "command", "commun", "composit", "concept", "develop", "dijkstra", "exercis", "familiar", "fundament", "guard", "illustr", "input", "method", "output", "paper", "parallel", "primit", "process", "program", "program", "sampl", "sequenti", "solut", "structur", "suggest", "surprisingli", "varieti", "versatil"], "word_count": {"basic": 1, "combin": 1, "command": 1, "commun": 1, "composit": 1, "concept": 1, "develop": 1, "dijkstra": 1, "exercis": 1, "familiar": 1, "fundament": 1, "guard": 1, "illustr": 1, "input": 1, "method": 1, "output": 1, "paper": 1, "parallel": 1, "primit": 1, "process": 1, "program": 3, "sampl": 1, "sequenti": 1, "solut": 1, "structur": 1, "suggest": 1, "surprisingli": 1, "varieti": 1, "versatil": 1}}, "3074": {"id": "3074", "title": "A Time- and Space- Efficient Garbage Compaction Algorithm", "abstract": "Given an area of storage containing scattered, marked nodes of differing sizes, one may wish  to rearrange them into a compact mass at one end of the area while revising all pointers to marked nodes  to show their new locations.  An algorithm is described here which accomplishes this task in linear time  relative to the size of the storage area, and in a space of the order of one bit for each pointer.  The  algorithm operates by reversibly encoding the situation (that a collection of locations point to a single  location) by a linear list, emanating from the pointed-to location, passing through the pointing locations,  and terminating with the pointed-to location's transplanted contents.", "authors": "Morris, F.L.", "words_pool": ["accomplish", "algorithm", "area", "bit", "collect", "compact", "compact", "content", "differ", "effici", "eman", "encod", "end", "garbag", "linear", "list", "locat", "locat", "mark", "mass", "node", "oper", "order", "pass", "point", "point", "pointer", "pointer", "point", "rearrang", "rel", "revers", "revis", "scatter", "show", "singl", "situat", "size", "size", "space", "storag", "task", "termin", "time", "transplant", "wish", "morri"], "word_count": {"accomplish": 1, "algorithm": 2, "area": 3, "bit": 1, "collect": 1, "compact": 1, "content": 1, "differ": 1, "effici": 1, "eman": 1, "encod": 1, "end": 1, "garbag": 1, "linear": 2, "list": 1, "locat": 6, "mark": 2, "mass": 1, "node": 2, "oper": 1, "order": 1, "pass": 1, "point": 4, "pointer": 2, "rearrang": 1, "rel": 1, "revers": 1, "revis": 1, "scatter": 1, "show": 1, "singl": 1, "situat": 1, "size": 2, "space": 1, "storag": 2, "task": 1, "termin": 1, "time": 1, "transplant": 1, "wish": 1, "morri": 1}}, "3075": {"id": "3075", "title": "Fast Parallel Sorting Algorithms", "abstract": "A parallel bucket-sort algorithm is presented that requires time O(log n) and the use of n  processors.  The algorithm makes use of a technique that requires more space than the product of processors  and time.  A realistic model is used model is used in which no memory contention is permitted.  A procedure  is also presented to sort n numbers in time O(k log n) using n 1 + 1/k processors, for k an arbitrary  integer.  The model of computation for this procedure permits simultaneous fetches from the same memory  location.", "authors": "Hirschberg, D.S.", "words_pool": ["algorithm", "algorithm", "arbitrari", "bucket", "comput", "content", "fast", "fetch", "integ", "locat", "log", "make", "memori", "model", "number", "parallel", "permit", "permit", "present", "procedur", "processor", "product", "realist", "requir", "simultan", "sort", "sort", "space", "techniqu", "time", "hirschberg"], "word_count": {"algorithm": 2, "arbitrari": 1, "bucket": 1, "comput": 1, "content": 1, "fast": 1, "fetch": 1, "integ": 1, "locat": 1, "log": 2, "make": 1, "memori": 2, "model": 3, "number": 1, "parallel": 1, "permit": 2, "present": 2, "procedur": 2, "processor": 3, "product": 1, "realist": 1, "requir": 2, "simultan": 1, "sort": 2, "space": 1, "techniqu": 1, "time": 3, "hirschberg": 1}}, "3076": {"id": "3076", "title": "Value Conflicts and Social Choice in Electronic Funds Transfer System Developments", "abstract": "During the last few years, computer-based systems which automate the transfer and recording  of debits and credits have begun to be implemented on a large scale.  These systems promise both financial  benefits for the institutions that use them and potential conveniences to their customers.  However,  they also raise significant social, legal, and technical questions that must be resolved if full scale  systems for Electronic Funds Transfer (EFT) are not to cause more problems for the larger public than  they solve.  This paper examines the incentives for EFT developments and the social problems they raise  in the context of conflicts between five different value positions that are often implicit in analyses  of proposed EFT arrangements.  These conflicts reflect the relative importance of certain problems for  specific groups.  The value positions implicit in EFT proposals help to organize analyses of market arrangements,  system reliability, and privacy of transactions.  These topics are analyzed in this article and related  to the value positions held by concerned parties.  Last, the ways in which the public can learn about  the social qualities of different EFT arrangements and the pace of EFT developments are both discussed  in the context of social choice.", "authors": "Kling, R.", "words_pool": ["analys", "analyz", "arrang", "articl", "autom", "base", "begun", "benefit", "choic", "comput", "concern", "conflict", "context", "conveni", "credit", "custom", "debit", "develop", "discuss", "eft", "electron", "examin", "financi", "full", "fund", "group", "held", "help", "implement", "implicit", "import", "incent", "institut", "larg", "larger", "learn", "legal", "market", "organ", "pace", "paper", "parti", "posit", "potenti", "privaci", "problem", "promis", "propos", "propos", "public", "qualiti", "question", "rais", "record", "reflect", "relat", "rel", "reliabl", "resolv", "scale", "signific", "social", "solv", "specif", "system", "system", "technic", "topic", "transact", "transfer", "way", "year", "kling"], "word_count": {"analys": 2, "analyz": 1, "arrang": 3, "articl": 1, "autom": 1, "base": 1, "begun": 1, "benefit": 1, "choic": 1, "comput": 1, "concern": 1, "conflict": 2, "context": 2, "conveni": 1, "credit": 1, "custom": 1, "debit": 1, "develop": 2, "discuss": 1, "eft": 6, "electron": 1, "examin": 1, "financi": 1, "full": 1, "fund": 1, "group": 1, "held": 1, "help": 1, "implement": 1, "implicit": 2, "import": 1, "incent": 1, "institut": 1, "larg": 1, "larger": 1, "learn": 1, "legal": 1, "market": 1, "organ": 1, "pace": 1, "paper": 1, "parti": 1, "posit": 3, "potenti": 1, "privaci": 1, "problem": 3, "promis": 1, "propos": 2, "public": 2, "qualiti": 1, "question": 1, "rais": 2, "record": 1, "reflect": 1, "relat": 1, "rel": 1, "reliabl": 1, "resolv": 1, "scale": 2, "signific": 1, "social": 4, "solv": 1, "specif": 1, "system": 4, "technic": 1, "topic": 1, "transact": 1, "transfer": 2, "way": 1, "year": 1, "kling": 1}}, "3077": {"id": "3077", "title": "Can Programming Be Liberated from the von Neumann Style?  A Functional Style and Its Algebra  of Programs", "abstract": "Conventional programming languages are growing ever more enormous, but not stronger.  Inherent  defects at the most basic level cause them to be both fat and weak: their primitive word-at-a-time style  of programming inherited from their common ancestor-the von Neumann computer, their close coupling off  semantics to state transitions, their division of programming into a world of expressions and a world  of statements, their inability to effectively use powerful combining forms for building new programs  from existing ones, and their lack of useful mathematical properties for reasoning about programs. An  alternative functional style of programming is founded on the use of combining forms for creating programs.   Functional programs deal with structured data, are often nonrepetitive and nonrecursive, are hierarchically  constructed, do not name their arguments, and do not require the complex machinery of procedure declarations  to become generally applicable.  Combining forms can use high level programs to build still higher level ones in a style not possible in conventional languages.  Associated with the functional style of programming  is an algebra of programs whose variables range over programs and whose operations are combining forms.   This algebra can be used to transform programs and to solve equations whose \"unknowns\" are programs  in much the same way one transforms equations in high school algebra.  These transformations are given  by algebraic laws and are carried out in the same language in which programs are written.  Combining  forms are chosen not only for their programming power but also for the power of their associated algebraic  laws.  General theorems of of the algebra give the detailed behavior and termination conditions for large  classes of programs.  A new class of computing systems uses the functional programming style both in  its programming language and in its state transition rules.  Unlike von Neumann languages, these systems  have semantics loosely coupled to states-only one state transition occurs per major computation.", "authors": "Backus, J.", "words_pool": ["algebra", "algebra", "altern", "ancestor", "applic", "argument", "basic", "behavior", "build", "build", "carri", "chosen", "class", "class", "close", "combin", "common", "complex", "comput", "comput", "comput", "condit", "construct", "convent", "coupl", "coupl", "creat", "data", "deal", "declar", "defect", "detail", "divis", "effect", "enorm", "equat", "exist", "express", "fat", "form", "found", "function", "gener", "gener", "give", "grow", "hierarch", "high", "higher", "inabl", "inher", "inherit", "lack", "languag", "languag", "larg", "law", "level", "liber", "loos", "machineri", "major", "mathemat", "neumann", "nonrecurs", "nonrepetit", "occur", "oper", "power", "power", "primit", "procedur", "program", "program", "properti", "rang", "reason", "requir", "rule", "school", "semant", "solv", "state", "statement", "state", "stronger", "structur", "style", "system", "termin", "theorem", "time", "transform", "transform", "transform", "transit", "transit", "unknown", "unlik", "variabl", "von", "weak", "word", "world", "written", "backu"], "word_count": {"algebra": 6, "altern": 1, "ancestor": 1, "applic": 1, "argument": 1, "basic": 1, "behavior": 1, "build": 2, "carri": 1, "chosen": 1, "class": 2, "close": 1, "combin": 5, "common": 1, "complex": 1, "comput": 3, "condit": 1, "construct": 1, "convent": 2, "coupl": 2, "creat": 1, "data": 1, "deal": 1, "declar": 1, "defect": 1, "detail": 1, "divis": 1, "effect": 1, "enorm": 1, "equat": 2, "exist": 1, "express": 1, "fat": 1, "form": 5, "found": 1, "function": 4, "gener": 2, "give": 1, "grow": 1, "hierarch": 1, "high": 2, "higher": 1, "inabl": 1, "inher": 1, "inherit": 1, "lack": 1, "languag": 5, "larg": 1, "law": 2, "level": 3, "liber": 1, "loos": 1, "machineri": 1, "major": 1, "mathemat": 1, "neumann": 2, "nonrecurs": 1, "nonrepetit": 1, "occur": 1, "oper": 1, "power": 3, "primit": 1, "procedur": 1, "program": 19, "properti": 1, "rang": 1, "reason": 1, "requir": 1, "rule": 1, "school": 1, "semant": 2, "solv": 1, "state": 4, "statement": 1, "stronger": 1, "structur": 1, "style": 5, "system": 2, "termin": 1, "theorem": 1, "time": 1, "transform": 3, "transit": 3, "unknown": 1, "unlik": 1, "variabl": 1, "von": 2, "weak": 1, "word": 1, "world": 2, "written": 1, "backu": 1}}, "3078": {"id": "3078", "title": "Analysis of the Availability of Computer Systems Using Computer- Aided Algebra", "abstract": ".", "authors": "Chattergy, R. Pooch, U", "words_pool": ["aid", "algebra", "analysi", "avail", "comput", "system", "chattergi", "pooch"], "word_count": {"aid": 1, "algebra": 1, "analysi": 1, "avail": 1, "comput": 2, "system": 1, "chattergi": 1, "pooch": 1}}, "3079": {"id": "3079", "title": "An Algorithm for Reasoning About Equality", "abstract": "A simple technique for reasoning about equalities that is fast and complete for ground formulas  with function symbols and equality is presented.  A proof of correctness is given as well.", "authors": "Shostak, R.E.", "words_pool": ["algorithm", "complet", "correct", "equal", "equal", "fast", "formula", "function", "ground", "present", "proof", "reason", "simpl", "symbol", "techniqu", "shostak"], "word_count": {"algorithm": 1, "complet": 1, "correct": 1, "equal": 2, "fast": 1, "formula": 1, "function": 1, "ground": 1, "present": 1, "proof": 1, "reason": 1, "simpl": 1, "symbol": 1, "techniqu": 1, "shostak": 1}}, "3080": {"id": "3080", "title": "Proving the Correctness of Heuristically Optimized Code", "abstract": "A system for proving that programs written in a high level language are correctly translated  to a low level language is described.  A primary use of the system is as a post optimization step in code  generation.  The low level language programs need not be generated by a compiler and in fact could be  hand coded.  Examples of the usefulness of such a system are given.  Some interesting results are the  ability to handle programs that implement recursion by bypassing the start of the program, and the detection  and pinpointing of a wide class of errors in the low level language programs.  The examples demonstrate  that optimization of the genre of this paper can result in substantially faster operation and the saving  of memory in terms of program and stack sizes.", "authors": "Samet, H.", "words_pool": ["abil", "bypass", "class", "code", "code", "compil", "correctli", "correct", "demonstr", "detect", "error", "exampl", "fact", "faster", "gener", "gener", "genr", "hand", "handl", "heurist", "high", "implement", "interest", "languag", "level", "low", "memori", "need", "oper", "optim", "optim", "paper", "pinpoint", "post", "primari", "program", "program", "prove", "recurs", "result", "result", "save", "size", "stack", "start", "step", "substanti", "system", "term", "translat", "use", "wide", "written", "samet"], "word_count": {"abil": 1, "bypass": 1, "class": 1, "code": 2, "compil": 1, "correctli": 1, "correct": 1, "demonstr": 1, "detect": 1, "error": 1, "exampl": 2, "fact": 1, "faster": 1, "gener": 2, "genr": 1, "hand": 1, "handl": 1, "heurist": 1, "high": 1, "implement": 1, "interest": 1, "languag": 4, "level": 4, "low": 3, "memori": 1, "need": 1, "oper": 1, "optim": 2, "paper": 1, "pinpoint": 1, "post": 1, "primari": 1, "program": 6, "prove": 1, "recurs": 1, "result": 2, "save": 1, "size": 1, "stack": 1, "start": 1, "step": 1, "substanti": 1, "system": 3, "term": 1, "translat": 1, "use": 1, "wide": 1, "written": 1, "samet": 1}}, "3081": {"id": "3081", "title": "Shallow Binding in Lisp 1.5", "abstract": "Shallow binding is a scheme which allows the value of a variable to be accessed in a bounded  amount of computation.  An elegant model for shallow binding in  Lisp 1.5 is presented in which context-switching  is an environment tree transformation called rerooting.  Rerooting is completely general and reversible,  and is optional in the sense that a Lisp 1.5 interpreter will operate correctly whether or not rerooting  is invoked one very context change.   Since rerooting leaves assoc [v, a] invariant, for all variables  v and all environments a, the programmer can have access to a rerooting primitive, shallow[], which gives  him dynamic control over whether accesses are shallow or deep, and which affects only the speed of execution  of a program, not its semantics.  In addition, multiple processes can be active in the same environment  structure, so long as rerooting is an indivisible operation.  Finally, the concept of rerooting is shown  to combine the concept of shallow binding in Lisp with Dijkstra's display for Algol and hence is a general  model for shallow binding.", "authors": "Baker, H.G. Jr.", "words_pool": ["access", "access", "access", "activ", "addit", "affect", "algol", "amount", "assoc", "bind", "bound", "call", "chang", "combin", "complet", "comput", "concept", "context", "control", "correctli", "deep", "dijkstra", "display", "dynam", "eleg", "environ", "environ", "execut", "final", "gener", "indivis", "interpret", "invari", "invok", "leav", "lisp", "long", "model", "multipl", "oper", "oper", "option", "present", "primit", "process", "program", "programm", "reroot", "revers", "scheme", "semant", "sens", "shallow", "shown", "speed", "structur", "switch", "transform", "tree", "variabl", "variabl", "baker", "jr"], "word_count": {"access": 3, "activ": 1, "addit": 1, "affect": 1, "algol": 1, "amount": 1, "assoc": 1, "bind": 4, "bound": 1, "call": 1, "chang": 1, "combin": 1, "complet": 1, "comput": 1, "concept": 2, "context": 2, "control": 1, "correctli": 1, "deep": 1, "dijkstra": 1, "display": 1, "dynam": 1, "eleg": 1, "environ": 3, "execut": 1, "final": 1, "gener": 2, "indivis": 1, "interpret": 1, "invari": 1, "invok": 1, "leav": 1, "lisp": 3, "long": 1, "model": 2, "multipl": 1, "oper": 2, "option": 1, "present": 1, "primit": 1, "process": 1, "program": 1, "programm": 1, "reroot": 7, "revers": 1, "scheme": 1, "semant": 1, "sens": 1, "shallow": 6, "shown": 1, "speed": 1, "structur": 1, "switch": 1, "transform": 1, "tree": 1, "variabl": 2, "baker": 1, "jr": 1}}, "3082": {"id": "3082", "title": "Time, Clocks, and the Ordering of Events in a Distributed System", "abstract": "The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events.  A distributed algorithm is given for synchronizing  a system of logical clocks which can be used to totally order the events.  The use of the total ordering  is illustrated with a method for solving synchronization problems.  The algorithm is then specialized  for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can  become.", "authors": "Lamport, L.", "words_pool": ["algorithm", "bound", "clock", "concept", "defin", "deriv", "distribut", "event", "event", "examin", "happen", "illustr", "logic", "method", "order", "order", "partial", "physic", "problem", "shown", "solv", "special", "synchron", "synchron", "synchroni", "system", "time", "total", "total", "lamport"], "word_count": {"algorithm": 2, "bound": 1, "clock": 3, "concept": 1, "defin": 1, "deriv": 1, "distribut": 2, "event": 3, "examin": 1, "happen": 1, "illustr": 1, "logic": 1, "method": 1, "order": 3, "partial": 1, "physic": 1, "problem": 1, "shown": 1, "solv": 1, "special": 1, "synchron": 3, "synchroni": 1, "system": 2, "time": 1, "total": 2, "lamport": 1}}, "3083": {"id": "3083", "title": "Pseudochaining in Hash Tables", "abstract": "This paper presents pseudochaining as a new collision-resolution method.  Pseudochaining is  half way between open addressing and chaining.  It owes its name to the fact that link fields are present  in each cell of the hash table which permits \"chaining\" of the first overflow items in the table.  The  efficiency of the method is derived and a tradeoff analysis is given.", "authors": "Halatsis, C. Philokyprou, G.", "words_pool": ["address", "analysi", "cell", "chain", "collis", "deriv", "effici", "fact", "field", "half", "hash", "item", "link", "method", "open", "overflow", "owe", "paper", "permit", "present", "present", "pseudochain", "resolut", "tabl", "tabl", "tradeoff", "halatsi", "philokypr"], "word_count": {"address": 1, "analysi": 1, "cell": 1, "chain": 2, "collis": 1, "deriv": 1, "effici": 1, "fact": 1, "field": 1, "half": 1, "hash": 1, "item": 1, "link": 1, "method": 2, "open": 1, "overflow": 1, "owe": 1, "paper": 1, "permit": 1, "present": 2, "pseudochain": 2, "resolut": 1, "tabl": 2, "tradeoff": 1, "halatsi": 1, "philokypr": 1}}, "3084": {"id": "3084", "title": "Interpolation Search -A Log LogN Search", "abstract": "Interpolation search is a method of retrieving a desired record by key in an ordered file by  using the value of the key and the statistical distribution of the keys.  It is shown that on the average  log logN file accesses are required to retrieve a key, assuming that the N keys are uniformly distributed.   The number of extra accesses is also estimated and shown to be very low.  The same holds if the cumulative  distribution function of the keys is known.  Computational experiments confirm these results.", "authors": "Perl, Y. Itai, A. Avni, H.", "words_pool": ["access", "assum", "averag", "comput", "confirm", "cumul", "desir", "distribut", "distribut", "estim", "experi", "extra", "function", "hold", "interpol", "key", "key", "known", "log", "logn", "low", "method", "number", "order", "record", "requir", "result", "retriev", "retriev", "search", "shown", "statist", "uniformli", "perl", "itai", "avni"], "word_count": {"access": 2, "assum": 1, "averag": 1, "comput": 1, "confirm": 1, "cumul": 1, "desir": 1, "distribut": 3, "estim": 1, "experi": 1, "extra": 1, "function": 1, "hold": 1, "interpol": 1, "key": 6, "known": 1, "log": 1, "logn": 1, "low": 1, "method": 1, "number": 1, "order": 1, "record": 1, "requir": 1, "result": 1, "retriev": 2, "search": 1, "shown": 2, "statist": 1, "uniformli": 1, "perl": 1, "itai": 1, "avni": 1}}, "3085": {"id": "3085", "title": "An O(n) Algorithm for Determining a Near-Optimal Computation Order of Matrix Chain Products", "abstract": "This paper discusses the computation of matrix chain products of the form M1 x M2 x ... x Mn  where Mi's are matrices.  The order in which the matrices are computed affects the number of operations.   A sufficient condition about the association of the matrices in the optimal order is presented.  An  O(n) algorithm to find an order of computation which takes less than 25 percent longer than the optimal  time Topt is also presented.  In most cases, the algorithm yields the optimal order or an order which  takes only a few percent longer than Topt (less than 1 percent on the average).", "authors": "Chin, F.Y.", "words_pool": ["affect", "algorithm", "associ", "averag", "case", "chain", "comput", "comput", "condit", "determin", "discuss", "find", "form", "longer", "m1", "m2", "matric", "matrix", "mi", "mn", "number", "oper", "optim", "order", "paper", "percent", "present", "product", "suffici", "take", "time", "topt", "yield", "chin"], "word_count": {"affect": 1, "algorithm": 2, "associ": 1, "averag": 1, "case": 1, "chain": 1, "comput": 3, "condit": 1, "determin": 1, "discuss": 1, "find": 1, "form": 1, "longer": 2, "m1": 1, "m2": 1, "matric": 3, "matrix": 1, "mi": 1, "mn": 1, "number": 1, "oper": 1, "optim": 3, "order": 5, "paper": 1, "percent": 3, "present": 2, "product": 1, "suffici": 1, "take": 2, "time": 1, "topt": 2, "yield": 1, "chin": 1}}, "3086": {"id": "3086", "title": "On the Complexity of Computing the Measure of U[ai, bi]", "abstract": "The decision tree complexity of computing the measure of the union of n (possibly overlapping)  intervals is shown to be  (n log n), even if comparisons between linear functions of the interval endpoints  are allowed.  The existence of an   (n log n) lower bound to determine whether any two of n real numbers  are within   of each other is also demonstrated.  These problems provide an excellent opportunity for  discussing the effects of the computational model on the ease of analysis and on the results produced.", "authors": "Fredman, M.L. Weide, B.", "words_pool": ["ai", "allow", "analysi", "bi", "bound", "comparison", "complex", "comput", "comput", "decis", "demonstr", "determin", "discuss", "eas", "effect", "endpoint", "excel", "exist", "function", "interv", "interv", "linear", "log", "lower", "measur", "model", "number", "opportun", "overlap", "possibl", "problem", "produc", "provid", "real", "result", "shown", "tree", "union", "fredman", "weid"], "word_count": {"ai": 1, "allow": 1, "analysi": 1, "bi": 1, "bound": 1, "comparison": 1, "complex": 1, "comput": 2, "decis": 1, "demonstr": 1, "determin": 1, "discuss": 1, "eas": 1, "effect": 1, "endpoint": 1, "excel": 1, "exist": 1, "function": 1, "interv": 2, "linear": 1, "log": 2, "lower": 1, "measur": 1, "model": 1, "number": 1, "opportun": 1, "overlap": 1, "possibl": 1, "problem": 1, "produc": 1, "provid": 1, "real": 1, "result": 1, "shown": 1, "tree": 1, "union": 1, "fredman": 1, "weid": 1}}, "3087": {"id": "3087", "title": "An English Language Question Answering System for a Large Relational Database", "abstract": "By typing requests in English, casual users will be able to obtain explicit answers from a  large relational database of aircraft flight and maintenance data using a system called PLANES.  The  design and implementation of this system is described and illustrated with detailed examples of the operation  of system components and examples of overall system operation.  The language processing portion of the  system uses a number of augmented transition networks, each of which matches phrases with a specific  meaning, along with context registers (his tory keepers) and concept case frames; these are used for judging  meaningfulness of questions, generating dialogue for clarifying partially understood questions, and resolving  ellipsis and pronoun reference problems.  Other system components construct a formal query for the relational  database, and optimize the order of searching relations.  Methods are discussed for handling vague or  complex questions and for providing browsing ability.  Also included are discussions of important issues  in programming natural language systems for limited domains, and the relationship of this system to others.", "authors": "Waltz, D.L.", "words_pool": ["abil", "abl", "aircraft", "answer", "answer", "augment", "brows", "call", "case", "casual", "clarifi", "complex", "compon", "concept", "construct", "context", "data", "databas", "design", "detail", "dialogu", "discuss", "discuss", "domain", "ellipsi", "english", "exampl", "explicit", "flight", "formal", "frame", "gener", "handl", "illustr", "implement", "import", "includ", "issu", "judg", "keeper", "languag", "larg", "limit", "mainten", "match", "mean", "meaning", "method", "natur", "network", "number", "obtain", "oper", "optim", "order", "partial", "phrase", "plane", "portion", "problem", "process", "program", "pronoun", "provid", "queri", "question", "question", "refer", "regist", "relat", "relat", "relationship", "request", "resolv", "search", "specif", "system", "system", "tori", "transit", "type", "understood", "user", "vagu", "waltz"], "word_count": {"abil": 1, "abl": 1, "aircraft": 1, "answer": 1, "augment": 1, "brows": 1, "call": 1, "case": 1, "casual": 1, "clarifi": 1, "complex": 1, "compon": 2, "concept": 1, "construct": 1, "context": 1, "data": 1, "databas": 2, "design": 1, "detail": 1, "dialogu": 1, "discuss": 2, "domain": 1, "ellipsi": 1, "english": 1, "exampl": 2, "explicit": 1, "flight": 1, "formal": 1, "frame": 1, "gener": 1, "handl": 1, "illustr": 1, "implement": 1, "import": 1, "includ": 1, "issu": 1, "judg": 1, "keeper": 1, "languag": 2, "larg": 1, "limit": 1, "mainten": 1, "match": 1, "mean": 1, "meaning": 1, "method": 1, "natur": 1, "network": 1, "number": 1, "obtain": 1, "oper": 2, "optim": 1, "order": 1, "partial": 1, "phrase": 1, "plane": 1, "portion": 1, "problem": 1, "process": 1, "program": 1, "pronoun": 1, "provid": 1, "queri": 1, "question": 3, "refer": 1, "regist": 1, "relat": 3, "relationship": 1, "request": 1, "resolv": 1, "search": 1, "specif": 1, "system": 8, "tori": 1, "transit": 1, "type": 1, "understood": 1, "user": 1, "vagu": 1, "waltz": 1}}, "3088": {"id": "3088", "title": "General Equations for Idealized CPU-I/O Overlap Configurations", "abstract": "General equations are derived for estimating the maximum possible utilization of main storage  partitions, CPU and I/O devices under different conditions in an idealized CPU-I/O overlap model of multiprogrammed  computer systems.  The equations are directly applicable to any configuration consisting  of sets of  identical CPU's I/O processors, main storage partitions and user tasks.  Examples are provided to illustrate  the use of the equations to compute effective processing time per record and expected timesharing response  time under both balanced and unbalanced resource utilization conditions.", "authors": "Teory, T.J.", "words_pool": ["applic", "balanc", "comput", "comput", "condit", "configur", "configur", "consist", "cpu", "deriv", "devic", "directli", "effect", "equat", "estim", "exampl", "expect", "gener", "ideal", "ident", "illustr", "main", "maximum", "model", "multiprogram", "overlap", "partit", "process", "processor", "provid", "record", "resourc", "respons", "set", "storag", "system", "task", "time", "timeshar", "unbalanc", "user", "util", "teori"], "word_count": {"applic": 1, "balanc": 1, "comput": 2, "condit": 2, "configur": 1, "consist": 1, "cpu": 3, "deriv": 1, "devic": 1, "directli": 1, "effect": 1, "equat": 3, "estim": 1, "exampl": 1, "expect": 1, "gener": 1, "ideal": 1, "ident": 1, "illustr": 1, "main": 2, "maximum": 1, "model": 1, "multiprogram": 1, "overlap": 1, "partit": 2, "process": 1, "processor": 1, "provid": 1, "record": 1, "resourc": 1, "respons": 1, "set": 1, "storag": 2, "system": 1, "task": 1, "time": 2, "timeshar": 1, "unbalanc": 1, "user": 1, "util": 2, "teori": 1}}, "3089": {"id": "3089", "title": "Performance of Rollback Recovery Systems under Intermittent Failures", "abstract": "A mathematical model of a transaction-oriented system under intermittent failures is proposed.   The system is assumed to operate with a checkpointing and rollback/recovery method to ensure reliable  information processing.  The model is used to derive the principal performance measures, including availability,  response time, and the system saturation point.", "authors": "Gelenbe, E. Derochette, D.", "words_pool": ["assum", "avail", "checkpoint", "deriv", "ensur", "failur", "includ", "inform", "intermitt", "mathemat", "measur", "method", "model", "oper", "orient", "perform", "point", "princip", "process", "propos", "recoveri", "reliabl", "respons", "rollback", "satur", "system", "system", "time", "transact", "gelenb", "derochett"], "word_count": {"assum": 1, "avail": 1, "checkpoint": 1, "deriv": 1, "ensur": 1, "failur": 1, "includ": 1, "inform": 1, "intermitt": 1, "mathemat": 1, "measur": 1, "method": 1, "model": 2, "oper": 1, "orient": 1, "perform": 1, "point": 1, "princip": 1, "process": 1, "propos": 1, "recoveri": 1, "reliabl": 1, "respons": 1, "rollback": 1, "satur": 1, "system": 3, "time": 1, "transact": 1, "gelenb": 1, "derochett": 1}}, "3090": {"id": "3090", "title": "Automated Welfare Client-Tracking and Service Integration: The Political Economy of Computing", "abstract": "The impacts of an automated client-tracking system on the clients, caseworkers, administrators,  and operations of the welfare agencies that use it are reported.  The major impact of this system was  to enhance the administrative  attractiveness of the using agencies in the eyes of funders rather than  to increase their internal administrative efficiency.  This impact is a joint product of both the technical  features of the computer-based system and of the organizational demands placed upon different agencies,  administrators, and caseworkers.  It illustrates the way \"successful\" automated information systems fit  the political economies of the groups that use them.", "authors": "Kling, R.", "words_pool": ["administr", "administr", "agenc", "attract", "autom", "base", "casework", "client", "client", "comput", "comput", "demand", "economi", "economi", "effici", "enhanc", "eye", "featur", "fit", "funder", "group", "illustr", "impact", "impact", "increas", "inform", "integr", "intern", "joint", "major", "oper", "organiz", "polit", "product", "report", "servic", "success", "system", "system", "technic", "track", "welfar", "kling"], "word_count": {"administr": 4, "agenc": 3, "attract": 1, "autom": 2, "base": 1, "casework": 2, "client": 2, "comput": 1, "demand": 1, "economi": 1, "effici": 1, "enhanc": 1, "eye": 1, "featur": 1, "fit": 1, "funder": 1, "group": 1, "illustr": 1, "impact": 3, "increas": 1, "inform": 1, "integr": 1, "intern": 1, "joint": 1, "major": 1, "oper": 1, "organiz": 1, "polit": 1, "product": 1, "report": 1, "servic": 1, "success": 1, "system": 4, "technic": 1, "track": 1, "welfar": 1, "kling": 1}}, "3091": {"id": "3091", "title": "Some Basic Determinants of Computer Programming Productivity", "abstract": "The propose of this research was to examine the relationship between processing characteristics  of programs and experience characteristics of programmers and program development time.  The ultimate  objective was to develop a technique for predicting the amount of time necessary to create a computer  program.  The fifteen program characteristics hypothesized as being associated with an increase in programming  time required are objectively measurable from preprogramming specifications.  The five programmer characteristics  are experience-related and are also measurable before a programming task is begun.  Nine program characteristics  emerged as major influences on program development time, each associated with increased program development  time.  All five programmer characteristics were found to be related to reduced program development time.   A multiple regression  equation which contained one programmer characteristic and four program characteristics  gave evidence of good predictive power for forecasting program development time.", "authors": "Chrysler, E.", "words_pool": ["amount", "basic", "begun", "characterist", "characterist", "comput", "contain", "creat", "determin", "develop", "develop", "emerg", "equat", "evid", "examin", "experi", "fifteen", "forecast", "found", "gave", "good", "hypothes", "increas", "increas", "influenc", "major", "measur", "multipl", "object", "object", "power", "predict", "predict", "preprogram", "process", "product", "program", "programm", "programm", "program", "program", "propos", "reduc", "regress", "relat", "relationship", "requir", "research", "specif", "task", "techniqu", "time", "ultim", "chrysler"], "word_count": {"amount": 1, "basic": 1, "begun": 1, "characterist": 8, "comput": 1, "contain": 1, "creat": 1, "determin": 1, "develop": 6, "emerg": 1, "equat": 1, "evid": 1, "examin": 1, "experi": 2, "fifteen": 1, "forecast": 1, "found": 1, "gave": 1, "good": 1, "hypothes": 1, "increas": 2, "influenc": 1, "major": 1, "measur": 2, "multipl": 1, "object": 2, "power": 1, "predict": 2, "preprogram": 1, "process": 1, "product": 1, "program": 12, "programm": 4, "propos": 1, "reduc": 1, "regress": 1, "relat": 2, "relationship": 1, "requir": 1, "research": 1, "specif": 1, "task": 1, "techniqu": 1, "time": 7, "ultim": 1, "chrysler": 1}}, "3092": {"id": "3092", "title": "Characteristics of Application Software Maintenance", "abstract": "Maintenance and enhancement of application software consume a major portion of the total life  cycle cost of a system.  Rough estimates of the total systems and programming resources consumed range  as high as 75-80 percent in each category.  However, the area has been given little attention in the  literature.  To analyze the problems in this area a questionnaire was developed and pretested.  It was  then submitted to 120 organizations.  Respondents totaled 69.  Responses were analyzed with the SPSS  statistical package.  The results of the analysis indicate that: (1) maintenance and enhancement do consume  much of the total resources of systems and programming groups; (2) maintenance and enhancement tend to  be viewed by management as at least somewhat more important than new application software development;  (3) in maintenance and enhancement, problems of a management orientation tend to be more significant  than those of a technical orientation; and (4) user demands for enhancements and extension constitute  the most important management problem area.", "authors": "Lientz, B.P. Swanson, E", "words_pool": ["analysi", "analyz", "analyz", "applic", "area", "attent", "categori", "characterist", "constitut", "consum", "consum", "cost", "cycl", "demand", "develop", "develop", "enhanc", "enhanc", "estim", "extens", "group", "high", "import", "life", "literatur", "mainten", "major", "manag", "organ", "orient", "packag", "percent", "portion", "pretest", "problem", "problem", "program", "questionnair", "rang", "resourc", "respond", "respons", "result", "rough", "signific", "softwar", "spss", "statist", "submit", "system", "system", "technic", "tend", "total", "total", "user", "view", "lientz", "swanson"], "word_count": {"analysi": 1, "analyz": 2, "applic": 2, "area": 3, "attent": 1, "categori": 1, "characterist": 1, "constitut": 1, "consum": 3, "cost": 1, "cycl": 1, "demand": 1, "develop": 2, "enhanc": 5, "estim": 1, "extens": 1, "group": 1, "high": 1, "import": 2, "life": 1, "literatur": 1, "mainten": 4, "major": 1, "manag": 3, "organ": 1, "orient": 2, "packag": 1, "percent": 1, "portion": 1, "pretest": 1, "problem": 3, "program": 2, "questionnair": 1, "rang": 1, "resourc": 2, "respond": 1, "respons": 1, "result": 1, "rough": 1, "signific": 1, "softwar": 2, "spss": 1, "statist": 1, "submit": 1, "system": 3, "technic": 1, "tend": 2, "total": 4, "user": 1, "view": 1, "lientz": 1, "swanson": 1}}, "3093": {"id": "3093", "title": "Automatic Error Recovery for LR Parsers", "abstract": "In this paper we present a scheme for detecting and recovering from syntax errors in programs.   The scheme, which is based on LR parsing, is driven by information which is directly and automatically  obtainable from the information that is already present in an LR parser.  The approach, which is patterned  after that of Levy and Graham and Rhodes, appears to provide error recovery which is both simple and  powerful.", "authors": ".", "words_pool": ["appear", "approach", "automat", "base", "detect", "directli", "driven", "error", "error", "graham", "inform", "levi", "lr", "obtain", "paper", "parser", "parser", "pars", "pattern", "power", "present", "program", "provid", "recov", "recoveri", "rhode", "scheme", "simpl", "syntax"], "word_count": {"appear": 1, "approach": 1, "automat": 1, "base": 1, "detect": 1, "directli": 1, "driven": 1, "error": 2, "graham": 1, "inform": 2, "levi": 1, "lr": 2, "obtain": 1, "paper": 1, "parser": 1, "pars": 1, "pattern": 1, "power": 1, "present": 2, "program": 1, "provid": 1, "recov": 1, "recoveri": 1, "rhode": 1, "scheme": 2, "simpl": 1, "syntax": 1}}, "3094": {"id": "3094", "title": "Analyses of Deterministic Parsing Algorithms", "abstract": "This paper describes an approach for determining the minimum, maximum, and average times to  parse sentences acceptable by a deterministic parser.  These quantities are presented in the form of  symbolic formulas, called time-formulas.  The variables in these formulas represent not only the length  of the input string but also the time to perform elementary operations such as pushing, popping, subscripting,  iterating, etc.  By binding to the  variables actual numerical values corresponding to a given compiler-machine  configuration, one can determine the execution time for that configuration.  Time-formulas are derived  by examining the grammar rules and the program representing the algorithm one wishes to analyze.  The  approach is described by using a specific grammar that defines simple arithmetic expressions.  Two deterministic parsers are analyzed: a top-down recursive descent LL(1) parser, and a bottom-up SLR(1) parser.  The  paper provides estimates for the relative efficiencies of the two parsers.  The estimates applicable  to a specific machine, the PDP-10, are presented and substantiated buy benchmarks.  Finally, the paper  illustrates the proposed approach by applying it to the analyses of parsers for a simple programming  language.", "authors": "Cohen, J. Roth, M.S.", "words_pool": ["accept", "actual", "algorithm", "algorithm", "analys", "analyz", "analyz", "applic", "appli", "approach", "arithmet", "averag", "benchmark", "bind", "bottom", "buy", "call", "compil", "configur", "defin", "deriv", "descent", "describ", "determin", "determin", "determinist", "effici", "elementari", "estim", "examin", "execut", "express", "final", "form", "formula", "grammar", "illustr", "input", "iter", "languag", "length", "ll", "machin", "maximum", "minimum", "numer", "oper", "paper", "pars", "parser", "parser", "pars", "pdp", "perform", "pop", "present", "program", "program", "propos", "push", "quantiti", "recurs", "rel", "repres", "repres", "rule", "sentenc", "simpl", "slr", "specif", "string", "subscript", "substanti", "symbol", "time", "time", "top", "valu", "variabl", "wish", "cohen", "roth"], "word_count": {"accept": 1, "actual": 1, "algorithm": 1, "analys": 1, "analyz": 2, "applic": 1, "appli": 1, "approach": 3, "arithmet": 1, "averag": 1, "benchmark": 1, "bind": 1, "bottom": 1, "buy": 1, "call": 1, "compil": 1, "configur": 2, "defin": 1, "deriv": 1, "descent": 1, "describ": 1, "determin": 2, "determinist": 2, "effici": 1, "elementari": 1, "estim": 2, "examin": 1, "execut": 1, "express": 1, "final": 1, "form": 1, "formula": 4, "grammar": 2, "illustr": 1, "input": 1, "iter": 1, "languag": 1, "length": 1, "ll": 1, "machin": 2, "maximum": 1, "minimum": 1, "numer": 1, "oper": 1, "paper": 3, "pars": 1, "parser": 6, "pdp": 1, "perform": 1, "pop": 1, "present": 2, "program": 2, "propos": 1, "push": 1, "quantiti": 1, "recurs": 1, "rel": 1, "repres": 2, "rule": 1, "sentenc": 1, "simpl": 2, "slr": 1, "specif": 2, "string": 1, "subscript": 1, "substanti": 1, "symbol": 1, "time": 5, "top": 1, "valu": 1, "variabl": 2, "wish": 1, "cohen": 1, "roth": 1}}, "3095": {"id": "3095", "title": "A Selective Traversal Algorithm for Binary Search Trees", "abstract": "The problem of selecting data items from a binary search tree according to a list of range  conditions is considered.  The process of visiting a minimal number of nodes to retrieve data satisfying  the range conditions is called selective traversal.  Presented in this paper is an algorithm for selective  traversal which uses a tag field for each node in the tree.  The algorithm is particularly useful and  efficient when examination of data is more time consuming than examination of a tag field.", "authors": "Driscoll, J.R. Lien, Y.E.", "words_pool": ["accord", "algorithm", "binari", "call", "condit", "consid", "consum", "data", "effici", "examin", "field", "item", "list", "minim", "node", "node", "number", "paper", "present", "problem", "process", "rang", "retriev", "satisfi", "search", "select", "select", "tag", "time", "travers", "tree", "tree", "visit", "driscol", "lien"], "word_count": {"accord": 1, "algorithm": 2, "binari": 1, "call": 1, "condit": 2, "consid": 1, "consum": 1, "data": 3, "effici": 1, "examin": 2, "field": 2, "item": 1, "list": 1, "minim": 1, "node": 2, "number": 1, "paper": 1, "present": 1, "problem": 1, "process": 1, "rang": 2, "retriev": 1, "satisfi": 1, "search": 1, "select": 3, "tag": 2, "time": 1, "travers": 2, "tree": 2, "visit": 1, "driscol": 1, "lien": 1}}, "3096": {"id": "3096", "title": "An Optimal Method for Deletion in One-Sided Height-Balanced Trees", "abstract": "A one-sided height-balanced tree is a binary tree in which every node's right subtree has a  height which is equal to or exactly one greater than the height of its left subtree.  It has an advantage  over the more general AVL tree in that only one bit of balancing information is required (two bits are  required for the ACL tree).  It is shown that deletion of an arbitrary node of such a tree can be accomplished  in O(logn) operations, where n is the number of nodes in the tree.  Moreover the method is optimal in  the sense that its complexity cannot be reduced in order of magnitude.  This result, coupled with earlier  results by Hirschberg, indicates that, of the three basic problems of insertion, deletion, and retrieval,  only insertion is adversely affected by this modification of an AVL tree.", "authors": ".", "words_pool": ["accomplish", "acl", "advantag", "advers", "affect", "arbitrari", "avl", "balanc", "balanc", "basic", "binari", "bit", "bit", "complex", "coupl", "delet", "earlier", "equal", "exactli", "gener", "greater", "height", "hirschberg", "inform", "insert", "left", "logn", "magnitud", "method", "modif", "node", "node", "number", "oper", "optim", "order", "problem", "reduc", "requir", "result", "result", "retriev", "sens", "shown", "side", "subtre", "tree", "tree"], "word_count": {"accomplish": 1, "acl": 1, "advantag": 1, "advers": 1, "affect": 1, "arbitrari": 1, "avl": 2, "balanc": 2, "basic": 1, "binari": 1, "bit": 2, "complex": 1, "coupl": 1, "delet": 2, "earlier": 1, "equal": 1, "exactli": 1, "gener": 1, "greater": 1, "height": 3, "hirschberg": 1, "inform": 1, "insert": 2, "left": 1, "logn": 1, "magnitud": 1, "method": 1, "modif": 1, "node": 3, "number": 1, "oper": 1, "optim": 1, "order": 1, "problem": 1, "reduc": 1, "requir": 2, "result": 2, "retriev": 1, "sens": 1, "shown": 1, "side": 1, "subtre": 2, "tree": 7}}, "3097": {"id": "3097", "title": "Optimal Shift Strategy for a Block-Transfer CCD Memory", "abstract": "For the purposes of this paper, a block-transfer CCD memory is composed of serial shift registers  whose shift rate can vary, but which have a definite minimum shift rate (the refresh rate) and a definite  maximum shift rate.  The bits iin the shift registers are numbered 0 to N - 1, and blocks of N bits are  always transferred, always starting at bit 0.   What is the best shift strategy so that a block transfer  request occurring at a random time will have to wait the minimal amount of time before bit 0 can be reached?   The minimum shift rate requirement does not allow one to  simply \"park\" at bit 0 and wait for a transfer  request.  The optimal strategy involves shifting as slowly as possible until bit 0 is passed, then shifting  as quickly as possible until a critical boundary is reached, shortly before bit 0 comes around again.   This is called the \"hurry up and wait\" strategy and is well known outside the computer field.  The block-transfer  CCD memory can also be viewed as a paging drum with a variable (bounded) rotation speed.", "authors": "Sites, R.L.", "words_pool": ["allow", "amount", "bit", "bit", "block", "block", "boundari", "bound", "call", "ccd", "come", "compos", "comput", "critic", "definit", "drum", "field", "hurri", "iin", "involv", "known", "maximum", "memori", "minim", "minimum", "number", "occur", "optim", "page", "paper", "park", "pass", "purpos", "quickli", "random", "rate", "reach", "refresh", "regist", "request", "requir", "rotat", "serial", "shift", "shift", "shortli", "simpli", "slowli", "speed", "start", "strategi", "time", "transfer", "transfer", "variabl", "vari", "view", "wait", "site"], "word_count": {"allow": 1, "amount": 1, "bit": 7, "block": 4, "boundari": 1, "bound": 1, "call": 1, "ccd": 2, "come": 1, "compos": 1, "comput": 1, "critic": 1, "definit": 2, "drum": 1, "field": 1, "hurri": 1, "iin": 1, "involv": 1, "known": 1, "maximum": 1, "memori": 2, "minim": 1, "minimum": 2, "number": 1, "occur": 1, "optim": 1, "page": 1, "paper": 1, "park": 1, "pass": 1, "purpos": 1, "quickli": 1, "random": 1, "rate": 5, "reach": 2, "refresh": 1, "regist": 2, "request": 2, "requir": 1, "rotat": 1, "serial": 1, "shift": 9, "shortli": 1, "simpli": 1, "slowli": 1, "speed": 1, "start": 1, "strategi": 3, "time": 2, "transfer": 5, "variabl": 1, "vari": 1, "view": 1, "wait": 3, "site": 1}}, "3098": {"id": "3098", "title": "Computer Generation of Gamma Random Variables", "abstract": "A new method for generating random variables from the gamma distribution with nonintegral shape  parameter a is proposed.  This method is similar to two other methods recently given by Wallace and Fishman.   It is compared with Fishman's and Ahrens and Dieter's methods.  The core storage requirements and programming  effort for this method are similar to those of Fishman's method.  The proposed method is the same as  Fishman's method for 1 < a < 2 and is faster than Fishman's method for 3 < a < 19.  Also, the proposed  method is much simpler than Ahrens and Dieter's method and is faster for a < 8.", "authors": "Tadikamalla, P.R.", "words_pool": ["ahren", "compar", "comput", "core", "dieter", "distribut", "effort", "faster", "fishman", "gamma", "gener", "gener", "method", "method", "nonintegr", "paramet", "program", "propos", "random", "recent", "requir", "shape", "similar", "simpler", "storag", "variabl", "wallac", "tadikamalla"], "word_count": {"ahren": 2, "compar": 1, "comput": 1, "core": 1, "dieter": 2, "distribut": 1, "effort": 1, "faster": 2, "fishman": 5, "gamma": 1, "gener": 1, "method": 11, "nonintegr": 1, "paramet": 1, "program": 1, "propos": 3, "random": 1, "recent": 1, "requir": 1, "shape": 1, "similar": 2, "simpler": 1, "storag": 1, "variabl": 1, "wallac": 1, "tadikamalla": 1}}, "3099": {"id": "3099", "title": "New Sufficient Optimality Conditions for Integer Programming and their Application", "abstract": "The purpose of this report is to present a new class of sufficient optimality conditions for  pure and mixed integer programming problems.  Some of the sets of sufficient conditions presented can  be thought of as generalizations of optimality conditions based on primal-dual complementarity in linear  programming.  These sufficient conditions are particularly useful for the construction of difficult integer  programming problems with known optimal solutions.  These problems may then be used to test and/or \"benchmark\"  integer programming codes.", "authors": "Fleisher, J.M. Meyer, R.R.", "words_pool": ["applic", "base", "benchmark", "class", "code", "complementar", "condit", "construct", "difficult", "dual", "gener", "integ", "known", "linear", "mix", "optim", "optim", "present", "present", "primal", "problem", "program", "pure", "purpos", "report", "set", "solut", "suffici", "test", "thought", "fleisher", "meyer"], "word_count": {"applic": 1, "base": 1, "benchmark": 1, "class": 1, "code": 1, "complementar": 1, "condit": 4, "construct": 1, "difficult": 1, "dual": 1, "gener": 1, "integ": 3, "known": 1, "linear": 1, "mix": 1, "optim": 3, "present": 2, "primal": 1, "problem": 3, "program": 4, "pure": 1, "purpos": 1, "report": 1, "set": 1, "solut": 1, "suffici": 3, "test": 1, "thought": 1, "fleisher": 1, "meyer": 1}}, "3100": {"id": "3100", "title": "An Interference Matching Technique for Inducing Abstractions", "abstract": "A method for inducing knowledge by abstraction from a sequence of training examples is described.   The proposed method, interference matching, induces abstractions by finding relational properties common  to two or more exemplars.  Three tasks solved by a program that uses an interference-matching algorithm  are presented.  Several problems concerning the description of the training examples and the adequacy  of interference matching are discussed, and directions for future research are considered.", "authors": "Hayes-Roth, F. McDermott, J.", "words_pool": ["abstract", "abstract", "adequaci", "algorithm", "common", "concern", "consid", "descript", "direct", "discuss", "exampl", "exemplar", "find", "futur", "induc", "induc", "interfer", "knowledg", "match", "method", "present", "problem", "program", "properti", "propos", "relat", "research", "sequenc", "solv", "task", "techniqu", "train", "hay", "roth", "mcdermott"], "word_count": {"abstract": 2, "adequaci": 1, "algorithm": 1, "common": 1, "concern": 1, "consid": 1, "descript": 1, "direct": 1, "discuss": 1, "exampl": 2, "exemplar": 1, "find": 1, "futur": 1, "induc": 2, "interfer": 3, "knowledg": 1, "match": 3, "method": 2, "present": 1, "problem": 1, "program": 1, "properti": 1, "propos": 1, "relat": 1, "research": 1, "sequenc": 1, "solv": 1, "task": 1, "techniqu": 1, "train": 2, "hay": 1, "roth": 1, "mcdermott": 1}}, "3101": {"id": "3101", "title": "The SL5 Procedure Mechanism", "abstract": "This paper describes an integrated procedure mechanism that permits procedures to be used as  recursive functions or as coroutines.  This integration is accomplished by treating procedures and their  activation records (called environments) as data objects and by decomposing procedure invocation into  three separate components at the source-language level.  In addition, argument binding is under the control  of the programmer, permitting the definition of various methods of argument transmission in the source  language itself.  The resulting procedure mechanism,which is part of the SL5 programming language, is  well suited to goal-oriented problems and to other problems that are more readily programmed by using  coroutines. Several examples are given.", "authors": "Hanson, D. Griswold, R.E.", "words_pool": ["accomplish", "activ", "addit", "argument", "bind", "call", "compon", "control", "coroutin", "data", "decompos", "definit", "describ", "environ", "exampl", "function", "goal", "integr", "integr", "invoc", "languag", "level", "mechan", "method", "object", "orient", "paper", "part", "permit", "permit", "problem", "procedur", "procedur", "program", "programm", "program", "readili", "record", "recurs", "result", "separ", "sl5", "sourc", "suit", "transmiss", "treat", "hanson", "griswold"], "word_count": {"accomplish": 1, "activ": 1, "addit": 1, "argument": 2, "bind": 1, "call": 1, "compon": 1, "control": 1, "coroutin": 2, "data": 1, "decompos": 1, "definit": 1, "describ": 1, "environ": 1, "exampl": 1, "function": 1, "goal": 1, "integr": 2, "invoc": 1, "languag": 3, "level": 1, "mechan": 2, "method": 1, "object": 1, "orient": 1, "paper": 1, "part": 1, "permit": 2, "problem": 2, "procedur": 5, "program": 2, "programm": 1, "readili": 1, "record": 1, "recurs": 1, "result": 1, "separ": 1, "sl5": 1, "sourc": 2, "suit": 1, "transmiss": 1, "treat": 1, "hanson": 1, "griswold": 1}}, "3102": {"id": "3102", "title": "Incorporation of Units into Programming Languages", "abstract": "The issues of how a programming language might aid in keeping track of physical units (feet,  sec, etc.) are discussed.  A method is given for the introduction of relationships among units (a watt  is volts*amps, a yard is three feet) and subsequent automatic conversion based upon these relationships.  Various proposals for syntax are considered.", "authors": "Karr, M. Loveman III, D", "words_pool": ["aid", "amp", "automat", "base", "consid", "convers", "discuss", "feet", "incorpor", "introduct", "issu", "keep", "languag", "languag", "method", "physic", "program", "propos", "relationship", "sec", "subsequ", "syntax", "track", "unit", "volt", "watt", "yard", "karr", "loveman", "iii"], "word_count": {"aid": 1, "amp": 1, "automat": 1, "base": 1, "consid": 1, "convers": 1, "discuss": 1, "feet": 2, "incorpor": 1, "introduct": 1, "issu": 1, "keep": 1, "languag": 1, "method": 1, "physic": 1, "program": 1, "propos": 1, "relationship": 2, "sec": 1, "subsequ": 1, "syntax": 1, "track": 1, "unit": 2, "volt": 1, "watt": 1, "yard": 1, "karr": 1, "loveman": 1, "iii": 1}}, "3103": {"id": "3103", "title": "Automatic Data Structure Selection: An Example and Overview", "abstract": "The use of several levels of abstraction has proved to be very helpful in constructing and  maintaining programs.  When programs are designed with abstract data types such as sets and lists, programmer  time can be saved by automating the process of filling in low-level implementation details.  In the past,  programming systems have provided only a single general purpose implementation for an abstract type.   Thus the programs produced using abstract types were then inefficient in space or time.  In this paper  a system for automatically choosing efficient implementations for abstract types from a library of implementations  is discussed.  This process is discussed in detail for an example program.  General issues in data structure  selection are also reviewed.", "authors": "Low, J.R.", "words_pool": ["abstract", "abstract", "automat", "autom", "choos", "construct", "data", "design", "detail", "detail", "discuss", "effici", "fill", "gener", "help", "implement", "implement", "ineffici", "issu", "level", "level", "librari", "list", "low", "maintain", "overview", "paper", "past", "process", "produc", "program", "programm", "program", "program", "prove", "provid", "purpos", "review", "save", "select", "set", "singl", "space", "structur", "system", "system", "time", "type", "type", "low"], "word_count": {"abstract": 5, "automat": 1, "autom": 1, "choos": 1, "construct": 1, "data": 2, "design": 1, "detail": 2, "discuss": 2, "effici": 1, "fill": 1, "gener": 2, "help": 1, "implement": 4, "ineffici": 1, "issu": 1, "level": 2, "librari": 1, "list": 1, "low": 1, "maintain": 1, "overview": 1, "paper": 1, "past": 1, "process": 2, "produc": 1, "program": 5, "programm": 1, "prove": 1, "provid": 1, "purpos": 1, "review": 1, "save": 1, "select": 1, "set": 1, "singl": 1, "space": 1, "structur": 1, "system": 2, "time": 2, "type": 4}}, "3104": {"id": "3104", "title": "Test Data as an Aid in Proving Program Correctness", "abstract": "Proofs of program correctness tend to be long and tedious, whereas testing, though useful in  detecting errors, usually does not guarantee correctness.  This paper introduces a techniques whereby  test data can be used in proving program correctness.  In addition to simplifying the process of proving  correctness, this method simplifies the process of providing accurate specification for a program.  The  applicability of this technique to procedures and recursive programs is demonstrated.", "authors": "Geller, M.", "words_pool": ["accur", "addit", "aid", "applic", "correct", "data", "demonstr", "detect", "error", "guarante", "introduc", "long", "method", "paper", "procedur", "process", "program", "program", "proof", "provid", "prove", "recurs", "simplifi", "simplifi", "specif", "techniqu", "techniqu", "tediou", "tend", "test", "test", "geller"], "word_count": {"accur": 1, "addit": 1, "aid": 1, "applic": 1, "correct": 4, "data": 1, "demonstr": 1, "detect": 1, "error": 1, "guarante": 1, "introduc": 1, "long": 1, "method": 1, "paper": 1, "procedur": 1, "process": 2, "program": 4, "proof": 1, "provid": 1, "prove": 2, "recurs": 1, "simplifi": 2, "specif": 1, "techniqu": 2, "tediou": 1, "tend": 1, "test": 2, "geller": 1}}, "3105": {"id": "3105", "title": "A Language Extension for Expressing Constraints on Data Access", "abstract": "Controlled sharing of information is needed and desirable for many applications and is supported  in operating systems by access control mechanisms.  This paper shows how to extend programming languages  to provide controlled sharing.  The extension permits expression of access constraints on shared data.   Access constraints can apply both to simple objects, and to objects that are components of larger objects,  such as bank account records in a bank's data base.  The constraints are stated declaratively, and can  be enforced by static checking similar to type checking.  The approach can be used to extend any strongly-typed  language, but is particularly suitable for extending languages that support the notion of abstract data  types.", "authors": "Jones, A", "words_pool": ["abstract", "access", "account", "applic", "appli", "approach", "bank", "base", "check", "compon", "constraint", "control", "control", "data", "declar", "desir", "enforc", "express", "express", "extend", "extend", "extens", "inform", "languag", "languag", "larger", "mechan", "need", "notion", "object", "oper", "paper", "permit", "program", "provid", "record", "share", "share", "show", "similar", "simpl", "state", "static", "strongli", "suitabl", "support", "support", "system", "type", "type", "type", "jone"], "word_count": {"abstract": 1, "access": 3, "account": 1, "applic": 1, "appli": 1, "approach": 1, "bank": 2, "base": 1, "check": 2, "compon": 1, "constraint": 3, "control": 3, "data": 3, "declar": 1, "desir": 1, "enforc": 1, "express": 1, "extend": 3, "extens": 1, "inform": 1, "languag": 3, "larger": 1, "mechan": 1, "need": 1, "notion": 1, "object": 3, "oper": 1, "paper": 1, "permit": 1, "program": 1, "provid": 1, "record": 1, "share": 3, "show": 1, "similar": 1, "simpl": 1, "state": 1, "static": 1, "strongli": 1, "suitabl": 1, "support": 2, "system": 1, "type": 3, "jone": 1}}, "3106": {"id": "3106", "title": "A Fast Algorithm for Copying List Structures", "abstract": ".", "authors": "Clark, D", "words_pool": ["algorithm", "copi", "fast", "list", "structur", "clark"], "word_count": {"algorithm": 1, "copi": 1, "fast": 1, "list": 1, "structur": 1, "clark": 1}}, "3107": {"id": "3107", "title": "Generating Beta Variates with Nonintegrel Shape Parameters", "abstract": "A new rejection method is described for generating beta variates.  The method is compared with  previously published methods both theoretically and through computer timings.  It is suggested that the  method has advantages in both speed and programming simplicity over previous methods, especially for  \"difficult\" combinations of parameter values.", "authors": "Cheng, R", "words_pool": ["advantag", "beta", "combin", "compar", "comput", "difficult", "especi", "gener", "method", "method", "nonintegrel", "paramet", "paramet", "previou", "previous", "program", "publish", "reject", "shape", "simplic", "speed", "suggest", "theoret", "time", "valu", "variat", "cheng"], "word_count": {"advantag": 1, "beta": 1, "combin": 1, "compar": 1, "comput": 1, "difficult": 1, "especi": 1, "gener": 1, "method": 5, "nonintegrel": 1, "paramet": 1, "previou": 1, "previous": 1, "program": 1, "publish": 1, "reject": 1, "shape": 1, "simplic": 1, "speed": 1, "suggest": 1, "theoret": 1, "time": 1, "valu": 1, "variat": 1, "cheng": 1}}, "3108": {"id": "3108", "title": "Economical Encoding of Commas Between Strings", "abstract": "A method for insertion of delimiters between strings without using new symbols is presented.   As the lengths of the strings increase, the extra cost, in terms of prolongation, becomes vanishingly  small compared to the lengths of the strings.", "authors": "Even, S. Rodeh, M.", "words_pool": ["comma", "compar", "cost", "delimit", "econom", "encod", "extra", "increas", "insert", "length", "method", "present", "prolong", "small", "string", "symbol", "term", "vanishingli", "rodeh"], "word_count": {"comma": 1, "compar": 1, "cost": 1, "delimit": 1, "econom": 1, "encod": 1, "extra": 1, "increas": 1, "insert": 1, "length": 2, "method": 1, "present": 1, "prolong": 1, "small": 1, "string": 3, "symbol": 1, "term": 1, "vanishingli": 1, "rodeh": 1}}, "3109": {"id": "3109", "title": "A Data Structure for Manipulating Priority Queues", "abstract": "A data structure is described which can be used for representing a collection of priority queues.   The primitive operations are insertion, deletion, union, update, and search for an item of earliest  priority.", "authors": "Vuillemin, J.", "words_pool": ["collect", "data", "delet", "earliest", "insert", "item", "manipul", "oper", "primit", "prioriti", "queue", "repres", "search", "structur", "union", "updat", "vuillemin"], "word_count": {"collect": 1, "data": 1, "delet": 1, "earliest": 1, "insert": 1, "item": 1, "manipul": 1, "oper": 1, "primit": 1, "prioriti": 2, "queue": 1, "repres": 1, "search": 1, "structur": 1, "union": 1, "updat": 1, "vuillemin": 1}}, "3110": {"id": "3110", "title": "Assembling Code for Machines with Span-Dependent Instructions", "abstract": "Many modern computers contain instructions whose lengths depend on the distance from a given  instance of such an instruction to the operand of that instruction.  This paper considers the problem  of minimizing the lengths of programs for such machines.  An efficient solution is presented for the  case in which the operand of every such \"span-dependent\" instruction is either a label or an assembly-time  expression of a certain restricted form", "words_pool": ["assembl", "assembl", "case", "code", "comput", "consid", "depend", "depend", "distanc", "effici", "express", "form", "instanc", "instruct", "instruct", "label", "length", "machin", "minim", "modern", "operand", "paper", "present", "problem", "program", "restrict", "solut", "span", "time"], "word_count": {"assembl": 1, "case": 1, "code": 1, "comput": 1, "consid": 1, "depend": 2, "distanc": 1, "effici": 1, "express": 1, "form": 1, "instanc": 1, "instruct": 4, "label": 1, "length": 2, "machin": 1, "minim": 1, "modern": 1, "operand": 2, "paper": 1, "present": 1, "problem": 1, "program": 1, "restrict": 1, "solut": 1, "span": 1, "time": 1}}, "f this restriction is relaxed by allowing these operands to  be more general assembly-time expressions, then the problem is shown to be NP-complete.": {"id": "f this restriction is relaxed by allowing these operands to  be more general assembly-time expressions, then the problem is shown to be NP-complete.", "authors": "Szymanski, T.G.", "words_pool": ["szymanski"], "word_count": {"szymanski": 1}}, "3111": {"id": "3111", "title": "Secure Communications Over Insecure Channels", "abstract": "According to traditional conceptions of cryptographic security, it is necessary to transmit  a key, by secret means, before encrypted messages can be sent securely.  This paper shows that it is  possible to select a key over open communications channels in such a fashion that communications security  can be maintained.  A method is described which forces any enemy to expend an amount of work which increases  as the square of the work required of the two communicants to select the key.  The method provides a  logically new kind of protection against the passive eaves dropper.  It suggests that further research  on this topic will be highly rewarding, both in a theoretical and a practical sense.", "authors": "Merkle, R", "words_pool": ["accord", "amount", "channel", "communic", "commun", "concept", "cryptograph", "dropper", "eav", "encrypt", "enemi", "expend", "fashion", "forc", "highli", "increas", "insecur", "key", "kind", "logic", "maintain", "mean", "messag", "method", "open", "paper", "passiv", "practic", "protect", "requir", "research", "reward", "secret", "secur", "secur", "secur", "select", "sens", "show", "squar", "suggest", "theoret", "topic", "tradit", "transmit", "work", "merkl"], "word_count": {"accord": 1, "amount": 1, "channel": 1, "communic": 1, "commun": 2, "concept": 1, "cryptograph": 1, "dropper": 1, "eav": 1, "encrypt": 1, "enemi": 1, "expend": 1, "fashion": 1, "forc": 1, "highli": 1, "increas": 1, "insecur": 1, "key": 3, "kind": 1, "logic": 1, "maintain": 1, "mean": 1, "messag": 1, "method": 2, "open": 1, "paper": 1, "passiv": 1, "practic": 1, "protect": 1, "requir": 1, "research": 1, "reward": 1, "secret": 1, "secur": 3, "select": 2, "sens": 1, "show": 1, "squar": 1, "suggest": 1, "theoret": 1, "topic": 1, "tradit": 1, "transmit": 1, "work": 2, "merkl": 1}}, "3112": {"id": "3112", "title": "List Processing in Real Time on a Serial Computer", "abstract": "A real-time list processing system is one in which the time required by the elementary list  operations (e.g. CONS, CAR, CDR, RPLACA, REPLACD, EQ, and ATOM in LISP) is bounded by a (small) constant.   Classical implementations of list processing systems lack this property because allocating a list cell  from the heap may cause a garbage collection, which process requires time proportional to the heap size  to finish.  A real-time list processing system is presented which continuously reclaims garbage, including  directed cycles, while linearizing and compacting the accessible cells into contiguous locations to avoid  fragmenting the free storage pool.  The program is small and requires no time-sharing interrupts, making  it suitable for microcode.  Finally, the system requires the same average time, and not more than twice  the space, of a classical implementation, and those space requirements can be reduced to approximately  classical proportions by compact list representation.  Arrays of different sizes, a program stack, and  hash linking are simple extensions to our system, and reference counting is found to be inferior for  many applications.", "authors": "Baker, H.G.", "words_pool": ["access", "alloc", "applic", "approxim", "array", "atom", "averag", "avoid", "bound", "car", "cdr", "cell", "cell", "classic", "collect", "compact", "compact", "comput", "con", "constant", "contigu", "continu", "count", "cycl", "direct", "elementari", "eq", "extens", "final", "finish", "found", "fragment", "free", "garbag", "hash", "heap", "implement", "implement", "includ", "inferior", "interrupt", "lack", "linear", "link", "lisp", "list", "locat", "make", "microcod", "oper", "pool", "present", "process", "process", "program", "properti", "proport", "proport", "real", "reclaim", "reduc", "refer", "replacd", "represent", "requir", "requir", "requir", "rplaca", "serial", "share", "simpl", "size", "size", "small", "space", "stack", "storag", "suitabl", "system", "system", "time", "baker"], "word_count": {"access": 1, "alloc": 1, "applic": 1, "approxim": 1, "array": 1, "atom": 1, "averag": 1, "avoid": 1, "bound": 1, "car": 1, "cdr": 1, "cell": 2, "classic": 3, "collect": 1, "compact": 2, "comput": 1, "con": 1, "constant": 1, "contigu": 1, "continu": 1, "count": 1, "cycl": 1, "direct": 1, "elementari": 1, "eq": 1, "extens": 1, "final": 1, "finish": 1, "found": 1, "fragment": 1, "free": 1, "garbag": 2, "hash": 1, "heap": 2, "implement": 2, "includ": 1, "inferior": 1, "interrupt": 1, "lack": 1, "linear": 1, "link": 1, "lisp": 1, "list": 6, "locat": 1, "make": 1, "microcod": 1, "oper": 1, "pool": 1, "present": 1, "process": 4, "program": 2, "properti": 1, "proport": 2, "real": 2, "reclaim": 1, "reduc": 1, "refer": 1, "replacd": 1, "represent": 1, "requir": 5, "rplaca": 1, "serial": 1, "share": 1, "simpl": 1, "size": 2, "small": 2, "space": 2, "stack": 1, "storag": 1, "suitabl": 1, "system": 5, "time": 6, "baker": 1}}, "3113": {"id": "3113", "title": "Optimal Conversion of Extended-Entry Decision Tables with General Cost Criteria", "abstract": "A general dynamic programming algorithm for converting limited, extended, or mixed entry decision  tables to optimal decision trees is presented which can take into account rule frequencies or probabilities,  minimum time and/or space cost criteria, common action sets, compressed rules and ELSE rules, sequencing  constraints on condition tests, excludable combinations of conditions, certain ambiguities, and interrupted  rule masking.", "authors": "Lew, A.", "words_pool": ["account", "action", "algorithm", "ambigu", "combin", "common", "compress", "condit", "condit", "constraint", "convers", "convert", "cost", "criteria", "decis", "dynam", "entri", "exclud", "extend", "frequenc", "gener", "interrupt", "limit", "mask", "minimum", "mix", "optim", "present", "probabl", "program", "rule", "rule", "sequenc", "set", "space", "tabl", "take", "test", "time", "tree", "lew"], "word_count": {"account": 1, "action": 1, "algorithm": 1, "ambigu": 1, "combin": 1, "common": 1, "compress": 1, "condit": 2, "constraint": 1, "convers": 1, "convert": 1, "cost": 1, "criteria": 1, "decis": 2, "dynam": 1, "entri": 1, "exclud": 1, "extend": 1, "frequenc": 1, "gener": 1, "interrupt": 1, "limit": 1, "mask": 1, "minimum": 1, "mix": 1, "optim": 1, "present": 1, "probabl": 1, "program": 1, "rule": 4, "sequenc": 1, "set": 1, "space": 1, "tabl": 1, "take": 1, "test": 1, "time": 1, "tree": 1, "lew": 1}}, "3114": {"id": "3114", "title": "A Technique for Isolating Differences Between Files", "abstract": "A simple algorithm is described for isolating the differences between two files.  One application  is the comparing of two versions of a source program or other file in order to display all differences.   The algorithm isolates differences in a way that corresponds closely to our intuitive notion of difference,  is easy to implement, and is computationally efficient, with time linear in the file length.  For most  applications the algorithm isolates differences similar to those isolated by the longest common subsequence.   Another application of this algorithm merges files containing independently generated changes into a  single file.  The algorithm can also be used to generate efficient encodings of a file in the form of  the differences between itself and a given \"datum\" file, permitting reconstruction of the original file  from the difference and datum files.", "authors": "Heckel, P.", "words_pool": ["algorithm", "applic", "applic", "close", "common", "compar", "comput", "correspond", "datum", "differ", "differ", "display", "easi", "effici", "encod", "form", "gener", "gener", "implement", "independ", "intuit", "isol", "isol", "isol", "length", "linear", "longest", "merg", "notion", "order", "origin", "permit", "program", "reconstruct", "similar", "simpl", "singl", "sourc", "subsequ", "techniqu", "time", "version", "heckel"], "word_count": {"algorithm": 5, "applic": 3, "close": 1, "common": 1, "compar": 1, "comput": 1, "correspond": 1, "datum": 2, "differ": 7, "display": 1, "easi": 1, "effici": 2, "encod": 1, "form": 1, "gener": 2, "implement": 1, "independ": 1, "intuit": 1, "isol": 4, "length": 1, "linear": 1, "longest": 1, "merg": 1, "notion": 1, "order": 1, "origin": 1, "permit": 1, "program": 1, "reconstruct": 1, "similar": 1, "simpl": 1, "singl": 1, "sourc": 1, "subsequ": 1, "techniqu": 1, "time": 1, "version": 1, "heckel": 1}}, "3115": {"id": "3115", "title": "Orderly Enumeration of Nonsingular Binary Matrices Applied to Text Encryption", "abstract": "Nonsingular binary matrices of order N, i.e., nonsingular over the field {0, 1}, and an initial  segment of the natural numbers are placed in one-to-one correspondence.  Each natural number corresponds  to two intermediate vectors.  These vectors are mapped into a nonsingular binary matrix.  Examples of  complete enumeration of all 2 x 2 and 3 x 3 nonsingular binary matrices were produced by mapping the  intermediate vectors to the matrices.  The mapping has application to the Vernam encipherment method  using pseudorandom number sequences.  A bit string formed form bytes of text of a data encryption key  can be used as a representation of a natural number.  This natural number is transformed to a nonsingular  binary matrix.  key leverage is obtained by using the matrix as a\"seed\" in a shift register sequence  pseudorandom number generator.", "authors": "Payne, W.H. McMillen, K.L.", "words_pool": ["applic", "appli", "binari", "bit", "byte", "complet", "correspond", "correspond", "data", "encipher", "encrypt", "enumer", "exampl", "field", "form", "form", "gener", "initi", "intermedi", "key", "leverag", "map", "map", "matric", "matrix", "method", "natur", "nonsingular", "number", "number", "obtain", "order", "orderli", "produc", "pseudorandom", "regist", "represent", "seed", "segment", "sequenc", "sequenc", "shift", "string", "text", "transform", "vector", "vernam", "payn", "mcmillen"], "word_count": {"applic": 1, "appli": 1, "binari": 4, "bit": 1, "byte": 1, "complet": 1, "correspond": 2, "data": 1, "encipher": 1, "encrypt": 1, "enumer": 1, "exampl": 1, "field": 1, "form": 2, "gener": 1, "initi": 1, "intermedi": 2, "key": 2, "leverag": 1, "map": 3, "matric": 3, "matrix": 3, "method": 1, "natur": 4, "nonsingular": 5, "number": 6, "obtain": 1, "order": 1, "orderli": 1, "produc": 1, "pseudorandom": 2, "regist": 1, "represent": 1, "seed": 1, "segment": 1, "sequenc": 2, "shift": 1, "string": 1, "text": 1, "transform": 1, "vector": 3, "vernam": 1, "payn": 1, "mcmillen": 1}}, "3116": {"id": "3116", "title": "Interference Detection Among Solids and Surfaces", "abstract": ".", "authors": "Boyse, J", "words_pool": ["detect", "interfer", "solid", "surfac", "boys"], "word_count": {"detect": 1, "interfer": 1, "solid": 1, "surfac": 1, "boys": 1}}, "3117": {"id": "3117", "title": "The Impact and Use of Computer Technology by the Police", "abstract": ".", "authors": "Colton, K", "words_pool": ["comput", "impact", "polic", "technolog", "colton"], "word_count": {"comput": 1, "impact": 1, "polic": 1, "technolog": 1, "colton": 1}}, "3118": {"id": "3118", "title": "Permutation of Data Blocks in a Bubble Memory", "abstract": "A common internal organization of bubble memories consists of a set of (minor)  loops, connected through another (major) loop.  The problem of obtaining any  give n permutation of the minor loop contents in minimum time is studied in this paper.  A lower bound to the number of steps required buy a permutation algorithm is derived, and the class of optimum algorithms is  identified.", "authors": "Bongiovanni, G", "words_pool": ["algorithm", "algorithm", "block", "bound", "bubbl", "buy", "class", "common", "connect", "consist", "content", "data", "deriv", "give", "identifi", "intern", "loop", "loop", "lower", "major", "memori", "memori", "minimum", "minor", "number", "obtain", "optimum", "organ", "paper", "permut", "problem", "requir", "set", "step", "studi", "time", "bongiovanni"], "word_count": {"algorithm": 2, "block": 1, "bound": 1, "bubbl": 1, "buy": 1, "class": 1, "common": 1, "connect": 1, "consist": 1, "content": 1, "data": 1, "deriv": 1, "give": 1, "identifi": 1, "intern": 1, "loop": 3, "lower": 1, "major": 1, "memori": 1, "minimum": 1, "minor": 2, "number": 1, "obtain": 1, "optimum": 1, "organ": 1, "paper": 1, "permut": 2, "problem": 1, "requir": 1, "set": 1, "step": 1, "studi": 1, "time": 1, "bongiovanni": 1}}, "3119": {"id": "3119", "title": "The Impact of Distributions and Disciplines on Multiple Processor Systems", "abstract": "Simple queueing models are used to study the performance tradeoffs of  multiple processor systems.  Issues considered include the impact of CPU service disciplines and distributions, level of multiprogramming, multitasking, and job priorities.", "authors": "Sauer, C.H. Chandy, K.M.", "words_pool": ["consid", "cpu", "disciplin", "distribut", "impact", "includ", "issu", "job", "level", "model", "multipl", "multiprogram", "multitask", "perform", "prioriti", "processor", "queue", "servic", "simpl", "studi", "system", "tradeoff", "sauer", "chandi"], "word_count": {"consid": 1, "cpu": 1, "disciplin": 1, "distribut": 1, "impact": 1, "includ": 1, "issu": 1, "job": 1, "level": 1, "model": 1, "multipl": 1, "multiprogram": 1, "multitask": 1, "perform": 1, "prioriti": 1, "processor": 1, "queue": 1, "servic": 1, "simpl": 1, "studi": 1, "system": 1, "tradeoff": 1, "sauer": 1, "chandi": 1}}, "3120": {"id": "3120", "title": "An Event-Driven Compiling Technique", "abstract": "Due to the linear structure of source text, difficulties may arise in a  one-pass compilation process.  These difficulties occur when an entity cannot be processed because of a forward reference to information only obtainable from subsequent entities.  Classic solutions ask for data structures appropriate for each case.  A technique is presented here which uses instead control structures, namely events and processes.  The work of the compiler-writer becomes easier both conceptually and in practice because he can forget these problems at the outset and he avoids special processing for each problem. This technique has been applied to the construction of an Algol 68 compiler.  Three examples from that implementation are described and discussed here.", "authors": "Banatre, J.P. Routeau, J.P. Trilling, L.", "words_pool": ["algol", "appli", "aris", "ask", "avoid", "case", "classic", "compil", "compil", "compil", "conceptu", "construct", "control", "data", "difficulti", "discuss", "driven", "due", "easier", "entiti", "entiti", "event", "event", "exampl", "forget", "forward", "implement", "inform", "linear", "obtain", "occur", "outset", "pass", "practic", "present", "problem", "problem", "process", "process", "process", "process", "refer", "solut", "sourc", "special", "structur", "structur", "subsequ", "techniqu", "text", "work", "writer", "banatr", "routeau", "trill"], "word_count": {"algol": 1, "appli": 1, "aris": 1, "ask": 1, "avoid": 1, "case": 1, "classic": 1, "compil": 3, "conceptu": 1, "construct": 1, "control": 1, "data": 1, "difficulti": 2, "discuss": 1, "driven": 1, "due": 1, "easier": 1, "entiti": 2, "event": 1, "exampl": 1, "forget": 1, "forward": 1, "implement": 1, "inform": 1, "linear": 1, "obtain": 1, "occur": 1, "outset": 1, "pass": 1, "practic": 1, "present": 1, "problem": 2, "process": 4, "refer": 1, "solut": 1, "sourc": 1, "special": 1, "structur": 3, "subsequ": 1, "techniqu": 2, "text": 1, "work": 1, "writer": 1, "banatr": 1, "routeau": 1, "trill": 1}}, "3121": {"id": "3121", "title": "Syntactic Source to Source Transforms and Program Manipulation", "abstract": "Syntactic transforms are the source to source program transformations which preserve the history of computation, and thus do not modify the execution time.  Combined with a small number of primitive semantic transforms, they provide a powerful tool for program manipulation.  A catalogue of syntactic transforms, and its use for solution of a system of program equations, is given.  Examples of derivation of more complex source to source transformations are also presented.  Two case studies illustrate the way in which syntactic  and semantic source to source transformations may be used for development of clear, simple, and reasonably efficient programs.", "authors": "Arsac, J.J.", "words_pool": ["case", "catalogu", "clear", "combin", "complex", "comput", "deriv", "develop", "effici", "equat", "exampl", "execut", "histori", "illustr", "manipul", "modifi", "number", "power", "present", "preserv", "primit", "program", "program", "provid", "reason", "semant", "simpl", "small", "solut", "sourc", "studi", "syntact", "system", "time", "tool", "transform", "transform", "arsac"], "word_count": {"case": 1, "catalogu": 1, "clear": 1, "combin": 1, "complex": 1, "comput": 1, "deriv": 1, "develop": 1, "effici": 1, "equat": 1, "exampl": 1, "execut": 1, "histori": 1, "illustr": 1, "manipul": 1, "modifi": 1, "number": 1, "power": 1, "present": 1, "preserv": 1, "primit": 1, "program": 4, "provid": 1, "reason": 1, "semant": 2, "simpl": 1, "small": 1, "solut": 1, "sourc": 6, "studi": 1, "syntact": 3, "system": 1, "time": 1, "tool": 1, "transform": 6, "arsac": 1}}, "3122": {"id": "3122", "title": "Production and Employment of Ph.D.'s in Computer Science - 1977 and 1978", "authors": "Taulbee, O.E. Conte, S.D.", "words_pool": ["comput", "employ", "ph", "product", "scienc", "taulbe", "cont"], "word_count": {"comput": 1, "employ": 1, "ph": 1, "product": 1, "scienc": 1, "taulbe": 1, "cont": 1}}, "3123": {"id": "3123", "title": "Employment Characteristics of Doctoral Level Computer Scientists", "authors": "Fairley, R.E.", "words_pool": ["characterist", "comput", "doctor", "employ", "level", "scientist", "fairley"], "word_count": {"characterist": 1, "comput": 1, "doctor": 1, "employ": 1, "level": 1, "scientist": 1, "fairley": 1}}, "3124": {"id": "3124", "title": "Recursive Data Structures in APL", "abstract": "A mathematical study of three approaches for defining nested arrays in APL is presented.  Theorems exhibiting the relationships between the definitional systems are given and illustrated through graph representations.  One of the approaches is used to define an APL array to be a recursive data structure equivalent to a tree structure in which all data is stored at the leaves as homogeneous arrays of numbers and characters.  An extension of APL is proposed that includes new primitive functions to manipulate the nesting level of arrays and new operators to assist in the construction of data-driven algorithms.", "authors": ".", "words_pool": ["algorithm", "apl", "approach", "array", "array", "assist", "charact", "construct", "data", "defin", "defin", "definit", "driven", "equival", "exhibit", "extens", "function", "graph", "homogen", "illustr", "includ", "leav", "level", "manipul", "mathemat", "nest", "nest", "number", "oper", "present", "primit", "propos", "recurs", "relationship", "represent", "store", "structur", "structur", "studi", "system", "theorem", "tree"], "word_count": {"algorithm": 1, "apl": 3, "approach": 2, "array": 4, "assist": 1, "charact": 1, "construct": 1, "data": 3, "defin": 2, "definit": 1, "driven": 1, "equival": 1, "exhibit": 1, "extens": 1, "function": 1, "graph": 1, "homogen": 1, "illustr": 1, "includ": 1, "leav": 1, "level": 1, "manipul": 1, "mathemat": 1, "nest": 2, "number": 1, "oper": 1, "present": 1, "primit": 1, "propos": 1, "recurs": 1, "relationship": 1, "represent": 1, "store": 1, "structur": 2, "studi": 1, "system": 1, "theorem": 1, "tree": 1}}, "3125": {"id": "3125", "title": "Global Optimization by Suppression of Partial Redundancies", "abstract": "The elimination of redundant computations and the moving of invariant computations out of loops are often done separately, with invariants  moved outward loop by loop.  We propose to do both at once and to move each expression directly to the entrance of the outermost loop in which it is invariant.  This is done by solving a more general problem, i.e. the elimination of computations performed twice on a given execution path.  Such computations are termed partially redundant.  Moreover, the algorithm does not require any graphical information or restrictions on the shape of the program graph. Testing this algorithm has shown that its execution cost is nearly linear with the size of the program, and that it leads to a smaller optimizer that requires less execution time.", "authors": "Morel, E. Renvoise, C.", "words_pool": ["algorithm", "comput", "cost", "directli", "elimin", "entranc", "execut", "express", "gener", "global", "graph", "graphic", "inform", "invari", "invari", "lead", "linear", "loop", "loop", "move", "move", "move", "nearli", "optim", "optim", "outermost", "outward", "partial", "partial", "path", "perform", "problem", "program", "propos", "redund", "redund", "requir", "requir", "restrict", "separ", "shape", "shown", "size", "smaller", "solv", "suppress", "term", "test", "time", "morel", "renvois"], "word_count": {"algorithm": 2, "comput": 4, "cost": 1, "directli": 1, "elimin": 2, "entranc": 1, "execut": 3, "express": 1, "gener": 1, "global": 1, "graph": 1, "graphic": 1, "inform": 1, "invari": 3, "lead": 1, "linear": 1, "loop": 4, "move": 3, "nearli": 1, "optim": 1, "outermost": 1, "outward": 1, "partial": 1, "path": 1, "perform": 1, "problem": 1, "program": 2, "propos": 1, "redund": 2, "requir": 2, "restrict": 1, "separ": 1, "shape": 1, "shown": 1, "size": 1, "smaller": 1, "solv": 1, "suppress": 1, "term": 1, "test": 1, "time": 1, "morel": 1, "renvois": 1}}, "3126": {"id": "3126", "title": "Comments on Perfect Hashing Functions: A Single Probe Retrieving  Method for Static Sets", "authors": "Anderson, M.G.", "words_pool": ["comment", "function", "hash", "method", "perfect", "probe", "retriev", "set", "singl", "static", "anderson"], "word_count": {"comment": 1, "function": 1, "hash": 1, "method": 1, "perfect": 1, "probe": 1, "retriev": 1, "set": 1, "singl": 1, "static": 1, "anderson": 1}}, "3127": {"id": "3127", "title": "Thoth, a Portable Real-Time Operating System", "abstract": "Thoth isa real-time operating system which is designed to be portable over a large set of machines.  It is currently running on two minicomputers with quite different architectures.  Both the system and application programs which use it are written in a high-level language. Because the system is implemented by the same software on different hardware, it has the same interface to user programs.  Hence, application programs which use Thoth are  highly portable.  Thoth encourages structuring programs as networks of communicating processes  by providing efficient interprocess communication primitives.", "authors": ". Sager, G.R.", "words_pool": ["applic", "architectur", "commun", "commun", "design", "effici", "encourag", "hardwar", "high", "highli", "implement", "interfac", "interprocess", "isa", "languag", "larg", "level", "machin", "minicomput", "network", "oper", "portabl", "primit", "process", "program", "provid", "real", "run", "set", "softwar", "structur", "system", "thoth", "time", "user", "written", "sager"], "word_count": {"applic": 2, "architectur": 1, "commun": 2, "design": 1, "effici": 1, "encourag": 1, "hardwar": 1, "high": 1, "highli": 1, "implement": 1, "interfac": 1, "interprocess": 1, "isa": 1, "languag": 1, "larg": 1, "level": 1, "machin": 1, "minicomput": 1, "network": 1, "oper": 1, "portabl": 2, "primit": 1, "process": 1, "program": 4, "provid": 1, "real": 1, "run": 1, "set": 1, "softwar": 1, "structur": 1, "system": 3, "thoth": 3, "time": 1, "user": 1, "written": 1, "sager": 1}}, "3128": {"id": "3128", "title": "Synchronization with Eventcounts and Sequencers", "abstract": "Synchronization of concurrent processes requires controlling the relative  ordering of events in the processes. A new synchronization mechanism is proposed, using  abstract objects called eventcounts and sequencers, that allows processes to control the ordering of events directly, rather than using mutual exclusion to protect manipulations of shared variables that control ordering of events.  Direct control of ordering seems to simplify correctness arguments and also simplifies implementation in distributed systems.  The mechanism is defined formally, and then several examples of its use are given.  The relationship of the mechanism to protection mechanisms in the system is explained; in particular, eventcounts are shown to be applicable to situations where confinement of information matters.  An implementation of eventcount s and sequencers in a system with shared memory is described.", "authors": "Reed, D.P. Kanodia, R", "words_pool": ["abstract", "applic", "argument", "call", "concurr", "confin", "control", "control", "correct", "defin", "direct", "directli", "distribut", "eventcount", "eventcount", "event", "exampl", "exclus", "explain", "formal", "implement", "inform", "manipul", "matter", "mechan", "mechan", "memori", "mutual", "object", "order", "process", "propos", "protect", "protect", "relationship", "rel", "requir", "sequenc", "share", "shown", "simplifi", "simplifi", "situat", "synchron", "system", "system", "variabl", "reed", "kanodia"], "word_count": {"abstract": 1, "applic": 1, "argument": 1, "call": 1, "concurr": 1, "confin": 1, "control": 4, "correct": 1, "defin": 1, "direct": 1, "directli": 1, "distribut": 1, "eventcount": 3, "event": 3, "exampl": 1, "exclus": 1, "explain": 1, "formal": 1, "implement": 2, "inform": 1, "manipul": 1, "matter": 1, "mechan": 4, "memori": 1, "mutual": 1, "object": 1, "order": 4, "process": 3, "propos": 1, "protect": 2, "relationship": 1, "rel": 1, "requir": 1, "sequenc": 2, "share": 2, "shown": 1, "simplifi": 2, "situat": 1, "synchron": 2, "system": 3, "variabl": 1, "reed": 1, "kanodia": 1}}, "3129": {"id": "3129", "title": "Optimal Storage Allocation for Serial Files", "abstract": "A computer system uses several serial files.  The files reside on a  direct-access storage device in which storage space is limited.  Records are  added to the files either by jobs in batch processing mode, or by on-line  transactions. Each transaction (or job) generates a demand vector which  designates the space required in each file for record addition. Whenever one  file runs out of space, the system must be reorganized.  This paper considers  several criteria for best allocating storage space to the files.", "authors": "Mendelson, H. Pliskin, J.S. Yechiali, U.", "words_pool": ["access", "ad", "addit", "alloc", "alloc", "batch", "comput", "consid", "criteria", "demand", "design", "devic", "direct", "gener", "job", "job", "limit", "line", "mode", "optim", "paper", "process", "record", "record", "reorgan", "requir", "resid", "run", "serial", "space", "storag", "system", "transact", "transact", "vector", "mendelson", "pliskin", "yechiali"], "word_count": {"access": 1, "ad": 1, "addit": 1, "alloc": 1, "batch": 1, "comput": 1, "consid": 1, "criteria": 1, "demand": 1, "design": 1, "devic": 1, "direct": 1, "gener": 1, "job": 2, "limit": 1, "line": 1, "mode": 1, "optim": 1, "paper": 1, "process": 1, "record": 2, "reorgan": 1, "requir": 1, "resid": 1, "run": 1, "serial": 1, "space": 4, "storag": 3, "system": 2, "transact": 2, "vector": 1, "mendelson": 1, "pliskin": 1, "yechiali": 1}}, "3130": {"id": "3130", "title": ". Engel, G.L. Stokes, G.", "abstract": "Contained in this report are the recommendations for the undergraduate degree program in Computer Science of the Curriculum Committee on Computer Science (C3S) of the Association for Computing Machinery (ACM).   The core curriculum common to all computer science undergraduate programs is presented in terms of elementary level topics and courses, and intermediate level courses. Elective courses, used to round out an undergraduate program, are then discussed, and the entire program including the computer science component and other material is presented.  Issues related to undergraduate computer science education, such as service courses, supporting areas, continuing education, facilities, staff, and articulation are presented.", "authors": "Austing, R.H. Barnes, B.H. Bonnette, D", "words_pool": ["acm", "area", "articul", "associ", "c3", "committe", "common", "compon", "comput", "comput", "contain", "continu", "core", "cours", "curriculum", "degre", "discuss", "educ", "elect", "elementari", "engel", "entir", "facil", "includ", "intermedi", "issu", "level", "machineri", "materi", "present", "program", "program", "recommend", "relat", "report", "round", "scienc", "servic", "staff", "stoke", "support", "term", "topic", "undergradu", "aust", "barn", "bonnett"], "word_count": {"acm": 1, "area": 1, "articul": 1, "associ": 1, "c3": 1, "committe": 1, "common": 1, "compon": 1, "comput": 6, "contain": 1, "continu": 1, "core": 1, "cours": 4, "curriculum": 2, "degre": 1, "discuss": 1, "educ": 2, "elect": 1, "elementari": 1, "engel": 1, "entir": 1, "facil": 1, "includ": 1, "intermedi": 1, "issu": 1, "level": 2, "machineri": 1, "materi": 1, "present": 3, "program": 4, "recommend": 1, "relat": 1, "report": 1, "round": 1, "scienc": 5, "servic": 1, "staff": 1, "stoke": 1, "support": 1, "term": 1, "topic": 1, "undergradu": 4, "aust": 1, "barn": 1, "bonnett": 1}}, "3131": {"id": "3131", "title": "FOCUS Microcomputer Number System", "abstract": "FOCUS is a number system and supporting computational algorithms especially useful for microcomputer control and other signal processing applications.  FOCUS has the wide-ranging character of floating-point numbers with a uniformity of state distributions that give FOCUS better than a twofold accuracy advantage over an equal word length floating-point system.  FOCUS computations are typically five times faster than single precision fixed-point or integer arithmetic for a mixture of operations, comparable in speed with hardware arithmetic for many applications.  Algorithms for 8-bit and 16-bit implementations of FOCUS are included.", "authors": "Edgar, A.D. Lee, S", "words_pool": ["accuraci", "advantag", "algorithm", "applic", "arithmet", "bit", "charact", "compar", "comput", "comput", "control", "distribut", "equal", "especi", "faster", "fix", "float", "focu", "give", "hardwar", "implement", "includ", "integ", "length", "microcomput", "mixtur", "number", "number", "oper", "point", "precis", "process", "rang", "signal", "singl", "speed", "state", "support", "system", "time", "twofold", "typic", "uniform", "wide", "word", "edgar", "lee"], "word_count": {"accuraci": 1, "advantag": 1, "algorithm": 2, "applic": 2, "arithmet": 2, "bit": 2, "charact": 1, "compar": 1, "comput": 2, "control": 1, "distribut": 1, "equal": 1, "especi": 1, "faster": 1, "fix": 1, "float": 2, "focu": 5, "give": 1, "hardwar": 1, "implement": 1, "includ": 1, "integ": 1, "length": 1, "microcomput": 1, "mixtur": 1, "number": 2, "oper": 1, "point": 3, "precis": 1, "process": 1, "rang": 1, "signal": 1, "singl": 1, "speed": 1, "state": 1, "support": 1, "system": 2, "time": 1, "twofold": 1, "typic": 1, "uniform": 1, "wide": 1, "word": 1, "edgar": 1, "lee": 1}}, "3132": {"id": "3132", "title": "Experiments with Some Algorithms that Find Central Solutions for Pattern Classification", "abstract": "In two-class pattern recognition, it is a standard technique to have an algorithm finding hyperplanes which separates the two classes in a linearly separable training set.  The traditional methods find a hyperplane which separates all points in the other, but such a hyperplane is not necessarily centered in the empty space between the two classes.  Since a central hyperplane does not favor one class or the other, it should have a lower error rate in classifying new points and is therefore better than a noncentral hyperplane.  Six algorithms for finding central hyperplanes are tested on three data sets.  Although frequently used practice, the modified relaxation algorithm is very poor.  Three algorithms which are defined in the paper are found to be quite good.", "authors": "Slagle, J.", "words_pool": ["algorithm", "algorithm", "center", "central", "class", "class", "classif", "classifi", "data", "defin", "empti", "error", "experi", "favor", "find", "find", "found", "frequent", "good", "hyperplan", "hyperplan", "linearli", "lower", "method", "modifi", "necessarili", "noncentr", "paper", "pattern", "point", "poor", "practic", "rate", "recognit", "relax", "separ", "separ", "set", "set", "solut", "space", "standard", "techniqu", "test", "tradit", "train", "slagl"], "word_count": {"algorithm": 4, "center": 1, "central": 2, "class": 4, "classif": 1, "classifi": 1, "data": 1, "defin": 1, "empti": 1, "error": 1, "experi": 1, "favor": 1, "find": 3, "found": 1, "frequent": 1, "good": 1, "hyperplan": 6, "linearli": 1, "lower": 1, "method": 1, "modifi": 1, "necessarili": 1, "noncentr": 1, "paper": 1, "pattern": 1, "point": 2, "poor": 1, "practic": 1, "rate": 1, "recognit": 1, "relax": 1, "separ": 3, "set": 2, "solut": 1, "space": 1, "standard": 1, "techniqu": 1, "test": 1, "tradit": 1, "train": 1, "slagl": 1}}, "3133": {"id": "3133", "title": "Logic and Semantic Networks", "abstract": "An extended form of semantic network is defined, which can be regarded as a syntactic variant of the clausal form of logic. By virtue of its relationship with logic, the extended semantic network is provided with a precise semantics, inference rules, and a procedural interpretation.  On the other hand, by regarding semantic networks as an  abstract data structure for the representation of clauses, we provide a theorem-prover with a potentially useful indexing scheme and path-following strategy for guiding the search for a proof.", "authors": ".", "words_pool": ["abstract", "clausal", "claus", "data", "defin", "extend", "form", "guid", "hand", "index", "infer", "interpret", "logic", "network", "network", "path", "potenti", "precis", "procedur", "proof", "prover", "provid", "provid", "regard", "regard", "relationship", "represent", "rule", "scheme", "search", "semant", "semant", "strategi", "structur", "syntact", "theorem", "variant", "virtu"], "word_count": {"abstract": 1, "clausal": 1, "claus": 1, "data": 1, "defin": 1, "extend": 2, "form": 2, "guid": 1, "hand": 1, "index": 1, "infer": 1, "interpret": 1, "logic": 2, "network": 3, "path": 1, "potenti": 1, "precis": 1, "procedur": 1, "proof": 1, "prover": 1, "provid": 2, "regard": 2, "relationship": 1, "represent": 1, "rule": 1, "scheme": 1, "search": 1, "semant": 4, "strategi": 1, "structur": 1, "syntact": 1, "theorem": 1, "variant": 1, "virtu": 1}}, "3134": {"id": "3134", "title": "The Use of Normal Multiplication Tables for Information Storage and Retrieval", "abstract": "This paper describes a method for the organization and retrieval of attribute  based information systems, using the normal multiplication table as a directory for the information system.  Algorithms for the organization an d retrieval of information are described.  This method is particularly suitable for queries requesting a group of information items,  all of which possess a particular set of attributes (and possibly some other attributes as well).  Several examples are given; the results with respect to the number of disk accesses and disk space are compared to other common approaches.  Algorithms evaluating the appropriateness of the above approach to a given information system are described.  For a certain class of information systems, the normal multiplication table method yields far more rapid retrieval with a more economical space requirement than conventional systems.   Moreover this method incorporates an improved modification of the inverted  file technique.", "authors": "Motzkin, D.", "words_pool": ["access", "algorithm", "approach", "approach", "appropri", "attribut", "attribut", "base", "class", "common", "compar", "convent", "describ", "directori", "disk", "econom", "evalu", "exampl", "group", "improv", "incorpor", "inform", "invert", "item", "method", "modif", "multipl", "normal", "number", "organ", "paper", "possess", "possibl", "queri", "rapid", "request", "requir", "respect", "result", "retriev", "set", "space", "storag", "suitabl", "system", "system", "tabl", "tabl", "techniqu", "yield", "motzkin"], "word_count": {"access": 1, "algorithm": 2, "approach": 2, "appropri": 1, "attribut": 3, "base": 1, "class": 1, "common": 1, "compar": 1, "convent": 1, "describ": 1, "directori": 1, "disk": 2, "econom": 1, "evalu": 1, "exampl": 1, "group": 1, "improv": 1, "incorpor": 1, "inform": 6, "invert": 1, "item": 1, "method": 4, "modif": 1, "multipl": 2, "normal": 2, "number": 1, "organ": 2, "paper": 1, "possess": 1, "possibl": 1, "queri": 1, "rapid": 1, "request": 1, "requir": 1, "respect": 1, "result": 1, "retriev": 3, "set": 1, "space": 2, "storag": 1, "suitabl": 1, "system": 5, "tabl": 2, "techniqu": 1, "yield": 1, "motzkin": 1}}, "3135": {"id": "3135", "title": "Detection of Three-Dimensional Patterns of Atoms in Chemical Structures", "abstract": "An algorithm for detecting occurrences of a three-dimensional pattern of objects within a larger structure is presented.  The search technique presented uses the geometric structure of the pattern to define characteristics demanded of candidates for matching. This is useful in cases where the properties of each atom, considered individually, do not adequately limit the number of sets of possible matchings. Several applications of this technique in the field of chemistry are: (1) in pharmacology: searching for a common constellation of atoms in molecules possessing similar biological activities; (2) in X-ray crystallography: fitting a structure or a structural fragment to a set of peaks in the electron-density distribution of a Fourier map; (3) in chemical documentation; retrieving from a file the structures containing specified substructures.", "authors": "Lesk, A.M.", "words_pool": ["activ", "adequ", "algorithm", "applic", "atom", "atom", "biolog", "candid", "case", "characterist", "chemic", "chemistri", "common", "consid", "constel", "crystallographi", "defin", "demand", "densiti", "detect", "detect", "dimension", "distribut", "document", "electron", "field", "fit", "fourier", "fragment", "geometr", "individu", "larger", "limit", "map", "match", "match", "molecul", "number", "object", "occurr", "pattern", "pattern", "peak", "pharmacolog", "possess", "present", "properti", "ray", "retriev", "search", "search", "set", "set", "similar", "structur", "structur", "structur", "substructur", "techniqu", "lesk"], "word_count": {"activ": 1, "adequ": 1, "algorithm": 1, "applic": 1, "atom": 2, "biolog": 1, "candid": 1, "case": 1, "characterist": 1, "chemic": 1, "chemistri": 1, "common": 1, "consid": 1, "constel": 1, "crystallographi": 1, "defin": 1, "demand": 1, "densiti": 1, "detect": 1, "dimension": 1, "distribut": 1, "document": 1, "electron": 1, "field": 1, "fit": 1, "fourier": 1, "fragment": 1, "geometr": 1, "individu": 1, "larger": 1, "limit": 1, "map": 1, "match": 2, "molecul": 1, "number": 1, "object": 1, "occurr": 1, "pattern": 2, "peak": 1, "pharmacolog": 1, "possess": 1, "present": 2, "properti": 1, "ray": 1, "retriev": 1, "search": 2, "set": 2, "similar": 1, "structur": 5, "substructur": 1, "techniqu": 2, "lesk": 1}}, "3136": {"id": "3136", "title": "Price/Performance Patterns of U.S. Computer Systems", "abstract": "Econometric models of the U.S. computer market have been developed to study  the relationships between system price and hardware performance.  Single measures of price/performance such as \"Grosch's Law\" are shown to be so over simplified as to be meaningless.  Multiple-regression models predicting system cost as a function of several hardware characteristics do, however, reveal a market dichotomy.  On one hand there exists a stable, price predictable market for larger, general purpose computer systems.  The other market is the developing one for small business computer systems, a market which is relatively unstable with low price predictability.", "authors": "Cale, E.G. Gremillion, L.L. McKenney, J.L.", "words_pool": ["busi", "characterist", "comput", "cost", "develop", "develop", "dichotomi", "econometr", "exist", "function", "gener", "grosch", "hand", "hardwar", "larger", "law", "low", "market", "meaningless", "measur", "model", "multipl", "pattern", "perform", "predict", "predict", "predict", "price", "purpos", "regress", "relationship", "reveal", "shown", "simplifi", "singl", "small", "stabl", "studi", "system", "system", "unstabl", "cale", "gremillion", "mckenney"], "word_count": {"busi": 1, "characterist": 1, "comput": 3, "cost": 1, "develop": 2, "dichotomi": 1, "econometr": 1, "exist": 1, "function": 1, "gener": 1, "grosch": 1, "hand": 1, "hardwar": 2, "larger": 1, "law": 1, "low": 1, "market": 5, "meaningless": 1, "measur": 1, "model": 2, "multipl": 1, "pattern": 1, "perform": 2, "predict": 3, "price": 4, "purpos": 1, "regress": 1, "relationship": 1, "reveal": 1, "shown": 1, "simplifi": 1, "singl": 1, "small": 1, "stabl": 1, "studi": 1, "system": 4, "unstabl": 1, "cale": 1, "gremillion": 1, "mckenney": 1}}, "3137": {"id": "3137", "title": "A Methodology for the Design of Distributed Information Systems", "abstract": "A macro model of a distributed information system in presented.  The model describes the major costs of using an information system from the perspective of the end-user.  The making evident the effect of various design and operating parameters on overall cost per transaction.  The technique is illustrated by application to the design of an interactive transaction processing system.", "authors": "Bucci, G. Streeter, D", "words_pool": ["applic", "cost", "cost", "describ", "design", "distribut", "effect", "end", "evid", "illustr", "inform", "interact", "macro", "major", "make", "methodolog", "model", "oper", "paramet", "perspect", "present", "process", "system", "system", "techniqu", "transact", "user", "bucci", "streeter"], "word_count": {"applic": 1, "cost": 2, "describ": 1, "design": 2, "distribut": 1, "effect": 1, "end": 1, "evid": 1, "illustr": 1, "inform": 2, "interact": 1, "macro": 1, "major": 1, "make": 1, "methodolog": 1, "model": 2, "oper": 1, "paramet": 1, "perspect": 1, "present": 1, "process": 1, "system": 3, "techniqu": 1, "transact": 2, "user": 1, "bucci": 1, "streeter": 1}}, "3138": {"id": "3138", "title": "A Mathematical Programming Updating Method Using Modified Givens Transformations and Applied to LP Problems", "abstract": "An efficient and numerically stable method is presented for the problem of updating an orthogonal decomposition of a matrix of column (or row) vectors. The fundamental idea is to add a column (or row) analogous to adding an additional row of data in a linear least squares problem. A column (or row) is dropped by a formal scaling with the imaginary unit,  -1, followed by least squares addition of the column (or row).  The elimination process for the procedure is successive ssive application of the Givens transformation in modified (more efficient) form.  These ideas are illustrated with an implementation of the revised simplex method.  The algorithm is a general purpose one that does not account for any particular structure or sparsity in the equations.  Some suggested computational tests for determining signs of various controlling parameters in the revised simplex algorithm are mentioned.  A simple means of constructing test cases and some sample computing times are presented.", "authors": ".", "words_pool": ["account", "add", "ad", "addit", "addit", "algorithm", "analog", "applic", "appli", "case", "column", "comput", "comput", "construct", "control", "data", "decomposit", "determin", "drop", "effici", "elimin", "equat", "form", "formal", "fundament", "gener", "given", "idea", "idea", "illustr", "imaginari", "implement", "linear", "lp", "mathemat", "matrix", "mean", "mention", "method", "modifi", "numer", "orthogon", "paramet", "present", "problem", "problem", "procedur", "process", "program", "purpos", "revis", "row", "sampl", "scale", "sign", "simpl", "simplex", "sparsiti", "squar", "ssive", "stabl", "structur", "success", "suggest", "test", "test", "time", "transform", "transform", "unit", "updat", "vector"], "word_count": {"account": 1, "add": 1, "ad": 1, "addit": 2, "algorithm": 2, "analog": 1, "applic": 1, "appli": 1, "case": 1, "column": 4, "comput": 2, "construct": 1, "control": 1, "data": 1, "decomposit": 1, "determin": 1, "drop": 1, "effici": 2, "elimin": 1, "equat": 1, "form": 1, "formal": 1, "fundament": 1, "gener": 1, "given": 1, "idea": 2, "illustr": 1, "imaginari": 1, "implement": 1, "linear": 1, "lp": 1, "mathemat": 1, "matrix": 1, "mean": 1, "mention": 1, "method": 2, "modifi": 1, "numer": 1, "orthogon": 1, "paramet": 1, "present": 2, "problem": 2, "procedur": 1, "process": 1, "program": 1, "purpos": 1, "revis": 2, "row": 5, "sampl": 1, "scale": 1, "sign": 1, "simpl": 1, "simplex": 2, "sparsiti": 1, "squar": 2, "ssive": 1, "stabl": 1, "structur": 1, "success": 1, "suggest": 1, "test": 2, "time": 1, "transform": 1, "unit": 1, "updat": 1, "vector": 1}}, "3139": {"id": "3139", "title": "New Methods to Color the Vertices of a Graph", "abstract": "This paper describes efficient new heuristic methods to color the vertices of a graph which rely upon the comparison of the degrees and structure of a graph.  A method is developed which is exact for bipartite graphs and is an important part of heuristic procedures to find maximal cliques in general graphs.  Finally an exact method is given which performs better than the Randall-Brown algorithm and is able to color larger graphs, and the new heuristic methods, the classical methods, and the exact method are compared.", "authors": "Brelaz, D.", "words_pool": ["abl", "algorithm", "bipartit", "brown", "classic", "cliqu", "color", "compar", "comparison", "degre", "describ", "develop", "effici", "exact", "final", "find", "gener", "graph", "graph", "heurist", "import", "larger", "maxim", "method", "method", "paper", "part", "perform", "procedur", "randal", "reli", "structur", "vertic", "brelaz"], "word_count": {"abl": 1, "algorithm": 1, "bipartit": 1, "brown": 1, "classic": 1, "cliqu": 1, "color": 2, "compar": 1, "comparison": 1, "degre": 1, "describ": 1, "develop": 1, "effici": 1, "exact": 3, "final": 1, "find": 1, "gener": 1, "graph": 5, "heurist": 3, "import": 1, "larger": 1, "maxim": 1, "method": 6, "paper": 1, "part": 1, "perform": 1, "procedur": 1, "randal": 1, "reli": 1, "structur": 1, "vertic": 1, "brelaz": 1}}, "3140": {"id": "3140", "title": "Social Processes and Proofs of Theorems and Programs", "abstract": "It is argued that formal verifications of programs, no matter how obtained, will not play the same key role in the development of computer science and software engineering as proofs do in mathematics.  Furthermore the absence of continuity, the inevitability of change, and the complexity of specification of significantly many real programs make the form al verification process difficult to justify and manage.  It is felt that ease of formal verification should not dominate program language design.", "authors": ". Lipton, R.J. Perlis, A.J.", "words_pool": ["absenc", "al", "argu", "chang", "complex", "comput", "continu", "design", "develop", "difficult", "domin", "eas", "engin", "felt", "form", "formal", "inevit", "justifi", "key", "languag", "make", "manag", "mathemat", "matter", "obtain", "play", "process", "process", "program", "program", "proof", "real", "role", "scienc", "significantli", "social", "softwar", "specif", "theorem", "verif", "verif", "lipton", "perli"], "word_count": {"absenc": 1, "al": 1, "argu": 1, "chang": 1, "complex": 1, "comput": 1, "continu": 1, "design": 1, "develop": 1, "difficult": 1, "domin": 1, "eas": 1, "engin": 1, "felt": 1, "form": 1, "formal": 2, "inevit": 1, "justifi": 1, "key": 1, "languag": 1, "make": 1, "manag": 1, "mathemat": 1, "matter": 1, "obtain": 1, "play": 1, "process": 1, "program": 3, "proof": 1, "real": 1, "role": 1, "scienc": 1, "significantli": 1, "social": 1, "softwar": 1, "specif": 1, "theorem": 1, "verif": 3, "lipton": 1, "perli": 1}}, "3141": {"id": "3141", "title": "An Improved Algorithm for Decentralized Extrema-Finding in Circular Configurations of Processes", "abstract": "This note presents an improvement to LeLann's algorithm for finding the largest (or smallest) of a set of uniquely numbered processes arranged in a circle, in which no central controller exists and the number of processes is not known a priori. This decentralized algorithm uses a technique of selective message extinction in order to achieve an average number of message passes of order (n log n) rather than O(n2).", "authors": "Chang, E. Roberts, R.", "words_pool": ["achiev", "algorithm", "arrang", "averag", "central", "circl", "circular", "configur", "control", "decentr", "exist", "extinct", "extrema", "find", "improv", "improv", "known", "largest", "lelann", "log", "messag", "n2", "note", "number", "number", "order", "pass", "present", "priori", "process", "select", "set", "smallest", "techniqu", "uniqu", "chang", "robert"], "word_count": {"achiev": 1, "algorithm": 2, "arrang": 1, "averag": 1, "central": 1, "circl": 1, "circular": 1, "configur": 1, "control": 1, "decentr": 1, "exist": 1, "extinct": 1, "extrema": 1, "find": 1, "improv": 1, "known": 1, "largest": 1, "lelann": 1, "log": 1, "messag": 2, "n2": 1, "note": 1, "number": 3, "order": 2, "pass": 1, "present": 1, "priori": 1, "process": 2, "select": 1, "set": 1, "smallest": 1, "techniqu": 1, "uniqu": 1, "chang": 1, "robert": 1}}, "3142": {"id": "3142", "title": "Consumer Difficulties With Computerized Transactions:  An Empirical Investigation", "abstract": "The prevalence with which errors may be encountered by the  end targets of a computerized process is assessed.  How many and what type of errors occur?  How easily are they corrected?  What is the reaction of consumers to errors-to a failure to correct them?  What can be learned by designers of large management packages from such data? Results show that with the present state of the art, approximately 40 percent of individuals (or households) having average contacts with different types of accounts experience one or more errors per year.  Eighty percent relate to billing.  Attempts to correct errors often turned out to be difficult and not always successful. There appears to be some conflict between computer-using organizations and their public.  Also the role of poor man agement packages including poor software is indicated.  While most management systems may be adequate, results of the survey raise concerns about the timeliness and the number of designs of very large linked program packages (as EFT for instance).", "authors": "Sterling, T.D.", "words_pool": ["account", "adequ", "agement", "appear", "approxim", "art", "assess", "attempt", "averag", "bill", "comput", "computer", "concern", "conflict", "consum", "consum", "contact", "correct", "correct", "data", "design", "design", "difficult", "difficulti", "easili", "eft", "eighti", "empir", "encount", "end", "error", "experi", "failur", "household", "includ", "individu", "instanc", "investig", "larg", "learn", "link", "man", "manag", "number", "occur", "organ", "packag", "percent", "poor", "present", "preval", "process", "program", "public", "rais", "reaction", "relat", "result", "role", "show", "softwar", "state", "success", "survey", "system", "target", "timeli", "transact", "turn", "type", "type", "year", "sterl"], "word_count": {"account": 1, "adequ": 1, "agement": 1, "appear": 1, "approxim": 1, "art": 1, "assess": 1, "attempt": 1, "averag": 1, "bill": 1, "comput": 1, "computer": 1, "concern": 1, "conflict": 1, "consum": 1, "contact": 1, "correct": 3, "data": 1, "design": 2, "difficult": 1, "difficulti": 1, "easili": 1, "eft": 1, "eighti": 1, "empir": 1, "encount": 1, "end": 1, "error": 5, "experi": 1, "failur": 1, "household": 1, "includ": 1, "individu": 1, "instanc": 1, "investig": 1, "larg": 2, "learn": 1, "link": 1, "man": 1, "manag": 2, "number": 1, "occur": 1, "organ": 1, "packag": 3, "percent": 2, "poor": 2, "present": 1, "preval": 1, "process": 1, "program": 1, "public": 1, "rais": 1, "reaction": 1, "relat": 1, "result": 2, "role": 1, "show": 1, "softwar": 1, "state": 1, "success": 1, "survey": 1, "system": 1, "target": 1, "timeli": 1, "transact": 1, "turn": 1, "type": 2, "year": 1, "sterl": 1}}, "3143": {"id": "3143", "title": "Reasoning About Arrays", "abstract": "A variety of concepts, laws, and notations are presented which facilitate reasoning about arrays.  The basic concepts include intervals and their partitions, functional restriction, images, pointwise extension of relations, ordering, single-point variation of functions, various equivalence relations  for array values, and concatenation.  The effectiveness of these ideas is illustrated by informal descriptions of algorithms for binary search and merging, and by a short formal proof.", "authors": "Reynolds, J", "words_pool": ["algorithm", "array", "array", "basic", "binari", "concaten", "concept", "descript", "effect", "equival", "extens", "facilit", "formal", "function", "function", "idea", "illustr", "imag", "includ", "inform", "interv", "law", "merg", "notat", "order", "partit", "point", "pointwis", "present", "proof", "reason", "relat", "restrict", "search", "short", "singl", "valu", "variat", "varieti", "reynold"], "word_count": {"algorithm": 1, "array": 2, "basic": 1, "binari": 1, "concaten": 1, "concept": 2, "descript": 1, "effect": 1, "equival": 1, "extens": 1, "facilit": 1, "formal": 1, "function": 2, "idea": 1, "illustr": 1, "imag": 1, "includ": 1, "inform": 1, "interv": 1, "law": 1, "merg": 1, "notat": 1, "order": 1, "partit": 1, "point": 1, "pointwis": 1, "present": 1, "proof": 1, "reason": 1, "relat": 2, "restrict": 1, "search": 1, "short": 1, "singl": 1, "valu": 1, "variat": 1, "varieti": 1, "reynold": 1}}, "3144": {"id": "3144", "title": "A Model for and DIscussion of Multi-Interpreter Systems", "abstract": "A multi-interpreter system is a system in which programs execute by virtue of being interpreted by other programs, which themselves may either be interpreted (i.e. nested interpreters) or run directly on the host machine.  The model reveals the anatomy of interpreters and how these differ from procedures, and exhibits links to protection domains and multiprocessor architectures.", "authors": "Manthey, M.J.", "words_pool": ["anatomi", "architectur", "differ", "directli", "discuss", "domain", "execut", "exhibit", "host", "interpret", "interpret", "interpret", "link", "machin", "model", "multi", "multiprocessor", "nest", "procedur", "program", "protect", "reveal", "run", "system", "system", "virtu", "manthey"], "word_count": {"anatomi": 1, "architectur": 1, "differ": 1, "directli": 1, "discuss": 1, "domain": 1, "execut": 1, "exhibit": 1, "host": 1, "interpret": 5, "link": 1, "machin": 1, "model": 1, "multi": 1, "multiprocessor": 1, "nest": 1, "procedur": 1, "program": 2, "protect": 1, "reveal": 1, "run": 1, "system": 2, "virtu": 1, "manthey": 1}}, "3145": {"id": "3145", "title": "An Implementation of Structured Walk-Throughs in Teaching Cobol Programming", "abstract": "The effectiveness of structured walk-throughs in teaching introductory Cobol programming was empirically assessed with a sample of 215 under-graduate business administration majors.  Cobol proficiency was measured by a final examination testing (a) knowledge of language rules, (b) ability to read and debug a program, and (c) the ability to write a program.  Analysis of multiple covariance was used to statistically adjust test scores for age and conditional reasoning scores. The findings provide empirical support for incorporating structured walk-throughs into the programming learning process more effectively develop student proficiency in writing Cobol programs.", "authors": "Lemos, R.S.", "words_pool": ["abil", "adjust", "administr", "age", "analysi", "assess", "busi", "cobol", "condit", "covari", "debug", "develop", "effect", "effect", "empir", "empir", "examin", "final", "find", "graduat", "implement", "incorpor", "introductori", "knowledg", "languag", "learn", "major", "measur", "multipl", "process", "profici", "program", "program", "program", "provid", "read", "reason", "rule", "sampl", "score", "statist", "structur", "student", "support", "teach", "test", "test", "through", "walk", "write", "write", "lemo"], "word_count": {"abil": 2, "adjust": 1, "administr": 1, "age": 1, "analysi": 1, "assess": 1, "busi": 1, "cobol": 3, "condit": 1, "covari": 1, "debug": 1, "develop": 1, "effect": 2, "empir": 2, "examin": 1, "final": 1, "find": 1, "graduat": 1, "implement": 1, "incorpor": 1, "introductori": 1, "knowledg": 1, "languag": 1, "learn": 1, "major": 1, "measur": 1, "multipl": 1, "process": 1, "profici": 2, "program": 5, "provid": 1, "read": 1, "reason": 1, "rule": 1, "sampl": 1, "score": 2, "statist": 1, "structur": 2, "student": 1, "support": 1, "teach": 1, "test": 2, "through": 2, "walk": 2, "write": 2, "lemo": 1}}, "3146": {"id": "3146", "title": "An Academic Program Providing Realistic Training in Software Engineering", "abstract": "An academic program at Harvey Mudd College, called the Clinic program, brings projects from industry on  campus to be studied and solved by student teams.  The objective of the Clinic is to provide students, working as small teams under  careful faculty supervision, an opportunity to work on real world problems of sufficient magnitude and complexity.  Under this program, students can acquire essential skills of software engineering, such as team work, software project management, software design methodology, and communication skills, in a realistic environment. Sample software projects undertaken by the Clinic are described.  Experience so far has shown that the program is a viable transition from an academic to industrial world.", "authors": "Busenberg, S", "words_pool": ["academ", "acquir", "bring", "call", "campu", "care", "clinic", "colleg", "commun", "complex", "design", "engin", "environ", "essenti", "experi", "faculti", "harvey", "industri", "industri", "magnitud", "manag", "methodolog", "mudd", "object", "opportun", "problem", "program", "project", "project", "provid", "provid", "real", "realist", "sampl", "shown", "skill", "small", "softwar", "solv", "student", "student", "studi", "suffici", "supervis", "team", "team", "train", "transit", "undertaken", "viabl", "work", "work", "world", "busenberg"], "word_count": {"academ": 2, "acquir": 1, "bring": 1, "call": 1, "campu": 1, "care": 1, "clinic": 3, "colleg": 1, "commun": 1, "complex": 1, "design": 1, "engin": 1, "environ": 1, "essenti": 1, "experi": 1, "faculti": 1, "harvey": 1, "industri": 2, "magnitud": 1, "manag": 1, "methodolog": 1, "mudd": 1, "object": 1, "opportun": 1, "problem": 1, "program": 4, "project": 3, "provid": 1, "real": 1, "realist": 1, "sampl": 1, "shown": 1, "skill": 2, "small": 1, "softwar": 4, "solv": 1, "student": 3, "studi": 1, "suffici": 1, "supervis": 1, "team": 3, "train": 1, "transit": 1, "undertaken": 1, "viabl": 1, "work": 3, "world": 2, "busenberg": 1}}, "3147": {"id": "3147", "title": "A Model for Automating File and Program Design in Business Application Systems", "abstract": "This paper discusses a model for finding an efficient implementation of a  business application system whose logical specifications have been determined in advance.  The model views file and program design as a problem of systematically coordinating the configurations of datasets and computations.  It uses a straight forward search technique to determine aggregations of computations, aggregations of datasets, device, organization, and key order for each data set, key order for  each computation, and access method  for each dataset-computation pair.  Although computational results are presented for a sample problem involving 54 computations and 49 datasets, the main point of the paper is that the underlying model works computationally an d is simple enough to be adapted to many file design situations.", "authors": "Alter, S.", "words_pool": ["access", "adapt", "advanc", "aggreg", "applic", "autom", "busi", "comput", "comput", "comput", "comput", "configur", "coordin", "data", "dataset", "dataset", "design", "determin", "determin", "devic", "discuss", "effici", "find", "forward", "implement", "involv", "key", "logic", "main", "method", "model", "order", "organ", "pair", "paper", "point", "present", "problem", "program", "result", "sampl", "search", "set", "simpl", "situat", "specif", "straight", "system", "systemat", "system", "techniqu", "underli", "view", "work", "alter"], "word_count": {"access": 1, "adapt": 1, "advanc": 1, "aggreg": 2, "applic": 1, "autom": 1, "busi": 1, "comput": 7, "configur": 1, "coordin": 1, "data": 1, "dataset": 4, "design": 2, "determin": 2, "devic": 1, "discuss": 1, "effici": 1, "find": 1, "forward": 1, "implement": 1, "involv": 1, "key": 2, "logic": 1, "main": 1, "method": 1, "model": 3, "order": 2, "organ": 1, "pair": 1, "paper": 2, "point": 1, "present": 1, "problem": 2, "program": 1, "result": 1, "sampl": 1, "search": 1, "set": 1, "simpl": 1, "situat": 1, "specif": 1, "straight": 1, "system": 1, "systemat": 1, "techniqu": 1, "underli": 1, "view": 1, "work": 1, "alter": 1}}, "3148": {"id": "3148", "title": "High Level Programming for Distributed Computing", "abstract": "Programming for distributed and other loosely coupled systems is a problem of growing interest.  This paper describes an approach to distributed computing at the level of general purpose programming languages.  Based on primitive notions of module, message, and transaction key, the methodology is shown to be independent of particular languages and machines.  It appears to be useful for programming a wide range of tasks.  This is part of an ambitious program of development in advanced programming languages, and relations with other aspects of the project are also discussed.", "authors": ".", "words_pool": ["advanc", "ambiti", "appear", "approach", "aspect", "base", "comput", "coupl", "describ", "develop", "discuss", "distribut", "gener", "grow", "high", "independ", "interest", "key", "languag", "level", "loos", "machin", "messag", "methodolog", "modul", "notion", "paper", "part", "primit", "problem", "program", "program", "project", "purpos", "rang", "relat", "shown", "system", "task", "transact", "wide"], "word_count": {"advanc": 1, "ambiti": 1, "appear": 1, "approach": 1, "aspect": 1, "base": 1, "comput": 1, "coupl": 1, "describ": 1, "develop": 1, "discuss": 1, "distribut": 2, "gener": 1, "grow": 1, "high": 1, "independ": 1, "interest": 1, "key": 1, "languag": 3, "level": 1, "loos": 1, "machin": 1, "messag": 1, "methodolog": 1, "modul": 1, "notion": 1, "paper": 1, "part": 1, "primit": 1, "problem": 1, "program": 5, "project": 1, "purpos": 1, "rang": 1, "relat": 1, "shown": 1, "system": 1, "task": 1, "transact": 1, "wide": 1}}, "3149": {"id": "3149", "title": "The Cyclic Order Property of Vertices as an Aid in Scene Analysis", "abstract": "A cyclic-order property is defined for bodies bounded by smooth-curved faces. The property is shown to be useful for analyzing pictures of such bodies, particularly when the line data extracted from the pictures are imperfect. This property augments previously known grammatical rules that determine the existence of three-dimensional bodies corresponding to given two-dimensional line-structure data.", "authors": "Shapira, R. Freeman, H.", "words_pool": ["aid", "analysi", "analyz", "augment", "bodi", "bound", "curv", "cyclic", "data", "defin", "determin", "dimension", "exist", "extract", "face", "grammat", "imperfect", "known", "line", "order", "pictur", "previous", "properti", "rule", "scene", "shown", "smooth", "structur", "vertic", "shapira", "freeman"], "word_count": {"aid": 1, "analysi": 1, "analyz": 1, "augment": 1, "bodi": 3, "bound": 1, "curv": 1, "cyclic": 1, "data": 2, "defin": 1, "determin": 1, "dimension": 2, "exist": 1, "extract": 1, "face": 1, "grammat": 1, "imperfect": 1, "known": 1, "line": 2, "order": 1, "pictur": 2, "previous": 1, "properti": 3, "rule": 1, "scene": 1, "shown": 1, "smooth": 1, "structur": 1, "vertic": 1, "shapira": 1, "freeman": 1}}, "3150": {"id": "3150", "title": "Beyond Programming Languages", "abstract": "As computer technology matures, our growing ability to create large systems is  leading to basic changes in the nature of programming.  Current programming  language concepts will not be adequate for building and maintaining systems of the complexity called for by the tasks we attempt.  Just as high level languages enabled the programmer to escape from the intricacies of a machine's order code, higher level programming systems can provide the means to understand and manipulate complex systems and components.  In order to develop such systems, we need to shift our attention away from the detailed specification of algorithms, towards the description of the properties of the packages and objects with which we build.  This paper analyzes some of the shortcomings of programming languages as they now exist, and lays out some possible directions for future research.", "authors": "Winograd, T.", "words_pool": ["abil", "adequ", "algorithm", "analyz", "attempt", "attent", "basic", "build", "build", "call", "code", "complex", "complex", "compon", "comput", "concept", "creat", "descript", "detail", "develop", "direct", "enabl", "escap", "exist", "futur", "grow", "high", "higher", "intricaci", "languag", "languag", "larg", "lay", "lead", "level", "machin", "maintain", "manipul", "matur", "mean", "natur", "need", "object", "order", "packag", "paper", "programm", "program", "properti", "provid", "research", "shift", "shortcom", "specif", "system", "task", "technolog", "understand", "winograd"], "word_count": {"abil": 1, "adequ": 1, "algorithm": 1, "analyz": 1, "attempt": 1, "attent": 1, "basic": 1, "build": 2, "call": 1, "code": 1, "complex": 2, "compon": 1, "comput": 1, "concept": 1, "creat": 1, "descript": 1, "detail": 1, "develop": 1, "direct": 1, "enabl": 1, "escap": 1, "exist": 1, "futur": 1, "grow": 1, "high": 1, "higher": 1, "intricaci": 1, "languag": 3, "larg": 1, "lay": 1, "lead": 1, "level": 2, "machin": 1, "maintain": 1, "manipul": 1, "matur": 1, "mean": 1, "natur": 1, "need": 1, "object": 1, "order": 2, "packag": 1, "paper": 1, "programm": 1, "program": 4, "properti": 1, "provid": 1, "research": 1, "shift": 1, "shortcom": 1, "specif": 1, "system": 5, "task": 1, "technolog": 1, "understand": 1, "winograd": 1}}, "3151": {"id": "3151", "title": "An Optimal Real-Time Algorithm for Planar Convex Hulls", "abstract": "An algorithm is described for the construction in real-time of the convex hull of a set of n points in the plane.   Using an appropriate data structure, the algorithm constructs the convex hull by successive updates, each taking time O(log n), thereby achieving a total processing time O(n log n).", "authors": "Preparata, F.P.", "words_pool": ["achiev", "algorithm", "construct", "construct", "convex", "data", "hull", "hull", "log", "optim", "planar", "plane", "point", "process", "real", "set", "structur", "success", "take", "time", "total", "updat", "preparata"], "word_count": {"achiev": 1, "algorithm": 2, "construct": 2, "convex": 2, "data": 1, "hull": 2, "log": 2, "optim": 1, "planar": 1, "plane": 1, "point": 1, "process": 1, "real": 1, "set": 1, "structur": 1, "success": 1, "take": 1, "time": 3, "total": 1, "updat": 1, "preparata": 1}}, "3152": {"id": "3152", "title": "Storage Reorganization Techniques for Matrix Computation in a Paging Environment", "abstract": "In order to multiply matrices while minimizing the number of page fetches required, it is often more efficient to reorganize the data into submatrix form and to use block multiplication  rather than to use the best known algorithms which leave the matrices stored in row-(or column-)oriented form.  An efficient method for accomplishing this reorganization is given.  This also makes possible the derivation of an asymptotically better bound for multiplication of matrices given in row-oriented form by adapting the technique of Strassen to the reorganized data.  The reorganization/block  multiplication scheme is shown to be advantageous for matrices and pages of realistic size; the Strassen adaptation is not.  The former scheme is also shown to be advantageous even if the transpose of one of the matrices is available at no additional cost.", "authors": "Fischer, P", "words_pool": ["accomplish", "adapt", "adapt", "addit", "advantag", "algorithm", "asymptot", "block", "bound", "column", "comput", "cost", "data", "deriv", "effici", "environ", "fetch", "form", "known", "leav", "make", "matric", "matrix", "method", "minim", "multipl", "multipli", "number", "order", "orient", "page", "page", "page", "realist", "reorgan", "reorgan", "reorgan", "requir", "row", "scheme", "shown", "size", "storag", "store", "strassen", "submatrix", "techniqu", "techniqu", "transpos", "fischer"], "word_count": {"accomplish": 1, "adapt": 2, "addit": 1, "advantag": 2, "algorithm": 1, "asymptot": 1, "block": 2, "bound": 1, "column": 1, "comput": 1, "cost": 1, "data": 2, "deriv": 1, "effici": 2, "environ": 1, "fetch": 1, "form": 3, "known": 1, "leav": 1, "make": 1, "matric": 5, "matrix": 1, "method": 1, "minim": 1, "multipl": 3, "multipli": 1, "number": 1, "order": 1, "orient": 2, "page": 2, "realist": 1, "reorgan": 4, "requir": 1, "row": 2, "scheme": 2, "shown": 2, "size": 1, "storag": 1, "store": 1, "strassen": 2, "submatrix": 1, "techniqu": 1, "transpos": 1, "fischer": 1}}, "3153": {"id": "3153", "title": "The Control of Response Times in Multi-Class Systems by Memory Allocations", "abstract": "The possibility of giving different quality of service to jobs of different classes by regulating their memory allocation is examined in the context of a paged computer system.  Two parameterized algorithms which partition the main memory between two classes of jobs are considered.  Initially, a closed system consisting of a process or and paging and file devices, with fixed numbers of jobs, is studied to determine optimal degrees of multiprogramming and the proportion of processor time devoted to each class.  Applying a decomposition approach and treating the closed system as a single server, the response times in an open system with external arrivals are studied.  The object is to investigate the effect of the memory alocation parameters on the expected response times under the two algorithms. Numerical solutions and economical lower bounds for the expected response times as functions of the control parameters are obtained.  A way of applying the results to systems with more than two job classes is indicated.", "authors": "Hine, J.H. Mitrani, I. Tsur, S.", "words_pool": ["algorithm", "alloc", "alloc", "aloc", "appli", "approach", "arriv", "bound", "class", "class", "close", "comput", "consid", "consist", "context", "control", "decomposit", "degre", "determin", "devic", "devot", "econom", "effect", "examin", "expect", "extern", "fix", "function", "give", "initi", "investig", "job", "job", "lower", "main", "memori", "multi", "multiprogram", "number", "numer", "object", "obtain", "open", "optim", "page", "page", "parameter", "paramet", "partit", "possibl", "process", "processor", "proport", "qualiti", "regul", "respons", "result", "server", "servic", "singl", "solut", "studi", "system", "system", "time", "time", "treat", "hine", "mitrani", "tsur"], "word_count": {"algorithm": 2, "alloc": 1, "aloc": 1, "appli": 2, "approach": 1, "arriv": 1, "bound": 1, "class": 4, "close": 2, "comput": 1, "consid": 1, "consist": 1, "context": 1, "control": 1, "decomposit": 1, "degre": 1, "determin": 1, "devic": 1, "devot": 1, "econom": 1, "effect": 1, "examin": 1, "expect": 2, "extern": 1, "fix": 1, "function": 1, "give": 1, "initi": 1, "investig": 1, "job": 4, "lower": 1, "main": 1, "memori": 3, "multi": 1, "multiprogram": 1, "number": 1, "numer": 1, "object": 1, "obtain": 1, "open": 1, "optim": 1, "page": 2, "parameter": 1, "paramet": 2, "partit": 1, "possibl": 1, "process": 1, "processor": 1, "proport": 1, "qualiti": 1, "regul": 1, "respons": 3, "result": 1, "server": 1, "servic": 1, "singl": 1, "solut": 1, "studi": 2, "system": 5, "time": 4, "treat": 1, "hine": 1, "mitrani": 1, "tsur": 1}}, "3154": {"id": "3154", "title": "Algorithm = Logic + Control", "abstract": "An algorithm can be regarded as consisting of a logic component, which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used.  The logic component determines the meaning of the algorithm whereas the control component only affects its efficiency.  The efficiency of an algorithm can often by improving the control component without changing the logic of the algorithm.  We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text.", "authors": "Kowalski, R.", "words_pool": ["affect", "algorithm", "argu", "aspect", "chang", "compon", "comput", "consist", "control", "correct", "determin", "easili", "effici", "identifi", "improv", "improv", "knowledg", "logic", "mean", "mean", "modifi", "problem", "problem", "program", "program", "regard", "separ", "solv", "specifi", "strategi", "text", "kowalski"], "word_count": {"affect": 1, "algorithm": 4, "argu": 1, "aspect": 1, "chang": 1, "compon": 5, "comput": 1, "consist": 1, "control": 4, "correct": 1, "determin": 2, "easili": 1, "effici": 2, "identifi": 1, "improv": 2, "knowledg": 2, "logic": 4, "mean": 2, "modifi": 1, "problem": 2, "program": 2, "regard": 1, "separ": 1, "solv": 2, "specifi": 1, "strategi": 1, "text": 1, "kowalski": 1}}, "3155": {"id": "3155", "title": "The Paradigms of Programming", "authors": "Floyd, R", "abstract": ".", "words_pool": ["paradigm", "program", "floyd"], "word_count": {"paradigm": 1, "program": 1, "floyd": 1}}, "3156": {"id": "3156", "title": "Computing Connected Components on Parallel Computers", "abstract": "We present a parallel algorithm which uses n2 processors to find the connected components of an undirected graph with n vertices in time O(log2n).  An O(log2n) time bound also can be achieved using only n$n/$log2n)) processors. The algorithm can be used to find the transitive closure of a symmetric Boolean matrix.  We assume that the processors have access to a common memory.  Simultaneous access to the same location is permitted for fetch instructions but not for store instructions.", "authors": "Hirschberg, D.S. Chandra, A", "words_pool": ["access", "achiev", "algorithm", "assum", "boolean", "bound", "closur", "common", "compon", "comput", "comput", "connect", "fetch", "find", "graph", "instruct", "locat", "log2n", "matrix", "memori", "n2", "parallel", "permit", "present", "processor", "simultan", "store", "symmetr", "time", "transit", "undirect", "vertic", "hirschberg", "chandra"], "word_count": {"access": 2, "achiev": 1, "algorithm": 2, "assum": 1, "boolean": 1, "bound": 1, "closur": 1, "common": 1, "compon": 1, "comput": 2, "connect": 1, "fetch": 1, "find": 2, "graph": 1, "instruct": 2, "locat": 1, "log2n": 3, "matrix": 1, "memori": 1, "n2": 1, "parallel": 1, "permit": 1, "present": 1, "processor": 3, "simultan": 1, "store": 1, "symmetr": 1, "time": 2, "transit": 1, "undirect": 1, "vertic": 1, "hirschberg": 1, "chandra": 1}}, "3157": {"id": "3157", "title": "Proving Termination with Multiset Orderings", "abstract": "A common tool for proving the termination of programs is the well-founded set, a set ordered in such a way as to admit no infinite descending sequences. The basic approach is to find a termination function  that maps the values of the program variables into some well-founded set, such that the value of the termination function is repeatedly reduced throughout the computation.  All too often, the termination functions required  are difficult to find and are of a complexity out of proportion to the program under consideration. Multisets (bags) over a given well-founded set S are sets that admit multiple occurrences of elements taken from S.  The given ordering on S induces an ordering on the finite multisets over S.  This multiset ordering is shown to be well-founded.  The multiset ordering enables the use of relatively simple and intuitive termination functions in otherwise difficult termination proofs.  In particular, the multiset ordering is used to prove the termination of production systems, programs defined in terms of sets of rewriting rules.", "authors": "Dershowitz, N. Manna, Z.", "words_pool": ["admit", "approach", "bag", "basic", "common", "complex", "comput", "consider", "defin", "descend", "difficult", "element", "enabl", "find", "finit", "found", "function", "function", "induc", "infinit", "intuit", "map", "multipl", "multiset", "multiset", "occurr", "order", "order", "order", "product", "program", "program", "proof", "proport", "prove", "prove", "reduc", "repeatedli", "requir", "rewrit", "rule", "sequenc", "set", "set", "shown", "simpl", "system", "termin", "term", "tool", "valu", "variabl", "dershowitz", "manna"], "word_count": {"admit": 2, "approach": 1, "bag": 1, "basic": 1, "common": 1, "complex": 1, "comput": 1, "consider": 1, "defin": 1, "descend": 1, "difficult": 2, "element": 1, "enabl": 1, "find": 2, "finit": 1, "found": 4, "function": 4, "induc": 1, "infinit": 1, "intuit": 1, "map": 1, "multipl": 1, "multiset": 5, "occurr": 1, "order": 6, "product": 1, "program": 4, "proof": 1, "proport": 1, "prove": 2, "reduc": 1, "repeatedli": 1, "requir": 1, "rewrit": 1, "rule": 1, "sequenc": 1, "set": 6, "shown": 1, "simpl": 1, "system": 1, "termin": 7, "term": 1, "tool": 1, "valu": 1, "variabl": 1, "dershowitz": 1, "manna": 1}}, "3158": {"id": "3158", "title": "Secure Personal Computing in an Insecure Network", "abstract": "A method for implementing secure personal computing in a network with one or more central facilities is proposed.  The method employs a public-key encryption device and hardware keys.  Each user is responsible  for his own security and need not rely on the security of the central facility or the communication links.  A user can safely store confidential files in the central facility or transmit confidential  data to other users on the network.", "authors": "Denning, D.E.", "words_pool": ["central", "commun", "comput", "confidenti", "data", "devic", "employ", "encrypt", "facil", "facil", "hardwar", "implement", "insecur", "key", "key", "link", "method", "need", "network", "person", "propos", "public", "reli", "respons", "safe", "secur", "secur", "store", "transmit", "user", "user", "den"], "word_count": {"central": 3, "commun": 1, "comput": 1, "confidenti": 2, "data": 1, "devic": 1, "employ": 1, "encrypt": 1, "facil": 3, "hardwar": 1, "implement": 1, "insecur": 1, "key": 2, "link": 1, "method": 2, "need": 1, "network": 2, "person": 1, "propos": 1, "public": 1, "reli": 1, "respons": 1, "safe": 1, "secur": 3, "store": 1, "transmit": 1, "user": 3, "den": 1}}, "3159": {"id": "3159", "title": "Further Remark on Stably Updating Mean and Standard Deviation Estimates", "authors": "Nelson, L.S.", "words_pool": ["deviat", "estim", "mean", "remark", "stabli", "standard", "updat", "nelson"], "word_count": {"deviat": 1, "estim": 1, "mean": 1, "remark": 1, "stabli": 1, "standard": 1, "updat": 1, "nelson": 1}}, "3160": {"id": "3160", "title": "Rejuvenating Experimental Computer Science", "abstract": "This report is based on the results of an NSF sponsored workshop held in Wasington, D", "authors": ". Sutherland, W.R.", "words_pool": ["base", "comput", "experiment", "held", "nsf", "rejuven", "report", "result", "scienc", "sponsor", "wasington", "workshop", "sutherland"], "word_count": {"base": 1, "comput": 1, "experiment": 1, "held": 1, "nsf": 1, "rejuven": 1, "report": 1, "result": 1, "scienc": 1, "sponsor": 1, "wasington": 1, "workshop": 1, "sutherland": 1}}, "3161": {"id": "3161", "title": "An ACM Executive Committee Position on the Crisis  in Experimental Computer Science", "authors": "McCracken, D.D., CCP Denning, P.J. Brandin, D.H.", "words_pool": ["acm", "committe", "comput", "crisi", "execut", "experiment", "posit", "scienc", "mccracken", "ccp", "den", "brandin"], "word_count": {"acm": 1, "committe": 1, "comput": 1, "crisi": 1, "execut": 1, "experiment": 1, "posit": 1, "scienc": 1, "mccracken": 1, "ccp": 1, "den": 1, "brandin": 1}}, "3162": {"id": "3162", "title": "On Improving the Worst Case Running Time of the Boyer-Moore String Matching Algorithm", "abstract": "It is shown how to modify the Boyer-Moore string matching algorithm so that its worst case running time is linear even when multiple occurrences of the  pattern are present in the text.", "authors": "Galil, Z.", "words_pool": ["algorithm", "boyer", "case", "improv", "linear", "match", "modifi", "moor", "multipl", "occurr", "pattern", "present", "run", "shown", "string", "text", "time", "worst", "galil"], "word_count": {"algorithm": 1, "boyer": 1, "case": 1, "improv": 1, "linear": 1, "match": 1, "modifi": 1, "moor": 1, "multipl": 1, "occurr": 1, "pattern": 1, "present": 1, "run": 1, "shown": 1, "string": 1, "text": 1, "time": 1, "worst": 1, "galil": 1}}, "3163": {"id": "3163", "title": "An Optimal Insertion Algorithm for One-Sided Height-Balanced BInary Search Trees", "abstract": "An algorithm for inserting an element into a one-sided height-balanced (OSHB) binary search tree is presented.  The algorithm operates in time  O(log n), where n is the number of nodes in the tree.  This represents an improvement over the best previous ly known insertion algorithms of Hirschberg and Kosaraju, which require time O(log 2n).  Moreover, the O(log n) complexity is optimal. Earlier  results have shown that deletion in such a structure can also be performed in O(log n) time.  Thus the result of this paper gives a negative answer to the question of whether such trees should be the first examples of their kind, where deletion has a smaller time  complexity than insertion.  Furthermore, it can now be concluded that insertion, deletion, and retrieval in OSHB trees can be performed in the same time as the corresponding operations for the more general AVL trees, to within a constant factor.  However, the insertion and deletion algorithms for OSHB trees appear much more complicated than the corresponding algorithms for AVL trees.", "authors": "Raiha,K.J. Zweben, S.H.", "words_pool": ["2n", "algorithm", "algorithm", "answer", "avl", "balanc", "binari", "complex", "complic", "conclud", "constant", "delet", "earlier", "element", "exampl", "factor", "gener", "height", "hirschberg", "improv", "insert", "insert", "kind", "known", "kosaraju", "log", "ly", "neg", "node", "number", "oper", "oper", "optim", "oshb", "paper", "perform", "present", "previou", "question", "repres", "requir", "result", "result", "retriev", "search", "shown", "side", "smaller", "structur", "time", "tree", "tree", "raiha", "zweben"], "word_count": {"2n": 1, "algorithm": 5, "answer": 1, "avl": 2, "balanc": 1, "binari": 1, "complex": 2, "complic": 1, "conclud": 1, "constant": 1, "delet": 4, "earlier": 1, "element": 1, "exampl": 1, "factor": 1, "gener": 1, "height": 1, "hirschberg": 1, "improv": 1, "insert": 5, "kind": 1, "known": 1, "kosaraju": 1, "log": 4, "ly": 1, "neg": 1, "node": 1, "number": 1, "oper": 2, "optim": 1, "oshb": 3, "paper": 1, "perform": 2, "present": 1, "previou": 1, "question": 1, "repres": 1, "requir": 1, "result": 2, "retriev": 1, "search": 1, "shown": 1, "side": 1, "smaller": 1, "structur": 1, "time": 5, "tree": 7, "raiha": 1, "zweben": 1}}, "3164": {"id": "3164", "title": "Progressive Acyclic Digraphs-A Tool for Database Integrity", "abstract": "A progressive acyclic digraph (PAD) algorithm accepts are requests and maintains a graph in an acyclic state.  When a request creates a cycle, nodes are, \"detached\" until the new are can be entered acyclically This process is important in certain areas of database implementation in which there are constraints on the permissible sequences of actions. Two PAD algorithms are presented; one uses a simple path matrix representation and the other uses a list with an \"artificial gradient.\"  Experiments suggest that for large N the second is considerably faster, though both are asymptotically O(NR), where N is the number of nodes and R is the expected number of nodes reachable along paths from any given node.", "authors": "Hansen, W.J.", "words_pool": ["accept", "action", "acycl", "acycl", "algorithm", "algorithm", "area", "artifici", "asymptot", "consider", "constraint", "creat", "cycl", "databas", "detach", "digraph", "digraph", "enter", "expect", "experi", "faster", "gradient", "graph", "implement", "import", "integr", "larg", "list", "maintain", "matrix", "node", "node", "nr", "number", "pad", "path", "path", "permiss", "present", "process", "progress", "reachabl", "represent", "request", "request", "sequenc", "simpl", "state", "suggest", "tool", "hansen"], "word_count": {"accept": 1, "action": 1, "acycl": 3, "algorithm": 2, "area": 1, "artifici": 1, "asymptot": 1, "consider": 1, "constraint": 1, "creat": 1, "cycl": 1, "databas": 1, "detach": 1, "digraph": 1, "enter": 1, "expect": 1, "experi": 1, "faster": 1, "gradient": 1, "graph": 1, "implement": 1, "import": 1, "integr": 1, "larg": 1, "list": 1, "maintain": 1, "matrix": 1, "node": 4, "nr": 1, "number": 2, "pad": 2, "path": 2, "permiss": 1, "present": 1, "process": 1, "progress": 1, "reachabl": 1, "represent": 1, "request": 2, "sequenc": 1, "simpl": 1, "state": 1, "suggest": 1, "tool": 1, "hansen": 1}}, "3165": {"id": "3165", "title": "Approximation of Polygonal Maps by Cellular Maps", "abstract": "The approximation of polygonal thematic maps by cellular maps, an important operation in geographical data processing, is analyzed.  The data organization used for representing the polygonal maps is a widely used segment-based data structure, where class labels identify the regions bordering each segment on either side. The approximation algorithm presented operates on such an organization, eliminating the need for the recognition of region boundaries. Each segment is examined only once.  The versatility of the new organization is further illustrated by the outline of algorithms for area computation and point inclusion.  The algorithm is applied to a set of soil maps converted to computer-readable form by means of a coordinate digitizer.", "authors": "Nagy, G. Wagle, S.G.", "words_pool": ["algorithm", "algorithm", "analyz", "appli", "approxim", "area", "base", "border", "boundari", "cellular", "class", "comput", "comput", "convert", "coordin", "data", "digit", "elimin", "examin", "form", "geograph", "identifi", "illustr", "import", "inclus", "label", "map", "mean", "need", "oper", "oper", "organ", "outlin", "point", "polygon", "present", "process", "readabl", "recognit", "region", "region", "repres", "segment", "set", "side", "soil", "structur", "themat", "versatil", "wide", "nagi", "wagl"], "word_count": {"algorithm": 3, "analyz": 1, "appli": 1, "approxim": 2, "area": 1, "base": 1, "border": 1, "boundari": 1, "cellular": 1, "class": 1, "comput": 2, "convert": 1, "coordin": 1, "data": 3, "digit": 1, "elimin": 1, "examin": 1, "form": 1, "geograph": 1, "identifi": 1, "illustr": 1, "import": 1, "inclus": 1, "label": 1, "map": 4, "mean": 1, "need": 1, "oper": 2, "organ": 3, "outlin": 1, "point": 1, "polygon": 2, "present": 1, "process": 1, "readabl": 1, "recognit": 1, "region": 2, "repres": 1, "segment": 3, "set": 1, "side": 1, "soil": 1, "structur": 1, "themat": 1, "versatil": 1, "wide": 1, "nagi": 1, "wagl": 1}}, "3166": {"id": "3166", "title": "Computing Standard Deviations: Accuracy", "abstract": "Four algorithms for the numerical computation of the standard deviation of (unweighted) sampled data are analyzed.  Two of the algorithms are well-known in the statistical and computational literature; the other two are new algorithms specifically intended for automatic computation.  Our discussion is  expository, with emphasis on reaching a suitable definition of \"accuracy.\"  Each of the four algorithms is analyzed for the conditions under which it will be accurate.  We conclude that all four algorithms will provide accurate answers for many problems, but two of the algorithms, one new, one old, are substantially more accurate on difficult problems than are the other two.", "authors": "Chan, T.F. Lewis, J.G.", "words_pool": ["accuraci", "accur", "algorithm", "analyz", "answer", "automat", "comput", "comput", "comput", "conclud", "condit", "data", "definit", "deviat", "deviat", "difficult", "discuss", "emphasi", "expositori", "intend", "known", "literatur", "numer", "problem", "provid", "reach", "sampl", "specif", "standard", "statist", "substanti", "suitabl", "unweight", "chan", "lewi"], "word_count": {"accuraci": 1, "accur": 3, "algorithm": 6, "analyz": 2, "answer": 1, "automat": 1, "comput": 3, "conclud": 1, "condit": 1, "data": 1, "definit": 1, "deviat": 1, "difficult": 1, "discuss": 1, "emphasi": 1, "expositori": 1, "intend": 1, "known": 1, "literatur": 1, "numer": 1, "problem": 2, "provid": 1, "reach": 1, "sampl": 1, "specif": 1, "standard": 1, "statist": 1, "substanti": 1, "suitabl": 1, "unweight": 1, "chan": 1, "lewi": 1}}, "3167": {"id": "3167", "title": "Updating Mean and Variance Estimates: An Improved Method", "abstract": "A method of improved efficiency is given for updating the mean and variance of weighted sampled data when an additional data value is included in the set.  Evidence is presented that the method is stable and at least as accurate as the best existing updating method.", "authors": "West, D.H.D.", "words_pool": ["accur", "addit", "data", "effici", "estim", "evid", "exist", "improv", "includ", "mean", "method", "present", "sampl", "set", "stabl", "updat", "varianc", "weight", "west"], "word_count": {"accur": 1, "addit": 1, "data": 2, "effici": 1, "estim": 1, "evid": 1, "exist": 1, "improv": 1, "includ": 1, "mean": 1, "method": 3, "present": 1, "sampl": 1, "set": 1, "stabl": 1, "updat": 2, "varianc": 1, "weight": 1, "west": 1}}, "3168": {"id": "3168", "title": "Comment on \"An Optimal Evaluation of Boolean Expressions in an Online Query System.\"", "authors": "Laird, P.D.", "words_pool": ["boolean", "comment", "evalu", "express", "onlin", "optim", "queri", "system", "laird"], "word_count": {"boolean": 1, "comment": 1, "evalu": 1, "express": 1, "onlin": 1, "optim": 1, "queri": 1, "system": 1, "laird": 1}}, "3169": {"id": "3169", "title": "Note on \"An Optimal Evaluation of Boolean Expressions  in an Online Query System.\"", "authors": "Gudes, E. Hoffman, A.", "words_pool": ["boolean", "evalu", "express", "note", "onlin", "optim", "queri", "system", "gude", "hoffman"], "word_count": {"boolean": 1, "evalu": 1, "express": 1, "note": 1, "onlin": 1, "optim": 1, "queri": 1, "system": 1, "gude": 1, "hoffman": 1}}, "3170": {"id": "3170", "title": "On the Proof of Correctness of a Calendar Program", "abstract": "A formal specification is given for a simple calendar program, and the derivation and proof of correctness of the program are  sketched.  The specification is easy to understand, and its correctness is  manifest to humans.", "authors": "Lamport, L.", "words_pool": ["calendar", "correct", "deriv", "easi", "formal", "human", "manifest", "program", "proof", "simpl", "sketch", "specif", "understand", "lamport"], "word_count": {"calendar": 1, "correct": 2, "deriv": 1, "easi": 1, "formal": 1, "human": 1, "manifest": 1, "program": 2, "proof": 1, "simpl": 1, "sketch": 1, "specif": 2, "understand": 1, "lamport": 1}}, "3171": {"id": "3171", "title": "Line Numbers Made Cheap", "abstract": "A technique is described for run-time line number administration to be used for implementations of high level languages.  Under suitable circumstances, this method requires absolutely no overhead, in either time or space, during execution of the program.", "authors": "Klint, P.", "words_pool": ["absolut", "administr", "cheap", "circumst", "execut", "high", "implement", "languag", "level", "line", "made", "method", "number", "number", "overhead", "program", "requir", "run", "space", "suitabl", "techniqu", "time", "klint"], "word_count": {"absolut": 1, "administr": 1, "cheap": 1, "circumst": 1, "execut": 1, "high": 1, "implement": 1, "languag": 1, "level": 1, "line": 1, "made": 1, "method": 1, "number": 1, "overhead": 1, "program": 1, "requir": 1, "run": 1, "space": 1, "suitabl": 1, "techniqu": 1, "time": 2, "klint": 1}}, "3172": {"id": "3172", "title": "An Algorithm for Planning Collision-Free Paths Among Polyhedral Obstacles", "abstract": "This paper describes a collision avoidance algorithm for planning a safe path for a polyhedral object moving among known polyhedral objects.  The algorithm transforms the obstacles so that they represent the locus of forbidden positions for an arbitrary reference point on the moving object.  A trajectory of this reference point which avoids all forbidden regions is free of collisions. Trajectories are found by searching a network which indicates, for each vertex  in the transformed obstacles, which other vertices can be reached safely.", "authors": ".", "words_pool": ["algorithm", "arbitrari", "avoid", "avoid", "collis", "collis", "describ", "forbidden", "found", "free", "known", "locu", "move", "network", "object", "object", "obstacl", "paper", "path", "path", "plan", "point", "polyhedr", "posit", "reach", "refer", "region", "repres", "safe", "safe", "search", "trajectori", "trajectori", "transform", "transform", "vertex", "vertic"], "word_count": {"algorithm": 2, "arbitrari": 1, "avoid": 2, "collis": 2, "describ": 1, "forbidden": 2, "found": 1, "free": 1, "known": 1, "locu": 1, "move": 2, "network": 1, "object": 3, "obstacl": 2, "paper": 1, "path": 1, "plan": 1, "point": 2, "polyhedr": 2, "posit": 1, "reach": 1, "refer": 2, "region": 1, "repres": 1, "safe": 2, "search": 1, "trajectori": 2, "transform": 2, "vertex": 1, "vertic": 1}}, "3173": {"id": "3173", "title": "A Psychology of Learning BASIC", "abstract": "This paper addresses the question: What does a person know following learning of BASIC programming?  Several underlying conceptual structures are identified: (1) a transaction is an event that occurs in the computer and involves some operation on some object at some location, (2) a prestatement is a set of transactions corresponding to a line of code, (3) chunks are frequently occurring  configurations of prestatements corresponding to several lines of code.", "authors": "Mayer, R.E.", "words_pool": ["address", "basic", "chunk", "code", "comput", "conceptu", "configur", "event", "frequent", "identifi", "involv", "know", "learn", "line", "line", "locat", "object", "occur", "occur", "oper", "paper", "person", "prestat", "prestat", "program", "psycholog", "question", "set", "structur", "transact", "transact", "underli", "mayer"], "word_count": {"address": 1, "basic": 1, "chunk": 1, "code": 2, "comput": 1, "conceptu": 1, "configur": 1, "event": 1, "frequent": 1, "identifi": 1, "involv": 1, "know": 1, "learn": 1, "line": 2, "locat": 1, "object": 1, "occur": 2, "oper": 1, "paper": 1, "person": 1, "prestat": 2, "program": 1, "psycholog": 1, "question": 1, "set": 1, "structur": 1, "transact": 2, "underli": 1, "mayer": 1}}, "3174": {"id": "3174", "title": "Password Security: A Case History", "abstract": "This paper describes the history of the design of the password security scheme on a remotely accessed time-sharing system. The present design was the result of countering observed attempts to penetrate the system.  The result is a compromise between extreme security and ease of use.", "authors": "Morris, R. Thompson, K.", "words_pool": ["access", "attempt", "case", "compromis", "counter", "describ", "design", "eas", "extrem", "histori", "observ", "paper", "password", "penetr", "present", "remot", "result", "scheme", "secur", "share", "system", "time", "morri", "thompson"], "word_count": {"access": 1, "attempt": 1, "case": 1, "compromis": 1, "counter": 1, "describ": 1, "design": 2, "eas": 1, "extrem": 1, "histori": 1, "observ": 1, "paper": 1, "password": 1, "penetr": 1, "present": 1, "remot": 1, "result": 2, "scheme": 1, "secur": 2, "share": 1, "system": 2, "time": 1, "morri": 1, "thompson": 1}}, "3175": {"id": "3175", "title": "Breaking Substitution Ciphers Using a Relaxation Algorithm", "abstract": "Substitution ciphers are codes in which each letter of the alphabet has one fixed substitute, and the word divisions  do not change.  In this paper the problem of breaking substitution ciphers is represented as a probabilistic labeling problem. Every code letter is assigned probabilities of representing plain text letters.  These probabilities are updated in parallel for all code letters, using joint letter probabilities.  Iterating the updating scheme results in improved estimates that finally lead to breaking the cipher.  The method is applies successfully to two examples.", "authors": "Peleg, S. Rosenfeld, A.", "words_pool": ["algorithm", "alphabet", "appli", "assign", "break", "chang", "cipher", "cipher", "code", "code", "divis", "estim", "exampl", "final", "fix", "improv", "iter", "joint", "label", "lead", "letter", "letter", "method", "paper", "parallel", "plain", "probabilist", "probabl", "problem", "relax", "repres", "repres", "result", "scheme", "substitut", "substitut", "success", "text", "updat", "updat", "word", "peleg", "rosenfeld"], "word_count": {"algorithm": 1, "alphabet": 1, "appli": 1, "assign": 1, "break": 2, "chang": 1, "cipher": 3, "code": 3, "divis": 1, "estim": 1, "exampl": 1, "final": 1, "fix": 1, "improv": 1, "iter": 1, "joint": 1, "label": 1, "lead": 1, "letter": 5, "method": 1, "paper": 1, "parallel": 1, "plain": 1, "probabilist": 1, "probabl": 3, "problem": 2, "relax": 1, "repres": 2, "result": 1, "scheme": 1, "substitut": 3, "success": 1, "text": 1, "updat": 2, "word": 1, "peleg": 1, "rosenfeld": 1}}, "3176": {"id": "3176", "title": "Storing a Sparse Table", "abstract": "The problem of storing and searching large sparse tables is ubiquitous in  computer science.  The standard technique for storing such tables is hashing, but hashing has poor worst-case performance.  We propose a good worst-case method for storing a static table of n entries, each an integer between 0 and N - 1.  The method requires 0(n) w words of storage and allows O(logn N) access time.  Although our method is a little complicated to use in practice, our analysis shows why a simpler algorithm used for compressing LR parsing tables works so well.", "authors": "Tarjan, R.E. Yao, A", "words_pool": ["access", "algorithm", "analysi", "case", "complic", "compress", "comput", "entri", "good", "hash", "integ", "larg", "logn", "lr", "method", "pars", "perform", "poor", "practic", "problem", "propos", "requir", "scienc", "search", "show", "simpler", "spars", "standard", "static", "storag", "store", "tabl", "tabl", "techniqu", "time", "ubiquit", "word", "work", "worst", "tarjan", "yao"], "word_count": {"access": 1, "algorithm": 1, "analysi": 1, "case": 2, "complic": 1, "compress": 1, "comput": 1, "entri": 1, "good": 1, "hash": 2, "integ": 1, "larg": 1, "logn": 1, "lr": 1, "method": 3, "pars": 1, "perform": 1, "poor": 1, "practic": 1, "problem": 1, "propos": 1, "requir": 1, "scienc": 1, "search": 1, "show": 1, "simpler": 1, "spars": 1, "standard": 1, "static": 1, "storag": 1, "store": 3, "tabl": 4, "techniqu": 1, "time": 1, "ubiquit": 1, "word": 1, "work": 1, "worst": 2, "tarjan": 1, "yao": 1}}, "3177": {"id": "3177", "title": "How to Share a Secret", "abstract": "In this paper we show how to divide data D into n pieces in such a way that D is easily reconstructable from any k pieces, but even complete knowledge of k - 1 pieces reveals olutely no information about D.  This technique enables the construction of robust key management schemes for cryptographic systems that can function securely and reliably even when misfortunes destroy half the pieces and security breaches expose all but one of the remaining pieces.", "authors": "Shamir, A.", "words_pool": ["breach", "complet", "construct", "cryptograph", "data", "destroy", "divid", "easili", "enabl", "expos", "function", "half", "inform", "key", "knowledg", "manag", "misfortun", "olut", "paper", "piec", "reconstruct", "reliabl", "remain", "reveal", "robust", "scheme", "secret", "secur", "secur", "share", "show", "system", "techniqu", "shamir"], "word_count": {"breach": 1, "complet": 1, "construct": 1, "cryptograph": 1, "data": 1, "destroy": 1, "divid": 1, "easili": 1, "enabl": 1, "expos": 1, "function": 1, "half": 1, "inform": 1, "key": 1, "knowledg": 1, "manag": 1, "misfortun": 1, "olut": 1, "paper": 1, "piec": 5, "reconstruct": 1, "reliabl": 1, "remain": 1, "reveal": 1, "robust": 1, "scheme": 1, "secret": 1, "secur": 2, "share": 1, "show": 1, "system": 1, "techniqu": 1, "shamir": 1}}, "3178": {"id": "3178", "title": "Introduction to the EFT Symposium", "authors": "Kling, R.", "words_pool": ["eft", "introduct", "symposium", "kling"], "word_count": {"eft": 1, "introduct": 1, "symposium": 1, "kling": 1}}, "3179": {"id": "3179", "title": "Overview of the EFT Symposium", "abstract": ".", "authors": "Kraemer, K.L. Colton, K", "words_pool": ["eft", "overview", "symposium", "kraemer", "colton"], "word_count": {"eft": 1, "overview": 1, "symposium": 1, "kraemer": 1, "colton": 1}}, "3180": {"id": "3180", "title": "Costs of the Current U.S. Payments System", "abstract": "Neither the banking industry nor public policy makers have good information on the comparative costs of alternative payment systems such as cash, checks, credit cards, and EFT transactions.  As a result, EFT systems and services are likely to be implemented without a valid assessment of whether they are cost-justified, lst alone justified in terms of other criteria.", "authors": "Lipis, A.H.", "words_pool": ["altern", "assess", "bank", "card", "cash", "check", "compar", "cost", "cost", "credit", "criteria", "eft", "good", "implement", "industri", "inform", "justifi", "like", "lst", "maker", "payment", "payment", "polici", "public", "result", "servic", "system", "system", "term", "transact", "valid", "lipi"], "word_count": {"altern": 1, "assess": 1, "bank": 1, "card": 1, "cash": 1, "check": 1, "compar": 1, "cost": 2, "credit": 1, "criteria": 1, "eft": 2, "good": 1, "implement": 1, "industri": 1, "inform": 1, "justifi": 2, "like": 1, "lst": 1, "maker": 1, "payment": 1, "polici": 1, "public": 1, "result": 1, "servic": 1, "system": 2, "term": 1, "transact": 1, "valid": 1, "lipi": 1}}, "3181": {"id": "3181", "title": "Public Protection and Education with EFT", "abstract": "Research has revealed the existence of widespread misinformation and lack of knowledge about EFT among business and government as well as consumers.  As a result, any effort to stimulate meaningful public participation in decisions on the introduction of EFT systems will require a coordinated educational effort of considerable scale.  In addition, research has revealed  shortcomings in the present system for defining responsibilities, liabilities, and avenues of recourse.  THis article presents several possible alternatives for improving the current system, but ongoing research is also needed to assure that actions taken will be responsive to the changing environment and consumer needs.", "authors": "Long, R.H.", "words_pool": ["action", "addit", "altern", "articl", "assur", "avenu", "busi", "chang", "consider", "consum", "consum", "coordin", "decis", "defin", "educ", "educ", "effort", "eft", "environ", "exist", "govern", "improv", "introduct", "knowledg", "lack", "liabil", "meaning", "misinform", "need", "need", "ongo", "particip", "present", "present", "protect", "public", "recours", "requir", "research", "respons", "respons", "result", "reveal", "scale", "shortcom", "stimul", "system", "system", "widespread", "long"], "word_count": {"action": 1, "addit": 1, "altern": 1, "articl": 1, "assur": 1, "avenu": 1, "busi": 1, "chang": 1, "consider": 1, "consum": 2, "coordin": 1, "decis": 1, "defin": 1, "educ": 1, "effort": 2, "eft": 2, "environ": 1, "exist": 1, "govern": 1, "improv": 1, "introduct": 1, "knowledg": 1, "lack": 1, "liabil": 1, "meaning": 1, "misinform": 1, "need": 2, "ongo": 1, "particip": 1, "present": 2, "protect": 1, "public": 1, "recours": 1, "requir": 1, "research": 3, "respons": 2, "result": 1, "reveal": 2, "scale": 1, "shortcom": 1, "stimul": 1, "system": 3, "widespread": 1, "long": 1}}, "3182": {"id": "3182", "title": "Vulnerabilities of EFTs to Intentionally Caused Losses", "abstract": "The hypothesis that consumers are provided greater accuracy and freedom from error and fraud with electronic funds transfer systems (EFTs) is discussed in light of the technical capabilities and potential of the computer to protect against both accidentally and intentionally caused losses. Although the nomenclature for business crimes remains the same as for manual depository and other financial service systems - for example,  fraud, theft, embezzlement - the characteristics of the crimes are new. The changes resulting from the accelerating use of EFTs and  its continual technological advances broaden the scope of security issues to be examined.  Factors such as backup requirements,  regulatory and legislative actions, and economics give rise to the urgency for immediate research into solutions for emerging EFTs - related vulnerabilities.", "authors": "Parker, D", "words_pool": ["acceler", "accident", "accuraci", "action", "advanc", "backup", "broaden", "busi", "capabl", "caus", "characterist", "comput", "consum", "continu", "crime", "depositori", "discuss", "econom", "eft", "electron", "embezzl", "emerg", "error", "examin", "factor", "financi", "fraud", "freedom", "fund", "give", "greater", "hypothesi", "intent", "issu", "legisl", "light", "loss", "nomenclatur", "potenti", "protect", "provid", "regulatori", "relat", "remain", "requir", "research", "result", "rise", "scope", "secur", "servic", "solut", "system", "technic", "technolog", "theft", "transfer", "urgenc", "vulner", "parker"], "word_count": {"acceler": 1, "accident": 1, "accuraci": 1, "action": 1, "advanc": 1, "backup": 1, "broaden": 1, "busi": 1, "capabl": 1, "caus": 1, "characterist": 1, "comput": 1, "consum": 1, "continu": 1, "crime": 2, "depositori": 1, "discuss": 1, "econom": 1, "eft": 3, "electron": 1, "embezzl": 1, "emerg": 1, "error": 1, "examin": 1, "factor": 1, "financi": 1, "fraud": 2, "freedom": 1, "fund": 1, "give": 1, "greater": 1, "hypothesi": 1, "intent": 1, "issu": 1, "legisl": 1, "light": 1, "loss": 1, "nomenclatur": 1, "potenti": 1, "protect": 1, "provid": 1, "regulatori": 1, "relat": 1, "remain": 1, "requir": 1, "research": 1, "result": 1, "rise": 1, "scope": 1, "secur": 1, "servic": 1, "solut": 1, "system": 2, "technic": 1, "technolog": 1, "theft": 1, "transfer": 1, "urgenc": 1, "vulner": 1, "parker": 1}}, "3183": {"id": "3183", "title": "Policy, Values, and EFT Research: Anatomy of a Research Agenda", "abstract": ".", "authors": "Kraemer, K.L. Colton, K", "words_pool": ["agenda", "anatomi", "eft", "polici", "research", "valu", "kraemer", "colton"], "word_count": {"agenda": 1, "anatomi": 1, "eft": 1, "polici": 1, "research": 2, "valu": 1, "kraemer": 1, "colton": 1}}, "3184": {"id": "3184", "title": "Revised Report on the Algorithmic Language ALGOL 60", "abstract": "The report gives a complete defining description of the international algorithmic language ALGOL 60. This is a language suitable for expressing  a large class of numerical processes in a form sufficiently concise for  direct automatic translation into the language of programmed automatic computers.", "authors": "Nuar, P.", "words_pool": ["algol", "algorithm", "automat", "class", "complet", "comput", "concis", "defin", "descript", "direct", "express", "form", "intern", "languag", "larg", "numer", "process", "program", "report", "revis", "suffici", "suitabl", "translat", "nuar"], "word_count": {"algol": 1, "algorithm": 1, "automat": 2, "class": 1, "complet": 1, "comput": 1, "concis": 1, "defin": 1, "descript": 1, "direct": 1, "express": 1, "form": 1, "intern": 1, "languag": 3, "larg": 1, "numer": 1, "process": 1, "program": 1, "report": 1, "revis": 1, "suffici": 1, "suitabl": 1, "translat": 1, "nuar": 1}}, "3185": {"id": "3185", "title": "The Humble Programmer", "abstract": "We shall do a much better programming job, provided that we approach the task with a full appreciation if its tremendous difficulty, provided that we  stick to modest and elegant programming languages, provided that we respect the intrinsic limitations of the human mind and approach the task as Very Humble Programmers.", "authors": "Dijkstra, E. W.", "words_pool": ["appreci", "approach", "difficulti", "eleg", "full", "human", "humbl", "intrins", "job", "languag", "limit", "mind", "modest", "programm", "programm", "program", "provid", "respect", "stick", "task", "tremend", "dijkstra"], "word_count": {"appreci": 1, "approach": 2, "difficulti": 1, "eleg": 1, "full": 1, "human": 1, "humbl": 1, "intrins": 1, "job": 1, "languag": 1, "limit": 1, "mind": 1, "modest": 1, "programm": 1, "program": 2, "provid": 3, "respect": 1, "stick": 1, "task": 2, "tremend": 1, "dijkstra": 1}}, "3186": {"id": "3186", "title": "GO TO Statement Considerd Harmful", "authors": "Dijkstra, E. W.", "words_pool": ["considerd", "harm", "statement", "dijkstra"], "word_count": {"considerd": 1, "harm": 1, "statement": 1, "dijkstra": 1}}, "3187": {"id": "3187", "title": "Certification of Algorithm 271 (QUICKERSORT)", "abstract": "QUICKERSORT compiled and run without correction through the ALDEP translator for the CDC 1604A. Comparison of average sorting items with other recently published algorithms demonstrates QUICKERSORT's superior performance.", "authors": "Blair, C.R.", "words_pool": ["1604a", "aldep", "algorithm", "algorithm", "averag", "cdc", "certif", "comparison", "compil", "correct", "demonstr", "item", "perform", "publish", "quickersort", "recent", "run", "sort", "superior", "translat", "blair"], "word_count": {"1604a": 1, "aldep": 1, "algorithm": 1, "averag": 1, "cdc": 1, "certif": 1, "comparison": 1, "compil": 1, "correct": 1, "demonstr": 1, "item": 1, "perform": 1, "publish": 1, "quickersort": 2, "recent": 1, "run": 1, "sort": 1, "superior": 1, "translat": 1, "blair": 1}}, "3188": {"id": "3188", "title": "Semiotics and Programming Languages", "abstract": "I have based my paper on semiotics and its three dimension. I should insert at this point that language has many aspects and that pragmatics, semantics and syntactics do not necessary cover all of them. One can, however, project most  aspects into the three semiotic dimension and there seems to be a strong  tendency to do so today.", "authors": "Zemanek, H.", "words_pool": ["aspect", "base", "cover", "dimens", "insert", "languag", "languag", "paper", "point", "pragmat", "program", "project", "semant", "semiot", "semiot", "strong", "syntact", "tendenc", "today", "zemanek"], "word_count": {"aspect": 2, "base": 1, "cover": 1, "dimens": 2, "insert": 1, "languag": 1, "paper": 1, "point": 1, "pragmat": 1, "program": 1, "project": 1, "semant": 1, "semiot": 2, "strong": 1, "syntact": 1, "tendenc": 1, "today": 1, "zemanek": 1}}, "3189": {"id": "3189", "title": "An Algebraic Compiler for the FORTRAN Assembly Program", "abstract": "An algebraic compiler has been written which may be added to the FORTRAN  Assembly Program. This compiler will expand all algebraic statements with the  following operations: addition, subtraction, multiplication and division. It will compile multi-level expressions in floating-point arithmetic (this is easily be revised to fixed-point).", "authors": "Stiegler, A. D.", "words_pool": ["ad", "addit", "algebra", "arithmet", "assembl", "compil", "compil", "divis", "easili", "expand", "express", "fix", "float", "fortran", "level", "multi", "multipl", "oper", "point", "program", "revis", "statement", "subtract", "written", "stiegler"], "word_count": {"ad": 1, "addit": 1, "algebra": 2, "arithmet": 1, "assembl": 1, "compil": 3, "divis": 1, "easili": 1, "expand": 1, "express": 1, "fix": 1, "float": 1, "fortran": 1, "level": 1, "multi": 1, "multipl": 1, "oper": 1, "point": 2, "program": 1, "revis": 1, "statement": 1, "subtract": 1, "written": 1, "stiegler": 1}}, "3190": {"id": "3190", "title": "Correction to Economies of Scale and the IBM System/360", "abstract": "On page 439, a \"typical\" instruction mix id discussed and the timing computed as outlined in that page. Through an undetected programming error, the times and the resulting regression equation are slightly in error.", "authors": "Solomon, M", "words_pool": ["comput", "correct", "discuss", "economi", "equat", "error", "ibm", "id", "instruct", "mix", "outlin", "page", "program", "regress", "result", "scale", "slightli", "system", "time", "time", "typic", "undetect", "solomon"], "word_count": {"comput": 1, "correct": 1, "discuss": 1, "economi": 1, "equat": 1, "error": 2, "ibm": 1, "id": 1, "instruct": 1, "mix": 1, "outlin": 1, "page": 2, "program": 1, "regress": 1, "result": 1, "scale": 1, "slightli": 1, "system": 1, "time": 2, "typic": 1, "undetect": 1, "solomon": 1}}, "3191": {"id": "3191", "title": "Generating Permutations by Nested Cycling", "abstract": "The purpose of this letter is two_fold: first to give due credit to the Tompkins-Paige algorithm, and second to clarify a comment by Hill, CR Review 13891 on \"Programs for Permutations\".", "authors": "Langdon, Glen G.", "words_pool": ["algorithm", "clarifi", "comment", "cr", "credit", "cycl", "due", "fold", "gener", "give", "hill", "letter", "nest", "paig", "permut", "program", "purpos", "review", "tompkin", "langdon", "glen"], "word_count": {"algorithm": 1, "clarifi": 1, "comment": 1, "cr": 1, "credit": 1, "cycl": 1, "due": 1, "fold": 1, "gener": 1, "give": 1, "hill": 1, "letter": 1, "nest": 1, "paig": 1, "permut": 1, "program": 1, "purpos": 1, "review": 1, "tompkin": 1, "langdon": 1, "glen": 1}}, "3192": {"id": "3192", "title": "The Lincoln Keyboard - a Typewriter Keyboard Designed  for Computers Input Flexibility", "abstract": "A new typewriter keyboard, for direct and punched paper tape computer input will replace the usual commercial keyboard with 88 characters chosen for the  convenience  of programmers. The Lincoln Keyboard is expected to facilitate the programming of algorithmic process and should allow considerable  flexibility in assembly and utility routines.", "authors": "Vanderburgh, A.", "words_pool": ["algorithm", "allow", "assembl", "charact", "chosen", "commerci", "comput", "comput", "consider", "conveni", "design", "direct", "expect", "facilit", "flexibl", "input", "keyboard", "lincoln", "paper", "process", "programm", "program", "punch", "replac", "routin", "tape", "typewrit", "usual", "util", "vanderburgh"], "word_count": {"algorithm": 1, "allow": 1, "assembl": 1, "charact": 1, "chosen": 1, "commerci": 1, "comput": 1, "consider": 1, "conveni": 1, "design": 1, "direct": 1, "expect": 1, "facilit": 1, "flexibl": 1, "input": 1, "keyboard": 3, "lincoln": 1, "paper": 1, "process": 1, "programm": 1, "program": 1, "punch": 1, "replac": 1, "routin": 1, "tape": 1, "typewrit": 1, "usual": 1, "util": 1, "vanderburgh": 1}}, "3193": {"id": "3193", "title": "", "abstract": "Work is in progress on a formula coding technique allowing direct entry into the computer of formulae typed on an 84 character Flexo-writer. This Flexo-writer will be modified for automatic half-line advance and retract, without carriage return, to permit completely general sub and superscripting.", "words_pool": ["advanc", "allow", "automat", "carriag", "charact", "code", "complet", "comput", "direct", "entri", "flexo", "formula", "formula", "gener", "half", "line", "modifi", "permit", "progress", "retract", "superscript", "techniqu", "type", "work", "writer"], "word_count": {"advanc": 1, "allow": 1, "automat": 1, "carriag": 1, "charact": 1, "code": 1, "complet": 1, "comput": 1, "direct": 1, "entri": 1, "flexo": 2, "formula": 2, "gener": 1, "half": 1, "line": 1, "modifi": 1, "permit": 1, "progress": 1, "retract": 1, "superscript": 1, "techniqu": 1, "type": 1, "work": 1, "writer": 2}}, "3194": {"id": "3194", "title": "A Non-heuristic Program for Proving Elementary Logical Theorems", "abstract": "The paper discusses problems involved in designing a device capable of distinguishing among speech events that are normally recognized as different  by native speakers of a particular language. Parallels between these problems and those of chemical analysis are pointed out.", "authors": "Dunham, B. Fridshal, R. Sward, G. L.", "words_pool": ["analysi", "capabl", "chemic", "design", "devic", "discuss", "distinguish", "elementari", "event", "heurist", "involv", "languag", "logic", "nativ", "non", "paper", "parallel", "point", "problem", "program", "prove", "recogn", "speaker", "speech", "theorem", "dunham", "fridshal", "sward"], "word_count": {"analysi": 1, "capabl": 1, "chemic": 1, "design": 1, "devic": 1, "discuss": 1, "distinguish": 1, "elementari": 1, "event": 1, "heurist": 1, "involv": 1, "languag": 1, "logic": 1, "nativ": 1, "non": 1, "paper": 1, "parallel": 1, "point": 1, "problem": 2, "program": 1, "prove": 1, "recogn": 1, "speaker": 1, "speech": 1, "theorem": 1, "dunham": 1, "fridshal": 1, "sward": 1}}, "3195": {"id": "3195", "title": "Reiteration of ACM Policy Toward Standardization", "abstract": "The periodic change in officers, chairman and editors which usually follows as election occasionally results in a change in policy. In the case of this  department there is no radical change, but this is nevertheless the proper time to reiterate ans underline ACM's policy with respect to standardization in the  computer area.", "authors": "Gorn, S.", "words_pool": ["acm", "an", "area", "case", "chairman", "chang", "comput", "depart", "editor", "elect", "follow", "occasion", "offic", "period", "polici", "proper", "radic", "reiter", "reiter", "respect", "result", "standard", "time", "underlin", "gorn"], "word_count": {"acm": 1, "an": 1, "area": 1, "case": 1, "chairman": 1, "chang": 3, "comput": 1, "depart": 1, "editor": 1, "elect": 1, "follow": 1, "occasion": 1, "offic": 1, "period": 1, "polici": 2, "proper": 1, "radic": 1, "reiter": 1, "respect": 1, "result": 1, "standard": 1, "time": 1, "underlin": 1, "gorn": 1}}, "3196": {"id": "3196", "title": "The Reactive Typewriter Program", "abstract": "84-character keyboard including alphabetical upper and lower case for good readability. If the machine is restricted to only a single case, the lower case is preferred. The reactive typewriter should be portable. the reactive  typewriter should operate over any commercially used, dial-type telephone (voice) or telegraph (Telex) line or over leased (nondial) telegraph lines interchangeably.", "authors": "Mooers, C. N.", "words_pool": ["alphabet", "case", "charact", "commerci", "dial", "good", "includ", "interchang", "keyboard", "leas", "line", "line", "lower", "machin", "nondial", "oper", "portabl", "prefer", "program", "reactiv", "readabl", "restrict", "singl", "telegraph", "telephon", "telex", "type", "typewrit", "upper", "voic", "mooer"], "word_count": {"alphabet": 1, "case": 3, "charact": 1, "commerci": 1, "dial": 1, "good": 1, "includ": 1, "interchang": 1, "keyboard": 1, "leas": 1, "line": 2, "lower": 2, "machin": 1, "nondial": 1, "oper": 1, "portabl": 1, "prefer": 1, "program": 1, "reactiv": 2, "readabl": 1, "restrict": 1, "singl": 1, "telegraph": 2, "telephon": 1, "telex": 1, "type": 1, "typewrit": 2, "upper": 1, "voic": 1, "mooer": 1}}, "3197": {"id": "3197", "title": "Structures of Standards-Processing Organizations in the Computer Area", "abstract": "In line with the ACM's policy statement [Comm. ACM 5 (Nov. 1962), 547-549], the following organizational descriptions have been provided in order to describe standardization activities pertinent to computers and information processing.", "authors": "Gorn, S. Bemer, R. W. Green, J.", "words_pool": ["acm", "activ", "area", "comm", "comput", "comput", "describ", "descript", "inform", "line", "nov", "order", "organiz", "organ", "pertin", "polici", "process", "provid", "standard", "standard", "statement", "structur", "gorn", "bemer", "green"], "word_count": {"acm": 2, "activ": 1, "area": 1, "comm": 1, "comput": 1, "describ": 1, "descript": 1, "inform": 1, "line": 1, "nov": 1, "order": 1, "organiz": 1, "organ": 1, "pertin": 1, "polici": 1, "process": 1, "provid": 1, "standard": 1, "statement": 1, "structur": 1, "gorn": 1, "bemer": 1, "green": 1}}, "3198": {"id": "3198", "title": "Microprogramming, Emulators and Programming Languages", "abstract": "The problem we have been concerned with is that of converting language to action - or intellectual energy to mechanical energy. The medium that we use  for this purpose is language and therefore we are preoccupied with the subject of language. In the areas of language investigation we have concentrated first  on formalizing syntax and then on semantics.", "authors": "Greem, J.", "words_pool": ["action", "area", "concentr", "concern", "convert", "emul", "energi", "formal", "intellectu", "investig", "languag", "languag", "mechan", "medium", "microprogram", "preoccupi", "problem", "program", "purpos", "semant", "subject", "syntax", "greem"], "word_count": {"action": 1, "area": 1, "concentr": 1, "concern": 1, "convert": 1, "emul": 1, "energi": 2, "formal": 1, "intellectu": 1, "investig": 1, "languag": 4, "mechan": 1, "medium": 1, "microprogram": 1, "preoccupi": 1, "problem": 1, "program": 1, "purpos": 1, "semant": 1, "subject": 1, "syntax": 1, "greem": 1}}, "3199": {"id": "3199", "title": "ALGEM - An Algebraic Manipulator", "abstract": "ALGEM is a package of subprograms written in Slip, FORTRAN IV and MAP 7094  II to manipulate algebraic expressions. Algem's basic algebraic operations are  additions, subtractions, multiplications, division and exponentiation. It is  capable of handling any number of single letter variables, variable exponents,  and of finding the highest common factor of two polynomials. Also included are such functions as substitution, differentiation, determining coefficients of specified variables, solving a linear equation, basic I/O routines plus other special purpose and arithmetic routines. The major innovation of Algem over  other manipulators is the assignment of types to all expressions and the use  of a standard ordering procedure.", "authors": "Gotlieb, C. C. Novak, R. J.", "words_pool": ["addit", "algebra", "algem", "arithmet", "assign", "basic", "capabl", "coeffici", "common", "determin", "differenti", "divis", "equat", "exponenti", "expon", "express", "factor", "find", "fortran", "function", "handl", "highest", "ii", "includ", "innov", "iv", "letter", "linear", "major", "manipul", "manipul", "manipul", "map", "multipl", "number", "oper", "order", "packag", "polynomi", "procedur", "purpos", "routin", "singl", "slip", "solv", "special", "standard", "subprogram", "substitut", "subtract", "type", "variabl", "variabl", "written", "gotlieb", "novak"], "word_count": {"addit": 1, "algebra": 2, "algem": 3, "arithmet": 1, "assign": 1, "basic": 2, "capabl": 1, "coeffici": 1, "common": 1, "determin": 1, "differenti": 1, "divis": 1, "equat": 1, "exponenti": 1, "expon": 1, "express": 2, "factor": 1, "find": 1, "fortran": 1, "function": 1, "handl": 1, "highest": 1, "ii": 1, "includ": 1, "innov": 1, "iv": 1, "letter": 1, "linear": 1, "major": 1, "manipul": 2, "map": 1, "multipl": 1, "number": 1, "oper": 1, "order": 1, "packag": 1, "polynomi": 1, "procedur": 1, "purpos": 1, "routin": 2, "singl": 1, "slip": 1, "solv": 1, "special": 1, "standard": 1, "subprogram": 1, "substitut": 1, "subtract": 1, "type": 1, "variabl": 3, "written": 1, "gotlieb": 1, "novak": 1}}, "3200": {"id": "3200", "title": "A FORMAC Program for the Solution of Linear Boundary and Initial Value  Problems", "abstract": "A computer program is described which has been developed for obtaining approximate solutions to linear initial and boundary-value problems involving  differential equations. For each problem, input to the program includes:    1. The equations (in symbolic form) to be satisfied  -  the differential equations, equations describing auxiliary conditions such as boundary  conditions, etc.    2. A numerical description of the regions in which each of the equations are to be satisfied.    3. Sets of functions (in symbolic form) to be used in linear combinations to approximate the solution functions. Give the above input, the program generates an approximation to the solutions of the specified problemm in terms  of the specified functions which is optimum in the least-squares sense.", "authors": "Cuthill, E.", "words_pool": ["approxim", "approxim", "auxiliari", "boundari", "combin", "comput", "condit", "describ", "descript", "develop", "differenti", "equat", "form", "formac", "function", "gener", "give", "includ", "initi", "input", "involv", "linear", "numer", "obtain", "optimum", "problem", "problemm", "problem", "program", "region", "satisfi", "sens", "set", "solut", "solut", "squar", "symbol", "term", "cuthil"], "word_count": {"approxim": 3, "auxiliari": 1, "boundari": 2, "combin": 1, "comput": 1, "condit": 2, "describ": 1, "descript": 1, "develop": 1, "differenti": 2, "equat": 5, "form": 2, "formac": 1, "function": 3, "gener": 1, "give": 1, "includ": 1, "initi": 1, "input": 2, "involv": 1, "linear": 2, "numer": 1, "obtain": 1, "optimum": 1, "problem": 2, "problemm": 1, "program": 3, "region": 1, "satisfi": 2, "sens": 1, "set": 1, "solut": 3, "squar": 1, "symbol": 2, "term": 1, "cuthil": 1}}, "3201": {"id": "3201", "title": "Symbolic Manipulation of Poisson Series", "abstract": "Poisson series of three variables are manageable symbolically through as a  set of formal subroutines written partially in the IBM 7094 machine language, but to be called in the FORTRAN language for use in Fortran  programs. An  effort has been made to supply those operations which are most required by celestial mechanics. The routines are entirely self-contained subroutines and require only standard Fortran input/output units 5 and 6; they are design to avoid waste and overflow of core storage space.", "authors": "Danby, J. Deprit, A. Rom, A.", "words_pool": ["avoid", "call", "celesti", "contain", "core", "design", "effort", "entir", "formal", "fortran", "ibm", "input", "languag", "machin", "made", "manag", "manipul", "mechan", "oper", "output", "overflow", "partial", "poisson", "program", "requir", "requir", "routin", "seri", "set", "space", "standard", "storag", "subroutin", "suppli", "symbol", "symbol", "unit", "variabl", "wast", "written", "danbi", "deprit", "rom"], "word_count": {"avoid": 1, "call": 1, "celesti": 1, "contain": 1, "core": 1, "design": 1, "effort": 1, "entir": 1, "formal": 1, "fortran": 3, "ibm": 1, "input": 1, "languag": 2, "machin": 1, "made": 1, "manag": 1, "manipul": 1, "mechan": 1, "oper": 1, "output": 1, "overflow": 1, "partial": 1, "poisson": 1, "program": 1, "requir": 2, "routin": 1, "seri": 1, "set": 1, "space": 1, "standard": 1, "storag": 1, "subroutin": 2, "suppli": 1, "symbol": 1, "unit": 1, "variabl": 1, "wast": 1, "written": 1, "danbi": 1, "deprit": 1, "rom": 1}}, "3202": {"id": "3202", "title": "MANIP: A Computer System for Algebra and Analytic Differentiation", "abstract": "A mathematical expression to be operated upon is written in FORTRAN-like  notation and stored in the computer as a string of BCD characters with all blanks removed. It may be as complicated as desired (parentheses nested without restriction, etc.) so long as the entire expression (or any subsequent form) does not exceed 5000 characters. The problemm of performing algebraic operations and obtaining analytic derivatives was translated into that of identifying and manipulating character sequences. Programs which resulted were written in FORTRAN IV for a CDC 3600 and are discussed in detail.", "authors": "Bender, B.", "words_pool": ["algebra", "algebra", "analyt", "bcd", "blank", "cdc", "charact", "charact", "complic", "comput", "deriv", "desir", "detail", "differenti", "discuss", "entir", "exceed", "express", "form", "fortran", "identifi", "iv", "long", "manip", "manipul", "mathemat", "nest", "notat", "obtain", "oper", "oper", "parenthes", "perform", "problemm", "program", "remov", "restrict", "result", "sequenc", "store", "string", "subsequ", "system", "translat", "written", "bender"], "word_count": {"algebra": 1, "analyt": 1, "bcd": 1, "blank": 1, "cdc": 1, "charact": 3, "complic": 1, "comput": 1, "deriv": 1, "desir": 1, "detail": 1, "differenti": 1, "discuss": 1, "entir": 1, "exceed": 1, "express": 2, "form": 1, "fortran": 2, "identifi": 1, "iv": 1, "long": 1, "manip": 1, "manipul": 1, "mathemat": 1, "nest": 1, "notat": 1, "obtain": 1, "oper": 2, "parenthes": 1, "perform": 1, "problemm": 1, "program": 1, "remov": 1, "restrict": 1, "result": 1, "sequenc": 1, "store": 1, "string": 1, "subsequ": 1, "system": 1, "translat": 1, "written": 2, "bender": 1}}, "3203": {"id": "3203", "title": "GRAD Assistant - A Program for Symbolic Algebraic Manipulation and  Differentiation", "abstract": "The General Recursive Algebra and Differentiation Assistant (GRAD Assistant) now under development is a set of LISP functions which symbolically manipulate abd differentiate algebraic expressions. It is designed for use with problemms  in which a large amount of routine manipulation is to be done by a program  without human intervention. Thus, GRAD must recognize necessary simplifications without external guidance. While some complicated expressions (notably ones involving nested radicals and trigonometric functions) do not yield completely to the present version, it has proved quite useful indeed.", "authors": "Fletcher, J. G.", "words_pool": ["abd", "algebra", "algebra", "amount", "assist", "complet", "complic", "design", "develop", "differenti", "differenti", "express", "extern", "function", "gener", "grad", "guidanc", "human", "intervent", "involv", "larg", "lisp", "manipul", "manipul", "nest", "notabl", "present", "problemm", "program", "prove", "radic", "recogn", "recurs", "routin", "set", "simplif", "symbol", "symbol", "trigonometr", "version", "yield", "fletcher"], "word_count": {"abd": 1, "algebra": 2, "amount": 1, "assist": 2, "complet": 1, "complic": 1, "design": 1, "develop": 1, "differenti": 2, "express": 2, "extern": 1, "function": 2, "gener": 1, "grad": 2, "guidanc": 1, "human": 1, "intervent": 1, "involv": 1, "larg": 1, "lisp": 1, "manipul": 2, "nest": 1, "notabl": 1, "present": 1, "problemm": 1, "program": 1, "prove": 1, "radic": 1, "recogn": 1, "recurs": 1, "routin": 1, "set": 1, "simplif": 1, "symbol": 1, "trigonometr": 1, "version": 1, "yield": 1, "fletcher": 1}}, "3204": {"id": "3204", "title": "An On-Line Program for Non-Numerical Algebra", "abstract": "The goal of this program is to make a step toward te design of an automated mathematical assistant. Some requirements for such a program are: it must be easy to access, and that the result must be obtained in a reasonably short time. Accordingly the program is written for a time-shared computer. The Q-32 computer as System Development Corporation, Santa Monica, California, was  chosen because it also had a LISP 1.5 compiler. Programming and debugging was done from a remote teletype console at Stanford University.", "authors": "Korsvold, K.", "words_pool": ["access", "algebra", "assist", "autom", "california", "chosen", "compil", "comput", "consol", "corpor", "debug", "design", "develop", "easi", "goal", "line", "lisp", "make", "mathemat", "monica", "non", "numer", "obtain", "program", "program", "reason", "remot", "requir", "result", "santa", "share", "short", "stanford", "step", "system", "te", "teletyp", "time", "univers", "written", "korsvold"], "word_count": {"access": 1, "algebra": 1, "assist": 1, "autom": 1, "california": 1, "chosen": 1, "compil": 1, "comput": 2, "consol": 1, "corpor": 1, "debug": 1, "design": 1, "develop": 1, "easi": 1, "goal": 1, "line": 1, "lisp": 1, "make": 1, "mathemat": 1, "monica": 1, "non": 1, "numer": 1, "obtain": 1, "program": 4, "reason": 1, "remot": 1, "requir": 1, "result": 1, "santa": 1, "share": 1, "short": 1, "stanford": 1, "step": 1, "system": 1, "te": 1, "teletyp": 1, "time": 2, "univers": 1, "written": 1, "korsvold": 1}}}